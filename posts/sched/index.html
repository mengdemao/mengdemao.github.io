<!doctype html><html lang="zh-cn"
  >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>系统调度 - 编程日志</title><link rel="apple-touch-icon" href="https://mengdemao.github.io/images/favicons/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="https://mengdemao.github.io/images/favicons/favicon-32x32.png" sizes="32x32" type="image/png">
<link rel="icon" href="https://mengdemao.github.io/images/favicons/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="https://mengdemao.github.io/images/favicons/manifest.json">
<link rel="icon" href="https://mengdemao.github.io/images/favicons/favicon.ico">
<meta name="keywords" content="sched" />
<meta name="description" content="" /><meta itemprop="name" content="系统调度">
<meta itemprop="description" content="系统调度 调度核心函数实现 1/* 2* kernel/sched/core.c 3* 4* Core kernel scheduler code and related syscalls 5* 6* Copyright (C) 1991-2002 Linus Torvalds 7*/ 8#include &#34;sched.h&#34;9 10#include &lt;linux/nospec.h&gt;11 12#include &lt;linux/kcov.h&gt;13 14#include &lt;asm/switch_to.h&gt;15#include &lt;asm/tlb.h&gt;16 17#include &#34;../workqueue_internal.h&#34;18#include &#34;../smpboot.h&#34;19 20#include &#34;pelt.h&#34;21 22#define CREATE_TRACE_POINTS 23#include &lt;trace/events/sched.h&gt;24 25DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); 26 27#ifdef CONFIG_SCHED_DEBUG 28/* 29* Debugging: various feature bits 30* 31* If SCHED_DEBUG is disabled, each compilation"><meta itemprop="datePublished" content="2021-10-04T12:10:25+08:00" />
<meta itemprop="dateModified" content="2021-10-27T22:54:25+08:00" />
<meta itemprop="wordCount" content="26776">
<meta itemprop="keywords" content="kernel," /><meta property="og:title" content="系统调度" />
<meta property="og:description" content="系统调度 调度核心函数实现 1/* 2* kernel/sched/core.c 3* 4* Core kernel scheduler code and related syscalls 5* 6* Copyright (C) 1991-2002 Linus Torvalds 7*/ 8#include &#34;sched.h&#34;9 10#include &lt;linux/nospec.h&gt;11 12#include &lt;linux/kcov.h&gt;13 14#include &lt;asm/switch_to.h&gt;15#include &lt;asm/tlb.h&gt;16 17#include &#34;../workqueue_internal.h&#34;18#include &#34;../smpboot.h&#34;19 20#include &#34;pelt.h&#34;21 22#define CREATE_TRACE_POINTS 23#include &lt;trace/events/sched.h&gt;24 25DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); 26 27#ifdef CONFIG_SCHED_DEBUG 28/* 29* Debugging: various feature bits 30* 31* If SCHED_DEBUG is disabled, each compilation" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mengdemao.github.io/posts/sched/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-04T12:10:25+08:00" />
<meta property="article:modified_time" content="2021-10-27T22:54:25+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="系统调度"/>
<meta name="twitter:description" content="系统调度 调度核心函数实现 1/* 2* kernel/sched/core.c 3* 4* Core kernel scheduler code and related syscalls 5* 6* Copyright (C) 1991-2002 Linus Torvalds 7*/ 8#include &#34;sched.h&#34;9 10#include &lt;linux/nospec.h&gt;11 12#include &lt;linux/kcov.h&gt;13 14#include &lt;asm/switch_to.h&gt;15#include &lt;asm/tlb.h&gt;16 17#include &#34;../workqueue_internal.h&#34;18#include &#34;../smpboot.h&#34;19 20#include &#34;pelt.h&#34;21 22#define CREATE_TRACE_POINTS 23#include &lt;trace/events/sched.h&gt;24 25DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); 26 27#ifdef CONFIG_SCHED_DEBUG 28/* 29* Debugging: various feature bits 30* 31* If SCHED_DEBUG is disabled, each compilation"/>
<link rel="preload" href="https://mengdemao.github.io/css/bundle.min.56f818f19e58c97481c8333650e24bf131abfada62c954646a72ae940adb3bf5.css" integrity="sha256-VvgY8Z5YyXSByDM2UOJL8TGr&#43;tpiyVRkanKulArbO/U=" crossorigin="anonymous" as="style" onload="this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://mengdemao.github.io/css/bundle.min.56f818f19e58c97481c8333650e24bf131abfada62c954646a72ae940adb3bf5.css" integrity="sha256-VvgY8Z5YyXSByDM2UOJL8TGr&#43;tpiyVRkanKulArbO/U=" crossorigin="anonymous"></noscript></head>
  <body><script src="https://mengdemao.github.io/js/bootstrap.min.b5d86dd3a5f60c90be38a252bb65fc1a2732f32e71dc12c051720f0c7aef3cde.js" integrity="sha256-tdht06X2DJC&#43;OKJSu2X8Gicy8y5x3BLAUXIPDHrvPN4=" crossorigin="anonymous"></script><header><nav class="navbar top-app-bar top-app-bar-expand-lg fixed-top">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <i class="fas fa-bars"></i>
    </button><a class="navbar-brand me-3" href="https://mengdemao.github.io/"><img class="logo" alt="Logo" src="https://mengdemao.github.io/images/logo.webp" loading="lazy"
   width="136" height="69"
   />
编程日志
    </a>
    <button class="navbar-social-share" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSocialShare"
  aria-controls="offcanvasSocialShare" aria-label="Toggle social share">
  <i class="fas fa-share-alt"></i>
</button>

<div class="offcanvas offcanvas-bottom surface" tabindex="-1" id="offcanvasSocialShare" aria-labelledby="offcanvasSocialShare">
  <div class="offcanvas-header">
    <h3 class="offcanvas-title">Share</h3>
    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="offcanvas-body">
    <a class="btn btn-sm btn-outline-primary social-share-button" rel="noopener noreferrer" aria-label="Twitter Share Button"
      target="_blank" href="https://twitter.com/intent/tweet?title=%e7%b3%bb%e7%bb%9f%e8%b0%83%e5%ba%a6&url=https%3a%2f%2fmengdemao.github.io%2fposts%2fsched%2f">
      <i class="fab fa-fw fa-twitter"></i> Twitter
    </a>
    <a class="btn btn-sm btn-outline-primary social-share-button" rel="noopener noreferrer" aria-label="Facebook Share Button"
      target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmengdemao.github.io%2fposts%2fsched%2f">
      <i class="fab fa-fw fa-facebook-f"></i> Facebook
    </a>
  </div>
</div>

    <button class="navbar-settings" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSettings"
  aria-controls="offcanvasSettings" aria-label="Toggle settings">
  <i class="fas fa-ellipsis-v"></i>
</button>

<div class="offcanvas offcanvas-end surface h-100" tabindex="-1" id="offcanvasSettings" aria-labelledby="offcanvasSettings">
  <div class="offcanvas-header">
    <h3 class="offcanvas-title">设置</h3>
    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="offcanvas-body">

<section class="setting">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-adjust"></i> 模式</label>
    </div>
    <div class="col-auto ms-auto">
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="modeSwitcher">
      </div>
    </div>
  </form>
</section>

<section class="setting">
  <form class="font-size-switcher-form row">
    <div class="col-auto">
      <label for="fontSize" class="form-label"><i class="fas fa-fw fa-font"></i> 字体大小</label>
    </div>
    <div class="col-auto ms-auto">
      <input type="range" class="form-range" min="-2" max="2" id="fontSize">
    </div>
  </form>
</section>


<section class="setting palettes">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-palette"></i> 配色</label>
    </div>
    <div class="col-auto ms-auto">
      <a id="btnPalette" class="btn btn-sm btn-outline-primary" role="button" aria-label="palettePicker">
        <i class="fas fa-eye-dropper"></i>
      </a>
    </div>
  </form>
  <div class="mt-2 d-flex visually-hidden" id="palettePicker"><button type="button" id="palette-blue" aria-label="蓝色"
        class="btn btn-sm palette" data-palette="blue">
      </button><button type="button" id="palette-blue-gray" aria-label="蓝灰色"
        class="btn btn-sm palette" data-palette="blue-gray">
      </button><button type="button" id="palette-brown" aria-label="棕色"
        class="btn btn-sm palette" data-palette="brown">
      </button></div>
</section>
</div>
</div>

    <div class="collapse navbar-collapse" tabindex="-1" id="navbarSupportedContent" aria-labelledby="navbarSupportedContent">
      <form class="search-bar my-1" action="https://mengdemao.github.io/search">
  <div class="input-group input-group-sm">
    <span class="btn btn-search disabled position-absolute left-0"><i class="fas fa-fw fa-search"></i></span>
    <input class="form-control rounded-pill" name="q" type="search" aria-label="Search">
  </div>
</form>

      <ul class="navbar-nav ms-auto"><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/archives/">
            <i class="fas fa-fw fa-file-archive"></i>归档
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/categories/">
            <i class="fas fa-fw fa-folder"></i>分类
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/tags/">
            <i class="fas fa-fw fa-tags"></i>标签
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/series/">
            <i class="fas fa-fw fa-columns"></i>专栏
          </a>
        </li><li class="nav-item dropdown">
          <a class="nav-link" id="navbarDropdown-dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            <i class="fas fa-fw fa-chevron-circle-down"></i>下拉菜单
          </a>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown-dropdown"><li>
              <a class="dropdown-item"
                href="https://github.com/mengdemao/mengdemao.github.io" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-fw fa-github"></i>Github
              </a>
            </li><li>
              <a class="dropdown-item"
                href="https://mengdemao.github.io/zh-cn/series/manual">
                用户手册
              </a>
            </li></ul>
        </li></ul>
    </div>
  </div>
</nav>
</header>
<main role="main" class="container">
      <div class="row content">
<div class="col-lg-8">
  <div class="container"><nav class="row card component" aria-label="breadcrumb">
  <div class="card-body">
    <ol class="breadcrumb "><li class="breadcrumb-item"><a href="https://mengdemao.github.io/">主页</a></li><li class="breadcrumb-item"><a href="https://mengdemao.github.io/posts/">文章</a></li><li class="breadcrumb-item active">系统调度</li></ol>
  </div>
</nav>    <article class="row card component mb-4 post"><div class="post-panel-wrapper">
  <div class="d-flex flex-column component rounded post-panel">
    
    <a id="sidebarToggler" class="action d-none d-lg-block" role="button">
  <i class="fas fa-fw fa-expand-alt" data-fa-transform="rotate-45"></i>
</a>
  
    

    
    <a class="action" data-bs-container="body" data-bs-toggle="popover" data-bs-html="true" data-bs-placement="bottom"
  data-bs-trigger="focus" tabindex="0" role="button" aria-label="Copyright" 
  data-bs-content="&lt;a target=&#34;_blank&#34; rel=&#34;license noopener noreferrer&#34; href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&#34;&gt;CC BY-NC-ND 4.0 &lt;i class=&#34;fab fa-fw fa-creative-commons&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-by&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-nc&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-nd&#34;&gt;&lt;/i&gt;&lt;/a&gt;
">
  <i class="fas fa-fw fa-copyright"></i>
</a>
    <a class="action" data-bs-toggle="offcanvas" href="#offcanvasTOC" aria-controls="offcanvasTOC" role="button">
  <i class="fas fa-fw fa-list-alt"></i>
</a>
    
  </div>
</div>
<div class="card-body">
        <h1 class="card-title my-3">系统调度
</h1><div class="post-meta"><span class="post-date" title="created on">
    <i class="fas fa-fw fa-calendar-alt"></i>Oct 4, 2021
  </span>
  <span class="post-date me-2" title="updated on">
      <i class="fas fa-sync-alt"></i>
      Oct 27, 2021
    </span>
  <span class="post-reading-time" title="reading time">
    <i class="fas fa-fw fa-coffee"></i>54 分钟阅读
  </span><a href="https://mengdemao.github.io/categories/linux/" class="badge rounded-pill text-white bg-primary post-taxonomy">linux</a><a href="https://mengdemao.github.io/tags/kernel/" class="badge rounded-pill text-white bg-primary post-taxonomy">kernel</a></div>
<div class="offcanvas offcanvas-end surface h-100" tabindex="-1" id="offcanvasTOC" aria-labelledby="offcanvasTOCLabel">
  <div class="offcanvas-header">
    <h2 class="offcanvas-title" id="offcanvasTOCLabel">目录</h5>
      <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
        <i class="fas fa-times"></i>
      </button>
  </div>
  <div class="offcanvas-body">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#调度核心函数实现">调度核心函数实现</a></li>
  </ul>
</nav>
  </div>
</div><div class="post-content mb-3"><h1 id="系统调度">系统调度</h1>
<h2 id="调度核心函数实现">调度核心函数实现</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="ln">   1</span><span class="cm">/*
</span><span class="ln">   2</span><span class="cm"> *  kernel/sched/core.c
</span><span class="ln">   3</span><span class="cm"> *
</span><span class="ln">   4</span><span class="cm"> *  Core kernel scheduler code and related syscalls
</span><span class="ln">   5</span><span class="cm"> *
</span><span class="ln">   6</span><span class="cm"> *  Copyright (C) 1991-2002  Linus Torvalds
</span><span class="ln">   7</span><span class="cm"> */</span>
<span class="ln">   8</span><span class="cp">#include</span> <span class="cpf">&#34;sched.h&#34;</span><span class="cp">
</span><span class="ln">   9</span><span class="cp"></span>
<span class="ln">  10</span><span class="cp">#include</span> <span class="cpf">&lt;linux/nospec.h&gt;</span><span class="cp">
</span><span class="ln">  11</span><span class="cp"></span>
<span class="ln">  12</span><span class="cp">#include</span> <span class="cpf">&lt;linux/kcov.h&gt;</span><span class="cp">
</span><span class="ln">  13</span><span class="cp"></span>
<span class="ln">  14</span><span class="cp">#include</span> <span class="cpf">&lt;asm/switch_to.h&gt;</span><span class="cp">
</span><span class="ln">  15</span><span class="cp">#include</span> <span class="cpf">&lt;asm/tlb.h&gt;</span><span class="cp">
</span><span class="ln">  16</span><span class="cp"></span>
<span class="ln">  17</span><span class="cp">#include</span> <span class="cpf">&#34;../workqueue_internal.h&#34;</span><span class="cp">
</span><span class="ln">  18</span><span class="cp">#include</span> <span class="cpf">&#34;../smpboot.h&#34;</span><span class="cp">
</span><span class="ln">  19</span><span class="cp"></span>
<span class="ln">  20</span><span class="cp">#include</span> <span class="cpf">&#34;pelt.h&#34;</span><span class="cp">
</span><span class="ln">  21</span><span class="cp"></span>
<span class="ln">  22</span><span class="cp">#define CREATE_TRACE_POINTS
</span><span class="ln">  23</span><span class="cp">#include</span> <span class="cpf">&lt;trace/events/sched.h&gt;</span><span class="cp">
</span><span class="ln">  24</span><span class="cp"></span>
<span class="ln">  25</span><span class="n">DEFINE_PER_CPU_SHARED_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">runqueues</span><span class="p">);</span>
<span class="ln">  26</span>
<span class="ln">  27</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln">  28</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">  29</span><span class="cm"> * Debugging: various feature bits
</span><span class="ln">  30</span><span class="cm"> *
</span><span class="ln">  31</span><span class="cm"> * If SCHED_DEBUG is disabled, each compilation unit has its own copy of
</span><span class="ln">  32</span><span class="cm"> * sysctl_sched_features, defined in sched.h, to allow constants propagation
</span><span class="ln">  33</span><span class="cm"> * at compile time and compiler optimization based on features default.
</span><span class="ln">  34</span><span class="cm"> */</span>
<span class="ln">  35</span><span class="cp">#define SCHED_FEAT(name, enabled)	\
</span><span class="ln">  36</span><span class="cp">	(1UL &lt;&lt; __SCHED_FEAT_##name) * enabled |
</span><span class="ln">  37</span><span class="cp"></span><span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_features</span> <span class="o">=</span>
<span class="ln">  38</span><span class="cp">#include</span> <span class="cpf">&#34;features.h&#34;</span><span class="cp">
</span><span class="ln">  39</span><span class="cp"></span>	<span class="mi">0</span><span class="p">;</span>
<span class="ln">  40</span><span class="cp">#undef SCHED_FEAT
</span><span class="ln">  41</span><span class="cp">#endif
</span><span class="ln">  42</span><span class="cp"></span>
<span class="ln">  43</span><span class="cm">/*
</span><span class="ln">  44</span><span class="cm"> * Number of tasks to iterate in a single balance run.
</span><span class="ln">  45</span><span class="cm"> * Limited because this is done with IRQs disabled.
</span><span class="ln">  46</span><span class="cm"> */</span>
<span class="ln">  47</span><span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_nr_migrate</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="ln">  48</span>
<span class="ln">  49</span><span class="cm">/*
</span><span class="ln">  50</span><span class="cm"> * period over which we measure -rt task CPU usage in us.
</span><span class="ln">  51</span><span class="cm"> * default: 1s
</span><span class="ln">  52</span><span class="cm"> */</span>
<span class="ln">  53</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_rt_period</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>
<span class="ln">  54</span>
<span class="ln">  55</span><span class="n">__read_mostly</span> <span class="kt">int</span> <span class="n">scheduler_running</span><span class="p">;</span>
<span class="ln">  56</span>
<span class="ln">  57</span><span class="cm">/*
</span><span class="ln">  58</span><span class="cm"> * part of the period that we allow rt tasks to run in us.
</span><span class="ln">  59</span><span class="cm"> * default: 0.95s
</span><span class="ln">  60</span><span class="cm"> */</span>
<span class="ln">  61</span><span class="kt">int</span> <span class="n">sysctl_sched_rt_runtime</span> <span class="o">=</span> <span class="mi">950000</span><span class="p">;</span>
<span class="ln">  62</span>
<span class="ln">  63</span><span class="cm">/*
</span><span class="ln">  64</span><span class="cm"> * __task_rq_lock - lock the rq @p resides on.
</span><span class="ln">  65</span><span class="cm"> */</span>
<span class="ln">  66</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">__task_rq_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">  67</span>	<span class="n">__acquires</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="ln">  68</span><span class="p">{</span>
<span class="ln">  69</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">  70</span>
<span class="ln">  71</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">  72</span>
<span class="ln">  73</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln">  74</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">  75</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">  76</span>		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">  77</span>			<span class="n">rq_pin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">  78</span>			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln">  79</span>		<span class="p">}</span>
<span class="ln">  80</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">  81</span>
<span class="ln">  82</span>		<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="ln">  83</span>			<span class="n">cpu_relax</span><span class="p">();</span>
<span class="ln">  84</span>	<span class="p">}</span>
<span class="ln">  85</span><span class="p">}</span>
<span class="ln">  86</span>
<span class="ln">  87</span><span class="cm">/*
</span><span class="ln">  88</span><span class="cm"> * task_rq_lock - lock p-&gt;pi_lock and lock the rq @p resides on.
</span><span class="ln">  89</span><span class="cm"> */</span>
<span class="ln">  90</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">task_rq_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">  91</span>	<span class="n">__acquires</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">)</span>
<span class="ln">  92</span>	<span class="n">__acquires</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="ln">  93</span><span class="p">{</span>
<span class="ln">  94</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">  95</span>
<span class="ln">  96</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln">  97</span>		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">rf</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="ln">  98</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">  99</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 100</span>		<span class="cm">/*
</span><span class="ln"> 101</span><span class="cm">		 *	move_queued_task()		task_rq_lock()
</span><span class="ln"> 102</span><span class="cm">		 *
</span><span class="ln"> 103</span><span class="cm">		 *	ACQUIRE (rq-&gt;lock)
</span><span class="ln"> 104</span><span class="cm">		 *	[S] -&gt;on_rq = MIGRATING		[L] rq = task_rq()
</span><span class="ln"> 105</span><span class="cm">		 *	WMB (__set_task_cpu())		ACQUIRE (rq-&gt;lock);
</span><span class="ln"> 106</span><span class="cm">		 *	[S] -&gt;cpu = new_cpu		[L] task_rq()
</span><span class="ln"> 107</span><span class="cm">		 *					[L] -&gt;on_rq
</span><span class="ln"> 108</span><span class="cm">		 *	RELEASE (rq-&gt;lock)
</span><span class="ln"> 109</span><span class="cm">		 *
</span><span class="ln"> 110</span><span class="cm">		 * If we observe the old CPU in task_rq_lock(), the acquire of
</span><span class="ln"> 111</span><span class="cm">		 * the old rq-&gt;lock will fully serialize against the stores.
</span><span class="ln"> 112</span><span class="cm">		 *
</span><span class="ln"> 113</span><span class="cm">		 * If we observe the new CPU in task_rq_lock(), the address
</span><span class="ln"> 114</span><span class="cm">		 * dependency headed by &#39;[L] rq = task_rq()&#39; and the acquire
</span><span class="ln"> 115</span><span class="cm">		 * will pair with the WMB to ensure we then also see migrating.
</span><span class="ln"> 116</span><span class="cm">		 */</span>
<span class="ln"> 117</span>		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 118</span>			<span class="n">rq_pin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln"> 119</span>			<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln"> 120</span>		<span class="p">}</span>
<span class="ln"> 121</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 122</span>		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">rf</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="ln"> 123</span>
<span class="ln"> 124</span>		<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="ln"> 125</span>			<span class="n">cpu_relax</span><span class="p">();</span>
<span class="ln"> 126</span>	<span class="p">}</span>
<span class="ln"> 127</span><span class="p">}</span>
<span class="ln"> 128</span>
<span class="ln"> 129</span><span class="cm">/*
</span><span class="ln"> 130</span><span class="cm"> * RQ-clock updating methods:
</span><span class="ln"> 131</span><span class="cm"> */</span>
<span class="ln"> 132</span>
<span class="ln"> 133</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_rq_clock_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">s64</span> <span class="n">delta</span><span class="p">)</span>
<span class="ln"> 134</span><span class="p">{</span>
<span class="ln"> 135</span><span class="cm">/*
</span><span class="ln"> 136</span><span class="cm"> * In theory, the compile should just see 0 here, and optimize out the call
</span><span class="ln"> 137</span><span class="cm"> * to sched_rt_avg_update. But I don&#39;t trust it...
</span><span class="ln"> 138</span><span class="cm"> */</span>
<span class="ln"> 139</span>	<span class="n">s64</span> <span class="n">__maybe_unused</span> <span class="n">steal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">irq_delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 140</span>
<span class="ln"> 141</span><span class="cp">#ifdef CONFIG_IRQ_TIME_ACCOUNTING
</span><span class="ln"> 142</span><span class="cp"></span>	<span class="n">irq_delta</span> <span class="o">=</span> <span class="n">irq_time_read</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_irq_time</span><span class="p">;</span>
<span class="ln"> 143</span>
<span class="ln"> 144</span>	<span class="cm">/*
</span><span class="ln"> 145</span><span class="cm">	 * Since irq_time is only updated on {soft,}irq_exit, we might run into
</span><span class="ln"> 146</span><span class="cm">	 * this case when a previous update_rq_clock() happened inside a
</span><span class="ln"> 147</span><span class="cm">	 * {soft,}irq region.
</span><span class="ln"> 148</span><span class="cm">	 *
</span><span class="ln"> 149</span><span class="cm">	 * When this happens, we stop -&gt;clock_task and only update the
</span><span class="ln"> 150</span><span class="cm">	 * prev_irq_time stamp to account for the part that fit, so that a next
</span><span class="ln"> 151</span><span class="cm">	 * update will consume the rest. This ensures -&gt;clock_task is
</span><span class="ln"> 152</span><span class="cm">	 * monotonic.
</span><span class="ln"> 153</span><span class="cm">	 *
</span><span class="ln"> 154</span><span class="cm">	 * It does however cause some slight miss-attribution of {soft,}irq
</span><span class="ln"> 155</span><span class="cm">	 * time, a more accurate solution would be to update the irq_time using
</span><span class="ln"> 156</span><span class="cm">	 * the current rq-&gt;clock timestamp, except that would require using
</span><span class="ln"> 157</span><span class="cm">	 * atomic ops.
</span><span class="ln"> 158</span><span class="cm">	 */</span>
<span class="ln"> 159</span>	<span class="k">if</span> <span class="p">(</span><span class="n">irq_delta</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)</span>
<span class="ln"> 160</span>		<span class="n">irq_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 161</span>
<span class="ln"> 162</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_irq_time</span> <span class="o">+=</span> <span class="n">irq_delta</span><span class="p">;</span>
<span class="ln"> 163</span>	<span class="n">delta</span> <span class="o">-=</span> <span class="n">irq_delta</span><span class="p">;</span>
<span class="ln"> 164</span><span class="cp">#endif
</span><span class="ln"> 165</span><span class="cp">#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING
</span><span class="ln"> 166</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_false</span><span class="p">((</span><span class="o">&amp;</span><span class="n">paravirt_steal_rq_enabled</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 167</span>		<span class="n">steal</span> <span class="o">=</span> <span class="n">paravirt_steal_clock</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="ln"> 168</span>		<span class="n">steal</span> <span class="o">-=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_steal_time_rq</span><span class="p">;</span>
<span class="ln"> 169</span>
<span class="ln"> 170</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">steal</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">))</span>
<span class="ln"> 171</span>			<span class="n">steal</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 172</span>
<span class="ln"> 173</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_steal_time_rq</span> <span class="o">+=</span> <span class="n">steal</span><span class="p">;</span>
<span class="ln"> 174</span>		<span class="n">delta</span> <span class="o">-=</span> <span class="n">steal</span><span class="p">;</span>
<span class="ln"> 175</span>	<span class="p">}</span>
<span class="ln"> 176</span><span class="cp">#endif
</span><span class="ln"> 177</span><span class="cp"></span>
<span class="ln"> 178</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_task</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 179</span>
<span class="ln"> 180</span><span class="cp">#ifdef CONFIG_HAVE_SCHED_AVG_IRQ
</span><span class="ln"> 181</span><span class="cp"></span>	<span class="k">if</span> <span class="p">((</span><span class="n">irq_delta</span> <span class="o">+</span> <span class="n">steal</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sched_feat</span><span class="p">(</span><span class="n">NONTASK_CAPACITY</span><span class="p">))</span>
<span class="ln"> 182</span>		<span class="n">update_irq_load_avg</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">irq_delta</span> <span class="o">+</span> <span class="n">steal</span><span class="p">);</span>
<span class="ln"> 183</span><span class="cp">#endif
</span><span class="ln"> 184</span><span class="cp"></span><span class="p">}</span>
<span class="ln"> 185</span>
<span class="ln"> 186</span><span class="kt">void</span> <span class="nf">update_rq_clock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 187</span><span class="p">{</span>
<span class="ln"> 188</span>	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 189</span>
<span class="ln"> 190</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 191</span>
<span class="ln"> 192</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;</span> <span class="n">RQCF_ACT_SKIP</span><span class="p">)</span>
<span class="ln"> 193</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 194</span>
<span class="ln"> 195</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln"> 196</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">WARN_DOUBLE_CLOCK</span><span class="p">))</span>
<span class="ln"> 197</span>		<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;</span> <span class="n">RQCF_UPDATED</span><span class="p">);</span>
<span class="ln"> 198</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">|=</span> <span class="n">RQCF_UPDATED</span><span class="p">;</span>
<span class="ln"> 199</span><span class="cp">#endif
</span><span class="ln"> 200</span><span class="cp"></span>
<span class="ln"> 201</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">;</span>
<span class="ln"> 202</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 203</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 204</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 205</span>	<span class="n">update_rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln"> 206</span><span class="p">}</span>
<span class="ln"> 207</span>
<span class="ln"> 208</span>
<span class="ln"> 209</span><span class="cp">#ifdef CONFIG_SCHED_HRTICK
</span><span class="ln"> 210</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 211</span><span class="cm"> * Use HR-timers to deliver accurate preemption points.
</span><span class="ln"> 212</span><span class="cm"> */</span>
<span class="ln"> 213</span>
<span class="ln"> 214</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 215</span><span class="p">{</span>
<span class="ln"> 216</span>	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">))</span>
<span class="ln"> 217</span>		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">);</span>
<span class="ln"> 218</span><span class="p">}</span>
<span class="ln"> 219</span>
<span class="ln"> 220</span><span class="cm">/*
</span><span class="ln"> 221</span><span class="cm"> * High-resolution timer tick.
</span><span class="ln"> 222</span><span class="cm"> * Runs from hardirq context with interrupts disabled.
</span><span class="ln"> 223</span><span class="cm"> */</span>
<span class="ln"> 224</span><span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">hrtick</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="ln"> 225</span><span class="p">{</span>
<span class="ln"> 226</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">hrtick_timer</span><span class="p">);</span>
<span class="ln"> 227</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 228</span>
<span class="ln"> 229</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="ln"> 230</span>
<span class="ln"> 231</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 232</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 233</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 234</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 235</span>
<span class="ln"> 236</span>	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="ln"> 237</span><span class="p">}</span>
<span class="ln"> 238</span>
<span class="ln"> 239</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 240</span><span class="cp"></span>
<span class="ln"> 241</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__hrtick_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 242</span><span class="p">{</span>
<span class="ln"> 243</span>	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">;</span>
<span class="ln"> 244</span>
<span class="ln"> 245</span>	<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">);</span>
<span class="ln"> 246</span><span class="p">}</span>
<span class="ln"> 247</span>
<span class="ln"> 248</span><span class="cm">/*
</span><span class="ln"> 249</span><span class="cm"> * called from hardirq (IPI) context
</span><span class="ln"> 250</span><span class="cm"> */</span>
<span class="ln"> 251</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__hrtick_start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="ln"> 252</span><span class="p">{</span>
<span class="ln"> 253</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
<span class="ln"> 254</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 255</span>
<span class="ln"> 256</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 257</span>	<span class="n">__hrtick_restart</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 258</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 259</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 260</span><span class="p">}</span>
<span class="ln"> 261</span>
<span class="ln"> 262</span><span class="cm">/*
</span><span class="ln"> 263</span><span class="cm"> * Called to set the hrtick timer state.
</span><span class="ln"> 264</span><span class="cm"> *
</span><span class="ln"> 265</span><span class="cm"> * called with rq-&gt;lock held and irqs disabled
</span><span class="ln"> 266</span><span class="cm"> */</span>
<span class="ln"> 267</span><span class="kt">void</span> <span class="nf">hrtick_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delay</span><span class="p">)</span>
<span class="ln"> 268</span><span class="p">{</span>
<span class="ln"> 269</span>	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">;</span>
<span class="ln"> 270</span>	<span class="n">ktime_t</span> <span class="n">time</span><span class="p">;</span>
<span class="ln"> 271</span>	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 272</span>
<span class="ln"> 273</span>	<span class="cm">/*
</span><span class="ln"> 274</span><span class="cm">	 * Don&#39;t schedule slices shorter than 10000ns, that just
</span><span class="ln"> 275</span><span class="cm">	 * doesn&#39;t make sense and can cause timer DoS.
</span><span class="ln"> 276</span><span class="cm">	 */</span>
<span class="ln"> 277</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">s64</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="mi">10000LL</span><span class="p">);</span>
<span class="ln"> 278</span>	<span class="n">time</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">get_time</span><span class="p">(),</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln"> 279</span>
<span class="ln"> 280</span>	<span class="n">hrtimer_set_expires</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>
<span class="ln"> 281</span>
<span class="ln"> 282</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">==</span> <span class="n">this_rq</span><span class="p">())</span> <span class="p">{</span>
<span class="ln"> 283</span>		<span class="n">__hrtick_restart</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 284</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 285</span>		<span class="n">smp_call_function_single_async</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">);</span>
<span class="ln"> 286</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 287</span>	<span class="p">}</span>
<span class="ln"> 288</span><span class="p">}</span>
<span class="ln"> 289</span>
<span class="ln"> 290</span><span class="cp">#else
</span><span class="ln"> 291</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 292</span><span class="cm"> * Called to set the hrtick timer state.
</span><span class="ln"> 293</span><span class="cm"> *
</span><span class="ln"> 294</span><span class="cm"> * called with rq-&gt;lock held and irqs disabled
</span><span class="ln"> 295</span><span class="cm"> */</span>
<span class="ln"> 296</span><span class="kt">void</span> <span class="nf">hrtick_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delay</span><span class="p">)</span>
<span class="ln"> 297</span><span class="p">{</span>
<span class="ln"> 298</span>	<span class="cm">/*
</span><span class="ln"> 299</span><span class="cm">	 * Don&#39;t schedule slices shorter than 10000ns, that just
</span><span class="ln"> 300</span><span class="cm">	 * doesn&#39;t make sense. Rely on vruntime for fairness.
</span><span class="ln"> 301</span><span class="cm">	 */</span>
<span class="ln"> 302</span>	<span class="n">delay</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="mi">10000LL</span><span class="p">);</span>
<span class="ln"> 303</span>	<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">,</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">delay</span><span class="p">),</span>
<span class="ln"> 304</span>		      <span class="n">HRTIMER_MODE_REL_PINNED</span><span class="p">);</span>
<span class="ln"> 305</span><span class="p">}</span>
<span class="ln"> 306</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 307</span><span class="cp"></span>
<span class="ln"> 308</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_rq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 309</span><span class="p">{</span>
<span class="ln"> 310</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 311</span><span class="cp"></span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 312</span>
<span class="ln"> 313</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 314</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">__hrtick_start</span><span class="p">;</span>
<span class="ln"> 315</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_csd</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln"> 316</span><span class="cp">#endif
</span><span class="ln"> 317</span><span class="cp"></span>
<span class="ln"> 318</span>	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="ln"> 319</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">hrtick</span><span class="p">;</span>
<span class="ln"> 320</span><span class="p">}</span>
<span class="ln"> 321</span><span class="cp">#else	</span><span class="cm">/* CONFIG_SCHED_HRTICK */</span><span class="cp">
</span><span class="ln"> 322</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtick_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 323</span><span class="p">{</span>
<span class="ln"> 324</span><span class="p">}</span>
<span class="ln"> 325</span>
<span class="ln"> 326</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtick_rq_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 327</span><span class="p">{</span>
<span class="ln"> 328</span><span class="p">}</span>
<span class="ln"> 329</span><span class="cp">#endif	</span><span class="cm">/* CONFIG_SCHED_HRTICK */</span><span class="cp">
</span><span class="ln"> 330</span><span class="cp"></span>
<span class="ln"> 331</span><span class="cm">/*
</span><span class="ln"> 332</span><span class="cm"> * cmpxchg based fetch_or, macro so it works for different integer types
</span><span class="ln"> 333</span><span class="cm"> */</span>
<span class="ln"> 334</span><span class="cp">#define fetch_or(ptr, mask)						\
</span><span class="ln"> 335</span><span class="cp">	({								\
</span><span class="ln"> 336</span><span class="cp">		typeof(ptr) _ptr = (ptr);				\
</span><span class="ln"> 337</span><span class="cp">		typeof(mask) _mask = (mask);				\
</span><span class="ln"> 338</span><span class="cp">		typeof(*_ptr) _old, _val = *_ptr;			\
</span><span class="ln"> 339</span><span class="cp">									\
</span><span class="ln"> 340</span><span class="cp">		for (;;) {						\
</span><span class="ln"> 341</span><span class="cp">			_old = cmpxchg(_ptr, _val, _val | _mask);	\
</span><span class="ln"> 342</span><span class="cp">			if (_old == _val)				\
</span><span class="ln"> 343</span><span class="cp">				break;					\
</span><span class="ln"> 344</span><span class="cp">			_val = _old;					\
</span><span class="ln"> 345</span><span class="cp">		}							\
</span><span class="ln"> 346</span><span class="cp">	_old;								\
</span><span class="ln"> 347</span><span class="cp">})
</span><span class="ln"> 348</span><span class="cp"></span>
<span class="ln"> 349</span><span class="cp">#if defined(CONFIG_SMP) &amp;&amp; defined(TIF_POLLING_NRFLAG)
</span><span class="ln"> 350</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 351</span><span class="cm"> * Atomically set TIF_NEED_RESCHED and test for TIF_POLLING_NRFLAG,
</span><span class="ln"> 352</span><span class="cm"> * this avoids any races wrt polling state changes and thereby avoids
</span><span class="ln"> 353</span><span class="cm"> * spurious IPIs.
</span><span class="ln"> 354</span><span class="cm"> */</span>
<span class="ln"> 355</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">set_nr_and_not_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 356</span><span class="p">{</span>
<span class="ln"> 357</span>	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 358</span>	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">fetch_or</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">_TIF_NEED_RESCHED</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_TIF_POLLING_NRFLAG</span><span class="p">);</span>
<span class="ln"> 359</span><span class="p">}</span>
<span class="ln"> 360</span>
<span class="ln"> 361</span><span class="cm">/*
</span><span class="ln"> 362</span><span class="cm"> * Atomically set TIF_NEED_RESCHED if TIF_POLLING_NRFLAG is set.
</span><span class="ln"> 363</span><span class="cm"> *
</span><span class="ln"> 364</span><span class="cm"> * If this returns true, then the idle task promises to call
</span><span class="ln"> 365</span><span class="cm"> * sched_ttwu_pending() and reschedule soon.
</span><span class="ln"> 366</span><span class="cm"> */</span>
<span class="ln"> 367</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">set_nr_if_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 368</span><span class="p">{</span>
<span class="ln"> 369</span>	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 370</span>	<span class="n">typeof</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="n">old</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="ln"> 371</span>
<span class="ln"> 372</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln"> 373</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_TIF_POLLING_NRFLAG</span><span class="p">))</span>
<span class="ln"> 374</span>			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 375</span>		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">_TIF_NEED_RESCHED</span><span class="p">)</span>
<span class="ln"> 376</span>			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 377</span>		<span class="n">old</span> <span class="o">=</span> <span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val</span> <span class="o">|</span> <span class="n">_TIF_NEED_RESCHED</span><span class="p">);</span>
<span class="ln"> 378</span>		<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
<span class="ln"> 379</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 380</span>		<span class="n">val</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
<span class="ln"> 381</span>	<span class="p">}</span>
<span class="ln"> 382</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 383</span><span class="p">}</span>
<span class="ln"> 384</span>
<span class="ln"> 385</span><span class="cp">#else
</span><span class="ln"> 386</span><span class="cp"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">set_nr_and_not_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 387</span><span class="p">{</span>
<span class="ln"> 388</span>	<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 389</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 390</span><span class="p">}</span>
<span class="ln"> 391</span>
<span class="ln"> 392</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 393</span><span class="cp"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">set_nr_if_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 394</span><span class="p">{</span>
<span class="ln"> 395</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 396</span><span class="p">}</span>
<span class="ln"> 397</span><span class="cp">#endif
</span><span class="ln"> 398</span><span class="cp">#endif
</span><span class="ln"> 399</span><span class="cp"></span>
<span class="ln"> 400</span><span class="kt">void</span> <span class="nf">wake_q_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">wake_q_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="ln"> 401</span><span class="p">{</span>
<span class="ln"> 402</span>	<span class="k">struct</span> <span class="n">wake_q_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">wake_q</span><span class="p">;</span>
<span class="ln"> 403</span>
<span class="ln"> 404</span>	<span class="cm">/*
</span><span class="ln"> 405</span><span class="cm">	 * Atomically grab the task, if -&gt;wake_q is !nil already it means
</span><span class="ln"> 406</span><span class="cm">	 * its already queued (either by us or someone else) and will get the
</span><span class="ln"> 407</span><span class="cm">	 * wakeup due to that.
</span><span class="ln"> 408</span><span class="cm">	 *
</span><span class="ln"> 409</span><span class="cm">	 * In order to ensure that a pending wakeup will observe our pending
</span><span class="ln"> 410</span><span class="cm">	 * state, even in the failed case, an explicit smp_mb() must be used.
</span><span class="ln"> 411</span><span class="cm">	 */</span>
<span class="ln"> 412</span>	<span class="n">smp_mb__before_atomic</span><span class="p">();</span>
<span class="ln"> 413</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WAKE_Q_TAIL</span><span class="p">))</span>
<span class="ln"> 414</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 415</span>
<span class="ln"> 416</span>	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="ln"> 417</span>
<span class="ln"> 418</span>	<span class="cm">/*
</span><span class="ln"> 419</span><span class="cm">	 * The head is context local, there can be no concurrency.
</span><span class="ln"> 420</span><span class="cm">	 */</span>
<span class="ln"> 421</span>	<span class="o">*</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lastp</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="ln"> 422</span>	<span class="n">head</span><span class="o">-&gt;</span><span class="n">lastp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="ln"> 423</span><span class="p">}</span>
<span class="ln"> 424</span>
<span class="ln"> 425</span><span class="kt">void</span> <span class="nf">wake_up_q</span><span class="p">(</span><span class="k">struct</span> <span class="n">wake_q_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="ln"> 426</span><span class="p">{</span>
<span class="ln"> 427</span>	<span class="k">struct</span> <span class="n">wake_q_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="ln"> 428</span>
<span class="ln"> 429</span>	<span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">WAKE_Q_TAIL</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 430</span>		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="ln"> 431</span>
<span class="ln"> 432</span>		<span class="n">task</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">wake_q</span><span class="p">);</span>
<span class="ln"> 433</span>		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">);</span>
<span class="ln"> 434</span>		<span class="cm">/* Task can safely be re-inserted now: */</span>
<span class="ln"> 435</span>		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="ln"> 436</span>		<span class="n">task</span><span class="o">-&gt;</span><span class="n">wake_q</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 437</span>
<span class="ln"> 438</span>		<span class="cm">/*
</span><span class="ln"> 439</span><span class="cm">		 * wake_up_process() executes a full barrier, which pairs with
</span><span class="ln"> 440</span><span class="cm">		 * the queueing in wake_q_add() so as not to miss wakeups.
</span><span class="ln"> 441</span><span class="cm">		 */</span>
<span class="ln"> 442</span>		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="ln"> 443</span>		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="ln"> 444</span>	<span class="p">}</span>
<span class="ln"> 445</span><span class="p">}</span>
<span class="ln"> 446</span>
<span class="ln"> 447</span><span class="cm">/*
</span><span class="ln"> 448</span><span class="cm"> * resched_curr - mark rq&#39;s current task &#39;to be rescheduled now&#39;.
</span><span class="ln"> 449</span><span class="cm"> *
</span><span class="ln"> 450</span><span class="cm"> * On UP this means the setting of the need_resched flag, on SMP it
</span><span class="ln"> 451</span><span class="cm"> * might also involve a cross-CPU call to trigger the scheduler on
</span><span class="ln"> 452</span><span class="cm"> * the target CPU.
</span><span class="ln"> 453</span><span class="cm"> */</span>
<span class="ln"> 454</span><span class="kt">void</span> <span class="nf">resched_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 455</span><span class="p">{</span>
<span class="ln"> 456</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 457</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 458</span>
<span class="ln"> 459</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 460</span>
<span class="ln"> 461</span>	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>
<span class="ln"> 462</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 463</span>
<span class="ln"> 464</span>	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 465</span>
<span class="ln"> 466</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="p">{</span>
<span class="ln"> 467</span>		<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 468</span>		<span class="n">set_preempt_need_resched</span><span class="p">();</span>
<span class="ln"> 469</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 470</span>	<span class="p">}</span>
<span class="ln"> 471</span>
<span class="ln"> 472</span>	<span class="k">if</span> <span class="p">(</span><span class="n">set_nr_and_not_polling</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>
<span class="ln"> 473</span>		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 474</span>	<span class="k">else</span>
<span class="ln"> 475</span>		<span class="n">trace_sched_wake_idle_without_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 476</span><span class="p">}</span>
<span class="ln"> 477</span>
<span class="ln"> 478</span><span class="kt">void</span> <span class="nf">resched_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 479</span><span class="p">{</span>
<span class="ln"> 480</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 481</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln"> 482</span>
<span class="ln"> 483</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 484</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
<span class="ln"> 485</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 486</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 487</span><span class="p">}</span>
<span class="ln"> 488</span>
<span class="ln"> 489</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 490</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 491</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 492</span><span class="cm"> * In the semi idle case, use the nearest busy CPU for migrating timers
</span><span class="ln"> 493</span><span class="cm"> * from an idle CPU.  This is good for power-savings.
</span><span class="ln"> 494</span><span class="cm"> *
</span><span class="ln"> 495</span><span class="cm"> * We don&#39;t do similar optimization for completely idle system, as
</span><span class="ln"> 496</span><span class="cm"> * selecting an idle CPU will add more delays to the timers than intended
</span><span class="ln"> 497</span><span class="cm"> * (as that CPU&#39;s timer base may not be uptodate wrt jiffies etc).
</span><span class="ln"> 498</span><span class="cm"> */</span>
<span class="ln"> 499</span><span class="kt">int</span> <span class="nf">get_nohz_timer_target</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 500</span><span class="p">{</span>
<span class="ln"> 501</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="ln"> 502</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 503</span>
<span class="ln"> 504</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">HK_FLAG_TIMER</span><span class="p">))</span>
<span class="ln"> 505</span>		<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 506</span>
<span class="ln"> 507</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 508</span>	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 509</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 510</span>			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
<span class="ln"> 511</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 512</span>
<span class="ln"> 513</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">HK_FLAG_TIMER</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 514</span>				<span class="n">cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 515</span>				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 516</span>			<span class="p">}</span>
<span class="ln"> 517</span>		<span class="p">}</span>
<span class="ln"> 518</span>	<span class="p">}</span>
<span class="ln"> 519</span>
<span class="ln"> 520</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">HK_FLAG_TIMER</span><span class="p">))</span>
<span class="ln"> 521</span>		<span class="n">cpu</span> <span class="o">=</span> <span class="n">housekeeping_any_cpu</span><span class="p">(</span><span class="n">HK_FLAG_TIMER</span><span class="p">);</span>
<span class="ln"> 522</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln"> 523</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 524</span>	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 525</span><span class="p">}</span>
<span class="ln"> 526</span>
<span class="ln"> 527</span><span class="cm">/*
</span><span class="ln"> 528</span><span class="cm"> * When add_timer_on() enqueues a timer into the timer wheel of an
</span><span class="ln"> 529</span><span class="cm"> * idle CPU then this timer might expire before the next timer event
</span><span class="ln"> 530</span><span class="cm"> * which is scheduled to wake up that CPU. In case of a completely
</span><span class="ln"> 531</span><span class="cm"> * idle system the next event might even be infinite time into the
</span><span class="ln"> 532</span><span class="cm"> * future. wake_up_idle_cpu() ensures that the CPU is woken up and
</span><span class="ln"> 533</span><span class="cm"> * leaves the inner idle loop so the newly added timer is taken into
</span><span class="ln"> 534</span><span class="cm"> * account when the CPU goes back to idle and evaluates the timer
</span><span class="ln"> 535</span><span class="cm"> * wheel for the next timer event.
</span><span class="ln"> 536</span><span class="cm"> */</span>
<span class="ln"> 537</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">wake_up_idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 538</span><span class="p">{</span>
<span class="ln"> 539</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 540</span>
<span class="ln"> 541</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
<span class="ln"> 542</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 543</span>
<span class="ln"> 544</span>	<span class="k">if</span> <span class="p">(</span><span class="n">set_nr_and_not_polling</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span>
<span class="ln"> 545</span>		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 546</span>	<span class="k">else</span>
<span class="ln"> 547</span>		<span class="n">trace_sched_wake_idle_without_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 548</span><span class="p">}</span>
<span class="ln"> 549</span>
<span class="ln"> 550</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">wake_up_full_nohz_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 551</span><span class="p">{</span>
<span class="ln"> 552</span>	<span class="cm">/*
</span><span class="ln"> 553</span><span class="cm">	 * We just need the target to call irq_exit() and re-evaluate
</span><span class="ln"> 554</span><span class="cm">	 * the next tick. The nohz full kick at least implies that.
</span><span class="ln"> 555</span><span class="cm">	 * If needed we can still optimize that later with an
</span><span class="ln"> 556</span><span class="cm">	 * empty IRQ.
</span><span class="ln"> 557</span><span class="cm">	 */</span>
<span class="ln"> 558</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 559</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="cm">/* Don&#39;t try to wake offline CPUs. */</span>
<span class="ln"> 560</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tick_nohz_full_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 561</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">||</span>
<span class="ln"> 562</span>		    <span class="n">tick_nohz_tick_stopped</span><span class="p">())</span>
<span class="ln"> 563</span>			<span class="n">tick_nohz_full_kick_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 564</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 565</span>	<span class="p">}</span>
<span class="ln"> 566</span>
<span class="ln"> 567</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 568</span><span class="p">}</span>
<span class="ln"> 569</span>
<span class="ln"> 570</span><span class="cm">/*
</span><span class="ln"> 571</span><span class="cm"> * Wake up the specified CPU.  If the CPU is going offline, it is the
</span><span class="ln"> 572</span><span class="cm"> * caller&#39;s responsibility to deal with the lost wakeup, for example,
</span><span class="ln"> 573</span><span class="cm"> * by hooking into the CPU_DEAD notifier like timers and hrtimers do.
</span><span class="ln"> 574</span><span class="cm"> */</span>
<span class="ln"> 575</span><span class="kt">void</span> <span class="nf">wake_up_nohz_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 576</span><span class="p">{</span>
<span class="ln"> 577</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wake_up_full_nohz_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 578</span>		<span class="n">wake_up_idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 579</span><span class="p">}</span>
<span class="ln"> 580</span>
<span class="ln"> 581</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">got_nohz_idle_kick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 582</span><span class="p">{</span>
<span class="ln"> 583</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="ln"> 584</span>
<span class="ln"> 585</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">))</span>
<span class="ln"> 586</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 587</span>
<span class="ln"> 588</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">need_resched</span><span class="p">())</span>
<span class="ln"> 589</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 590</span>
<span class="ln"> 591</span>	<span class="cm">/*
</span><span class="ln"> 592</span><span class="cm">	 * We can&#39;t run Idle Load Balance on this CPU for this time so we
</span><span class="ln"> 593</span><span class="cm">	 * cancel it and clear NOHZ_BALANCE_KICK
</span><span class="ln"> 594</span><span class="cm">	 */</span>
<span class="ln"> 595</span>	<span class="n">atomic_andnot</span><span class="p">(</span><span class="n">NOHZ_KICK_MASK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 596</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 597</span><span class="p">}</span>
<span class="ln"> 598</span>
<span class="ln"> 599</span><span class="cp">#else </span><span class="cm">/* CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 600</span><span class="cp"></span>
<span class="ln"> 601</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">got_nohz_idle_kick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 602</span><span class="p">{</span>
<span class="ln"> 603</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 604</span><span class="p">}</span>
<span class="ln"> 605</span>
<span class="ln"> 606</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 607</span><span class="cp"></span>
<span class="ln"> 608</span><span class="cp">#ifdef CONFIG_NO_HZ_FULL
</span><span class="ln"> 609</span><span class="cp"></span><span class="kt">bool</span> <span class="nf">sched_can_stop_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 610</span><span class="p">{</span>
<span class="ln"> 611</span>	<span class="kt">int</span> <span class="n">fifo_nr_running</span><span class="p">;</span>
<span class="ln"> 612</span>
<span class="ln"> 613</span>	<span class="cm">/* Deadline tasks, even if single, need the tick */</span>
<span class="ln"> 614</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">.</span><span class="n">dl_nr_running</span><span class="p">)</span>
<span class="ln"> 615</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 616</span>
<span class="ln"> 617</span>	<span class="cm">/*
</span><span class="ln"> 618</span><span class="cm">	 * If there are more than one RR tasks, we need the tick to effect the
</span><span class="ln"> 619</span><span class="cm">	 * actual RR behaviour.
</span><span class="ln"> 620</span><span class="cm">	 */</span>
<span class="ln"> 621</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rr_nr_running</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 622</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rr_nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 623</span>			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 624</span>		<span class="k">else</span>
<span class="ln"> 625</span>			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 626</span>	<span class="p">}</span>
<span class="ln"> 627</span>
<span class="ln"> 628</span>	<span class="cm">/*
</span><span class="ln"> 629</span><span class="cm">	 * If there&#39;s no RR tasks, but FIFO tasks, we can skip the tick, no
</span><span class="ln"> 630</span><span class="cm">	 * forced preemption between FIFO tasks.
</span><span class="ln"> 631</span><span class="cm">	 */</span>
<span class="ln"> 632</span>	<span class="n">fifo_nr_running</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_nr_running</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rr_nr_running</span><span class="p">;</span>
<span class="ln"> 633</span>	<span class="k">if</span> <span class="p">(</span><span class="n">fifo_nr_running</span><span class="p">)</span>
<span class="ln"> 634</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 635</span>
<span class="ln"> 636</span>	<span class="cm">/*
</span><span class="ln"> 637</span><span class="cm">	 * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;
</span><span class="ln"> 638</span><span class="cm">	 * if there&#39;s more than one we need the tick for involuntary
</span><span class="ln"> 639</span><span class="cm">	 * preemption.
</span><span class="ln"> 640</span><span class="cm">	 */</span>
<span class="ln"> 641</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 642</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 643</span>
<span class="ln"> 644</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 645</span><span class="p">}</span>
<span class="ln"> 646</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ_FULL */</span><span class="cp">
</span><span class="ln"> 647</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 648</span><span class="cp"></span>
<span class="ln"> 649</span><span class="cp">#if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) &amp;&amp; \
</span><span class="ln"> 650</span><span class="cp">			(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))
</span><span class="ln"> 651</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 652</span><span class="cm"> * Iterate task_group tree rooted at *from, calling @down when first entering a
</span><span class="ln"> 653</span><span class="cm"> * node and @up when leaving it for the final time.
</span><span class="ln"> 654</span><span class="cm"> *
</span><span class="ln"> 655</span><span class="cm"> * Caller must hold rcu_lock or sufficient equivalent.
</span><span class="ln"> 656</span><span class="cm"> */</span>
<span class="ln"> 657</span><span class="kt">int</span> <span class="nf">walk_tg_tree_from</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
<span class="ln"> 658</span>			     <span class="n">tg_visitor</span> <span class="n">down</span><span class="p">,</span> <span class="n">tg_visitor</span> <span class="n">up</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln"> 659</span><span class="p">{</span>
<span class="ln"> 660</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
<span class="ln"> 661</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 662</span>
<span class="ln"> 663</span>	<span class="n">parent</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
<span class="ln"> 664</span>
<span class="ln"> 665</span><span class="nl">down</span><span class="p">:</span>
<span class="ln"> 666</span>	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">down</span><span class="p">)(</span><span class="n">parent</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="ln"> 667</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln"> 668</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 669</span>	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">siblings</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 670</span>		<span class="n">parent</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
<span class="ln"> 671</span>		<span class="k">goto</span> <span class="n">down</span><span class="p">;</span>
<span class="ln"> 672</span>
<span class="ln"> 673</span><span class="nl">up</span><span class="p">:</span>
<span class="ln"> 674</span>		<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 675</span>	<span class="p">}</span>
<span class="ln"> 676</span>	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">up</span><span class="p">)(</span><span class="n">parent</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="ln"> 677</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">from</span><span class="p">)</span>
<span class="ln"> 678</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 679</span>
<span class="ln"> 680</span>	<span class="n">child</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
<span class="ln"> 681</span>	<span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="ln"> 682</span>	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="ln"> 683</span>		<span class="k">goto</span> <span class="n">up</span><span class="p">;</span>
<span class="ln"> 684</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 685</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 686</span><span class="p">}</span>
<span class="ln"> 687</span>
<span class="ln"> 688</span><span class="kt">int</span> <span class="nf">tg_nop</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln"> 689</span><span class="p">{</span>
<span class="ln"> 690</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 691</span><span class="p">}</span>
<span class="ln"> 692</span><span class="cp">#endif
</span><span class="ln"> 693</span><span class="cp"></span>
<span class="ln"> 694</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_load_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">update_load</span><span class="p">)</span>
<span class="ln"> 695</span><span class="p">{</span>
<span class="ln"> 696</span>	<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">-</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
<span class="ln"> 697</span>	<span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">;</span>
<span class="ln"> 698</span>
<span class="ln"> 699</span>	<span class="cm">/*
</span><span class="ln"> 700</span><span class="cm">	 * SCHED_IDLE tasks get minimal weight:
</span><span class="ln"> 701</span><span class="cm">	 */</span>
<span class="ln"> 702</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idle_policy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 703</span>		<span class="n">load</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">WEIGHT_IDLEPRIO</span><span class="p">);</span>
<span class="ln"> 704</span>		<span class="n">load</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">WMULT_IDLEPRIO</span><span class="p">;</span>
<span class="ln"> 705</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 706</span>	<span class="p">}</span>
<span class="ln"> 707</span>
<span class="ln"> 708</span>	<span class="cm">/*
</span><span class="ln"> 709</span><span class="cm">	 * SCHED_OTHER tasks have to update their load when changing their
</span><span class="ln"> 710</span><span class="cm">	 * weight
</span><span class="ln"> 711</span><span class="cm">	 */</span>
<span class="ln"> 712</span>	<span class="k">if</span> <span class="p">(</span><span class="n">update_load</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 713</span>		<span class="n">reweight_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
<span class="ln"> 714</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 715</span>		<span class="n">load</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">sched_prio_to_weight</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>
<span class="ln"> 716</span>		<span class="n">load</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">sched_prio_to_wmult</span><span class="p">[</span><span class="n">prio</span><span class="p">];</span>
<span class="ln"> 717</span>	<span class="p">}</span>
<span class="ln"> 718</span><span class="p">}</span>
<span class="ln"> 719</span>
<span class="ln"> 720</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enqueue_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 721</span><span class="p">{</span>
<span class="ln"> 722</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">))</span>
<span class="ln"> 723</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 724</span>
<span class="ln"> 725</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_RESTORE</span><span class="p">))</span>
<span class="ln"> 726</span>		<span class="n">sched_info_queued</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 727</span>
<span class="ln"> 728</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 729</span><span class="p">}</span>
<span class="ln"> 730</span>
<span class="ln"> 731</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dequeue_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 732</span><span class="p">{</span>
<span class="ln"> 733</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">))</span>
<span class="ln"> 734</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 735</span>
<span class="ln"> 736</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SAVE</span><span class="p">))</span>
<span class="ln"> 737</span>		<span class="n">sched_info_dequeued</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 738</span>
<span class="ln"> 739</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 740</span><span class="p">}</span>
<span class="ln"> 741</span>
<span class="ln"> 742</span><span class="kt">void</span> <span class="nf">activate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 743</span><span class="p">{</span>
<span class="ln"> 744</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 745</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 746</span>
<span class="ln"> 747</span>	<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 748</span><span class="p">}</span>
<span class="ln"> 749</span>
<span class="ln"> 750</span><span class="kt">void</span> <span class="nf">deactivate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 751</span><span class="p">{</span>
<span class="ln"> 752</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 753</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 754</span>
<span class="ln"> 755</span>	<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 756</span><span class="p">}</span>
<span class="ln"> 757</span>
<span class="ln"> 758</span><span class="cm">/*
</span><span class="ln"> 759</span><span class="cm"> * __normal_prio - return the priority that is based on the static prio
</span><span class="ln"> 760</span><span class="cm"> */</span>
<span class="ln"> 761</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__normal_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 762</span><span class="p">{</span>
<span class="ln"> 763</span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">;</span>
<span class="ln"> 764</span><span class="p">}</span>
<span class="ln"> 765</span>
<span class="ln"> 766</span><span class="cm">/*
</span><span class="ln"> 767</span><span class="cm"> * Calculate the expected normal priority: i.e. priority
</span><span class="ln"> 768</span><span class="cm"> * without taking RT-inheritance into account. Might be
</span><span class="ln"> 769</span><span class="cm"> * boosted by interactivity modifiers. Changes upon fork,
</span><span class="ln"> 770</span><span class="cm"> * setprio syscalls, and whenever the interactivity
</span><span class="ln"> 771</span><span class="cm"> * estimator recalculates.
</span><span class="ln"> 772</span><span class="cm"> */</span>
<span class="ln"> 773</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">normal_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 774</span><span class="p">{</span>
<span class="ln"> 775</span>	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>
<span class="ln"> 776</span>
<span class="ln"> 777</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_dl_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 778</span>		<span class="n">prio</span> <span class="o">=</span> <span class="n">MAX_DL_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 779</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 780</span>		<span class="n">prio</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">;</span>
<span class="ln"> 781</span>	<span class="k">else</span>
<span class="ln"> 782</span>		<span class="n">prio</span> <span class="o">=</span> <span class="n">__normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 783</span>	<span class="k">return</span> <span class="n">prio</span><span class="p">;</span>
<span class="ln"> 784</span><span class="p">}</span>
<span class="ln"> 785</span>
<span class="ln"> 786</span><span class="cm">/*
</span><span class="ln"> 787</span><span class="cm"> * Calculate the current priority, i.e. the priority
</span><span class="ln"> 788</span><span class="cm"> * taken into account by the scheduler. This value might
</span><span class="ln"> 789</span><span class="cm"> * be boosted by RT tasks, or might be boosted by
</span><span class="ln"> 790</span><span class="cm"> * interactivity modifiers. Will be RT if the task got
</span><span class="ln"> 791</span><span class="cm"> * RT-boosted. If not then it returns p-&gt;normal_prio.
</span><span class="ln"> 792</span><span class="cm"> */</span>
<span class="ln"> 793</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">effective_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 794</span><span class="p">{</span>
<span class="ln"> 795</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 796</span>	<span class="cm">/*
</span><span class="ln"> 797</span><span class="cm">	 * If we are RT tasks or we were boosted to RT priority,
</span><span class="ln"> 798</span><span class="cm">	 * keep the priority unchanged. Otherwise, update priority
</span><span class="ln"> 799</span><span class="cm">	 * to the normal priority:
</span><span class="ln"> 800</span><span class="cm">	 */</span>
<span class="ln"> 801</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
<span class="ln"> 802</span>		<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
<span class="ln"> 803</span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="ln"> 804</span><span class="p">}</span>
<span class="ln"> 805</span>
<span class="ln"> 806</span><span class="cm">/**
</span><span class="ln"> 807</span><span class="cm"> * task_curr - is this task currently executing on a CPU?
</span><span class="ln"> 808</span><span class="cm"> * @p: the task in question.
</span><span class="ln"> 809</span><span class="cm"> *
</span><span class="ln"> 810</span><span class="cm"> * Return: 1 if the task is currently executing. 0 otherwise.
</span><span class="ln"> 811</span><span class="cm"> */</span>
<span class="ln"> 812</span><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_curr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 813</span><span class="p">{</span>
<span class="ln"> 814</span>	<span class="k">return</span> <span class="n">cpu_curr</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">p</span><span class="p">;</span>
<span class="ln"> 815</span><span class="p">}</span>
<span class="ln"> 816</span>
<span class="ln"> 817</span><span class="cm">/*
</span><span class="ln"> 818</span><span class="cm"> * switched_from, switched_to and prio_changed must _NOT_ drop rq-&gt;lock,
</span><span class="ln"> 819</span><span class="cm"> * use the balance_callback list if you want balancing.
</span><span class="ln"> 820</span><span class="cm"> *
</span><span class="ln"> 821</span><span class="cm"> * this means any call to check_class_changed() must be followed by a call to
</span><span class="ln"> 822</span><span class="cm"> * balance_callback().
</span><span class="ln"> 823</span><span class="cm"> */</span>
<span class="ln"> 824</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_class_changed</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 825</span>				       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">,</span>
<span class="ln"> 826</span>				       <span class="kt">int</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="ln"> 827</span><span class="p">{</span>
<span class="ln"> 828</span>	<span class="k">if</span> <span class="p">(</span><span class="n">prev_class</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 829</span>		<span class="k">if</span> <span class="p">(</span><span class="n">prev_class</span><span class="o">-&gt;</span><span class="n">switched_from</span><span class="p">)</span>
<span class="ln"> 830</span>			<span class="n">prev_class</span><span class="o">-&gt;</span><span class="n">switched_from</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 831</span>
<span class="ln"> 832</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">switched_to</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 833</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">||</span> <span class="n">dl_task</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 834</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">prio_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">);</span>
<span class="ln"> 835</span><span class="p">}</span>
<span class="ln"> 836</span>
<span class="ln"> 837</span><span class="kt">void</span> <span class="nf">check_preempt_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 838</span><span class="p">{</span>
<span class="ln"> 839</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
<span class="ln"> 840</span>
<span class="ln"> 841</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 842</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 843</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 844</span>		<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 845</span>			<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span>
<span class="ln"> 846</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln"> 847</span>			<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 848</span>				<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 849</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln"> 850</span>			<span class="p">}</span>
<span class="ln"> 851</span>		<span class="p">}</span>
<span class="ln"> 852</span>	<span class="p">}</span>
<span class="ln"> 853</span>
<span class="ln"> 854</span>	<span class="cm">/*
</span><span class="ln"> 855</span><span class="cm">	 * A queue event has occurred, and we&#39;re going to schedule.  In
</span><span class="ln"> 856</span><span class="cm">	 * this case, we can save a useless back to back clock update.
</span><span class="ln"> 857</span><span class="cm">	 */</span>
<span class="ln"> 858</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span>
<span class="ln"> 859</span>		<span class="n">rq_clock_skip_update</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 860</span><span class="p">}</span>
<span class="ln"> 861</span>
<span class="ln"> 862</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 863</span><span class="cp"></span>
<span class="ln"> 864</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_per_cpu_kthread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 865</span><span class="p">{</span>
<span class="ln"> 866</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">))</span>
<span class="ln"> 867</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 868</span>
<span class="ln"> 869</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 870</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 871</span>
<span class="ln"> 872</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 873</span><span class="p">}</span>
<span class="ln"> 874</span>
<span class="ln"> 875</span><span class="cm">/*
</span><span class="ln"> 876</span><span class="cm"> * Per-CPU kthreads are allowed to run on !actie &amp;&amp; online CPUs, see
</span><span class="ln"> 877</span><span class="cm"> * __set_cpus_allowed_ptr() and select_fallback_rq().
</span><span class="ln"> 878</span><span class="cm"> */</span>
<span class="ln"> 879</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">is_cpu_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 880</span><span class="p">{</span>
<span class="ln"> 881</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 882</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 883</span>
<span class="ln"> 884</span>	<span class="k">if</span> <span class="p">(</span><span class="n">is_per_cpu_kthread</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 885</span>		<span class="k">return</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 886</span>
<span class="ln"> 887</span>	<span class="k">return</span> <span class="n">cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 888</span><span class="p">}</span>
<span class="ln"> 889</span>
<span class="ln"> 890</span><span class="cm">/*
</span><span class="ln"> 891</span><span class="cm"> * This is how migration works:
</span><span class="ln"> 892</span><span class="cm"> *
</span><span class="ln"> 893</span><span class="cm"> * 1) we invoke migration_cpu_stop() on the target CPU using
</span><span class="ln"> 894</span><span class="cm"> *    stop_one_cpu().
</span><span class="ln"> 895</span><span class="cm"> * 2) stopper starts to run (implicitly forcing the migrated thread
</span><span class="ln"> 896</span><span class="cm"> *    off the CPU)
</span><span class="ln"> 897</span><span class="cm"> * 3) it checks whether the migrated task is still in the wrong runqueue.
</span><span class="ln"> 898</span><span class="cm"> * 4) if it&#39;s in the wrong runqueue then the migration thread removes
</span><span class="ln"> 899</span><span class="cm"> *    it and puts it into the right queue.
</span><span class="ln"> 900</span><span class="cm"> * 5) stopper completes and stop_one_cpu() returns and the migration
</span><span class="ln"> 901</span><span class="cm"> *    is done.
</span><span class="ln"> 902</span><span class="cm"> */</span>
<span class="ln"> 903</span>
<span class="ln"> 904</span><span class="cm">/*
</span><span class="ln"> 905</span><span class="cm"> * move_queued_task - move a queued task to new rq.
</span><span class="ln"> 906</span><span class="cm"> *
</span><span class="ln"> 907</span><span class="cm"> * Returns (locked) new rq. Old rq&#39;s lock is released.
</span><span class="ln"> 908</span><span class="cm"> */</span>
<span class="ln"> 909</span><span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">move_queued_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">,</span>
<span class="ln"> 910</span>				   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_cpu</span><span class="p">)</span>
<span class="ln"> 911</span><span class="p">{</span>
<span class="ln"> 912</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 913</span>
<span class="ln"> 914</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">,</span> <span class="n">TASK_ON_RQ_MIGRATING</span><span class="p">);</span>
<span class="ln"> 915</span>	<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln"> 916</span>	<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln"> 917</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln"> 918</span>
<span class="ln"> 919</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">new_cpu</span><span class="p">);</span>
<span class="ln"> 920</span>
<span class="ln"> 921</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln"> 922</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln"> 923</span>	<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 924</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="ln"> 925</span>	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 926</span>
<span class="ln"> 927</span>	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln"> 928</span><span class="p">}</span>
<span class="ln"> 929</span>
<span class="ln"> 930</span><span class="k">struct</span> <span class="n">migration_arg</span> <span class="p">{</span>
<span class="ln"> 931</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="ln"> 932</span>	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln"> 933</span><span class="p">};</span>
<span class="ln"> 934</span>
<span class="ln"> 935</span><span class="cm">/*
</span><span class="ln"> 936</span><span class="cm"> * Move (not current) task off this CPU, onto the destination CPU. We&#39;re doing
</span><span class="ln"> 937</span><span class="cm"> * this because either it can&#39;t run here any more (set_cpus_allowed()
</span><span class="ln"> 938</span><span class="cm"> * away from this CPU, or CPU going down), or because we&#39;re
</span><span class="ln"> 939</span><span class="cm"> * attempting to rebalance this task on exec (sched_exec).
</span><span class="ln"> 940</span><span class="cm"> *
</span><span class="ln"> 941</span><span class="cm"> * So we race with normal scheduler movements, but that&#39;s OK, as long
</span><span class="ln"> 942</span><span class="cm"> * as the task is no longer on this CPU.
</span><span class="ln"> 943</span><span class="cm"> */</span>
<span class="ln"> 944</span><span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">__migrate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">,</span>
<span class="ln"> 945</span>				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">)</span>
<span class="ln"> 946</span><span class="p">{</span>
<span class="ln"> 947</span>	<span class="cm">/* Affinity changed (again). */</span>
<span class="ln"> 948</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_cpu_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">))</span>
<span class="ln"> 949</span>		<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln"> 950</span>
<span class="ln"> 951</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 952</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">move_queued_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">);</span>
<span class="ln"> 953</span>
<span class="ln"> 954</span>	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln"> 955</span><span class="p">}</span>
<span class="ln"> 956</span>
<span class="ln"> 957</span><span class="cm">/*
</span><span class="ln"> 958</span><span class="cm"> * migration_cpu_stop - this will be executed by a highprio stopper thread
</span><span class="ln"> 959</span><span class="cm"> * and performs thread migration by bumping thread off CPU then
</span><span class="ln"> 960</span><span class="cm"> * &#39;pushing&#39; onto another runqueue.
</span><span class="ln"> 961</span><span class="cm"> */</span>
<span class="ln"> 962</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">migration_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln"> 963</span><span class="p">{</span>
<span class="ln"> 964</span>	<span class="k">struct</span> <span class="n">migration_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="ln"> 965</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
<span class="ln"> 966</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln"> 967</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 968</span>
<span class="ln"> 969</span>	<span class="cm">/*
</span><span class="ln"> 970</span><span class="cm">	 * The original target CPU might have gone down and we might
</span><span class="ln"> 971</span><span class="cm">	 * be on another CPU but it doesn&#39;t matter.
</span><span class="ln"> 972</span><span class="cm">	 */</span>
<span class="ln"> 973</span>	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="ln"> 974</span>	<span class="cm">/*
</span><span class="ln"> 975</span><span class="cm">	 * We need to explicitly wake pending tasks before running
</span><span class="ln"> 976</span><span class="cm">	 * __migrate_task() such that we will not miss enforcing cpus_allowed
</span><span class="ln"> 977</span><span class="cm">	 * during wakeups, see set_cpus_allowed_ptr()&#39;s TASK_WAKING test.
</span><span class="ln"> 978</span><span class="cm">	 */</span>
<span class="ln"> 979</span>	<span class="n">sched_ttwu_pending</span><span class="p">();</span>
<span class="ln"> 980</span>
<span class="ln"> 981</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln"> 982</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 983</span>	<span class="cm">/*
</span><span class="ln"> 984</span><span class="cm">	 * If task_rq(p) != rq, it cannot be migrated here, because we&#39;re
</span><span class="ln"> 985</span><span class="cm">	 * holding rq-&gt;lock, if p-&gt;on_rq == 0 it cannot get enqueued because
</span><span class="ln"> 986</span><span class="cm">	 * we&#39;re holding p-&gt;pi_lock.
</span><span class="ln"> 987</span><span class="cm">	 */</span>
<span class="ln"> 988</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 989</span>		<span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 990</span>			<span class="n">rq</span> <span class="o">=</span> <span class="n">__migrate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">dest_cpu</span><span class="p">);</span>
<span class="ln"> 991</span>		<span class="k">else</span>
<span class="ln"> 992</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">wake_cpu</span> <span class="o">=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln"> 993</span>	<span class="p">}</span>
<span class="ln"> 994</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 995</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln"> 996</span>
<span class="ln"> 997</span>	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="ln"> 998</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 999</span><span class="p">}</span>
<span class="ln">1000</span>
<span class="ln">1001</span><span class="cm">/*
</span><span class="ln">1002</span><span class="cm"> * sched_class::set_cpus_allowed must do the below, but is not required to
</span><span class="ln">1003</span><span class="cm"> * actually call this function.
</span><span class="ln">1004</span><span class="cm"> */</span>
<span class="ln">1005</span><span class="kt">void</span> <span class="nf">set_cpus_allowed_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="ln">1006</span><span class="p">{</span>
<span class="ln">1007</span>	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">1008</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">=</span> <span class="n">cpumask_weight</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
<span class="ln">1009</span><span class="p">}</span>
<span class="ln">1010</span>
<span class="ln">1011</span><span class="kt">void</span> <span class="nf">do_set_cpus_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="ln">1012</span><span class="p">{</span>
<span class="ln">1013</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1014</span>	<span class="kt">bool</span> <span class="n">queued</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
<span class="ln">1015</span>
<span class="ln">1016</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">1017</span>
<span class="ln">1018</span>	<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1019</span>	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">1020</span>
<span class="ln">1021</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1022</span>		<span class="cm">/*
</span><span class="ln">1023</span><span class="cm">		 * Because __kthread_bind() calls this on blocked tasks without
</span><span class="ln">1024</span><span class="cm">		 * holding rq-&gt;lock.
</span><span class="ln">1025</span><span class="cm">		 */</span>
<span class="ln">1026</span>		<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">1027</span>		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">DEQUEUE_SAVE</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">1028</span>	<span class="p">}</span>
<span class="ln">1029</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">1030</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">1031</span>
<span class="ln">1032</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">1033</span>
<span class="ln">1034</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">1035</span>		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_RESTORE</span> <span class="o">|</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">1036</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">1037</span>		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">1038</span><span class="p">}</span>
<span class="ln">1039</span>
<span class="ln">1040</span><span class="cm">/*
</span><span class="ln">1041</span><span class="cm"> * Change a given task&#39;s CPU affinity. Migrate the thread to a
</span><span class="ln">1042</span><span class="cm"> * proper CPU and schedule it away if the CPU it&#39;s executing on
</span><span class="ln">1043</span><span class="cm"> * is removed from the allowed bitmask.
</span><span class="ln">1044</span><span class="cm"> *
</span><span class="ln">1045</span><span class="cm"> * NOTE: the caller must have a valid reference to the task, the
</span><span class="ln">1046</span><span class="cm"> * task must not exit() &amp; deallocate itself prematurely. The
</span><span class="ln">1047</span><span class="cm"> * call is not atomic; no spinlocks may be held.
</span><span class="ln">1048</span><span class="cm"> */</span>
<span class="ln">1049</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">__set_cpus_allowed_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">1050</span>				  <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">check</span><span class="p">)</span>
<span class="ln">1051</span><span class="p">{</span>
<span class="ln">1052</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpu_valid_mask</span> <span class="o">=</span> <span class="n">cpu_active_mask</span><span class="p">;</span>
<span class="ln">1053</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln">1054</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">1055</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">1056</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1057</span>
<span class="ln">1058</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1059</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">1060</span>
<span class="ln">1061</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1062</span>		<span class="cm">/*
</span><span class="ln">1063</span><span class="cm">		 * Kernel threads are allowed on online &amp;&amp; !active CPUs
</span><span class="ln">1064</span><span class="cm">		 */</span>
<span class="ln">1065</span>		<span class="n">cpu_valid_mask</span> <span class="o">=</span> <span class="n">cpu_online_mask</span><span class="p">;</span>
<span class="ln">1066</span>	<span class="p">}</span>
<span class="ln">1067</span>
<span class="ln">1068</span>	<span class="cm">/*
</span><span class="ln">1069</span><span class="cm">	 * Must re-check here, to close a race against __kthread_bind(),
</span><span class="ln">1070</span><span class="cm">	 * sched_setaffinity() is not guaranteed to observe the flag.
</span><span class="ln">1071</span><span class="cm">	 */</span>
<span class="ln">1072</span>	<span class="k">if</span> <span class="p">(</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_NO_SETAFFINITY</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1073</span>		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">1074</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1075</span>	<span class="p">}</span>
<span class="ln">1076</span>
<span class="ln">1077</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">))</span>
<span class="ln">1078</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1079</span>
<span class="ln">1080</span>	<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">cpumask_any_and</span><span class="p">(</span><span class="n">cpu_valid_mask</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">1081</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dest_cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1082</span>		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">1083</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1084</span>	<span class="p">}</span>
<span class="ln">1085</span>
<span class="ln">1086</span>	<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">1087</span>
<span class="ln">1088</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1089</span>		<span class="cm">/*
</span><span class="ln">1090</span><span class="cm">		 * For kernel threads that do indeed end up on online &amp;&amp;
</span><span class="ln">1091</span><span class="cm">		 * !active we want to ensure they are strict per-CPU threads.
</span><span class="ln">1092</span><span class="cm">		 */</span>
<span class="ln">1093</span>		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">1094</span>			<span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">1095</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">1096</span>	<span class="p">}</span>
<span class="ln">1097</span>
<span class="ln">1098</span>	<span class="cm">/* Can the task run on the task&#39;s current CPU? If so, we&#39;re done */</span>
<span class="ln">1099</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">new_mask</span><span class="p">))</span>
<span class="ln">1100</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1101</span>
<span class="ln">1102</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_WAKING</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1103</span>		<span class="k">struct</span> <span class="n">migration_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span> <span class="p">};</span>
<span class="ln">1104</span>		<span class="cm">/* Need help from migration thread: drop lock and wait. */</span>
<span class="ln">1105</span>		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1106</span>		<span class="n">stop_one_cpu</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">migration_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="ln">1107</span>		<span class="n">tlb_migrate_finish</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="ln">1108</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1109</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1110</span>		<span class="cm">/*
</span><span class="ln">1111</span><span class="cm">		 * OK, since we&#39;re going to drop the lock immediately
</span><span class="ln">1112</span><span class="cm">		 * afterwards anyway.
</span><span class="ln">1113</span><span class="cm">		 */</span>
<span class="ln">1114</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">move_queued_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">);</span>
<span class="ln">1115</span>	<span class="p">}</span>
<span class="ln">1116</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">1117</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1118</span>
<span class="ln">1119</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">1120</span><span class="p">}</span>
<span class="ln">1121</span>
<span class="ln">1122</span><span class="kt">int</span> <span class="nf">set_cpus_allowed_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="ln">1123</span><span class="p">{</span>
<span class="ln">1124</span>	<span class="k">return</span> <span class="n">__set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln">1125</span><span class="p">}</span>
<span class="ln">1126</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">set_cpus_allowed_ptr</span><span class="p">);</span>
<span class="ln">1127</span>
<span class="ln">1128</span><span class="kt">void</span> <span class="nf">set_task_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_cpu</span><span class="p">)</span>
<span class="ln">1129</span><span class="p">{</span>
<span class="ln">1130</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln">1131</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">1132</span><span class="cm">	 * We should never call set_task_cpu() on a blocked task,
</span><span class="ln">1133</span><span class="cm">	 * ttwu() will sort out the placement.
</span><span class="ln">1134</span><span class="cm">	 */</span>
<span class="ln">1135</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_WAKING</span> <span class="o">&amp;&amp;</span>
<span class="ln">1136</span>			<span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">);</span>
<span class="ln">1137</span>
<span class="ln">1138</span>	<span class="cm">/*
</span><span class="ln">1139</span><span class="cm">	 * Migrating fair class task must have p-&gt;on_rq = TASK_ON_RQ_MIGRATING,
</span><span class="ln">1140</span><span class="cm">	 * because schedstat_wait_{start,end} rebase migrating task&#39;s wait_start
</span><span class="ln">1141</span><span class="cm">	 * time relying on p-&gt;on_rq.
</span><span class="ln">1142</span><span class="cm">	 */</span>
<span class="ln">1143</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span>
<span class="ln">1144</span>		     <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span> <span class="o">&amp;&amp;</span>
<span class="ln">1145</span>		     <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">p</span><span class="p">)));</span>
<span class="ln">1146</span>
<span class="ln">1147</span><span class="cp">#ifdef CONFIG_LOCKDEP
</span><span class="ln">1148</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">1149</span><span class="cm">	 * The caller should hold either p-&gt;pi_lock or rq-&gt;lock, when changing
</span><span class="ln">1150</span><span class="cm">	 * a task&#39;s CPU. -&gt;pi_lock for waking tasks, rq-&gt;lock for runnable tasks.
</span><span class="ln">1151</span><span class="cm">	 *
</span><span class="ln">1152</span><span class="cm">	 * sched_move_task() holds both and thus holding either pins the cgroup,
</span><span class="ln">1153</span><span class="cm">	 * see task_group().
</span><span class="ln">1154</span><span class="cm">	 *
</span><span class="ln">1155</span><span class="cm">	 * Furthermore, all task_rq users should acquire both locks, see
</span><span class="ln">1156</span><span class="cm">	 * task_rq_lock().
</span><span class="ln">1157</span><span class="cm">	 */</span>
<span class="ln">1158</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">debug_locks</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">1159</span>				      <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)));</span>
<span class="ln">1160</span><span class="cp">#endif
</span><span class="ln">1161</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">1162</span><span class="cm">	 * Clearly, migrating tasks to offline CPUs is a fairly daft thing.
</span><span class="ln">1163</span><span class="cm">	 */</span>
<span class="ln">1164</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">new_cpu</span><span class="p">));</span>
<span class="ln">1165</span><span class="cp">#endif
</span><span class="ln">1166</span><span class="cp"></span>
<span class="ln">1167</span>	<span class="n">trace_sched_migrate_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln">1168</span>
<span class="ln">1169</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">new_cpu</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1170</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">migrate_task_rq</span><span class="p">)</span>
<span class="ln">1171</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">migrate_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln">1172</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">nr_migrations</span><span class="o">++</span><span class="p">;</span>
<span class="ln">1173</span>		<span class="n">rseq_migrate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1174</span>		<span class="n">perf_event_task_migrate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1175</span>	<span class="p">}</span>
<span class="ln">1176</span>
<span class="ln">1177</span>	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln">1178</span><span class="p">}</span>
<span class="ln">1179</span>
<span class="ln">1180</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln">1181</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__migrate_swap_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">1182</span><span class="p">{</span>
<span class="ln">1183</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1184</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">src_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_rq</span><span class="p">;</span>
<span class="ln">1185</span>		<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">srf</span><span class="p">,</span> <span class="n">drf</span><span class="p">;</span>
<span class="ln">1186</span>
<span class="ln">1187</span>		<span class="n">src_rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1188</span>		<span class="n">dst_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1189</span>
<span class="ln">1190</span>		<span class="n">rq_pin_lock</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srf</span><span class="p">);</span>
<span class="ln">1191</span>		<span class="n">rq_pin_lock</span><span class="p">(</span><span class="n">dst_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drf</span><span class="p">);</span>
<span class="ln">1192</span>
<span class="ln">1193</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_MIGRATING</span><span class="p">;</span>
<span class="ln">1194</span>		<span class="n">deactivate_task</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">1195</span>		<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">1196</span>		<span class="n">activate_task</span><span class="p">(</span><span class="n">dst_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">1197</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="ln">1198</span>		<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">dst_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">1199</span>
<span class="ln">1200</span>		<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">dst_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drf</span><span class="p">);</span>
<span class="ln">1201</span>		<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srf</span><span class="p">);</span>
<span class="ln">1202</span>
<span class="ln">1203</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">1204</span>		<span class="cm">/*
</span><span class="ln">1205</span><span class="cm">		 * Task isn&#39;t running anymore; make it appear like we migrated
</span><span class="ln">1206</span><span class="cm">		 * it before it went to sleep. This means on wakeup we make the
</span><span class="ln">1207</span><span class="cm">		 * previous CPU our target instead of where it really is.
</span><span class="ln">1208</span><span class="cm">		 */</span>
<span class="ln">1209</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">wake_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln">1210</span>	<span class="p">}</span>
<span class="ln">1211</span><span class="p">}</span>
<span class="ln">1212</span>
<span class="ln">1213</span><span class="k">struct</span> <span class="n">migration_swap_arg</span> <span class="p">{</span>
<span class="ln">1214</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">src_task</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_task</span><span class="p">;</span>
<span class="ln">1215</span>	<span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="n">dst_cpu</span><span class="p">;</span>
<span class="ln">1216</span><span class="p">};</span>
<span class="ln">1217</span>
<span class="ln">1218</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">migrate_swap_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln">1219</span><span class="p">{</span>
<span class="ln">1220</span>	<span class="k">struct</span> <span class="n">migration_swap_arg</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="ln">1221</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">src_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_rq</span><span class="p">;</span>
<span class="ln">1222</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="ln">1223</span>
<span class="ln">1224</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">))</span>
<span class="ln">1225</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="ln">1226</span>
<span class="ln">1227</span>	<span class="n">src_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">);</span>
<span class="ln">1228</span>	<span class="n">dst_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln">1229</span>
<span class="ln">1230</span>	<span class="n">double_raw_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span>
<span class="ln">1231</span>			<span class="o">&amp;</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">1232</span>	<span class="n">double_rq_lock</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">dst_rq</span><span class="p">);</span>
<span class="ln">1233</span>
<span class="ln">1234</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_task</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">)</span>
<span class="ln">1235</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln">1236</span>
<span class="ln">1237</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_task</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">)</span>
<span class="ln">1238</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln">1239</span>
<span class="ln">1240</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_task</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln">1241</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln">1242</span>
<span class="ln">1243</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_task</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln">1244</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln">1245</span>
<span class="ln">1246</span>	<span class="n">__migrate_swap_task</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_task</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln">1247</span>	<span class="n">__migrate_swap_task</span><span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_task</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">);</span>
<span class="ln">1248</span>
<span class="ln">1249</span>	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1250</span>
<span class="ln">1251</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln">1252</span>	<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">dst_rq</span><span class="p">);</span>
<span class="ln">1253</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">dst_task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">1254</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">src_task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">1255</span>
<span class="ln">1256</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">1257</span><span class="p">}</span>
<span class="ln">1258</span>
<span class="ln">1259</span><span class="cm">/*
</span><span class="ln">1260</span><span class="cm"> * Cross migrate two tasks
</span><span class="ln">1261</span><span class="cm"> */</span>
<span class="ln">1262</span><span class="kt">int</span> <span class="nf">migrate_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">1263</span>		<span class="kt">int</span> <span class="n">target_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">curr_cpu</span><span class="p">)</span>
<span class="ln">1264</span><span class="p">{</span>
<span class="ln">1265</span>	<span class="k">struct</span> <span class="n">migration_swap_arg</span> <span class="n">arg</span><span class="p">;</span>
<span class="ln">1266</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">1267</span>
<span class="ln">1268</span>	<span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">migration_swap_arg</span><span class="p">){</span>
<span class="ln">1269</span>		<span class="p">.</span><span class="n">src_task</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span>
<span class="ln">1270</span>		<span class="p">.</span><span class="n">src_cpu</span> <span class="o">=</span> <span class="n">curr_cpu</span><span class="p">,</span>
<span class="ln">1271</span>		<span class="p">.</span><span class="n">dst_task</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span>
<span class="ln">1272</span>		<span class="p">.</span><span class="n">dst_cpu</span> <span class="o">=</span> <span class="n">target_cpu</span><span class="p">,</span>
<span class="ln">1273</span>	<span class="p">};</span>
<span class="ln">1274</span>
<span class="ln">1275</span>	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">src_cpu</span> <span class="o">==</span> <span class="n">arg</span><span class="p">.</span><span class="n">dst_cpu</span><span class="p">)</span>
<span class="ln">1276</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1277</span>
<span class="ln">1278</span>	<span class="cm">/*
</span><span class="ln">1279</span><span class="cm">	 * These three tests are all lockless; this is OK since all of them
</span><span class="ln">1280</span><span class="cm">	 * will be re-checked with proper locks held further down the line.
</span><span class="ln">1281</span><span class="cm">	 */</span>
<span class="ln">1282</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">dst_cpu</span><span class="p">))</span>
<span class="ln">1283</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1284</span>
<span class="ln">1285</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">.</span><span class="n">src_task</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln">1286</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1287</span>
<span class="ln">1288</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">.</span><span class="n">dst_task</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln">1289</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1290</span>
<span class="ln">1291</span>	<span class="n">trace_sched_swap_numa</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln">1292</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">stop_two_cpus</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">,</span> <span class="n">migrate_swap_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="ln">1293</span>
<span class="ln">1294</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">1295</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">1296</span><span class="p">}</span>
<span class="ln">1297</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA_BALANCING */</span><span class="cp">
</span><span class="ln">1298</span><span class="cp"></span>
<span class="ln">1299</span><span class="cm">/*
</span><span class="ln">1300</span><span class="cm"> * wait_task_inactive - wait for a thread to unschedule.
</span><span class="ln">1301</span><span class="cm"> *
</span><span class="ln">1302</span><span class="cm"> * If @match_state is nonzero, it&#39;s the @p-&gt;state value just checked and
</span><span class="ln">1303</span><span class="cm"> * not expected to change.  If it changes, i.e. @p might have woken up,
</span><span class="ln">1304</span><span class="cm"> * then return zero.  When we succeed in waiting for @p to be off its CPU,
</span><span class="ln">1305</span><span class="cm"> * we return a positive number (its total switch count).  If a second call
</span><span class="ln">1306</span><span class="cm"> * a short while later returns the same number, the caller can be sure that
</span><span class="ln">1307</span><span class="cm"> * @p has remained unscheduled the whole time.
</span><span class="ln">1308</span><span class="cm"> *
</span><span class="ln">1309</span><span class="cm"> * The caller must ensure that the task *will* unschedule sometime soon,
</span><span class="ln">1310</span><span class="cm"> * else this function might spin for a *long* time. This function can&#39;t
</span><span class="ln">1311</span><span class="cm"> * be called with interrupts off, or it may introduce deadlock with
</span><span class="ln">1312</span><span class="cm"> * smp_call_function() if an IPI is sent by the same process we are
</span><span class="ln">1313</span><span class="cm"> * waiting to become inactive.
</span><span class="ln">1314</span><span class="cm"> */</span>
<span class="ln">1315</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">wait_task_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">match_state</span><span class="p">)</span>
<span class="ln">1316</span><span class="p">{</span>
<span class="ln">1317</span>	<span class="kt">int</span> <span class="n">running</span><span class="p">,</span> <span class="n">queued</span><span class="p">;</span>
<span class="ln">1318</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">1319</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ncsw</span><span class="p">;</span>
<span class="ln">1320</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">1321</span>
<span class="ln">1322</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln">1323</span>		<span class="cm">/*
</span><span class="ln">1324</span><span class="cm">		 * We do the initial early heuristics without holding
</span><span class="ln">1325</span><span class="cm">		 * any task-queue locks at all. We&#39;ll only try to get
</span><span class="ln">1326</span><span class="cm">		 * the runqueue lock when things look like they will
</span><span class="ln">1327</span><span class="cm">		 * work out!
</span><span class="ln">1328</span><span class="cm">		 */</span>
<span class="ln">1329</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1330</span>
<span class="ln">1331</span>		<span class="cm">/*
</span><span class="ln">1332</span><span class="cm">		 * If the task is actively running on another CPU
</span><span class="ln">1333</span><span class="cm">		 * still, just relax and busy-wait without holding
</span><span class="ln">1334</span><span class="cm">		 * any locks.
</span><span class="ln">1335</span><span class="cm">		 *
</span><span class="ln">1336</span><span class="cm">		 * NOTE! Since we don&#39;t hold any locks, it&#39;s not
</span><span class="ln">1337</span><span class="cm">		 * even sure that &#34;rq&#34; stays as the right runqueue!
</span><span class="ln">1338</span><span class="cm">		 * But we don&#39;t care, since &#34;task_running()&#34; will
</span><span class="ln">1339</span><span class="cm">		 * return false if the runqueue has changed and p
</span><span class="ln">1340</span><span class="cm">		 * is actually now running somewhere else!
</span><span class="ln">1341</span><span class="cm">		 */</span>
<span class="ln">1342</span>		<span class="k">while</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1343</span>			<span class="k">if</span> <span class="p">(</span><span class="n">match_state</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">match_state</span><span class="p">))</span>
<span class="ln">1344</span>				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1345</span>			<span class="n">cpu_relax</span><span class="p">();</span>
<span class="ln">1346</span>		<span class="p">}</span>
<span class="ln">1347</span>
<span class="ln">1348</span>		<span class="cm">/*
</span><span class="ln">1349</span><span class="cm">		 * Ok, time to look more closely! We need the rq
</span><span class="ln">1350</span><span class="cm">		 * lock now, to be *sure*. If we&#39;re wrong, we&#39;ll
</span><span class="ln">1351</span><span class="cm">		 * just go back and repeat.
</span><span class="ln">1352</span><span class="cm">		 */</span>
<span class="ln">1353</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1354</span>		<span class="n">trace_sched_wait_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1355</span>		<span class="n">running</span> <span class="o">=</span> <span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">1356</span>		<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1357</span>		<span class="n">ncsw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1358</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match_state</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">match_state</span><span class="p">)</span>
<span class="ln">1359</span>			<span class="n">ncsw</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nvcsw</span> <span class="o">|</span> <span class="n">LONG_MIN</span><span class="p">;</span> <span class="cm">/* sets MSB */</span>
<span class="ln">1360</span>		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1361</span>
<span class="ln">1362</span>		<span class="cm">/*
</span><span class="ln">1363</span><span class="cm">		 * If it changed from the expected state, bail out now.
</span><span class="ln">1364</span><span class="cm">		 */</span>
<span class="ln">1365</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ncsw</span><span class="p">))</span>
<span class="ln">1366</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">1367</span>
<span class="ln">1368</span>		<span class="cm">/*
</span><span class="ln">1369</span><span class="cm">		 * Was it really running after all now that we
</span><span class="ln">1370</span><span class="cm">		 * checked with the proper locks actually held?
</span><span class="ln">1371</span><span class="cm">		 *
</span><span class="ln">1372</span><span class="cm">		 * Oops. Go back and try again..
</span><span class="ln">1373</span><span class="cm">		 */</span>
<span class="ln">1374</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">running</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1375</span>			<span class="n">cpu_relax</span><span class="p">();</span>
<span class="ln">1376</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln">1377</span>		<span class="p">}</span>
<span class="ln">1378</span>
<span class="ln">1379</span>		<span class="cm">/*
</span><span class="ln">1380</span><span class="cm">		 * It&#39;s not enough that it&#39;s not actively running,
</span><span class="ln">1381</span><span class="cm">		 * it must be off the runqueue _entirely_, and not
</span><span class="ln">1382</span><span class="cm">		 * preempted!
</span><span class="ln">1383</span><span class="cm">		 *
</span><span class="ln">1384</span><span class="cm">		 * So if it was still runnable (but just not actively
</span><span class="ln">1385</span><span class="cm">		 * running right now), it&#39;s preempted, and we should
</span><span class="ln">1386</span><span class="cm">		 * yield - it could be a while.
</span><span class="ln">1387</span><span class="cm">		 */</span>
<span class="ln">1388</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">queued</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1389</span>			<span class="n">ktime_t</span> <span class="n">to</span> <span class="o">=</span> <span class="n">NSEC_PER_SEC</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
<span class="ln">1390</span>
<span class="ln">1391</span>			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="ln">1392</span>			<span class="n">schedule_hrtimeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="ln">1393</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln">1394</span>		<span class="p">}</span>
<span class="ln">1395</span>
<span class="ln">1396</span>		<span class="cm">/*
</span><span class="ln">1397</span><span class="cm">		 * Ahh, all good. It wasn&#39;t running, and it wasn&#39;t
</span><span class="ln">1398</span><span class="cm">		 * runnable, which means that it will never become
</span><span class="ln">1399</span><span class="cm">		 * running in the future either. We&#39;re all done!
</span><span class="ln">1400</span><span class="cm">		 */</span>
<span class="ln">1401</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">1402</span>	<span class="p">}</span>
<span class="ln">1403</span>
<span class="ln">1404</span>	<span class="k">return</span> <span class="n">ncsw</span><span class="p">;</span>
<span class="ln">1405</span><span class="p">}</span>
<span class="ln">1406</span>
<span class="ln">1407</span><span class="cm">/***
</span><span class="ln">1408</span><span class="cm"> * kick_process - kick a running thread to enter/exit the kernel
</span><span class="ln">1409</span><span class="cm"> * @p: the to-be-kicked thread
</span><span class="ln">1410</span><span class="cm"> *
</span><span class="ln">1411</span><span class="cm"> * Cause a process which is running on another CPU to enter
</span><span class="ln">1412</span><span class="cm"> * kernel-mode, without any delay. (to get signals handled.)
</span><span class="ln">1413</span><span class="cm"> *
</span><span class="ln">1414</span><span class="cm"> * NOTE: this function doesn&#39;t have to take the runqueue lock,
</span><span class="ln">1415</span><span class="cm"> * because all it wants to ensure is that the remote task enters
</span><span class="ln">1416</span><span class="cm"> * the kernel. If the IPI races and the task has been migrated
</span><span class="ln">1417</span><span class="cm"> * to another CPU then no harm is done and the purpose has been
</span><span class="ln">1418</span><span class="cm"> * achieved as well.
</span><span class="ln">1419</span><span class="cm"> */</span>
<span class="ln">1420</span><span class="kt">void</span> <span class="nf">kick_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">1421</span><span class="p">{</span>
<span class="ln">1422</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln">1423</span>
<span class="ln">1424</span>	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">1425</span>	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1426</span>	<span class="k">if</span> <span class="p">((</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">task_curr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">1427</span>		<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1428</span>	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="ln">1429</span><span class="p">}</span>
<span class="ln">1430</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kick_process</span><span class="p">);</span>
<span class="ln">1431</span>
<span class="ln">1432</span><span class="cm">/*
</span><span class="ln">1433</span><span class="cm"> * -&gt;cpus_allowed is protected by both rq-&gt;lock and p-&gt;pi_lock
</span><span class="ln">1434</span><span class="cm"> *
</span><span class="ln">1435</span><span class="cm"> * A few notes on cpu_active vs cpu_online:
</span><span class="ln">1436</span><span class="cm"> *
</span><span class="ln">1437</span><span class="cm"> *  - cpu_active must be a subset of cpu_online
</span><span class="ln">1438</span><span class="cm"> *
</span><span class="ln">1439</span><span class="cm"> *  - on CPU-up we allow per-CPU kthreads on the online &amp;&amp; !active CPU,
</span><span class="ln">1440</span><span class="cm"> *    see __set_cpus_allowed_ptr(). At this point the newly online
</span><span class="ln">1441</span><span class="cm"> *    CPU isn&#39;t yet part of the sched domains, and balancing will not
</span><span class="ln">1442</span><span class="cm"> *    see it.
</span><span class="ln">1443</span><span class="cm"> *
</span><span class="ln">1444</span><span class="cm"> *  - on CPU-down we clear cpu_active() to mask the sched domains and
</span><span class="ln">1445</span><span class="cm"> *    avoid the load balancer to place new tasks on the to be removed
</span><span class="ln">1446</span><span class="cm"> *    CPU. Existing tasks will remain running there and will be taken
</span><span class="ln">1447</span><span class="cm"> *    off.
</span><span class="ln">1448</span><span class="cm"> *
</span><span class="ln">1449</span><span class="cm"> * This means that fallback selection must not select !active CPUs.
</span><span class="ln">1450</span><span class="cm"> * And can assume that any active CPU must be online. Conversely
</span><span class="ln">1451</span><span class="cm"> * select_task_rq() below may allow selection of !active CPUs in order
</span><span class="ln">1452</span><span class="cm"> * to satisfy the above rules.
</span><span class="ln">1453</span><span class="cm"> */</span>
<span class="ln">1454</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_fallback_rq</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">1455</span><span class="p">{</span>
<span class="ln">1456</span>	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1457</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">nodemask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">1458</span>	<span class="k">enum</span> <span class="p">{</span> <span class="n">cpuset</span><span class="p">,</span> <span class="n">possible</span><span class="p">,</span> <span class="n">fail</span> <span class="p">}</span> <span class="n">state</span> <span class="o">=</span> <span class="n">cpuset</span><span class="p">;</span>
<span class="ln">1459</span>	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln">1460</span>
<span class="ln">1461</span>	<span class="cm">/*
</span><span class="ln">1462</span><span class="cm">	 * If the node that the CPU is on has been offlined, cpu_to_node()
</span><span class="ln">1463</span><span class="cm">	 * will return -1. There is no CPU on the node, and we should
</span><span class="ln">1464</span><span class="cm">	 * select the CPU on the other node.
</span><span class="ln">1465</span><span class="cm">	 */</span>
<span class="ln">1466</span>	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1467</span>		<span class="n">nodemask</span> <span class="o">=</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
<span class="ln">1468</span>
<span class="ln">1469</span>		<span class="cm">/* Look for allowed, online CPU in same node. */</span>
<span class="ln">1470</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1471</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">))</span>
<span class="ln">1472</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln">1473</span>			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln">1474</span>				<span class="k">return</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln">1475</span>		<span class="p">}</span>
<span class="ln">1476</span>	<span class="p">}</span>
<span class="ln">1477</span>
<span class="ln">1478</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln">1479</span>		<span class="cm">/* Any allowed, online CPU? */</span>
<span class="ln">1480</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1481</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_cpu_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">))</span>
<span class="ln">1482</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln">1483</span>
<span class="ln">1484</span>			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1485</span>		<span class="p">}</span>
<span class="ln">1486</span>
<span class="ln">1487</span>		<span class="cm">/* No more Mr. Nice Guy. */</span>
<span class="ln">1488</span>		<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1489</span>		<span class="k">case</span> <span class="nl">cpuset</span><span class="p">:</span>
<span class="ln">1490</span>			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CPUSETS</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1491</span>				<span class="n">cpuset_cpus_allowed_fallback</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1492</span>				<span class="n">state</span> <span class="o">=</span> <span class="n">possible</span><span class="p">;</span>
<span class="ln">1493</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln">1494</span>			<span class="p">}</span>
<span class="ln">1495</span>			<span class="cm">/* Fall-through */</span>
<span class="ln">1496</span>		<span class="k">case</span> <span class="nl">possible</span><span class="p">:</span>
<span class="ln">1497</span>			<span class="n">do_set_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>
<span class="ln">1498</span>			<span class="n">state</span> <span class="o">=</span> <span class="n">fail</span><span class="p">;</span>
<span class="ln">1499</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">1500</span>
<span class="ln">1501</span>		<span class="k">case</span> <span class="nl">fail</span><span class="p">:</span>
<span class="ln">1502</span>			<span class="n">BUG</span><span class="p">();</span>
<span class="ln">1503</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">1504</span>		<span class="p">}</span>
<span class="ln">1505</span>	<span class="p">}</span>
<span class="ln">1506</span>
<span class="ln">1507</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">1508</span>	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">cpuset</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1509</span>		<span class="cm">/*
</span><span class="ln">1510</span><span class="cm">		 * Don&#39;t tell them about moving exiting tasks or
</span><span class="ln">1511</span><span class="cm">		 * kernel threads (both mm NULL), since they never
</span><span class="ln">1512</span><span class="cm">		 * leave kernel.
</span><span class="ln">1513</span><span class="cm">		 */</span>
<span class="ln">1514</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
<span class="ln">1515</span>			<span class="n">printk_deferred</span><span class="p">(</span><span class="s">&#34;process %d (%s) no longer affine to cpu%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">1516</span>					<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">1517</span>		<span class="p">}</span>
<span class="ln">1518</span>	<span class="p">}</span>
<span class="ln">1519</span>
<span class="ln">1520</span>	<span class="k">return</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln">1521</span><span class="p">}</span>
<span class="ln">1522</span>
<span class="ln">1523</span><span class="cm">/*
</span><span class="ln">1524</span><span class="cm"> * The caller (fork, wakeup) owns p-&gt;pi_lock, -&gt;cpus_allowed is stable.
</span><span class="ln">1525</span><span class="cm"> */</span>
<span class="ln">1526</span><span class="k">static</span> <span class="kr">inline</span>
<span class="ln">1527</span><span class="kt">int</span> <span class="nf">select_task_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln">1528</span><span class="p">{</span>
<span class="ln">1529</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">1530</span>
<span class="ln">1531</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln">1532</span>		<span class="n">cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">1533</span>	<span class="k">else</span>
<span class="ln">1534</span>		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln">1535</span>
<span class="ln">1536</span>	<span class="cm">/*
</span><span class="ln">1537</span><span class="cm">	 * In order not to call set_task_cpu() on a blocking task we need
</span><span class="ln">1538</span><span class="cm">	 * to rely on ttwu() to place the task on a valid -&gt;cpus_allowed
</span><span class="ln">1539</span><span class="cm">	 * CPU.
</span><span class="ln">1540</span><span class="cm">	 *
</span><span class="ln">1541</span><span class="cm">	 * Since this is common to all placement strategies, this lives here.
</span><span class="ln">1542</span><span class="cm">	 *
</span><span class="ln">1543</span><span class="cm">	 * [ this allows -&gt;select_task() to simply return task_cpu(p) and
</span><span class="ln">1544</span><span class="cm">	 *   not worry about this generic constraint ]
</span><span class="ln">1545</span><span class="cm">	 */</span>
<span class="ln">1546</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">is_cpu_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)))</span>
<span class="ln">1547</span>		<span class="n">cpu</span> <span class="o">=</span> <span class="n">select_fallback_rq</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">1548</span>
<span class="ln">1549</span>	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln">1550</span><span class="p">}</span>
<span class="ln">1551</span>
<span class="ln">1552</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_avg</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="n">avg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">sample</span><span class="p">)</span>
<span class="ln">1553</span><span class="p">{</span>
<span class="ln">1554</span>	<span class="n">s64</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">sample</span> <span class="o">-</span> <span class="o">*</span><span class="n">avg</span><span class="p">;</span>
<span class="ln">1555</span>	<span class="o">*</span><span class="n">avg</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="ln">1556</span><span class="p">}</span>
<span class="ln">1557</span>
<span class="ln">1558</span><span class="kt">void</span> <span class="nf">sched_set_stop_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
<span class="ln">1559</span><span class="p">{</span>
<span class="ln">1560</span>	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">MAX_RT_PRIO</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">};</span>
<span class="ln">1561</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">old_stop</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">;</span>
<span class="ln">1562</span>
<span class="ln">1563</span>	<span class="k">if</span> <span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1564</span>		<span class="cm">/*
</span><span class="ln">1565</span><span class="cm">		 * Make it appear like a SCHED_FIFO task, its something
</span><span class="ln">1566</span><span class="cm">		 * userspace knows about and won&#39;t get confused about.
</span><span class="ln">1567</span><span class="cm">		 *
</span><span class="ln">1568</span><span class="cm">		 * Also, it will make PI more or less work without too
</span><span class="ln">1569</span><span class="cm">		 * much confusion -- but then, stop work should not
</span><span class="ln">1570</span><span class="cm">		 * rely on PI working anyway.
</span><span class="ln">1571</span><span class="cm">		 */</span>
<span class="ln">1572</span>		<span class="n">sched_setscheduler_nocheck</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">);</span>
<span class="ln">1573</span>
<span class="ln">1574</span>		<span class="n">stop</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stop_sched_class</span><span class="p">;</span>
<span class="ln">1575</span>	<span class="p">}</span>
<span class="ln">1576</span>
<span class="ln">1577</span>	<span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">;</span>
<span class="ln">1578</span>
<span class="ln">1579</span>	<span class="k">if</span> <span class="p">(</span><span class="n">old_stop</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1580</span>		<span class="cm">/*
</span><span class="ln">1581</span><span class="cm">		 * Reset it back to a normal scheduling class so that
</span><span class="ln">1582</span><span class="cm">		 * it can die in pieces.
</span><span class="ln">1583</span><span class="cm">		 */</span>
<span class="ln">1584</span>		<span class="n">old_stop</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
<span class="ln">1585</span>	<span class="p">}</span>
<span class="ln">1586</span><span class="p">}</span>
<span class="ln">1587</span>
<span class="ln">1588</span><span class="cp">#else
</span><span class="ln">1589</span><span class="cp"></span>
<span class="ln">1590</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__set_cpus_allowed_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">1591</span>					 <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">check</span><span class="p">)</span>
<span class="ln">1592</span><span class="p">{</span>
<span class="ln">1593</span>	<span class="k">return</span> <span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">1594</span><span class="p">}</span>
<span class="ln">1595</span>
<span class="ln">1596</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">1597</span><span class="cp"></span>
<span class="ln">1598</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln">1599</span><span class="nf">ttwu_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln">1600</span><span class="p">{</span>
<span class="ln">1601</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">1602</span>
<span class="ln">1603</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln">1604</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">1605</span>
<span class="ln">1606</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln">1607</span>
<span class="ln">1608</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">1609</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1610</span>		<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">ttwu_local</span><span class="p">);</span>
<span class="ln">1611</span>		<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_local</span><span class="p">);</span>
<span class="ln">1612</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">1613</span>		<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln">1614</span>
<span class="ln">1615</span>		<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_remote</span><span class="p">);</span>
<span class="ln">1616</span>		<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">1617</span>		<span class="n">for_each_domain</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1618</span>			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">1619</span>				<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">ttwu_wake_remote</span><span class="p">);</span>
<span class="ln">1620</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln">1621</span>			<span class="p">}</span>
<span class="ln">1622</span>		<span class="p">}</span>
<span class="ln">1623</span>		<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">1624</span>	<span class="p">}</span>
<span class="ln">1625</span>
<span class="ln">1626</span>	<span class="k">if</span> <span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_MIGRATED</span><span class="p">)</span>
<span class="ln">1627</span>		<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_migrate</span><span class="p">);</span>
<span class="ln">1628</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">1629</span><span class="cp"></span>
<span class="ln">1630</span>	<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">ttwu_count</span><span class="p">);</span>
<span class="ln">1631</span>	<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups</span><span class="p">);</span>
<span class="ln">1632</span>
<span class="ln">1633</span>	<span class="k">if</span> <span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_SYNC</span><span class="p">)</span>
<span class="ln">1634</span>		<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_sync</span><span class="p">);</span>
<span class="ln">1635</span><span class="p">}</span>
<span class="ln">1636</span>
<span class="ln">1637</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ttwu_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">en_flags</span><span class="p">)</span>
<span class="ln">1638</span><span class="p">{</span>
<span class="ln">1639</span>	<span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">en_flags</span><span class="p">);</span>
<span class="ln">1640</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="ln">1641</span>
<span class="ln">1642</span>	<span class="cm">/* If a worker is waking up, notify the workqueue: */</span>
<span class="ln">1643</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_WQ_WORKER</span><span class="p">)</span>
<span class="ln">1644</span>		<span class="n">wq_worker_waking_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">));</span>
<span class="ln">1645</span><span class="p">}</span>
<span class="ln">1646</span>
<span class="ln">1647</span><span class="cm">/*
</span><span class="ln">1648</span><span class="cm"> * Mark the task runnable and perform wakeup-preemption.
</span><span class="ln">1649</span><span class="cm"> */</span>
<span class="ln">1650</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">ttwu_do_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
<span class="ln">1651</span>			   <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">1652</span><span class="p">{</span>
<span class="ln">1653</span>	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">1654</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
<span class="ln">1655</span>	<span class="n">trace_sched_wakeup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1656</span>
<span class="ln">1657</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">1658</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1659</span>		<span class="cm">/*
</span><span class="ln">1660</span><span class="cm">		 * Our task @p is fully woken up and running; so its safe to
</span><span class="ln">1661</span><span class="cm">		 * drop the rq-&gt;lock, hereafter rq is only used for statistics.
</span><span class="ln">1662</span><span class="cm">		 */</span>
<span class="ln">1663</span>		<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">1664</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">1665</span>		<span class="n">rq_repin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">1666</span>	<span class="p">}</span>
<span class="ln">1667</span>
<span class="ln">1668</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">1669</span>		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="p">;</span>
<span class="ln">1670</span>		<span class="n">u64</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">max_idle_balance_cost</span><span class="p">;</span>
<span class="ln">1671</span>
<span class="ln">1672</span>		<span class="n">update_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">1673</span>
<span class="ln">1674</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
<span class="ln">1675</span>			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
<span class="ln">1676</span>
<span class="ln">1677</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1678</span>	<span class="p">}</span>
<span class="ln">1679</span><span class="cp">#endif
</span><span class="ln">1680</span><span class="cp"></span><span class="p">}</span>
<span class="ln">1681</span>
<span class="ln">1682</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln">1683</span><span class="nf">ttwu_do_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
<span class="ln">1684</span>		 <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">1685</span><span class="p">{</span>
<span class="ln">1686</span>	<span class="kt">int</span> <span class="n">en_flags</span> <span class="o">=</span> <span class="n">ENQUEUE_WAKEUP</span> <span class="o">|</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">;</span>
<span class="ln">1687</span>
<span class="ln">1688</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">1689</span>
<span class="ln">1690</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">1691</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_contributes_to_load</span><span class="p">)</span>
<span class="ln">1692</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">--</span><span class="p">;</span>
<span class="ln">1693</span>
<span class="ln">1694</span>	<span class="k">if</span> <span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_MIGRATED</span><span class="p">)</span>
<span class="ln">1695</span>		<span class="n">en_flags</span> <span class="o">|=</span> <span class="n">ENQUEUE_MIGRATED</span><span class="p">;</span>
<span class="ln">1696</span><span class="cp">#endif
</span><span class="ln">1697</span><span class="cp"></span>
<span class="ln">1698</span>	<span class="n">ttwu_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">en_flags</span><span class="p">);</span>
<span class="ln">1699</span>	<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">1700</span><span class="p">}</span>
<span class="ln">1701</span>
<span class="ln">1702</span><span class="cm">/*
</span><span class="ln">1703</span><span class="cm"> * Called in case the task @p isn&#39;t fully descheduled from its runqueue,
</span><span class="ln">1704</span><span class="cm"> * in this case we must do a remote wakeup. Its a &#39;light&#39; wakeup though,
</span><span class="ln">1705</span><span class="cm"> * since all we need to do is flip p-&gt;state to TASK_RUNNING, since
</span><span class="ln">1706</span><span class="cm"> * the task is still -&gt;on_rq.
</span><span class="ln">1707</span><span class="cm"> */</span>
<span class="ln">1708</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">ttwu_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln">1709</span><span class="p">{</span>
<span class="ln">1710</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">1711</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">1712</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1713</span>
<span class="ln">1714</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1715</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1716</span>		<span class="cm">/* check_preempt_curr() may use rq clock */</span>
<span class="ln">1717</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">1718</span>		<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1719</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">1720</span>	<span class="p">}</span>
<span class="ln">1721</span>	<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1722</span>
<span class="ln">1723</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">1724</span><span class="p">}</span>
<span class="ln">1725</span>
<span class="ln">1726</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">1727</span><span class="cp"></span><span class="kt">void</span> <span class="nf">sched_ttwu_pending</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">1728</span><span class="p">{</span>
<span class="ln">1729</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln">1730</span>	<span class="k">struct</span> <span class="n">llist_node</span> <span class="o">*</span><span class="n">llist</span> <span class="o">=</span> <span class="n">llist_del_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">);</span>
<span class="ln">1731</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
<span class="ln">1732</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">1733</span>
<span class="ln">1734</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llist</span><span class="p">)</span>
<span class="ln">1735</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">1736</span>
<span class="ln">1737</span>	<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1738</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">1739</span>
<span class="ln">1740</span>	<span class="n">llist_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">llist</span><span class="p">,</span> <span class="n">wake_entry</span><span class="p">)</span>
<span class="ln">1741</span>		<span class="n">ttwu_do_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_remote_wakeup</span> <span class="o">?</span> <span class="nl">WF_MIGRATED</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1742</span>
<span class="ln">1743</span>	<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1744</span><span class="p">}</span>
<span class="ln">1745</span>
<span class="ln">1746</span><span class="kt">void</span> <span class="nf">scheduler_ipi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">1747</span><span class="p">{</span>
<span class="ln">1748</span>	<span class="cm">/*
</span><span class="ln">1749</span><span class="cm">	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting
</span><span class="ln">1750</span><span class="cm">	 * TIF_NEED_RESCHED remotely (for the first time) will also send
</span><span class="ln">1751</span><span class="cm">	 * this IPI.
</span><span class="ln">1752</span><span class="cm">	 */</span>
<span class="ln">1753</span>	<span class="n">preempt_fold_need_resched</span><span class="p">();</span>
<span class="ln">1754</span>
<span class="ln">1755</span>	<span class="k">if</span> <span class="p">(</span><span class="n">llist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">got_nohz_idle_kick</span><span class="p">())</span>
<span class="ln">1756</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">1757</span>
<span class="ln">1758</span>	<span class="cm">/*
</span><span class="ln">1759</span><span class="cm">	 * Not all reschedule IPI handlers call irq_enter/irq_exit, since
</span><span class="ln">1760</span><span class="cm">	 * traditionally all their work was done from the interrupt return
</span><span class="ln">1761</span><span class="cm">	 * path. Now that we actually do some work, we need to make sure
</span><span class="ln">1762</span><span class="cm">	 * we do call them.
</span><span class="ln">1763</span><span class="cm">	 *
</span><span class="ln">1764</span><span class="cm">	 * Some archs already do call them, luckily irq_enter/exit nest
</span><span class="ln">1765</span><span class="cm">	 * properly.
</span><span class="ln">1766</span><span class="cm">	 *
</span><span class="ln">1767</span><span class="cm">	 * Arguably we should visit all archs and update all handlers,
</span><span class="ln">1768</span><span class="cm">	 * however a fair share of IPIs are still resched only so this would
</span><span class="ln">1769</span><span class="cm">	 * somewhat pessimize the simple resched case.
</span><span class="ln">1770</span><span class="cm">	 */</span>
<span class="ln">1771</span>	<span class="n">irq_enter</span><span class="p">();</span>
<span class="ln">1772</span>	<span class="n">sched_ttwu_pending</span><span class="p">();</span>
<span class="ln">1773</span>
<span class="ln">1774</span>	<span class="cm">/*
</span><span class="ln">1775</span><span class="cm">	 * Check if someone kicked us for doing the nohz idle load balance.
</span><span class="ln">1776</span><span class="cm">	 */</span>
<span class="ln">1777</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">got_nohz_idle_kick</span><span class="p">()))</span> <span class="p">{</span>
<span class="ln">1778</span>		<span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">1779</span>		<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">SCHED_SOFTIRQ</span><span class="p">);</span>
<span class="ln">1780</span>	<span class="p">}</span>
<span class="ln">1781</span>	<span class="n">irq_exit</span><span class="p">();</span>
<span class="ln">1782</span><span class="p">}</span>
<span class="ln">1783</span>
<span class="ln">1784</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">ttwu_queue_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln">1785</span><span class="p">{</span>
<span class="ln">1786</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1787</span>
<span class="ln">1788</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_remote_wakeup</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_MIGRATED</span><span class="p">);</span>
<span class="ln">1789</span>
<span class="ln">1790</span>	<span class="k">if</span> <span class="p">(</span><span class="n">llist_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">wake_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1791</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set_nr_if_polling</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span>
<span class="ln">1792</span>			<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1793</span>		<span class="k">else</span>
<span class="ln">1794</span>			<span class="n">trace_sched_wake_idle_without_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1795</span>	<span class="p">}</span>
<span class="ln">1796</span><span class="p">}</span>
<span class="ln">1797</span>
<span class="ln">1798</span><span class="kt">void</span> <span class="nf">wake_up_if_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">1799</span><span class="p">{</span>
<span class="ln">1800</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1801</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">1802</span>
<span class="ln">1803</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">1804</span>
<span class="ln">1805</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_idle_task</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)))</span>
<span class="ln">1806</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1807</span>
<span class="ln">1808</span>	<span class="k">if</span> <span class="p">(</span><span class="n">set_nr_if_polling</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1809</span>		<span class="n">trace_sched_wake_idle_without_ipi</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1810</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">1811</span>		<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1812</span>		<span class="k">if</span> <span class="p">(</span><span class="n">is_idle_task</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span>
<span class="ln">1813</span>			<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1814</span>		<span class="cm">/* Else CPU is not idle, do nothing here: */</span>
<span class="ln">1815</span>		<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1816</span>	<span class="p">}</span>
<span class="ln">1817</span>
<span class="ln">1818</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">1819</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">1820</span><span class="p">}</span>
<span class="ln">1821</span>
<span class="ln">1822</span><span class="kt">bool</span> <span class="nf">cpus_share_cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">that_cpu</span><span class="p">)</span>
<span class="ln">1823</span><span class="p">{</span>
<span class="ln">1824</span>	<span class="k">return</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_id</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">)</span> <span class="o">==</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_id</span><span class="p">,</span> <span class="n">that_cpu</span><span class="p">);</span>
<span class="ln">1825</span><span class="p">}</span>
<span class="ln">1826</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">1827</span><span class="cp"></span>
<span class="ln">1828</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">ttwu_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln">1829</span><span class="p">{</span>
<span class="ln">1830</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">1831</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">1832</span>
<span class="ln">1833</span><span class="cp">#if defined(CONFIG_SMP)
</span><span class="ln">1834</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">TTWU_QUEUE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpus_share_cache</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">(),</span> <span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">1835</span>		<span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span> <span class="cm">/* Sync clocks across CPUs */</span>
<span class="ln">1836</span>		<span class="n">ttwu_queue_remote</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">1837</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">1838</span>	<span class="p">}</span>
<span class="ln">1839</span><span class="cp">#endif
</span><span class="ln">1840</span><span class="cp"></span>
<span class="ln">1841</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1842</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">1843</span>	<span class="n">ttwu_do_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1844</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">1845</span><span class="p">}</span>
<span class="ln">1846</span>
<span class="ln">1847</span><span class="cm">/*
</span><span class="ln">1848</span><span class="cm"> * Notes on Program-Order guarantees on SMP systems.
</span><span class="ln">1849</span><span class="cm"> *
</span><span class="ln">1850</span><span class="cm"> *  MIGRATION
</span><span class="ln">1851</span><span class="cm"> *
</span><span class="ln">1852</span><span class="cm"> * The basic program-order guarantee on SMP systems is that when a task [t]
</span><span class="ln">1853</span><span class="cm"> * migrates, all its activity on its old CPU [c0] happens-before any subsequent
</span><span class="ln">1854</span><span class="cm"> * execution on its new CPU [c1].
</span><span class="ln">1855</span><span class="cm"> *
</span><span class="ln">1856</span><span class="cm"> * For migration (of runnable tasks) this is provided by the following means:
</span><span class="ln">1857</span><span class="cm"> *
</span><span class="ln">1858</span><span class="cm"> *  A) UNLOCK of the rq(c0)-&gt;lock scheduling out task t
</span><span class="ln">1859</span><span class="cm"> *  B) migration for t is required to synchronize *both* rq(c0)-&gt;lock and
</span><span class="ln">1860</span><span class="cm"> *     rq(c1)-&gt;lock (if not at the same time, then in that order).
</span><span class="ln">1861</span><span class="cm"> *  C) LOCK of the rq(c1)-&gt;lock scheduling in task
</span><span class="ln">1862</span><span class="cm"> *
</span><span class="ln">1863</span><span class="cm"> * Release/acquire chaining guarantees that B happens after A and C after B.
</span><span class="ln">1864</span><span class="cm"> * Note: the CPU doing B need not be c0 or c1
</span><span class="ln">1865</span><span class="cm"> *
</span><span class="ln">1866</span><span class="cm"> * Example:
</span><span class="ln">1867</span><span class="cm"> *
</span><span class="ln">1868</span><span class="cm"> *   CPU0            CPU1            CPU2
</span><span class="ln">1869</span><span class="cm"> *
</span><span class="ln">1870</span><span class="cm"> *   LOCK rq(0)-&gt;lock
</span><span class="ln">1871</span><span class="cm"> *   sched-out X
</span><span class="ln">1872</span><span class="cm"> *   sched-in Y
</span><span class="ln">1873</span><span class="cm"> *   UNLOCK rq(0)-&gt;lock
</span><span class="ln">1874</span><span class="cm"> *
</span><span class="ln">1875</span><span class="cm"> *                                   LOCK rq(0)-&gt;lock // orders against CPU0
</span><span class="ln">1876</span><span class="cm"> *                                   dequeue X
</span><span class="ln">1877</span><span class="cm"> *                                   UNLOCK rq(0)-&gt;lock
</span><span class="ln">1878</span><span class="cm"> *
</span><span class="ln">1879</span><span class="cm"> *                                   LOCK rq(1)-&gt;lock
</span><span class="ln">1880</span><span class="cm"> *                                   enqueue X
</span><span class="ln">1881</span><span class="cm"> *                                   UNLOCK rq(1)-&gt;lock
</span><span class="ln">1882</span><span class="cm"> *
</span><span class="ln">1883</span><span class="cm"> *                   LOCK rq(1)-&gt;lock // orders against CPU2
</span><span class="ln">1884</span><span class="cm"> *                   sched-out Z
</span><span class="ln">1885</span><span class="cm"> *                   sched-in X
</span><span class="ln">1886</span><span class="cm"> *                   UNLOCK rq(1)-&gt;lock
</span><span class="ln">1887</span><span class="cm"> *
</span><span class="ln">1888</span><span class="cm"> *
</span><span class="ln">1889</span><span class="cm"> *  BLOCKING -- aka. SLEEP + WAKEUP
</span><span class="ln">1890</span><span class="cm"> *
</span><span class="ln">1891</span><span class="cm"> * For blocking we (obviously) need to provide the same guarantee as for
</span><span class="ln">1892</span><span class="cm"> * migration. However the means are completely different as there is no lock
</span><span class="ln">1893</span><span class="cm"> * chain to provide order. Instead we do:
</span><span class="ln">1894</span><span class="cm"> *
</span><span class="ln">1895</span><span class="cm"> *   1) smp_store_release(X-&gt;on_cpu, 0)
</span><span class="ln">1896</span><span class="cm"> *   2) smp_cond_load_acquire(!X-&gt;on_cpu)
</span><span class="ln">1897</span><span class="cm"> *
</span><span class="ln">1898</span><span class="cm"> * Example:
</span><span class="ln">1899</span><span class="cm"> *
</span><span class="ln">1900</span><span class="cm"> *   CPU0 (schedule)  CPU1 (try_to_wake_up) CPU2 (schedule)
</span><span class="ln">1901</span><span class="cm"> *
</span><span class="ln">1902</span><span class="cm"> *   LOCK rq(0)-&gt;lock LOCK X-&gt;pi_lock
</span><span class="ln">1903</span><span class="cm"> *   dequeue X
</span><span class="ln">1904</span><span class="cm"> *   sched-out X
</span><span class="ln">1905</span><span class="cm"> *   smp_store_release(X-&gt;on_cpu, 0);
</span><span class="ln">1906</span><span class="cm"> *
</span><span class="ln">1907</span><span class="cm"> *                    smp_cond_load_acquire(&amp;X-&gt;on_cpu, !VAL);
</span><span class="ln">1908</span><span class="cm"> *                    X-&gt;state = WAKING
</span><span class="ln">1909</span><span class="cm"> *                    set_task_cpu(X,2)
</span><span class="ln">1910</span><span class="cm"> *
</span><span class="ln">1911</span><span class="cm"> *                    LOCK rq(2)-&gt;lock
</span><span class="ln">1912</span><span class="cm"> *                    enqueue X
</span><span class="ln">1913</span><span class="cm"> *                    X-&gt;state = RUNNING
</span><span class="ln">1914</span><span class="cm"> *                    UNLOCK rq(2)-&gt;lock
</span><span class="ln">1915</span><span class="cm"> *
</span><span class="ln">1916</span><span class="cm"> *                                          LOCK rq(2)-&gt;lock // orders against CPU1
</span><span class="ln">1917</span><span class="cm"> *                                          sched-out Z
</span><span class="ln">1918</span><span class="cm"> *                                          sched-in X
</span><span class="ln">1919</span><span class="cm"> *                                          UNLOCK rq(2)-&gt;lock
</span><span class="ln">1920</span><span class="cm"> *
</span><span class="ln">1921</span><span class="cm"> *                    UNLOCK X-&gt;pi_lock
</span><span class="ln">1922</span><span class="cm"> *   UNLOCK rq(0)-&gt;lock
</span><span class="ln">1923</span><span class="cm"> *
</span><span class="ln">1924</span><span class="cm"> *
</span><span class="ln">1925</span><span class="cm"> * However, for wakeups there is a second guarantee we must provide, namely we
</span><span class="ln">1926</span><span class="cm"> * must ensure that CONDITION=1 done by the caller can not be reordered with
</span><span class="ln">1927</span><span class="cm"> * accesses to the task state; see try_to_wake_up() and set_current_state().
</span><span class="ln">1928</span><span class="cm"> */</span>
<span class="ln">1929</span>
<span class="ln">1930</span><span class="cm">/**
</span><span class="ln">1931</span><span class="cm"> * try_to_wake_up - wake up a thread
</span><span class="ln">1932</span><span class="cm"> * @p: the thread to be awakened
</span><span class="ln">1933</span><span class="cm"> * @state: the mask of task states that can be woken
</span><span class="ln">1934</span><span class="cm"> * @wake_flags: wake modifier flags (WF_*)
</span><span class="ln">1935</span><span class="cm"> *
</span><span class="ln">1936</span><span class="cm"> * If (@state &amp; @p-&gt;state) @p-&gt;state = TASK_RUNNING.
</span><span class="ln">1937</span><span class="cm"> *
</span><span class="ln">1938</span><span class="cm"> * If the task was not queued/runnable, also place it back on a runqueue.
</span><span class="ln">1939</span><span class="cm"> *
</span><span class="ln">1940</span><span class="cm"> * Atomic against schedule() which would dequeue a task, also see
</span><span class="ln">1941</span><span class="cm"> * set_current_state().
</span><span class="ln">1942</span><span class="cm"> *
</span><span class="ln">1943</span><span class="cm"> * This function executes a full memory barrier before accessing the task
</span><span class="ln">1944</span><span class="cm"> * state; see set_current_state().
</span><span class="ln">1945</span><span class="cm"> *
</span><span class="ln">1946</span><span class="cm"> * Return: %true if @p-&gt;state changes (an actual wakeup was done),
</span><span class="ln">1947</span><span class="cm"> *	   %false otherwise.
</span><span class="ln">1948</span><span class="cm"> */</span>
<span class="ln">1949</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln">1950</span><span class="nf">try_to_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln">1951</span><span class="p">{</span>
<span class="ln">1952</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">1953</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">1954</span>
<span class="ln">1955</span>	<span class="cm">/*
</span><span class="ln">1956</span><span class="cm">	 * If we are going to wake up a thread waiting for CONDITION we
</span><span class="ln">1957</span><span class="cm">	 * need to ensure that CONDITION=1 done by the caller can not be
</span><span class="ln">1958</span><span class="cm">	 * reordered with p-&gt;state check below. This pairs with mb() in
</span><span class="ln">1959</span><span class="cm">	 * set_current_state() the waiting thread does.
</span><span class="ln">1960</span><span class="cm">	 */</span>
<span class="ln">1961</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">1962</span>	<span class="n">smp_mb__after_spinlock</span><span class="p">();</span>
<span class="ln">1963</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">))</span>
<span class="ln">1964</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">1965</span>
<span class="ln">1966</span>	<span class="n">trace_sched_waking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1967</span>
<span class="ln">1968</span>	<span class="cm">/* We&#39;re going to change -&gt;state: */</span>
<span class="ln">1969</span>	<span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">1970</span>	<span class="n">cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">1971</span>
<span class="ln">1972</span>	<span class="cm">/*
</span><span class="ln">1973</span><span class="cm">	 * Ensure we load p-&gt;on_rq _after_ p-&gt;state, otherwise it would
</span><span class="ln">1974</span><span class="cm">	 * be possible to, falsely, observe p-&gt;on_rq == 0 and get stuck
</span><span class="ln">1975</span><span class="cm">	 * in smp_cond_load_acquire() below.
</span><span class="ln">1976</span><span class="cm">	 *
</span><span class="ln">1977</span><span class="cm">	 * sched_ttwu_pending()			try_to_wake_up()
</span><span class="ln">1978</span><span class="cm">	 *   STORE p-&gt;on_rq = 1			  LOAD p-&gt;state
</span><span class="ln">1979</span><span class="cm">	 *   UNLOCK rq-&gt;lock
</span><span class="ln">1980</span><span class="cm">	 *
</span><span class="ln">1981</span><span class="cm">	 * __schedule() (switch to task &#39;p&#39;)
</span><span class="ln">1982</span><span class="cm">	 *   LOCK rq-&gt;lock			  smp_rmb();
</span><span class="ln">1983</span><span class="cm">	 *   smp_mb__after_spinlock();
</span><span class="ln">1984</span><span class="cm">	 *   UNLOCK rq-&gt;lock
</span><span class="ln">1985</span><span class="cm">	 *
</span><span class="ln">1986</span><span class="cm">	 * [task p]
</span><span class="ln">1987</span><span class="cm">	 *   STORE p-&gt;state = UNINTERRUPTIBLE	  LOAD p-&gt;on_rq
</span><span class="ln">1988</span><span class="cm">	 *
</span><span class="ln">1989</span><span class="cm">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in
</span><span class="ln">1990</span><span class="cm">	 * __schedule().  See the comment for smp_mb__after_spinlock().
</span><span class="ln">1991</span><span class="cm">	 */</span>
<span class="ln">1992</span>	<span class="n">smp_rmb</span><span class="p">();</span>
<span class="ln">1993</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">&amp;&amp;</span> <span class="n">ttwu_remote</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">))</span>
<span class="ln">1994</span>		<span class="k">goto</span> <span class="n">stat</span><span class="p">;</span>
<span class="ln">1995</span>
<span class="ln">1996</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">1997</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">1998</span><span class="cm">	 * Ensure we load p-&gt;on_cpu _after_ p-&gt;on_rq, otherwise it would be
</span><span class="ln">1999</span><span class="cm">	 * possible to, falsely, observe p-&gt;on_cpu == 0.
</span><span class="ln">2000</span><span class="cm">	 *
</span><span class="ln">2001</span><span class="cm">	 * One must be running (-&gt;on_cpu == 1) in order to remove oneself
</span><span class="ln">2002</span><span class="cm">	 * from the runqueue.
</span><span class="ln">2003</span><span class="cm">	 *
</span><span class="ln">2004</span><span class="cm">	 * __schedule() (switch to task &#39;p&#39;)	try_to_wake_up()
</span><span class="ln">2005</span><span class="cm">	 *   STORE p-&gt;on_cpu = 1		  LOAD p-&gt;on_rq
</span><span class="ln">2006</span><span class="cm">	 *   UNLOCK rq-&gt;lock
</span><span class="ln">2007</span><span class="cm">	 *
</span><span class="ln">2008</span><span class="cm">	 * __schedule() (put &#39;p&#39; to sleep)
</span><span class="ln">2009</span><span class="cm">	 *   LOCK rq-&gt;lock			  smp_rmb();
</span><span class="ln">2010</span><span class="cm">	 *   smp_mb__after_spinlock();
</span><span class="ln">2011</span><span class="cm">	 *   STORE p-&gt;on_rq = 0			  LOAD p-&gt;on_cpu
</span><span class="ln">2012</span><span class="cm">	 *
</span><span class="ln">2013</span><span class="cm">	 * Pairs with the LOCK+smp_mb__after_spinlock() on rq-&gt;lock in
</span><span class="ln">2014</span><span class="cm">	 * __schedule().  See the comment for smp_mb__after_spinlock().
</span><span class="ln">2015</span><span class="cm">	 */</span>
<span class="ln">2016</span>	<span class="n">smp_rmb</span><span class="p">();</span>
<span class="ln">2017</span>
<span class="ln">2018</span>	<span class="cm">/*
</span><span class="ln">2019</span><span class="cm">	 * If the owning (remote) CPU is still in the middle of schedule() with
</span><span class="ln">2020</span><span class="cm">	 * this task as prev, wait until its done referencing the task.
</span><span class="ln">2021</span><span class="cm">	 *
</span><span class="ln">2022</span><span class="cm">	 * Pairs with the smp_store_release() in finish_task().
</span><span class="ln">2023</span><span class="cm">	 *
</span><span class="ln">2024</span><span class="cm">	 * This ensures that tasks getting woken will be fully ordered against
</span><span class="ln">2025</span><span class="cm">	 * their previous state and preserve Program Order.
</span><span class="ln">2026</span><span class="cm">	 */</span>
<span class="ln">2027</span>	<span class="n">smp_cond_load_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span><span class="p">,</span> <span class="o">!</span><span class="n">VAL</span><span class="p">);</span>
<span class="ln">2028</span>
<span class="ln">2029</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_contributes_to_load</span> <span class="o">=</span> <span class="o">!!</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2030</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_WAKING</span><span class="p">;</span>
<span class="ln">2031</span>
<span class="ln">2032</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2033</span>		<span class="n">delayacct_blkio_end</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2034</span>		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">2035</span>	<span class="p">}</span>
<span class="ln">2036</span>
<span class="ln">2037</span>	<span class="n">cpu</span> <span class="o">=</span> <span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">wake_cpu</span><span class="p">,</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">2038</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2039</span>		<span class="n">wake_flags</span> <span class="o">|=</span> <span class="n">WF_MIGRATED</span><span class="p">;</span>
<span class="ln">2040</span>		<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">2041</span>	<span class="p">}</span>
<span class="ln">2042</span>
<span class="ln">2043</span><span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">2044</span><span class="cp"></span>
<span class="ln">2045</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2046</span>		<span class="n">delayacct_blkio_end</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2047</span>		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">2048</span>	<span class="p">}</span>
<span class="ln">2049</span>
<span class="ln">2050</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">2051</span><span class="cp"></span>
<span class="ln">2052</span>	<span class="n">ttwu_queue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">2053</span><span class="nl">stat</span><span class="p">:</span>
<span class="ln">2054</span>	<span class="n">ttwu_stat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">2055</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">2056</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2057</span>
<span class="ln">2058</span>	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="ln">2059</span><span class="p">}</span>
<span class="ln">2060</span>
<span class="ln">2061</span><span class="cm">/**
</span><span class="ln">2062</span><span class="cm"> * try_to_wake_up_local - try to wake up a local task with rq lock held
</span><span class="ln">2063</span><span class="cm"> * @p: the thread to be awakened
</span><span class="ln">2064</span><span class="cm"> * @rf: request-queue flags for pinning
</span><span class="ln">2065</span><span class="cm"> *
</span><span class="ln">2066</span><span class="cm"> * Put @p on the run-queue if it&#39;s not already there. The caller must
</span><span class="ln">2067</span><span class="cm"> * ensure that this_rq() is locked, @p is bound to this_rq() and not
</span><span class="ln">2068</span><span class="cm"> * the current task.
</span><span class="ln">2069</span><span class="cm"> */</span>
<span class="ln">2070</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">try_to_wake_up_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">2071</span><span class="p">{</span>
<span class="ln">2072</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2073</span>
<span class="ln">2074</span>	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">rq</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="p">())</span> <span class="o">||</span>
<span class="ln">2075</span>	    <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">current</span><span class="p">))</span>
<span class="ln">2076</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">2077</span>
<span class="ln">2078</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">2079</span>
<span class="ln">2080</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2081</span>		<span class="cm">/*
</span><span class="ln">2082</span><span class="cm">		 * This is OK, because current is on_cpu, which avoids it being
</span><span class="ln">2083</span><span class="cm">		 * picked for load-balance and preemption/IRQs are still
</span><span class="ln">2084</span><span class="cm">		 * disabled avoiding further scheduler activity on it and we&#39;ve
</span><span class="ln">2085</span><span class="cm">		 * not yet picked a replacement task.
</span><span class="ln">2086</span><span class="cm">		 */</span>
<span class="ln">2087</span>		<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">2088</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">2089</span>		<span class="n">rq_relock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">2090</span>	<span class="p">}</span>
<span class="ln">2091</span>
<span class="ln">2092</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_NORMAL</span><span class="p">))</span>
<span class="ln">2093</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">2094</span>
<span class="ln">2095</span>	<span class="n">trace_sched_waking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2096</span>
<span class="ln">2097</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2098</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2099</span>			<span class="n">delayacct_blkio_end</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2100</span>			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">2101</span>		<span class="p">}</span>
<span class="ln">2102</span>		<span class="n">ttwu_activate</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_WAKEUP</span> <span class="o">|</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">2103</span>	<span class="p">}</span>
<span class="ln">2104</span>
<span class="ln">2105</span>	<span class="n">ttwu_do_wakeup</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">2106</span>	<span class="n">ttwu_stat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">2107</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">2108</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">2109</span><span class="p">}</span>
<span class="ln">2110</span>
<span class="ln">2111</span><span class="cm">/**
</span><span class="ln">2112</span><span class="cm"> * wake_up_process - Wake up a specific process
</span><span class="ln">2113</span><span class="cm"> * @p: The process to be woken up.
</span><span class="ln">2114</span><span class="cm"> *
</span><span class="ln">2115</span><span class="cm"> * Attempt to wake up the nominated process and move it to the set of runnable
</span><span class="ln">2116</span><span class="cm"> * processes.
</span><span class="ln">2117</span><span class="cm"> *
</span><span class="ln">2118</span><span class="cm"> * Return: 1 if the process was woken up, 0 if it was already running.
</span><span class="ln">2119</span><span class="cm"> *
</span><span class="ln">2120</span><span class="cm"> * This function executes a full memory barrier before accessing the task state.
</span><span class="ln">2121</span><span class="cm"> */</span>
<span class="ln">2122</span><span class="kt">int</span> <span class="nf">wake_up_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">2123</span><span class="p">{</span>
<span class="ln">2124</span>	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">2125</span><span class="p">}</span>
<span class="ln">2126</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wake_up_process</span><span class="p">);</span>
<span class="ln">2127</span>
<span class="ln">2128</span><span class="kt">int</span> <span class="nf">wake_up_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="ln">2129</span><span class="p">{</span>
<span class="ln">2130</span>	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">2131</span><span class="p">}</span>
<span class="ln">2132</span>
<span class="ln">2133</span><span class="cm">/*
</span><span class="ln">2134</span><span class="cm"> * Perform scheduler related setup for a newly forked process p.
</span><span class="ln">2135</span><span class="cm"> * p is forked by current.
</span><span class="ln">2136</span><span class="cm"> *
</span><span class="ln">2137</span><span class="cm"> * __sched_fork() is basic setup used by init_idle() too:
</span><span class="ln">2138</span><span class="cm"> */</span>
<span class="ln">2139</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__sched_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">2140</span><span class="p">{</span>
<span class="ln">2141</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2142</span>
<span class="ln">2143</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">on_rq</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2144</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2145</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2146</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">prev_sum_exec_runtime</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2147</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">nr_migrations</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2148</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">vruntime</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2149</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">);</span>
<span class="ln">2150</span>
<span class="ln">2151</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">2152</span><span class="cp"></span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">cfs_rq</span>			<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">2153</span><span class="cp">#endif
</span><span class="ln">2154</span><span class="cp"></span>
<span class="ln">2155</span><span class="cp">#ifdef CONFIG_SCHEDSTATS
</span><span class="ln">2156</span><span class="cp"></span>	<span class="cm">/* Even if schedstat is disabled, there should not be garbage */</span>
<span class="ln">2157</span>	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">));</span>
<span class="ln">2158</span><span class="cp">#endif
</span><span class="ln">2159</span><span class="cp"></span>
<span class="ln">2160</span>	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>
<span class="ln">2161</span>	<span class="n">init_dl_task_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">);</span>
<span class="ln">2162</span>	<span class="n">init_dl_inactive_task_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">);</span>
<span class="ln">2163</span>	<span class="n">__dl_clear_params</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2164</span>
<span class="ln">2165</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">run_list</span><span class="p">);</span>
<span class="ln">2166</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">timeout</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2167</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span>	<span class="o">=</span> <span class="n">sched_rr_timeslice</span><span class="p">;</span>
<span class="ln">2168</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">on_rq</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2169</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">on_list</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2170</span>
<span class="ln">2171</span><span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS
</span><span class="ln">2172</span><span class="cp"></span>	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">);</span>
<span class="ln">2173</span><span class="cp">#endif
</span><span class="ln">2174</span><span class="cp"></span>
<span class="ln">2175</span>	<span class="n">init_numa_balancing</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">2176</span><span class="p">}</span>
<span class="ln">2177</span>
<span class="ln">2178</span><span class="n">DEFINE_STATIC_KEY_FALSE</span><span class="p">(</span><span class="n">sched_numa_balancing</span><span class="p">);</span>
<span class="ln">2179</span>
<span class="ln">2180</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln">2181</span><span class="cp"></span>
<span class="ln">2182</span><span class="kt">void</span> <span class="nf">set_numabalancing_state</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">)</span>
<span class="ln">2183</span><span class="p">{</span>
<span class="ln">2184</span>	<span class="k">if</span> <span class="p">(</span><span class="n">enabled</span><span class="p">)</span>
<span class="ln">2185</span>		<span class="n">static_branch_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">);</span>
<span class="ln">2186</span>	<span class="k">else</span>
<span class="ln">2187</span>		<span class="n">static_branch_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">);</span>
<span class="ln">2188</span><span class="p">}</span>
<span class="ln">2189</span>
<span class="ln">2190</span><span class="cp">#ifdef CONFIG_PROC_SYSCTL
</span><span class="ln">2191</span><span class="cp"></span><span class="kt">int</span> <span class="nf">sysctl_numa_balancing</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
<span class="ln">2192</span>			 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="ln">2193</span><span class="p">{</span>
<span class="ln">2194</span>	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="n">t</span><span class="p">;</span>
<span class="ln">2195</span>	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">2196</span>	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">);</span>
<span class="ln">2197</span>
<span class="ln">2198</span>	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
<span class="ln">2199</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">2200</span>
<span class="ln">2201</span>	<span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="ln">2202</span>	<span class="n">t</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">;</span>
<span class="ln">2203</span>	<span class="n">err</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="ln">2204</span>	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">2205</span>		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">2206</span>	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
<span class="ln">2207</span>		<span class="n">set_numabalancing_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="ln">2208</span>	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">2209</span><span class="p">}</span>
<span class="ln">2210</span><span class="cp">#endif
</span><span class="ln">2211</span><span class="cp">#endif
</span><span class="ln">2212</span><span class="cp"></span>
<span class="ln">2213</span><span class="cp">#ifdef CONFIG_SCHEDSTATS
</span><span class="ln">2214</span><span class="cp"></span>
<span class="ln">2215</span><span class="n">DEFINE_STATIC_KEY_FALSE</span><span class="p">(</span><span class="n">sched_schedstats</span><span class="p">);</span>
<span class="ln">2216</span><span class="k">static</span> <span class="kt">bool</span> <span class="n">__initdata</span> <span class="n">__sched_schedstats</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln">2217</span>
<span class="ln">2218</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_schedstats</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">)</span>
<span class="ln">2219</span><span class="p">{</span>
<span class="ln">2220</span>	<span class="k">if</span> <span class="p">(</span><span class="n">enabled</span><span class="p">)</span>
<span class="ln">2221</span>		<span class="n">static_branch_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_schedstats</span><span class="p">);</span>
<span class="ln">2222</span>	<span class="k">else</span>
<span class="ln">2223</span>		<span class="n">static_branch_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_schedstats</span><span class="p">);</span>
<span class="ln">2224</span><span class="p">}</span>
<span class="ln">2225</span>
<span class="ln">2226</span><span class="kt">void</span> <span class="nf">force_schedstat_enabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2227</span><span class="p">{</span>
<span class="ln">2228</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span> <span class="p">{</span>
<span class="ln">2229</span>		<span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;kernel profiling enabled schedstats, disable via kernel.sched_schedstats.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">2230</span>		<span class="n">static_branch_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_schedstats</span><span class="p">);</span>
<span class="ln">2231</span>	<span class="p">}</span>
<span class="ln">2232</span><span class="p">}</span>
<span class="ln">2233</span>
<span class="ln">2234</span><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_schedstats</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="ln">2235</span><span class="p">{</span>
<span class="ln">2236</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2237</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
<span class="ln">2238</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">2239</span>
<span class="ln">2240</span>	<span class="cm">/*
</span><span class="ln">2241</span><span class="cm">	 * This code is called before jump labels have been set up, so we can&#39;t
</span><span class="ln">2242</span><span class="cm">	 * change the static branch directly just yet.  Instead set a temporary
</span><span class="ln">2243</span><span class="cm">	 * variable so init_schedstats() can do it later.
</span><span class="ln">2244</span><span class="cm">	 */</span>
<span class="ln">2245</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&#34;enable&#34;</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2246</span>		<span class="n">__sched_schedstats</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">2247</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">2248</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&#34;disable&#34;</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2249</span>		<span class="n">__sched_schedstats</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln">2250</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">2251</span>	<span class="p">}</span>
<span class="ln">2252</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">2253</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">2254</span>		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&#34;Unable to parse schedstats=</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">2255</span>
<span class="ln">2256</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">2257</span><span class="p">}</span>
<span class="ln">2258</span><span class="n">__setup</span><span class="p">(</span><span class="s">&#34;schedstats=&#34;</span><span class="p">,</span> <span class="n">setup_schedstats</span><span class="p">);</span>
<span class="ln">2259</span>
<span class="ln">2260</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">init_schedstats</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2261</span><span class="p">{</span>
<span class="ln">2262</span>	<span class="n">set_schedstats</span><span class="p">(</span><span class="n">__sched_schedstats</span><span class="p">);</span>
<span class="ln">2263</span><span class="p">}</span>
<span class="ln">2264</span>
<span class="ln">2265</span><span class="cp">#ifdef CONFIG_PROC_SYSCTL
</span><span class="ln">2266</span><span class="cp"></span><span class="kt">int</span> <span class="nf">sysctl_schedstats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
<span class="ln">2267</span>			 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="ln">2268</span><span class="p">{</span>
<span class="ln">2269</span>	<span class="k">struct</span> <span class="n">ctl_table</span> <span class="n">t</span><span class="p">;</span>
<span class="ln">2270</span>	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">2271</span>	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_schedstats</span><span class="p">);</span>
<span class="ln">2272</span>
<span class="ln">2273</span>	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
<span class="ln">2274</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">2275</span>
<span class="ln">2276</span>	<span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
<span class="ln">2277</span>	<span class="n">t</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">;</span>
<span class="ln">2278</span>	<span class="n">err</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="ln">2279</span>	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">2280</span>		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">2281</span>	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
<span class="ln">2282</span>		<span class="n">set_schedstats</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="ln">2283</span>	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">2284</span><span class="p">}</span>
<span class="ln">2285</span><span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_SYSCTL */</span><span class="cp">
</span><span class="ln">2286</span><span class="cp">#else  </span><span class="cm">/* !CONFIG_SCHEDSTATS */</span><span class="cp">
</span><span class="ln">2287</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_schedstats</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln">2288</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SCHEDSTATS */</span><span class="cp">
</span><span class="ln">2289</span><span class="cp"></span>
<span class="ln">2290</span><span class="cm">/*
</span><span class="ln">2291</span><span class="cm"> * fork()/clone()-time setup:
</span><span class="ln">2292</span><span class="cm"> */</span>
<span class="ln">2293</span><span class="kt">int</span> <span class="nf">sched_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">2294</span><span class="p">{</span>
<span class="ln">2295</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">2296</span>
<span class="ln">2297</span>	<span class="n">__sched_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">2298</span>	<span class="cm">/*
</span><span class="ln">2299</span><span class="cm">	 * We mark the process as NEW here. This guarantees that
</span><span class="ln">2300</span><span class="cm">	 * nobody will actually run it, and a signal or other external
</span><span class="ln">2301</span><span class="cm">	 * event cannot wake it up and insert it on the runqueue either.
</span><span class="ln">2302</span><span class="cm">	 */</span>
<span class="ln">2303</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_NEW</span><span class="p">;</span>
<span class="ln">2304</span>
<span class="ln">2305</span>	<span class="cm">/*
</span><span class="ln">2306</span><span class="cm">	 * Make sure we do not leak PI boosting priority to the child.
</span><span class="ln">2307</span><span class="cm">	 */</span>
<span class="ln">2308</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
<span class="ln">2309</span>
<span class="ln">2310</span>	<span class="cm">/*
</span><span class="ln">2311</span><span class="cm">	 * Revert to default priority/policy on fork if requested.
</span><span class="ln">2312</span><span class="cm">	 */</span>
<span class="ln">2313</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2314</span>		<span class="k">if</span> <span class="p">(</span><span class="n">task_has_dl_policy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2315</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">SCHED_NORMAL</span><span class="p">;</span>
<span class="ln">2316</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">2317</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2318</span>		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PRIO_TO_NICE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">2319</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">2320</span>
<span class="ln">2321</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">__normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2322</span>		<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln">2323</span>
<span class="ln">2324</span>		<span class="cm">/*
</span><span class="ln">2325</span><span class="cm">		 * We don&#39;t need the reset flag anymore after the fork. It has
</span><span class="ln">2326</span><span class="cm">		 * fulfilled its duty:
</span><span class="ln">2327</span><span class="cm">		 */</span>
<span class="ln">2328</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2329</span>	<span class="p">}</span>
<span class="ln">2330</span>
<span class="ln">2331</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
<span class="ln">2332</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="ln">2333</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
<span class="ln">2334</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
<span class="ln">2335</span>	<span class="k">else</span>
<span class="ln">2336</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>
<span class="ln">2337</span>
<span class="ln">2338</span>	<span class="n">init_entity_runnable_average</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln">2339</span>
<span class="ln">2340</span>	<span class="cm">/*
</span><span class="ln">2341</span><span class="cm">	 * The child is not yet in the pid-hash so no cgroup attach races,
</span><span class="ln">2342</span><span class="cm">	 * and the cgroup is pinned to this child due to cgroup_fork()
</span><span class="ln">2343</span><span class="cm">	 * is ran before sched_fork().
</span><span class="ln">2344</span><span class="cm">	 *
</span><span class="ln">2345</span><span class="cm">	 * Silence PROVE_RCU.
</span><span class="ln">2346</span><span class="cm">	 */</span>
<span class="ln">2347</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2348</span>	<span class="n">rseq_migrate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2349</span>	<span class="cm">/*
</span><span class="ln">2350</span><span class="cm">	 * We&#39;re setting the CPU for the first time, we don&#39;t migrate,
</span><span class="ln">2351</span><span class="cm">	 * so use __set_task_cpu().
</span><span class="ln">2352</span><span class="cm">	 */</span>
<span class="ln">2353</span>	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="ln">2354</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_fork</span><span class="p">)</span>
<span class="ln">2355</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2356</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2357</span>
<span class="ln">2358</span><span class="cp">#ifdef CONFIG_SCHED_INFO
</span><span class="ln">2359</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sched_info_on</span><span class="p">()))</span>
<span class="ln">2360</span>		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">));</span>
<span class="ln">2361</span><span class="cp">#endif
</span><span class="ln">2362</span><span class="cp">#if defined(CONFIG_SMP)
</span><span class="ln">2363</span><span class="cp"></span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2364</span><span class="cp">#endif
</span><span class="ln">2365</span><span class="cp"></span>	<span class="n">init_task_preempt_count</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2366</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2367</span><span class="cp"></span>	<span class="n">plist_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_tasks</span><span class="p">,</span> <span class="n">MAX_PRIO</span><span class="p">);</span>
<span class="ln">2368</span>	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pushable_dl_tasks</span><span class="p">);</span>
<span class="ln">2369</span><span class="cp">#endif
</span><span class="ln">2370</span><span class="cp"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2371</span><span class="p">}</span>
<span class="ln">2372</span>
<span class="ln">2373</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">to_ratio</span><span class="p">(</span><span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">runtime</span><span class="p">)</span>
<span class="ln">2374</span><span class="p">{</span>
<span class="ln">2375</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
<span class="ln">2376</span>		<span class="k">return</span> <span class="n">BW_UNIT</span><span class="p">;</span>
<span class="ln">2377</span>
<span class="ln">2378</span>	<span class="cm">/*
</span><span class="ln">2379</span><span class="cm">	 * Doing this here saves a lot of checks in all
</span><span class="ln">2380</span><span class="cm">	 * the calling paths, and returning zero seems
</span><span class="ln">2381</span><span class="cm">	 * safe for them anyway.
</span><span class="ln">2382</span><span class="cm">	 */</span>
<span class="ln">2383</span>	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">2384</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2385</span>
<span class="ln">2386</span>	<span class="k">return</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">runtime</span> <span class="o">&lt;&lt;</span> <span class="n">BW_SHIFT</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="ln">2387</span><span class="p">}</span>
<span class="ln">2388</span>
<span class="ln">2389</span><span class="cm">/*
</span><span class="ln">2390</span><span class="cm"> * wake_up_new_task - wake up a newly created task for the first time.
</span><span class="ln">2391</span><span class="cm"> *
</span><span class="ln">2392</span><span class="cm"> * This function will do some initial scheduler statistics housekeeping
</span><span class="ln">2393</span><span class="cm"> * that must be done for every newly created context, then puts the task
</span><span class="ln">2394</span><span class="cm"> * on the runqueue and wakes it.
</span><span class="ln">2395</span><span class="cm"> */</span>
<span class="ln">2396</span><span class="kt">void</span> <span class="nf">wake_up_new_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">2397</span><span class="p">{</span>
<span class="ln">2398</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">2399</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">2400</span>
<span class="ln">2401</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">rf</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
<span class="ln">2402</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
<span class="ln">2403</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2404</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">2405</span><span class="cm">	 * Fork balancing, do it here and not earlier because:
</span><span class="ln">2406</span><span class="cm">	 *  - cpus_allowed can change in the fork path
</span><span class="ln">2407</span><span class="cm">	 *  - any previously selected CPU might disappear through hotplug
</span><span class="ln">2408</span><span class="cm">	 *
</span><span class="ln">2409</span><span class="cm">	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,
</span><span class="ln">2410</span><span class="cm">	 * as we&#39;re not fully set-up yet.
</span><span class="ln">2411</span><span class="cm">	 */</span>
<span class="ln">2412</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">recent_used_cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2413</span>	<span class="n">rseq_migrate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2414</span>	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">SD_BALANCE_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="ln">2415</span><span class="cp">#endif
</span><span class="ln">2416</span><span class="cp"></span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">2417</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">2418</span>	<span class="n">post_init_entity_util_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln">2419</span>
<span class="ln">2420</span>	<span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">2421</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="ln">2422</span>	<span class="n">trace_sched_wakeup_new</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">2423</span>	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">WF_FORK</span><span class="p">);</span>
<span class="ln">2424</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2425</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2426</span>		<span class="cm">/*
</span><span class="ln">2427</span><span class="cm">		 * Nothing relies on rq-&gt;lock after this, so its fine to
</span><span class="ln">2428</span><span class="cm">		 * drop it.
</span><span class="ln">2429</span><span class="cm">		 */</span>
<span class="ln">2430</span>		<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">2431</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_woken</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">2432</span>		<span class="n">rq_repin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">2433</span>	<span class="p">}</span>
<span class="ln">2434</span><span class="cp">#endif
</span><span class="ln">2435</span><span class="cp"></span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">2436</span><span class="p">}</span>
<span class="ln">2437</span>
<span class="ln">2438</span><span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS
</span><span class="ln">2439</span><span class="cp"></span>
<span class="ln">2440</span><span class="k">static</span> <span class="nf">DEFINE_STATIC_KEY_FALSE</span><span class="p">(</span><span class="n">preempt_notifier_key</span><span class="p">);</span>
<span class="ln">2441</span>
<span class="ln">2442</span><span class="kt">void</span> <span class="nf">preempt_notifier_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2443</span><span class="p">{</span>
<span class="ln">2444</span>	<span class="n">static_branch_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preempt_notifier_key</span><span class="p">);</span>
<span class="ln">2445</span><span class="p">}</span>
<span class="ln">2446</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_notifier_inc</span><span class="p">);</span>
<span class="ln">2447</span>
<span class="ln">2448</span><span class="kt">void</span> <span class="nf">preempt_notifier_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2449</span><span class="p">{</span>
<span class="ln">2450</span>	<span class="n">static_branch_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preempt_notifier_key</span><span class="p">);</span>
<span class="ln">2451</span><span class="p">}</span>
<span class="ln">2452</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_notifier_dec</span><span class="p">);</span>
<span class="ln">2453</span>
<span class="ln">2454</span><span class="cm">/**
</span><span class="ln">2455</span><span class="cm"> * preempt_notifier_register - tell me when current is being preempted &amp; rescheduled
</span><span class="ln">2456</span><span class="cm"> * @notifier: notifier struct to register
</span><span class="ln">2457</span><span class="cm"> */</span>
<span class="ln">2458</span><span class="kt">void</span> <span class="nf">preempt_notifier_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">)</span>
<span class="ln">2459</span><span class="p">{</span>
<span class="ln">2460</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preempt_notifier_key</span><span class="p">))</span>
<span class="ln">2461</span>		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;registering preempt_notifier while notifiers disabled</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">2462</span>
<span class="ln">2463</span>	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notifier</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">);</span>
<span class="ln">2464</span><span class="p">}</span>
<span class="ln">2465</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_notifier_register</span><span class="p">);</span>
<span class="ln">2466</span>
<span class="ln">2467</span><span class="cm">/**
</span><span class="ln">2468</span><span class="cm"> * preempt_notifier_unregister - no longer interested in preemption notifications
</span><span class="ln">2469</span><span class="cm"> * @notifier: notifier struct to unregister
</span><span class="ln">2470</span><span class="cm"> *
</span><span class="ln">2471</span><span class="cm"> * This is *not* safe to call from within a preemption notifier.
</span><span class="ln">2472</span><span class="cm"> */</span>
<span class="ln">2473</span><span class="kt">void</span> <span class="nf">preempt_notifier_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">)</span>
<span class="ln">2474</span><span class="p">{</span>
<span class="ln">2475</span>	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">notifier</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
<span class="ln">2476</span><span class="p">}</span>
<span class="ln">2477</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_notifier_unregister</span><span class="p">);</span>
<span class="ln">2478</span>
<span class="ln">2479</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln">2480</span><span class="p">{</span>
<span class="ln">2481</span>	<span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">;</span>
<span class="ln">2482</span>
<span class="ln">2483</span>	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
<span class="ln">2484</span>		<span class="n">notifier</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sched_in</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="n">raw_smp_processor_id</span><span class="p">());</span>
<span class="ln">2485</span><span class="p">}</span>
<span class="ln">2486</span>
<span class="ln">2487</span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln">2488</span><span class="p">{</span>
<span class="ln">2489</span>	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preempt_notifier_key</span><span class="p">))</span>
<span class="ln">2490</span>		<span class="n">__fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln">2491</span><span class="p">}</span>
<span class="ln">2492</span>
<span class="ln">2493</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln">2494</span><span class="nf">__fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
<span class="ln">2495</span>				   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="ln">2496</span><span class="p">{</span>
<span class="ln">2497</span>	<span class="k">struct</span> <span class="n">preempt_notifier</span> <span class="o">*</span><span class="n">notifier</span><span class="p">;</span>
<span class="ln">2498</span>
<span class="ln">2499</span>	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">preempt_notifiers</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
<span class="ln">2500</span>		<span class="n">notifier</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sched_out</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2501</span><span class="p">}</span>
<span class="ln">2502</span>
<span class="ln">2503</span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span>
<span class="ln">2504</span><span class="nf">fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
<span class="ln">2505</span>				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="ln">2506</span><span class="p">{</span>
<span class="ln">2507</span>	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">preempt_notifier_key</span><span class="p">))</span>
<span class="ln">2508</span>		<span class="n">__fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2509</span><span class="p">}</span>
<span class="ln">2510</span>
<span class="ln">2511</span><span class="cp">#else </span><span class="cm">/* !CONFIG_PREEMPT_NOTIFIERS */</span><span class="cp">
</span><span class="ln">2512</span><span class="cp"></span>
<span class="ln">2513</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln">2514</span><span class="p">{</span>
<span class="ln">2515</span><span class="p">}</span>
<span class="ln">2516</span>
<span class="ln">2517</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">2518</span><span class="nf">fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span>
<span class="ln">2519</span>				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="ln">2520</span><span class="p">{</span>
<span class="ln">2521</span><span class="p">}</span>
<span class="ln">2522</span>
<span class="ln">2523</span><span class="cp">#endif </span><span class="cm">/* CONFIG_PREEMPT_NOTIFIERS */</span><span class="cp">
</span><span class="ln">2524</span><span class="cp"></span>
<span class="ln">2525</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prepare_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="ln">2526</span><span class="p">{</span>
<span class="ln">2527</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2528</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">2529</span><span class="cm">	 * Claim the task as running, we do this before switching to it
</span><span class="ln">2530</span><span class="cm">	 * such that any running task will have this set.
</span><span class="ln">2531</span><span class="cm">	 */</span>
<span class="ln">2532</span>	<span class="n">next</span><span class="o">-&gt;</span><span class="n">on_cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">2533</span><span class="cp">#endif
</span><span class="ln">2534</span><span class="cp"></span><span class="p">}</span>
<span class="ln">2535</span>
<span class="ln">2536</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">finish_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln">2537</span><span class="p">{</span>
<span class="ln">2538</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2539</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">2540</span><span class="cm">	 * After -&gt;on_cpu is cleared, the task can be moved to a different CPU.
</span><span class="ln">2541</span><span class="cm">	 * We must ensure this doesn&#39;t happen until the switch is completely
</span><span class="ln">2542</span><span class="cm">	 * finished.
</span><span class="ln">2543</span><span class="cm">	 *
</span><span class="ln">2544</span><span class="cm">	 * In particular, the load of prev-&gt;state in finish_task_switch() must
</span><span class="ln">2545</span><span class="cm">	 * happen before this.
</span><span class="ln">2546</span><span class="cm">	 *
</span><span class="ln">2547</span><span class="cm">	 * Pairs with the smp_cond_load_acquire() in try_to_wake_up().
</span><span class="ln">2548</span><span class="cm">	 */</span>
<span class="ln">2549</span>	<span class="n">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">2550</span><span class="cp">#endif
</span><span class="ln">2551</span><span class="cp"></span><span class="p">}</span>
<span class="ln">2552</span>
<span class="ln">2553</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">2554</span><span class="nf">prepare_lock_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">2555</span><span class="p">{</span>
<span class="ln">2556</span>	<span class="cm">/*
</span><span class="ln">2557</span><span class="cm">	 * Since the runqueue lock will be released by the next
</span><span class="ln">2558</span><span class="cm">	 * task (which is an invalid locking op but in the case
</span><span class="ln">2559</span><span class="cm">	 * of the scheduler it&#39;s an obvious special-case), so we
</span><span class="ln">2560</span><span class="cm">	 * do an early lockdep release here:
</span><span class="ln">2561</span><span class="cm">	 */</span>
<span class="ln">2562</span>	<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">2563</span>	<span class="n">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_THIS_IP_</span><span class="p">);</span>
<span class="ln">2564</span><span class="cp">#ifdef CONFIG_DEBUG_SPINLOCK
</span><span class="ln">2565</span><span class="cp"></span>	<span class="cm">/* this is a valid case when another task releases the spinlock */</span>
<span class="ln">2566</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="ln">2567</span><span class="cp">#endif
</span><span class="ln">2568</span><span class="cp"></span><span class="p">}</span>
<span class="ln">2569</span>
<span class="ln">2570</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">finish_lock_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">2571</span><span class="p">{</span>
<span class="ln">2572</span>	<span class="cm">/*
</span><span class="ln">2573</span><span class="cm">	 * If we are tracking spinlock dependencies then we have to
</span><span class="ln">2574</span><span class="cm">	 * fix up the runqueue lock - which gets &#39;carried over&#39; from
</span><span class="ln">2575</span><span class="cm">	 * prev into current:
</span><span class="ln">2576</span><span class="cm">	 */</span>
<span class="ln">2577</span>	<span class="n">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_THIS_IP_</span><span class="p">);</span>
<span class="ln">2578</span>	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">2579</span><span class="p">}</span>
<span class="ln">2580</span>
<span class="ln">2581</span><span class="cm">/*
</span><span class="ln">2582</span><span class="cm"> * NOP if the arch has not defined these:
</span><span class="ln">2583</span><span class="cm"> */</span>
<span class="ln">2584</span>
<span class="ln">2585</span><span class="cp">#ifndef prepare_arch_switch
</span><span class="ln">2586</span><span class="cp"># define prepare_arch_switch(next)	do { } while (0)
</span><span class="ln">2587</span><span class="cp">#endif
</span><span class="ln">2588</span><span class="cp"></span>
<span class="ln">2589</span><span class="cp">#ifndef finish_arch_post_lock_switch
</span><span class="ln">2590</span><span class="cp"># define finish_arch_post_lock_switch()	do { } while (0)
</span><span class="ln">2591</span><span class="cp">#endif
</span><span class="ln">2592</span><span class="cp"></span>
<span class="ln">2593</span><span class="cm">/**
</span><span class="ln">2594</span><span class="cm"> * prepare_task_switch - prepare to switch tasks
</span><span class="ln">2595</span><span class="cm"> * @rq: the runqueue preparing to switch
</span><span class="ln">2596</span><span class="cm"> * @prev: the current task that is being switched out
</span><span class="ln">2597</span><span class="cm"> * @next: the task we are going to switch to.
</span><span class="ln">2598</span><span class="cm"> *
</span><span class="ln">2599</span><span class="cm"> * This is called with the rq lock held and interrupts off. It must
</span><span class="ln">2600</span><span class="cm"> * be paired with a subsequent finish_task_switch after the context
</span><span class="ln">2601</span><span class="cm"> * switch.
</span><span class="ln">2602</span><span class="cm"> *
</span><span class="ln">2603</span><span class="cm"> * prepare_task_switch sets up locking and calls architecture specific
</span><span class="ln">2604</span><span class="cm"> * hooks.
</span><span class="ln">2605</span><span class="cm"> */</span>
<span class="ln">2606</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">2607</span><span class="nf">prepare_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
<span class="ln">2608</span>		    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="ln">2609</span><span class="p">{</span>
<span class="ln">2610</span>	<span class="n">kcov_prepare_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2611</span>	<span class="n">sched_info_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2612</span>	<span class="n">perf_event_task_sched_out</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2613</span>	<span class="n">rseq_preempt</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2614</span>	<span class="n">fire_sched_out_preempt_notifiers</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2615</span>	<span class="n">prepare_task</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="ln">2616</span>	<span class="n">prepare_arch_switch</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="ln">2617</span><span class="p">}</span>
<span class="ln">2618</span>
<span class="ln">2619</span><span class="cm">/**
</span><span class="ln">2620</span><span class="cm"> * finish_task_switch - clean up after a task-switch
</span><span class="ln">2621</span><span class="cm"> * @prev: the thread we just switched away from.
</span><span class="ln">2622</span><span class="cm"> *
</span><span class="ln">2623</span><span class="cm"> * finish_task_switch must be called after the context switch, paired
</span><span class="ln">2624</span><span class="cm"> * with a prepare_task_switch call before the context switch.
</span><span class="ln">2625</span><span class="cm"> * finish_task_switch will reconcile locking set up by prepare_task_switch,
</span><span class="ln">2626</span><span class="cm"> * and do any other architecture-specific cleanup actions.
</span><span class="ln">2627</span><span class="cm"> *
</span><span class="ln">2628</span><span class="cm"> * Note that we may have delayed dropping an mm in context_switch(). If
</span><span class="ln">2629</span><span class="cm"> * so, we finish that here outside of the runqueue lock. (Doing it
</span><span class="ln">2630</span><span class="cm"> * with the lock held can cause deadlocks; see schedule() for
</span><span class="ln">2631</span><span class="cm"> * details.)
</span><span class="ln">2632</span><span class="cm"> *
</span><span class="ln">2633</span><span class="cm"> * The context switch have flipped the stack from under us and restored the
</span><span class="ln">2634</span><span class="cm"> * local variables which were saved when this task called schedule() in the
</span><span class="ln">2635</span><span class="cm"> * past. prev == current is still correct but we need to recalculate this_rq
</span><span class="ln">2636</span><span class="cm"> * because prev may have moved to another CPU.
</span><span class="ln">2637</span><span class="cm"> */</span>
<span class="ln">2638</span><span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">finish_task_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln">2639</span>	<span class="n">__releases</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="ln">2640</span><span class="p">{</span>
<span class="ln">2641</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln">2642</span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span><span class="p">;</span>
<span class="ln">2643</span>	<span class="kt">long</span> <span class="n">prev_state</span><span class="p">;</span>
<span class="ln">2644</span>
<span class="ln">2645</span>	<span class="cm">/*
</span><span class="ln">2646</span><span class="cm">	 * The previous task will have left us with a preempt_count of 2
</span><span class="ln">2647</span><span class="cm">	 * because it left us after:
</span><span class="ln">2648</span><span class="cm">	 *
</span><span class="ln">2649</span><span class="cm">	 *	schedule()
</span><span class="ln">2650</span><span class="cm">	 *	  preempt_disable();			// 1
</span><span class="ln">2651</span><span class="cm">	 *	  __schedule()
</span><span class="ln">2652</span><span class="cm">	 *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2
</span><span class="ln">2653</span><span class="cm">	 *
</span><span class="ln">2654</span><span class="cm">	 * Also, see FORK_PREEMPT_COUNT.
</span><span class="ln">2655</span><span class="cm">	 */</span>
<span class="ln">2656</span>	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="o">*</span><span class="n">PREEMPT_DISABLE_OFFSET</span><span class="p">,</span>
<span class="ln">2657</span>		      <span class="s">&#34;corrupted preempt_count: %s/%d/0x%x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">2658</span>		      <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">()))</span>
<span class="ln">2659</span>		<span class="n">preempt_count_set</span><span class="p">(</span><span class="n">FORK_PREEMPT_COUNT</span><span class="p">);</span>
<span class="ln">2660</span>
<span class="ln">2661</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">2662</span>
<span class="ln">2663</span>	<span class="cm">/*
</span><span class="ln">2664</span><span class="cm">	 * A task struct has one reference for the use as &#34;current&#34;.
</span><span class="ln">2665</span><span class="cm">	 * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls
</span><span class="ln">2666</span><span class="cm">	 * schedule one last time. The schedule call will never return, and
</span><span class="ln">2667</span><span class="cm">	 * the scheduled task must drop that reference.
</span><span class="ln">2668</span><span class="cm">	 *
</span><span class="ln">2669</span><span class="cm">	 * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in
</span><span class="ln">2670</span><span class="cm">	 * finish_task), otherwise a concurrent wakeup can get prev
</span><span class="ln">2671</span><span class="cm">	 * running on another CPU and we could rave with its RUNNING -&gt; DEAD
</span><span class="ln">2672</span><span class="cm">	 * transition, resulting in a double drop.
</span><span class="ln">2673</span><span class="cm">	 */</span>
<span class="ln">2674</span>	<span class="n">prev_state</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
<span class="ln">2675</span>	<span class="n">vtime_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2676</span>	<span class="n">perf_event_task_sched_in</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="ln">2677</span>	<span class="n">finish_task</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2678</span>	<span class="n">finish_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">2679</span>	<span class="n">finish_arch_post_lock_switch</span><span class="p">();</span>
<span class="ln">2680</span>	<span class="n">kcov_finish_switch</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">2681</span>
<span class="ln">2682</span>	<span class="n">fire_sched_in_preempt_notifiers</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">2683</span>	<span class="cm">/*
</span><span class="ln">2684</span><span class="cm">	 * When switching through a kernel thread, the loop in
</span><span class="ln">2685</span><span class="cm">	 * membarrier_{private,global}_expedited() may have observed that
</span><span class="ln">2686</span><span class="cm">	 * kernel thread and not issued an IPI. It is therefore possible to
</span><span class="ln">2687</span><span class="cm">	 * schedule between user-&gt;kernel-&gt;user threads without passing though
</span><span class="ln">2688</span><span class="cm">	 * switch_mm(). Membarrier requires a barrier after storing to
</span><span class="ln">2689</span><span class="cm">	 * rq-&gt;curr, before returning to userspace, so provide them here:
</span><span class="ln">2690</span><span class="cm">	 *
</span><span class="ln">2691</span><span class="cm">	 * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly
</span><span class="ln">2692</span><span class="cm">	 *   provided by mmdrop(),
</span><span class="ln">2693</span><span class="cm">	 * - a sync_core for SYNC_CORE.
</span><span class="ln">2694</span><span class="cm">	 */</span>
<span class="ln">2695</span>	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2696</span>		<span class="n">membarrier_mm_sync_core_before_usermode</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="ln">2697</span>		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="ln">2698</span>	<span class="p">}</span>
<span class="ln">2699</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prev_state</span> <span class="o">==</span> <span class="n">TASK_DEAD</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">2700</span>		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_dead</span><span class="p">)</span>
<span class="ln">2701</span>			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_dead</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2702</span>
<span class="ln">2703</span>		<span class="cm">/*
</span><span class="ln">2704</span><span class="cm">		 * Remove function-return probe instances associated with this
</span><span class="ln">2705</span><span class="cm">		 * task and put them back on the free list.
</span><span class="ln">2706</span><span class="cm">		 */</span>
<span class="ln">2707</span>		<span class="n">kprobe_flush_task</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2708</span>
<span class="ln">2709</span>		<span class="cm">/* Task is done with its stack. */</span>
<span class="ln">2710</span>		<span class="n">put_task_stack</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2711</span>
<span class="ln">2712</span>		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2713</span>	<span class="p">}</span>
<span class="ln">2714</span>
<span class="ln">2715</span>	<span class="n">tick_nohz_task_switch</span><span class="p">();</span>
<span class="ln">2716</span>	<span class="k">return</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln">2717</span><span class="p">}</span>
<span class="ln">2718</span>
<span class="ln">2719</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2720</span><span class="cp"></span>
<span class="ln">2721</span><span class="cm">/* rq-&gt;lock is NOT held, but preemption is disabled */</span>
<span class="ln">2722</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__balance_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">2723</span><span class="p">{</span>
<span class="ln">2724</span>	<span class="k">struct</span> <span class="n">callback_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="ln">2725</span>	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">2726</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">2727</span>
<span class="ln">2728</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2729</span>	<span class="n">head</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">balance_callback</span><span class="p">;</span>
<span class="ln">2730</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">balance_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">2731</span>	<span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2732</span>		<span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="p">))</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
<span class="ln">2733</span>		<span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="ln">2734</span>		<span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">2735</span>		<span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="ln">2736</span>
<span class="ln">2737</span>		<span class="n">func</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">2738</span>	<span class="p">}</span>
<span class="ln">2739</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2740</span><span class="p">}</span>
<span class="ln">2741</span>
<span class="ln">2742</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">balance_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">2743</span><span class="p">{</span>
<span class="ln">2744</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">balance_callback</span><span class="p">))</span>
<span class="ln">2745</span>		<span class="n">__balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">2746</span><span class="p">}</span>
<span class="ln">2747</span>
<span class="ln">2748</span><span class="cp">#else
</span><span class="ln">2749</span><span class="cp"></span>
<span class="ln">2750</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">balance_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">2751</span><span class="p">{</span>
<span class="ln">2752</span><span class="p">}</span>
<span class="ln">2753</span>
<span class="ln">2754</span><span class="cp">#endif
</span><span class="ln">2755</span><span class="cp"></span>
<span class="ln">2756</span><span class="cm">/**
</span><span class="ln">2757</span><span class="cm"> * schedule_tail - first thing a freshly forked thread must call.
</span><span class="ln">2758</span><span class="cm"> * @prev: the thread we just switched away from.
</span><span class="ln">2759</span><span class="cm"> */</span>
<span class="ln">2760</span><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="nf">schedule_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln">2761</span>	<span class="n">__releases</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="ln">2762</span><span class="p">{</span>
<span class="ln">2763</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">2764</span>
<span class="ln">2765</span>	<span class="cm">/*
</span><span class="ln">2766</span><span class="cm">	 * New tasks start with FORK_PREEMPT_COUNT, see there and
</span><span class="ln">2767</span><span class="cm">	 * finish_task_switch() for details.
</span><span class="ln">2768</span><span class="cm">	 *
</span><span class="ln">2769</span><span class="cm">	 * finish_task_switch() will drop rq-&gt;lock() and lower preempt_count
</span><span class="ln">2770</span><span class="cm">	 * and the preempt_enable() will end up enabling preemption (on
</span><span class="ln">2771</span><span class="cm">	 * PREEMPT_COUNT kernels).
</span><span class="ln">2772</span><span class="cm">	 */</span>
<span class="ln">2773</span>
<span class="ln">2774</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2775</span>	<span class="n">balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">2776</span>	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="ln">2777</span>
<span class="ln">2778</span>	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">set_child_tid</span><span class="p">)</span>
<span class="ln">2779</span>		<span class="n">put_user</span><span class="p">(</span><span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">set_child_tid</span><span class="p">);</span>
<span class="ln">2780</span>
<span class="ln">2781</span>	<span class="n">calculate_sigpending</span><span class="p">();</span>
<span class="ln">2782</span><span class="p">}</span>
<span class="ln">2783</span>
<span class="ln">2784</span><span class="cm">/*
</span><span class="ln">2785</span><span class="cm"> * context_switch - switch to the new MM and the new thread&#39;s register state.
</span><span class="ln">2786</span><span class="cm"> */</span>
<span class="ln">2787</span><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span>
<span class="ln">2788</span><span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
<span class="ln">2789</span>	       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">2790</span><span class="p">{</span>
<span class="ln">2791</span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">;</span>
<span class="ln">2792</span>
<span class="ln">2793</span>	<span class="n">prepare_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2794</span>
<span class="ln">2795</span>	<span class="n">mm</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
<span class="ln">2796</span>	<span class="n">oldmm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
<span class="ln">2797</span>	<span class="cm">/*
</span><span class="ln">2798</span><span class="cm">	 * For paravirt, this is coupled with an exit in switch_to to
</span><span class="ln">2799</span><span class="cm">	 * combine the page table reload and the switch backend into
</span><span class="ln">2800</span><span class="cm">	 * one hypercall.
</span><span class="ln">2801</span><span class="cm">	 */</span>
<span class="ln">2802</span>	<span class="n">arch_start_context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2803</span>
<span class="ln">2804</span>	<span class="cm">/*
</span><span class="ln">2805</span><span class="cm">	 * If mm is non-NULL, we pass through switch_mm(). If mm is
</span><span class="ln">2806</span><span class="cm">	 * NULL, we will pass through mmdrop() in finish_task_switch().
</span><span class="ln">2807</span><span class="cm">	 * Both of these contain the full memory barrier required by
</span><span class="ln">2808</span><span class="cm">	 * membarrier after storing to rq-&gt;curr, before returning to
</span><span class="ln">2809</span><span class="cm">	 * user-space.
</span><span class="ln">2810</span><span class="cm">	 */</span>
<span class="ln">2811</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2812</span>		<span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span>
<span class="ln">2813</span>		<span class="n">mmgrab</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
<span class="ln">2814</span>		<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2815</span>	<span class="p">}</span> <span class="k">else</span>
<span class="ln">2816</span>		<span class="n">switch_mm_irqs_off</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">2817</span>
<span class="ln">2818</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">2819</span>		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">2820</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span>
<span class="ln">2821</span>	<span class="p">}</span>
<span class="ln">2822</span>
<span class="ln">2823</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>
<span class="ln">2824</span>
<span class="ln">2825</span>	<span class="n">prepare_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">2826</span>
<span class="ln">2827</span>	<span class="cm">/* Here we just switch the register state and the stack. */</span>
<span class="ln">2828</span>	<span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="ln">2829</span>	<span class="n">barrier</span><span class="p">();</span>
<span class="ln">2830</span>
<span class="ln">2831</span>	<span class="k">return</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">2832</span><span class="p">}</span>
<span class="ln">2833</span>
<span class="ln">2834</span><span class="cm">/*
</span><span class="ln">2835</span><span class="cm"> * nr_running and nr_context_switches:
</span><span class="ln">2836</span><span class="cm"> *
</span><span class="ln">2837</span><span class="cm"> * externally visible scheduler statistics: current number of runnable
</span><span class="ln">2838</span><span class="cm"> * threads, total number of context switches performed since bootup.
</span><span class="ln">2839</span><span class="cm"> */</span>
<span class="ln">2840</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_running</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2841</span><span class="p">{</span>
<span class="ln">2842</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2843</span>
<span class="ln">2844</span>	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="ln">2845</span>		<span class="n">sum</span> <span class="o">+=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">;</span>
<span class="ln">2846</span>
<span class="ln">2847</span>	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="ln">2848</span><span class="p">}</span>
<span class="ln">2849</span>
<span class="ln">2850</span><span class="cm">/*
</span><span class="ln">2851</span><span class="cm"> * Check if only the current task is running on the CPU.
</span><span class="ln">2852</span><span class="cm"> *
</span><span class="ln">2853</span><span class="cm"> * Caution: this function does not check that the caller has disabled
</span><span class="ln">2854</span><span class="cm"> * preemption, thus the result might have a time-of-check-to-time-of-use
</span><span class="ln">2855</span><span class="cm"> * race.  The caller is responsible to use it correctly, for example:
</span><span class="ln">2856</span><span class="cm"> *
</span><span class="ln">2857</span><span class="cm"> * - from a non-preemptable section (of course)
</span><span class="ln">2858</span><span class="cm"> *
</span><span class="ln">2859</span><span class="cm"> * - from a thread that is bound to a single CPU
</span><span class="ln">2860</span><span class="cm"> *
</span><span class="ln">2861</span><span class="cm"> * - in a loop with very short iterations (e.g. a polling loop)
</span><span class="ln">2862</span><span class="cm"> */</span>
<span class="ln">2863</span><span class="kt">bool</span> <span class="nf">single_task_running</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2864</span><span class="p">{</span>
<span class="ln">2865</span>	<span class="k">return</span> <span class="n">raw_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">2866</span><span class="p">}</span>
<span class="ln">2867</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">single_task_running</span><span class="p">);</span>
<span class="ln">2868</span>
<span class="ln">2869</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">nr_context_switches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2870</span><span class="p">{</span>
<span class="ln">2871</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">2872</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2873</span>
<span class="ln">2874</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="ln">2875</span>		<span class="n">sum</span> <span class="o">+=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="p">;</span>
<span class="ln">2876</span>
<span class="ln">2877</span>	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="ln">2878</span><span class="p">}</span>
<span class="ln">2879</span>
<span class="ln">2880</span><span class="cm">/*
</span><span class="ln">2881</span><span class="cm"> * IO-wait accounting, and how its mostly bollocks (on SMP).
</span><span class="ln">2882</span><span class="cm"> *
</span><span class="ln">2883</span><span class="cm"> * The idea behind IO-wait account is to account the idle time that we could
</span><span class="ln">2884</span><span class="cm"> * have spend running if it were not for IO. That is, if we were to improve the
</span><span class="ln">2885</span><span class="cm"> * storage performance, we&#39;d have a proportional reduction in IO-wait time.
</span><span class="ln">2886</span><span class="cm"> *
</span><span class="ln">2887</span><span class="cm"> * This all works nicely on UP, where, when a task blocks on IO, we account
</span><span class="ln">2888</span><span class="cm"> * idle time as IO-wait, because if the storage were faster, it could&#39;ve been
</span><span class="ln">2889</span><span class="cm"> * running and we&#39;d not be idle.
</span><span class="ln">2890</span><span class="cm"> *
</span><span class="ln">2891</span><span class="cm"> * This has been extended to SMP, by doing the same for each CPU. This however
</span><span class="ln">2892</span><span class="cm"> * is broken.
</span><span class="ln">2893</span><span class="cm"> *
</span><span class="ln">2894</span><span class="cm"> * Imagine for instance the case where two tasks block on one CPU, only the one
</span><span class="ln">2895</span><span class="cm"> * CPU will have IO-wait accounted, while the other has regular idle. Even
</span><span class="ln">2896</span><span class="cm"> * though, if the storage were faster, both could&#39;ve ran at the same time,
</span><span class="ln">2897</span><span class="cm"> * utilising both CPUs.
</span><span class="ln">2898</span><span class="cm"> *
</span><span class="ln">2899</span><span class="cm"> * This means, that when looking globally, the current IO-wait accounting on
</span><span class="ln">2900</span><span class="cm"> * SMP is a lower bound, by reason of under accounting.
</span><span class="ln">2901</span><span class="cm"> *
</span><span class="ln">2902</span><span class="cm"> * Worse, since the numbers are provided per CPU, they are sometimes
</span><span class="ln">2903</span><span class="cm"> * interpreted per CPU, and that is nonsensical. A blocked task isn&#39;t strictly
</span><span class="ln">2904</span><span class="cm"> * associated with any one particular CPU, it can wake to another CPU than it
</span><span class="ln">2905</span><span class="cm"> * blocked on. This means the per CPU IO-wait number is meaningless.
</span><span class="ln">2906</span><span class="cm"> *
</span><span class="ln">2907</span><span class="cm"> * Task CPU affinities can make all that even more &#39;interesting&#39;.
</span><span class="ln">2908</span><span class="cm"> */</span>
<span class="ln">2909</span>
<span class="ln">2910</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_iowait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2911</span><span class="p">{</span>
<span class="ln">2912</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2913</span>
<span class="ln">2914</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="ln">2915</span>		<span class="n">sum</span> <span class="o">+=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">2916</span>
<span class="ln">2917</span>	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="ln">2918</span><span class="p">}</span>
<span class="ln">2919</span>
<span class="ln">2920</span><span class="cm">/*
</span><span class="ln">2921</span><span class="cm"> * Consumers of these two interfaces, like for example the cpufreq menu
</span><span class="ln">2922</span><span class="cm"> * governor are using nonsensical data. Boosting frequency for a CPU that has
</span><span class="ln">2923</span><span class="cm"> * IO-wait which might not even end up running the task when it does become
</span><span class="ln">2924</span><span class="cm"> * runnable.
</span><span class="ln">2925</span><span class="cm"> */</span>
<span class="ln">2926</span>
<span class="ln">2927</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nr_iowait_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">2928</span><span class="p">{</span>
<span class="ln">2929</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">2930</span>	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">2931</span><span class="p">}</span>
<span class="ln">2932</span>
<span class="ln">2933</span><span class="kt">void</span> <span class="nf">get_iowait_load</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_waiters</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">load</span><span class="p">)</span>
<span class="ln">2934</span><span class="p">{</span>
<span class="ln">2935</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln">2936</span>	<span class="o">*</span><span class="n">nr_waiters</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">2937</span>	<span class="o">*</span><span class="n">load</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="ln">2938</span><span class="p">}</span>
<span class="ln">2939</span>
<span class="ln">2940</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">2941</span><span class="cp"></span>
<span class="ln">2942</span><span class="cm">/*
</span><span class="ln">2943</span><span class="cm"> * sched_exec - execve() is a valuable balancing opportunity, because at
</span><span class="ln">2944</span><span class="cm"> * this point the task has the smallest effective memory and cache footprint.
</span><span class="ln">2945</span><span class="cm"> */</span>
<span class="ln">2946</span><span class="kt">void</span> <span class="nf">sched_exec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">2947</span><span class="p">{</span>
<span class="ln">2948</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="ln">2949</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">2950</span>	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln">2951</span>
<span class="ln">2952</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2953</span>	<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">SD_BALANCE_EXEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">2954</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dest_cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span>
<span class="ln">2955</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln">2956</span>
<span class="ln">2957</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">dest_cpu</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">2958</span>		<span class="k">struct</span> <span class="n">migration_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">dest_cpu</span> <span class="p">};</span>
<span class="ln">2959</span>
<span class="ln">2960</span>		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2961</span>		<span class="n">stop_one_cpu</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">migration_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="ln">2962</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">2963</span>	<span class="p">}</span>
<span class="ln">2964</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln">2965</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">2966</span><span class="p">}</span>
<span class="ln">2967</span>
<span class="ln">2968</span><span class="cp">#endif
</span><span class="ln">2969</span><span class="cp"></span>
<span class="ln">2970</span><span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_stat</span><span class="p">,</span> <span class="n">kstat</span><span class="p">);</span>
<span class="ln">2971</span><span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernel_cpustat</span><span class="p">,</span> <span class="n">kernel_cpustat</span><span class="p">);</span>
<span class="ln">2972</span>
<span class="ln">2973</span><span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">kstat</span><span class="p">);</span>
<span class="ln">2974</span><span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">kernel_cpustat</span><span class="p">);</span>
<span class="ln">2975</span>
<span class="ln">2976</span><span class="cm">/*
</span><span class="ln">2977</span><span class="cm"> * The function fair_sched_class.update_curr accesses the struct curr
</span><span class="ln">2978</span><span class="cm"> * and its field curr-&gt;exec_start; when called from task_sched_runtime(),
</span><span class="ln">2979</span><span class="cm"> * we observe a high rate of cache misses in practice.
</span><span class="ln">2980</span><span class="cm"> * Prefetching this data results in improved performance.
</span><span class="ln">2981</span><span class="cm"> */</span>
<span class="ln">2982</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">prefetch_curr_exec_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">2983</span><span class="p">{</span>
<span class="ln">2984</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">2985</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">2986</span><span class="cp">#else
</span><span class="ln">2987</span><span class="cp"></span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">2988</span><span class="cp">#endif
</span><span class="ln">2989</span><span class="cp"></span>	<span class="n">prefetch</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln">2990</span>	<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span><span class="p">);</span>
<span class="ln">2991</span><span class="p">}</span>
<span class="ln">2992</span>
<span class="ln">2993</span><span class="cm">/*
</span><span class="ln">2994</span><span class="cm"> * Return accounted runtime for the task.
</span><span class="ln">2995</span><span class="cm"> * In case the task is currently running, return the runtime plus current&#39;s
</span><span class="ln">2996</span><span class="cm"> * pending runtime that have not been accounted yet.
</span><span class="ln">2997</span><span class="cm"> */</span>
<span class="ln">2998</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">task_sched_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">2999</span><span class="p">{</span>
<span class="ln">3000</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">3001</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">3002</span>	<span class="n">u64</span> <span class="n">ns</span><span class="p">;</span>
<span class="ln">3003</span>
<span class="ln">3004</span><span class="cp">#if defined(CONFIG_64BIT) &amp;&amp; defined(CONFIG_SMP)
</span><span class="ln">3005</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">3006</span><span class="cm">	 * 64-bit doesn&#39;t need locks to atomically read a 64-bit value.
</span><span class="ln">3007</span><span class="cm">	 * So we have a optimization chance when the task&#39;s delta_exec is 0.
</span><span class="ln">3008</span><span class="cm">	 * Reading -&gt;on_cpu is racy, but this is ok.
</span><span class="ln">3009</span><span class="cm">	 *
</span><span class="ln">3010</span><span class="cm">	 * If we race with it leaving CPU, we&#39;ll take a lock. So we&#39;re correct.
</span><span class="ln">3011</span><span class="cm">	 * If we race with it entering CPU, unaccounted time is 0. This is
</span><span class="ln">3012</span><span class="cm">	 * indistinguishable from the read occurring a few cycles earlier.
</span><span class="ln">3013</span><span class="cm">	 * If we see -&gt;on_cpu without -&gt;on_rq, the task is leaving, and has
</span><span class="ln">3014</span><span class="cm">	 * been accounted, so we&#39;re correct here as well.
</span><span class="ln">3015</span><span class="cm">	 */</span>
<span class="ln">3016</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span> <span class="o">||</span> <span class="o">!</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">3017</span>		<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="ln">3018</span><span class="cp">#endif
</span><span class="ln">3019</span><span class="cp"></span>
<span class="ln">3020</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3021</span>	<span class="cm">/*
</span><span class="ln">3022</span><span class="cm">	 * Must be -&gt;curr _and_ -&gt;on_rq.  If dequeued, we would
</span><span class="ln">3023</span><span class="cm">	 * project cycles that may never be accounted to this
</span><span class="ln">3024</span><span class="cm">	 * thread, breaking clock_gettime().
</span><span class="ln">3025</span><span class="cm">	 */</span>
<span class="ln">3026</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3027</span>		<span class="n">prefetch_curr_exec_start</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">3028</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3029</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">update_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3030</span>	<span class="p">}</span>
<span class="ln">3031</span>	<span class="n">ns</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="ln">3032</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3033</span>
<span class="ln">3034</span>	<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
<span class="ln">3035</span><span class="p">}</span>
<span class="ln">3036</span>
<span class="ln">3037</span><span class="cm">/*
</span><span class="ln">3038</span><span class="cm"> * This function gets called by the timer code, with HZ frequency.
</span><span class="ln">3039</span><span class="cm"> * We call it with interrupts disabled.
</span><span class="ln">3040</span><span class="cm"> */</span>
<span class="ln">3041</span><span class="kt">void</span> <span class="nf">scheduler_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3042</span><span class="p">{</span>
<span class="ln">3043</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="ln">3044</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">3045</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">3046</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">3047</span>
<span class="ln">3048</span>	<span class="n">sched_clock_tick</span><span class="p">();</span>
<span class="ln">3049</span>
<span class="ln">3050</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3051</span>
<span class="ln">3052</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3053</span>	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">3054</span>	<span class="n">cpu_load_update_active</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3055</span>	<span class="n">calc_global_load_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3056</span>
<span class="ln">3057</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3058</span>
<span class="ln">3059</span>	<span class="n">perf_event_task_tick</span><span class="p">();</span>
<span class="ln">3060</span>
<span class="ln">3061</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">3062</span><span class="cp"></span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">=</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">3063</span>	<span class="n">trigger_load_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3064</span><span class="cp">#endif
</span><span class="ln">3065</span><span class="cp"></span><span class="p">}</span>
<span class="ln">3066</span>
<span class="ln">3067</span><span class="cp">#ifdef CONFIG_NO_HZ_FULL
</span><span class="ln">3068</span><span class="cp"></span>
<span class="ln">3069</span><span class="k">struct</span> <span class="n">tick_work</span> <span class="p">{</span>
<span class="ln">3070</span>	<span class="kt">int</span>			<span class="n">cpu</span><span class="p">;</span>
<span class="ln">3071</span>	<span class="n">atomic_t</span>		<span class="n">state</span><span class="p">;</span>
<span class="ln">3072</span>	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">work</span><span class="p">;</span>
<span class="ln">3073</span><span class="p">};</span>
<span class="ln">3074</span><span class="cm">/* Values for -&gt;state, see diagram below. */</span>
<span class="ln">3075</span><span class="cp">#define TICK_SCHED_REMOTE_OFFLINE	0
</span><span class="ln">3076</span><span class="cp">#define TICK_SCHED_REMOTE_OFFLINING	1
</span><span class="ln">3077</span><span class="cp">#define TICK_SCHED_REMOTE_RUNNING	2
</span><span class="ln">3078</span><span class="cp"></span>
<span class="ln">3079</span><span class="cm">/*
</span><span class="ln">3080</span><span class="cm"> * State diagram for -&gt;state:
</span><span class="ln">3081</span><span class="cm"> *
</span><span class="ln">3082</span><span class="cm"> *
</span><span class="ln">3083</span><span class="cm"> *          TICK_SCHED_REMOTE_OFFLINE
</span><span class="ln">3084</span><span class="cm"> *                    |   ^
</span><span class="ln">3085</span><span class="cm"> *                    |   |
</span><span class="ln">3086</span><span class="cm"> *                    |   | sched_tick_remote()
</span><span class="ln">3087</span><span class="cm"> *                    |   |
</span><span class="ln">3088</span><span class="cm"> *                    |   |
</span><span class="ln">3089</span><span class="cm"> *                    +--TICK_SCHED_REMOTE_OFFLINING
</span><span class="ln">3090</span><span class="cm"> *                    |   ^
</span><span class="ln">3091</span><span class="cm"> *                    |   |
</span><span class="ln">3092</span><span class="cm"> * sched_tick_start() |   | sched_tick_stop()
</span><span class="ln">3093</span><span class="cm"> *                    |   |
</span><span class="ln">3094</span><span class="cm"> *                    V   |
</span><span class="ln">3095</span><span class="cm"> *          TICK_SCHED_REMOTE_RUNNING
</span><span class="ln">3096</span><span class="cm"> *
</span><span class="ln">3097</span><span class="cm"> *
</span><span class="ln">3098</span><span class="cm"> * Other transitions get WARN_ON_ONCE(), except that sched_tick_remote()
</span><span class="ln">3099</span><span class="cm"> * and sched_tick_start() are happy to leave the state in RUNNING.
</span><span class="ln">3100</span><span class="cm"> */</span>
<span class="ln">3101</span>
<span class="ln">3102</span><span class="k">static</span> <span class="k">struct</span> <span class="n">tick_work</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">tick_work_cpu</span><span class="p">;</span>
<span class="ln">3103</span>
<span class="ln">3104</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_tick_remote</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="ln">3105</span><span class="p">{</span>
<span class="ln">3106</span>	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span> <span class="o">=</span> <span class="n">to_delayed_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="ln">3107</span>	<span class="k">struct</span> <span class="n">tick_work</span> <span class="o">*</span><span class="n">twork</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dwork</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tick_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="ln">3108</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">twork</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln">3109</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">3110</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">3111</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">3112</span>	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln">3113</span>	<span class="kt">int</span> <span class="n">os</span><span class="p">;</span>
<span class="ln">3114</span>
<span class="ln">3115</span>	<span class="cm">/*
</span><span class="ln">3116</span><span class="cm">	 * Handle the tick only if it appears the remote CPU is running in full
</span><span class="ln">3117</span><span class="cm">	 * dynticks mode. The check is racy by nature, but missing a tick or
</span><span class="ln">3118</span><span class="cm">	 * having one too much is no big deal because the scheduler tick updates
</span><span class="ln">3119</span><span class="cm">	 * statistics and checks timeslices in a time-independent way, regardless
</span><span class="ln">3120</span><span class="cm">	 * of when exactly it is running.
</span><span class="ln">3121</span><span class="cm">	 */</span>
<span class="ln">3122</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tick_nohz_tick_stopped_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln">3123</span>		<span class="k">goto</span> <span class="n">out_requeue</span><span class="p">;</span>
<span class="ln">3124</span>
<span class="ln">3125</span>	<span class="n">rq_lock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3126</span>	<span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">3127</span>	<span class="k">if</span> <span class="p">(</span><span class="n">is_idle_task</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="o">||</span> <span class="n">cpu_is_offline</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln">3128</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">3129</span>
<span class="ln">3130</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3131</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="p">;</span>
<span class="ln">3132</span>
<span class="ln">3133</span>	<span class="cm">/*
</span><span class="ln">3134</span><span class="cm">	 * Make sure the next tick runs within a reasonable
</span><span class="ln">3135</span><span class="cm">	 * amount of time.
</span><span class="ln">3136</span><span class="cm">	 */</span>
<span class="ln">3137</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">NSEC_PER_SEC</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
<span class="ln">3138</span>	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">3139</span>
<span class="ln">3140</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">3141</span>	<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3142</span>
<span class="ln">3143</span><span class="nl">out_requeue</span><span class="p">:</span>
<span class="ln">3144</span>	<span class="cm">/*
</span><span class="ln">3145</span><span class="cm">	 * Run the remote tick once per second (1Hz). This arbitrary
</span><span class="ln">3146</span><span class="cm">	 * frequency is large enough to avoid overload but short enough
</span><span class="ln">3147</span><span class="cm">	 * to keep scheduler internal stats reasonably up to date.  But
</span><span class="ln">3148</span><span class="cm">	 * first update state to reflect hotplug activity if required.
</span><span class="ln">3149</span><span class="cm">	 */</span>
<span class="ln">3150</span>	<span class="n">os</span> <span class="o">=</span> <span class="n">atomic_fetch_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">twork</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">TICK_SCHED_REMOTE_RUNNING</span><span class="p">);</span>
<span class="ln">3151</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">os</span> <span class="o">==</span> <span class="n">TICK_SCHED_REMOTE_OFFLINE</span><span class="p">);</span>
<span class="ln">3152</span>	<span class="k">if</span> <span class="p">(</span><span class="n">os</span> <span class="o">==</span> <span class="n">TICK_SCHED_REMOTE_RUNNING</span><span class="p">)</span>
<span class="ln">3153</span>		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_unbound_wq</span><span class="p">,</span> <span class="n">dwork</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
<span class="ln">3154</span><span class="p">}</span>
<span class="ln">3155</span>
<span class="ln">3156</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_tick_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">3157</span><span class="p">{</span>
<span class="ln">3158</span>	<span class="kt">int</span> <span class="n">os</span><span class="p">;</span>
<span class="ln">3159</span>	<span class="k">struct</span> <span class="n">tick_work</span> <span class="o">*</span><span class="n">twork</span><span class="p">;</span>
<span class="ln">3160</span>
<span class="ln">3161</span>	<span class="k">if</span> <span class="p">(</span><span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">HK_FLAG_TICK</span><span class="p">))</span>
<span class="ln">3162</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3163</span>
<span class="ln">3164</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">tick_work_cpu</span><span class="p">);</span>
<span class="ln">3165</span>
<span class="ln">3166</span>	<span class="n">twork</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">tick_work_cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">3167</span>	<span class="n">os</span> <span class="o">=</span> <span class="n">atomic_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">twork</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">TICK_SCHED_REMOTE_RUNNING</span><span class="p">);</span>
<span class="ln">3168</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">os</span> <span class="o">==</span> <span class="n">TICK_SCHED_REMOTE_RUNNING</span><span class="p">);</span>
<span class="ln">3169</span>	<span class="k">if</span> <span class="p">(</span><span class="n">os</span> <span class="o">==</span> <span class="n">TICK_SCHED_REMOTE_OFFLINE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3170</span>		<span class="n">twork</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln">3171</span>		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">twork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">sched_tick_remote</span><span class="p">);</span>
<span class="ln">3172</span>		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_unbound_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">twork</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
<span class="ln">3173</span>	<span class="p">}</span>
<span class="ln">3174</span><span class="p">}</span>
<span class="ln">3175</span>
<span class="ln">3176</span><span class="cp">#ifdef CONFIG_HOTPLUG_CPU
</span><span class="ln">3177</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_tick_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">3178</span><span class="p">{</span>
<span class="ln">3179</span>	<span class="k">struct</span> <span class="n">tick_work</span> <span class="o">*</span><span class="n">twork</span><span class="p">;</span>
<span class="ln">3180</span>	<span class="kt">int</span> <span class="n">os</span><span class="p">;</span>
<span class="ln">3181</span>
<span class="ln">3182</span>	<span class="k">if</span> <span class="p">(</span><span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">HK_FLAG_TICK</span><span class="p">))</span>
<span class="ln">3183</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3184</span>
<span class="ln">3185</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">tick_work_cpu</span><span class="p">);</span>
<span class="ln">3186</span>
<span class="ln">3187</span>	<span class="n">twork</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">tick_work_cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">3188</span>	<span class="cm">/* There cannot be competing actions, but don&#39;t rely on stop-machine. */</span>
<span class="ln">3189</span>	<span class="n">os</span> <span class="o">=</span> <span class="n">atomic_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">twork</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">TICK_SCHED_REMOTE_OFFLINING</span><span class="p">);</span>
<span class="ln">3190</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">os</span> <span class="o">!=</span> <span class="n">TICK_SCHED_REMOTE_RUNNING</span><span class="p">);</span>
<span class="ln">3191</span>	<span class="cm">/* Don&#39;t cancel, as this would mess up the state machine. */</span>
<span class="ln">3192</span><span class="p">}</span>
<span class="ln">3193</span><span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp">
</span><span class="ln">3194</span><span class="cp"></span>
<span class="ln">3195</span><span class="kt">int</span> <span class="n">__init</span> <span class="nf">sched_tick_offload_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3196</span><span class="p">{</span>
<span class="ln">3197</span>	<span class="n">tick_work_cpu</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">tick_work</span><span class="p">);</span>
<span class="ln">3198</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tick_work_cpu</span><span class="p">);</span>
<span class="ln">3199</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3200</span><span class="p">}</span>
<span class="ln">3201</span>
<span class="ln">3202</span><span class="cp">#else </span><span class="cm">/* !CONFIG_NO_HZ_FULL */</span><span class="cp">
</span><span class="ln">3203</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_tick_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">3204</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_tick_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">3205</span><span class="cp">#endif
</span><span class="ln">3206</span><span class="cp"></span>
<span class="ln">3207</span><span class="cp">#if defined(CONFIG_PREEMPT) &amp;&amp; (defined(CONFIG_DEBUG_PREEMPT) || \
</span><span class="ln">3208</span><span class="cp">				defined(CONFIG_TRACE_PREEMPT_TOGGLE))
</span><span class="ln">3209</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">3210</span><span class="cm"> * If the value passed in is equal to the current preempt count
</span><span class="ln">3211</span><span class="cm"> * then we just disabled preemption. Start timing the latency.
</span><span class="ln">3212</span><span class="cm"> */</span>
<span class="ln">3213</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">preempt_latency_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="ln">3214</span><span class="p">{</span>
<span class="ln">3215</span>	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3216</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">get_lock_parent_ip</span><span class="p">();</span>
<span class="ln">3217</span><span class="cp">#ifdef CONFIG_DEBUG_PREEMPT
</span><span class="ln">3218</span><span class="cp"></span>		<span class="n">current</span><span class="o">-&gt;</span><span class="n">preempt_disable_ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
<span class="ln">3219</span><span class="cp">#endif
</span><span class="ln">3220</span><span class="cp"></span>		<span class="n">trace_preempt_off</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
<span class="ln">3221</span>	<span class="p">}</span>
<span class="ln">3222</span><span class="p">}</span>
<span class="ln">3223</span>
<span class="ln">3224</span><span class="kt">void</span> <span class="nf">preempt_count_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="ln">3225</span><span class="p">{</span>
<span class="ln">3226</span><span class="cp">#ifdef CONFIG_DEBUG_PREEMPT
</span><span class="ln">3227</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">3228</span><span class="cm">	 * Underflow?
</span><span class="ln">3229</span><span class="cm">	 */</span>
<span class="ln">3230</span>	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">((</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)))</span>
<span class="ln">3231</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3232</span><span class="cp">#endif
</span><span class="ln">3233</span><span class="cp"></span>	<span class="n">__preempt_count_add</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="ln">3234</span><span class="cp">#ifdef CONFIG_DEBUG_PREEMPT
</span><span class="ln">3235</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">3236</span><span class="cm">	 * Spinlock count overflowing soon?
</span><span class="ln">3237</span><span class="cm">	 */</span>
<span class="ln">3238</span>	<span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">((</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_MASK</span><span class="p">)</span> <span class="o">&gt;=</span>
<span class="ln">3239</span>				<span class="n">PREEMPT_MASK</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>
<span class="ln">3240</span><span class="cp">#endif
</span><span class="ln">3241</span><span class="cp"></span>	<span class="n">preempt_latency_start</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="ln">3242</span><span class="p">}</span>
<span class="ln">3243</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">preempt_count_add</span><span class="p">);</span>
<span class="ln">3244</span><span class="n">NOKPROBE_SYMBOL</span><span class="p">(</span><span class="n">preempt_count_add</span><span class="p">);</span>
<span class="ln">3245</span>
<span class="ln">3246</span><span class="cm">/*
</span><span class="ln">3247</span><span class="cm"> * If the value passed in equals to the current preempt count
</span><span class="ln">3248</span><span class="cm"> * then we just enabled preemption. Stop timing the latency.
</span><span class="ln">3249</span><span class="cm"> */</span>
<span class="ln">3250</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">preempt_latency_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="ln">3251</span><span class="p">{</span>
<span class="ln">3252</span>	<span class="k">if</span> <span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
<span class="ln">3253</span>		<span class="n">trace_preempt_on</span><span class="p">(</span><span class="n">CALLER_ADDR0</span><span class="p">,</span> <span class="n">get_lock_parent_ip</span><span class="p">());</span>
<span class="ln">3254</span><span class="p">}</span>
<span class="ln">3255</span>
<span class="ln">3256</span><span class="kt">void</span> <span class="nf">preempt_count_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="ln">3257</span><span class="p">{</span>
<span class="ln">3258</span><span class="cp">#ifdef CONFIG_DEBUG_PREEMPT
</span><span class="ln">3259</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">3260</span><span class="cm">	 * Underflow?
</span><span class="ln">3261</span><span class="cm">	 */</span>
<span class="ln">3262</span>	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">preempt_count</span><span class="p">()))</span>
<span class="ln">3263</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3264</span>	<span class="cm">/*
</span><span class="ln">3265</span><span class="cm">	 * Is the spinlock portion underflowing?
</span><span class="ln">3266</span><span class="cm">	 */</span>
<span class="ln">3267</span>	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_LOCKS_WARN_ON</span><span class="p">((</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">PREEMPT_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">3268</span>			<span class="o">!</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">PREEMPT_MASK</span><span class="p">)))</span>
<span class="ln">3269</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3270</span><span class="cp">#endif
</span><span class="ln">3271</span><span class="cp"></span>
<span class="ln">3272</span>	<span class="n">preempt_latency_stop</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="ln">3273</span>	<span class="n">__preempt_count_sub</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="ln">3274</span><span class="p">}</span>
<span class="ln">3275</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">preempt_count_sub</span><span class="p">);</span>
<span class="ln">3276</span><span class="n">NOKPROBE_SYMBOL</span><span class="p">(</span><span class="n">preempt_count_sub</span><span class="p">);</span>
<span class="ln">3277</span>
<span class="ln">3278</span><span class="cp">#else
</span><span class="ln">3279</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">preempt_latency_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">3280</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">preempt_latency_stop</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">3281</span><span class="cp">#endif
</span><span class="ln">3282</span><span class="cp"></span>
<span class="ln">3283</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_preempt_disable_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">3284</span><span class="p">{</span>
<span class="ln">3285</span><span class="cp">#ifdef CONFIG_DEBUG_PREEMPT
</span><span class="ln">3286</span><span class="cp"></span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">preempt_disable_ip</span><span class="p">;</span>
<span class="ln">3287</span><span class="cp">#else
</span><span class="ln">3288</span><span class="cp"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3289</span><span class="cp">#endif
</span><span class="ln">3290</span><span class="cp"></span><span class="p">}</span>
<span class="ln">3291</span>
<span class="ln">3292</span><span class="cm">/*
</span><span class="ln">3293</span><span class="cm"> * Print scheduling while atomic bug:
</span><span class="ln">3294</span><span class="cm"> */</span>
<span class="ln">3295</span><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">__schedule_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln">3296</span><span class="p">{</span>
<span class="ln">3297</span>	<span class="cm">/* Save this before calling printk(), since that will clobber it */</span>
<span class="ln">3298</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">preempt_disable_ip</span> <span class="o">=</span> <span class="n">get_preempt_disable_ip</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">3299</span>
<span class="ln">3300</span>	<span class="k">if</span> <span class="p">(</span><span class="n">oops_in_progress</span><span class="p">)</span>
<span class="ln">3301</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3302</span>
<span class="ln">3303</span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&#34;BUG: scheduling while atomic: %s/%d/0x%08x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">3304</span>		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">preempt_count</span><span class="p">());</span>
<span class="ln">3305</span>
<span class="ln">3306</span>	<span class="n">debug_show_held_locks</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">3307</span>	<span class="n">print_modules</span><span class="p">();</span>
<span class="ln">3308</span>	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span>
<span class="ln">3309</span>		<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">3310</span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_PREEMPT</span><span class="p">)</span>
<span class="ln">3311</span>	    <span class="o">&amp;&amp;</span> <span class="n">in_atomic_preempt_off</span><span class="p">())</span> <span class="p">{</span>
<span class="ln">3312</span>		<span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;Preemption disabled at:&#34;</span><span class="p">);</span>
<span class="ln">3313</span>		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">preempt_disable_ip</span><span class="p">);</span>
<span class="ln">3314</span>		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">3315</span>	<span class="p">}</span>
<span class="ln">3316</span>	<span class="k">if</span> <span class="p">(</span><span class="n">panic_on_warn</span><span class="p">)</span>
<span class="ln">3317</span>		<span class="n">panic</span><span class="p">(</span><span class="s">&#34;scheduling while atomic</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">3318</span>
<span class="ln">3319</span>	<span class="n">dump_stack</span><span class="p">();</span>
<span class="ln">3320</span>	<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_WARN</span><span class="p">,</span> <span class="n">LOCKDEP_STILL_OK</span><span class="p">);</span>
<span class="ln">3321</span><span class="p">}</span>
<span class="ln">3322</span>
<span class="ln">3323</span><span class="cm">/*
</span><span class="ln">3324</span><span class="cm"> * Various schedule()-time debugging checks and statistics:
</span><span class="ln">3325</span><span class="cm"> */</span>
<span class="ln">3326</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">schedule_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln">3327</span><span class="p">{</span>
<span class="ln">3328</span><span class="cp">#ifdef CONFIG_SCHED_STACK_END_CHECK
</span><span class="ln">3329</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_stack_end_corrupted</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
<span class="ln">3330</span>		<span class="n">panic</span><span class="p">(</span><span class="s">&#34;corrupted stack end detected inside scheduler</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">3331</span><span class="cp">#endif
</span><span class="ln">3332</span><span class="cp"></span>
<span class="ln">3333</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_atomic_preempt_off</span><span class="p">()))</span> <span class="p">{</span>
<span class="ln">3334</span>		<span class="n">__schedule_bug</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">3335</span>		<span class="n">preempt_count_set</span><span class="p">(</span><span class="n">PREEMPT_DISABLED</span><span class="p">);</span>
<span class="ln">3336</span>	<span class="p">}</span>
<span class="ln">3337</span>	<span class="n">rcu_sleep_check</span><span class="p">();</span>
<span class="ln">3338</span>
<span class="ln">3339</span>	<span class="n">profile_hit</span><span class="p">(</span><span class="n">SCHED_PROFILING</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="ln">3340</span>
<span class="ln">3341</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sched_count</span><span class="p">);</span>
<span class="ln">3342</span><span class="p">}</span>
<span class="ln">3343</span>
<span class="ln">3344</span><span class="cm">/*
</span><span class="ln">3345</span><span class="cm"> * Pick up the highest-prio task:
</span><span class="ln">3346</span><span class="cm"> */</span>
<span class="ln">3347</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="ln">3348</span><span class="nf">pick_next_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">3349</span><span class="p">{</span>
<span class="ln">3350</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
<span class="ln">3351</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">3352</span>
<span class="ln">3353</span>	<span class="cm">/*
</span><span class="ln">3354</span><span class="cm">	 * Optimization: we know that if all tasks are in the fair class we can
</span><span class="ln">3355</span><span class="cm">	 * call that function directly, but only if the @prev task wasn&#39;t of a
</span><span class="ln">3356</span><span class="cm">	 * higher scheduling class, because otherwise those loose the
</span><span class="ln">3357</span><span class="cm">	 * opportunity to pull in more work from other CPUs.
</span><span class="ln">3358</span><span class="cm">	 */</span>
<span class="ln">3359</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span> <span class="o">||</span>
<span class="ln">3360</span>		    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">3361</span>		   <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3362</span>
<span class="ln">3363</span>		<span class="n">p</span> <span class="o">=</span> <span class="n">fair_sched_class</span><span class="p">.</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">3364</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">RETRY_TASK</span><span class="p">))</span>
<span class="ln">3365</span>			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="ln">3366</span>
<span class="ln">3367</span>		<span class="cm">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
<span class="ln">3368</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span>
<span class="ln">3369</span>			<span class="n">p</span> <span class="o">=</span> <span class="n">idle_sched_class</span><span class="p">.</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">3370</span>
<span class="ln">3371</span>		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="ln">3372</span>	<span class="p">}</span>
<span class="ln">3373</span>
<span class="ln">3374</span><span class="nl">again</span><span class="p">:</span>
<span class="ln">3375</span>	<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3376</span>		<span class="n">p</span> <span class="o">=</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">3377</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3378</span>			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">RETRY_TASK</span><span class="p">))</span>
<span class="ln">3379</span>				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="ln">3380</span>			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="ln">3381</span>		<span class="p">}</span>
<span class="ln">3382</span>	<span class="p">}</span>
<span class="ln">3383</span>
<span class="ln">3384</span>	<span class="cm">/* The idle class should always have a runnable task: */</span>
<span class="ln">3385</span>	<span class="n">BUG</span><span class="p">();</span>
<span class="ln">3386</span><span class="p">}</span>
<span class="ln">3387</span>
<span class="ln">3388</span><span class="cm">/*
</span><span class="ln">3389</span><span class="cm"> * __schedule() is the main scheduler function.
</span><span class="ln">3390</span><span class="cm"> *
</span><span class="ln">3391</span><span class="cm"> * The main means of driving the scheduler and thus entering this function are:
</span><span class="ln">3392</span><span class="cm"> *
</span><span class="ln">3393</span><span class="cm"> *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.
</span><span class="ln">3394</span><span class="cm"> *
</span><span class="ln">3395</span><span class="cm"> *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return
</span><span class="ln">3396</span><span class="cm"> *      paths. For example, see arch/x86/entry_64.S.
</span><span class="ln">3397</span><span class="cm"> *
</span><span class="ln">3398</span><span class="cm"> *      To drive preemption between tasks, the scheduler sets the flag in timer
</span><span class="ln">3399</span><span class="cm"> *      interrupt handler scheduler_tick().
</span><span class="ln">3400</span><span class="cm"> *
</span><span class="ln">3401</span><span class="cm"> *   3. Wakeups don&#39;t really cause entry into schedule(). They add a
</span><span class="ln">3402</span><span class="cm"> *      task to the run-queue and that&#39;s it.
</span><span class="ln">3403</span><span class="cm"> *
</span><span class="ln">3404</span><span class="cm"> *      Now, if the new task added to the run-queue preempts the current
</span><span class="ln">3405</span><span class="cm"> *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets
</span><span class="ln">3406</span><span class="cm"> *      called on the nearest possible occasion:
</span><span class="ln">3407</span><span class="cm"> *
</span><span class="ln">3408</span><span class="cm"> *       - If the kernel is preemptible (CONFIG_PREEMPT=y):
</span><span class="ln">3409</span><span class="cm"> *
</span><span class="ln">3410</span><span class="cm"> *         - in syscall or exception context, at the next outmost
</span><span class="ln">3411</span><span class="cm"> *           preempt_enable(). (this might be as soon as the wake_up()&#39;s
</span><span class="ln">3412</span><span class="cm"> *           spin_unlock()!)
</span><span class="ln">3413</span><span class="cm"> *
</span><span class="ln">3414</span><span class="cm"> *         - in IRQ context, return from interrupt-handler to
</span><span class="ln">3415</span><span class="cm"> *           preemptible context
</span><span class="ln">3416</span><span class="cm"> *
</span><span class="ln">3417</span><span class="cm"> *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set)
</span><span class="ln">3418</span><span class="cm"> *         then at the next:
</span><span class="ln">3419</span><span class="cm"> *
</span><span class="ln">3420</span><span class="cm"> *          - cond_resched() call
</span><span class="ln">3421</span><span class="cm"> *          - explicit schedule() call
</span><span class="ln">3422</span><span class="cm"> *          - return from syscall or exception to user-space
</span><span class="ln">3423</span><span class="cm"> *          - return from interrupt-handler to user-space
</span><span class="ln">3424</span><span class="cm"> *
</span><span class="ln">3425</span><span class="cm"> * WARNING: must be called with preemption disabled!
</span><span class="ln">3426</span><span class="cm"> */</span>
<span class="ln">3427</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">__schedule</span><span class="p">(</span><span class="kt">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="ln">3428</span><span class="p">{</span>
<span class="ln">3429</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="ln">3430</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
<span class="ln">3431</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">3432</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">3433</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln">3434</span>
<span class="ln">3435</span>	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="ln">3436</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">3437</span>	<span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">3438</span>
<span class="ln">3439</span>	<span class="n">schedule_debug</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">3440</span>
<span class="ln">3441</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">HRTICK</span><span class="p">))</span>
<span class="ln">3442</span>		<span class="n">hrtick_clear</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3443</span>
<span class="ln">3444</span>	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="ln">3445</span>	<span class="n">rcu_note_context_switch</span><span class="p">(</span><span class="n">preempt</span><span class="p">);</span>
<span class="ln">3446</span>
<span class="ln">3447</span>	<span class="cm">/*
</span><span class="ln">3448</span><span class="cm">	 * Make sure that signal_pending_state()-&gt;signal_pending() below
</span><span class="ln">3449</span><span class="cm">	 * can&#39;t be reordered with __set_current_state(TASK_INTERRUPTIBLE)
</span><span class="ln">3450</span><span class="cm">	 * done by the caller to avoid the race with signal_wake_up().
</span><span class="ln">3451</span><span class="cm">	 *
</span><span class="ln">3452</span><span class="cm">	 * The membarrier system call requires a full memory barrier
</span><span class="ln">3453</span><span class="cm">	 * after coming from user-space, before storing to rq-&gt;curr.
</span><span class="ln">3454</span><span class="cm">	 */</span>
<span class="ln">3455</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3456</span>	<span class="n">smp_mb__after_spinlock</span><span class="p">();</span>
<span class="ln">3457</span>
<span class="ln">3458</span>	<span class="cm">/* Promote REQ to ACT */</span>
<span class="ln">3459</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">3460</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3461</span>
<span class="ln">3462</span>	<span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
<span class="ln">3463</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preempt</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3464</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">prev</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">3465</span>			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
<span class="ln">3466</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">3467</span>			<span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">DEQUEUE_SLEEP</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">3468</span>			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3469</span>
<span class="ln">3470</span>			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3471</span>				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
<span class="ln">3472</span>				<span class="n">delayacct_blkio_start</span><span class="p">();</span>
<span class="ln">3473</span>			<span class="p">}</span>
<span class="ln">3474</span>
<span class="ln">3475</span>			<span class="cm">/*
</span><span class="ln">3476</span><span class="cm">			 * If a worker went to sleep, notify and ask workqueue
</span><span class="ln">3477</span><span class="cm">			 * whether it wants to wake up a task to maintain
</span><span class="ln">3478</span><span class="cm">			 * concurrency.
</span><span class="ln">3479</span><span class="cm">			 */</span>
<span class="ln">3480</span>			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_WQ_WORKER</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3481</span>				<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">to_wakeup</span><span class="p">;</span>
<span class="ln">3482</span>
<span class="ln">3483</span>				<span class="n">to_wakeup</span> <span class="o">=</span> <span class="n">wq_worker_sleeping</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">3484</span>				<span class="k">if</span> <span class="p">(</span><span class="n">to_wakeup</span><span class="p">)</span>
<span class="ln">3485</span>					<span class="n">try_to_wake_up_local</span><span class="p">(</span><span class="n">to_wakeup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3486</span>			<span class="p">}</span>
<span class="ln">3487</span>		<span class="p">}</span>
<span class="ln">3488</span>		<span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
<span class="ln">3489</span>	<span class="p">}</span>
<span class="ln">3490</span>
<span class="ln">3491</span>	<span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3492</span>	<span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="ln">3493</span>	<span class="n">clear_preempt_need_resched</span><span class="p">();</span>
<span class="ln">3494</span>
<span class="ln">3495</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3496</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="o">++</span><span class="p">;</span>
<span class="ln">3497</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="ln">3498</span>		<span class="cm">/*
</span><span class="ln">3499</span><span class="cm">		 * The membarrier system call requires each architecture
</span><span class="ln">3500</span><span class="cm">		 * to have a full memory barrier after updating
</span><span class="ln">3501</span><span class="cm">		 * rq-&gt;curr, before returning to user-space.
</span><span class="ln">3502</span><span class="cm">		 *
</span><span class="ln">3503</span><span class="cm">		 * Here are the schemes providing that barrier on the
</span><span class="ln">3504</span><span class="cm">		 * various architectures:
</span><span class="ln">3505</span><span class="cm">		 * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.
</span><span class="ln">3506</span><span class="cm">		 *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.
</span><span class="ln">3507</span><span class="cm">		 * - finish_lock_switch() for weakly-ordered
</span><span class="ln">3508</span><span class="cm">		 *   architectures where spin_unlock is a full barrier,
</span><span class="ln">3509</span><span class="cm">		 * - switch_to() for arm64 (weakly-ordered, spin_unlock
</span><span class="ln">3510</span><span class="cm">		 *   is a RELEASE barrier),
</span><span class="ln">3511</span><span class="cm">		 */</span>
<span class="ln">3512</span>		<span class="o">++*</span><span class="n">switch_count</span><span class="p">;</span>
<span class="ln">3513</span>
<span class="ln">3514</span>		<span class="n">trace_sched_switch</span><span class="p">(</span><span class="n">preempt</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">3515</span>
<span class="ln">3516</span>		<span class="cm">/* Also unlocks the rq: */</span>
<span class="ln">3517</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3518</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">3519</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>
<span class="ln">3520</span>		<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3521</span>	<span class="p">}</span>
<span class="ln">3522</span>
<span class="ln">3523</span>	<span class="n">balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3524</span><span class="p">}</span>
<span class="ln">3525</span>
<span class="ln">3526</span><span class="kt">void</span> <span class="n">__noreturn</span> <span class="nf">do_task_dead</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3527</span><span class="p">{</span>
<span class="ln">3528</span>	<span class="cm">/* Causes final put_task_struct in finish_task_switch(): */</span>
<span class="ln">3529</span>	<span class="n">set_special_state</span><span class="p">(</span><span class="n">TASK_DEAD</span><span class="p">);</span>
<span class="ln">3530</span>
<span class="ln">3531</span>	<span class="cm">/* Tell freezer to ignore us: */</span>
<span class="ln">3532</span>	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_NOFREEZE</span><span class="p">;</span>
<span class="ln">3533</span>
<span class="ln">3534</span>	<span class="n">__schedule</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="ln">3535</span>	<span class="n">BUG</span><span class="p">();</span>
<span class="ln">3536</span>
<span class="ln">3537</span>	<span class="cm">/* Avoid &#34;noreturn function does return&#34; - but don&#39;t continue if BUG() is a NOP: */</span>
<span class="ln">3538</span>	<span class="k">for</span> <span class="p">(;;)</span>
<span class="ln">3539</span>		<span class="n">cpu_relax</span><span class="p">();</span>
<span class="ln">3540</span><span class="p">}</span>
<span class="ln">3541</span>
<span class="ln">3542</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sched_submit_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="ln">3543</span><span class="p">{</span>
<span class="ln">3544</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">||</span> <span class="n">tsk_is_pi_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
<span class="ln">3545</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3546</span>	<span class="cm">/*
</span><span class="ln">3547</span><span class="cm">	 * If we are going to sleep and we have plugged IO queued,
</span><span class="ln">3548</span><span class="cm">	 * make sure to submit it to avoid deadlocks.
</span><span class="ln">3549</span><span class="cm">	 */</span>
<span class="ln">3550</span>	<span class="k">if</span> <span class="p">(</span><span class="n">blk_needs_flush_plug</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
<span class="ln">3551</span>		<span class="n">blk_schedule_flush_plug</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="ln">3552</span><span class="p">}</span>
<span class="ln">3553</span>
<span class="ln">3554</span><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3555</span><span class="p">{</span>
<span class="ln">3556</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="ln">3557</span>
<span class="ln">3558</span>	<span class="n">sched_submit_work</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="ln">3559</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln">3560</span>		<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">3561</span>		<span class="n">__schedule</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="ln">3562</span>		<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
<span class="ln">3563</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="ln">3564</span><span class="p">}</span>
<span class="ln">3565</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule</span><span class="p">);</span>
<span class="ln">3566</span>
<span class="ln">3567</span><span class="cm">/*
</span><span class="ln">3568</span><span class="cm"> * synchronize_rcu_tasks() makes sure that no task is stuck in preempted
</span><span class="ln">3569</span><span class="cm"> * state (have scheduled out non-voluntarily) by making sure that all
</span><span class="ln">3570</span><span class="cm"> * tasks have either left the run queue or have gone into user space.
</span><span class="ln">3571</span><span class="cm"> * As idle tasks do not do either, they must not ever be preempted
</span><span class="ln">3572</span><span class="cm"> * (schedule out non-voluntarily).
</span><span class="ln">3573</span><span class="cm"> *
</span><span class="ln">3574</span><span class="cm"> * schedule_idle() is similar to schedule_preempt_disable() except that it
</span><span class="ln">3575</span><span class="cm"> * never enables preemption because it does not call sched_submit_work().
</span><span class="ln">3576</span><span class="cm"> */</span>
<span class="ln">3577</span><span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule_idle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3578</span><span class="p">{</span>
<span class="ln">3579</span>	<span class="cm">/*
</span><span class="ln">3580</span><span class="cm">	 * As this skips calling sched_submit_work(), which the idle task does
</span><span class="ln">3581</span><span class="cm">	 * regardless because that function is a nop when the task is in a
</span><span class="ln">3582</span><span class="cm">	 * TASK_RUNNING state, make sure this isn&#39;t used someplace that the
</span><span class="ln">3583</span><span class="cm">	 * current task can be in any other state. Note, idle is always in the
</span><span class="ln">3584</span><span class="cm">	 * TASK_RUNNING state.
</span><span class="ln">3585</span><span class="cm">	 */</span>
<span class="ln">3586</span>	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="ln">3587</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln">3588</span>		<span class="n">__schedule</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="ln">3589</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="ln">3590</span><span class="p">}</span>
<span class="ln">3591</span>
<span class="ln">3592</span><span class="cp">#ifdef CONFIG_CONTEXT_TRACKING
</span><span class="ln">3593</span><span class="cp"></span><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule_user</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3594</span><span class="p">{</span>
<span class="ln">3595</span>	<span class="cm">/*
</span><span class="ln">3596</span><span class="cm">	 * If we come here after a random call to set_need_resched(),
</span><span class="ln">3597</span><span class="cm">	 * or we have been woken up remotely but the IPI has not yet arrived,
</span><span class="ln">3598</span><span class="cm">	 * we haven&#39;t yet exited the RCU idle mode. Do it here manually until
</span><span class="ln">3599</span><span class="cm">	 * we find a better solution.
</span><span class="ln">3600</span><span class="cm">	 *
</span><span class="ln">3601</span><span class="cm">	 * NB: There are buggy callers of this function.  Ideally we
</span><span class="ln">3602</span><span class="cm">	 * should warn if prev_state != CONTEXT_USER, but that will trigger
</span><span class="ln">3603</span><span class="cm">	 * too frequently to make sense yet.
</span><span class="ln">3604</span><span class="cm">	 */</span>
<span class="ln">3605</span>	<span class="k">enum</span> <span class="n">ctx_state</span> <span class="n">prev_state</span> <span class="o">=</span> <span class="n">exception_enter</span><span class="p">();</span>
<span class="ln">3606</span>	<span class="n">schedule</span><span class="p">();</span>
<span class="ln">3607</span>	<span class="n">exception_exit</span><span class="p">(</span><span class="n">prev_state</span><span class="p">);</span>
<span class="ln">3608</span><span class="p">}</span>
<span class="ln">3609</span><span class="cp">#endif
</span><span class="ln">3610</span><span class="cp"></span>
<span class="ln">3611</span><span class="cm">/**
</span><span class="ln">3612</span><span class="cm"> * schedule_preempt_disabled - called with preemption disabled
</span><span class="ln">3613</span><span class="cm"> *
</span><span class="ln">3614</span><span class="cm"> * Returns with preemption disabled. Note: preempt_count must be 1
</span><span class="ln">3615</span><span class="cm"> */</span>
<span class="ln">3616</span><span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule_preempt_disabled</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3617</span><span class="p">{</span>
<span class="ln">3618</span>	<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
<span class="ln">3619</span>	<span class="n">schedule</span><span class="p">();</span>
<span class="ln">3620</span>	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">3621</span><span class="p">}</span>
<span class="ln">3622</span>
<span class="ln">3623</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">preempt_schedule_common</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3624</span><span class="p">{</span>
<span class="ln">3625</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln">3626</span>		<span class="cm">/*
</span><span class="ln">3627</span><span class="cm">		 * Because the function tracer can trace preempt_count_sub()
</span><span class="ln">3628</span><span class="cm">		 * and it also uses preempt_enable/disable_notrace(), if
</span><span class="ln">3629</span><span class="cm">		 * NEED_RESCHED is set, the preempt_enable_notrace() called
</span><span class="ln">3630</span><span class="cm">		 * by the function tracer will call this function again and
</span><span class="ln">3631</span><span class="cm">		 * cause infinite recursion.
</span><span class="ln">3632</span><span class="cm">		 *
</span><span class="ln">3633</span><span class="cm">		 * Preemption must be disabled here before the function
</span><span class="ln">3634</span><span class="cm">		 * tracer can trace. Break up preempt_disable() into two
</span><span class="ln">3635</span><span class="cm">		 * calls. One to disable preemption without fear of being
</span><span class="ln">3636</span><span class="cm">		 * traced. The other to still record the preemption latency,
</span><span class="ln">3637</span><span class="cm">		 * which can also be traced by the function tracer.
</span><span class="ln">3638</span><span class="cm">		 */</span>
<span class="ln">3639</span>		<span class="n">preempt_disable_notrace</span><span class="p">();</span>
<span class="ln">3640</span>		<span class="n">preempt_latency_start</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">3641</span>		<span class="n">__schedule</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="ln">3642</span>		<span class="n">preempt_latency_stop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">3643</span>		<span class="n">preempt_enable_no_resched_notrace</span><span class="p">();</span>
<span class="ln">3644</span>
<span class="ln">3645</span>		<span class="cm">/*
</span><span class="ln">3646</span><span class="cm">		 * Check again in case we missed a preemption opportunity
</span><span class="ln">3647</span><span class="cm">		 * between schedule and now.
</span><span class="ln">3648</span><span class="cm">		 */</span>
<span class="ln">3649</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="ln">3650</span><span class="p">}</span>
<span class="ln">3651</span>
<span class="ln">3652</span><span class="cp">#ifdef CONFIG_PREEMPT
</span><span class="ln">3653</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">3654</span><span class="cm"> * this is the entry point to schedule() from in-kernel preemption
</span><span class="ln">3655</span><span class="cm"> * off of preempt_enable. Kernel preemptions off return from interrupt
</span><span class="ln">3656</span><span class="cm"> * occur there and call schedule directly.
</span><span class="ln">3657</span><span class="cm"> */</span>
<span class="ln">3658</span><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">preempt_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3659</span><span class="p">{</span>
<span class="ln">3660</span>	<span class="cm">/*
</span><span class="ln">3661</span><span class="cm">	 * If there is a non-zero preempt_count or interrupts are disabled,
</span><span class="ln">3662</span><span class="cm">	 * we do not want to preempt the current task. Just return..
</span><span class="ln">3663</span><span class="cm">	 */</span>
<span class="ln">3664</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">preemptible</span><span class="p">()))</span>
<span class="ln">3665</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3666</span>
<span class="ln">3667</span>	<span class="n">preempt_schedule_common</span><span class="p">();</span>
<span class="ln">3668</span><span class="p">}</span>
<span class="ln">3669</span><span class="n">NOKPROBE_SYMBOL</span><span class="p">(</span><span class="n">preempt_schedule</span><span class="p">);</span>
<span class="ln">3670</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">preempt_schedule</span><span class="p">);</span>
<span class="ln">3671</span>
<span class="ln">3672</span><span class="cm">/**
</span><span class="ln">3673</span><span class="cm"> * preempt_schedule_notrace - preempt_schedule called by tracing
</span><span class="ln">3674</span><span class="cm"> *
</span><span class="ln">3675</span><span class="cm"> * The tracing infrastructure uses preempt_enable_notrace to prevent
</span><span class="ln">3676</span><span class="cm"> * recursion and tracing preempt enabling caused by the tracing
</span><span class="ln">3677</span><span class="cm"> * infrastructure itself. But as tracing can happen in areas coming
</span><span class="ln">3678</span><span class="cm"> * from userspace or just about to enter userspace, a preempt enable
</span><span class="ln">3679</span><span class="cm"> * can occur before user_exit() is called. This will cause the scheduler
</span><span class="ln">3680</span><span class="cm"> * to be called when the system is still in usermode.
</span><span class="ln">3681</span><span class="cm"> *
</span><span class="ln">3682</span><span class="cm"> * To prevent this, the preempt_enable_notrace will use this function
</span><span class="ln">3683</span><span class="cm"> * instead of preempt_schedule() to exit user context if needed before
</span><span class="ln">3684</span><span class="cm"> * calling the scheduler.
</span><span class="ln">3685</span><span class="cm"> */</span>
<span class="ln">3686</span><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">preempt_schedule_notrace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3687</span><span class="p">{</span>
<span class="ln">3688</span>	<span class="k">enum</span> <span class="n">ctx_state</span> <span class="n">prev_ctx</span><span class="p">;</span>
<span class="ln">3689</span>
<span class="ln">3690</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">preemptible</span><span class="p">()))</span>
<span class="ln">3691</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3692</span>
<span class="ln">3693</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln">3694</span>		<span class="cm">/*
</span><span class="ln">3695</span><span class="cm">		 * Because the function tracer can trace preempt_count_sub()
</span><span class="ln">3696</span><span class="cm">		 * and it also uses preempt_enable/disable_notrace(), if
</span><span class="ln">3697</span><span class="cm">		 * NEED_RESCHED is set, the preempt_enable_notrace() called
</span><span class="ln">3698</span><span class="cm">		 * by the function tracer will call this function again and
</span><span class="ln">3699</span><span class="cm">		 * cause infinite recursion.
</span><span class="ln">3700</span><span class="cm">		 *
</span><span class="ln">3701</span><span class="cm">		 * Preemption must be disabled here before the function
</span><span class="ln">3702</span><span class="cm">		 * tracer can trace. Break up preempt_disable() into two
</span><span class="ln">3703</span><span class="cm">		 * calls. One to disable preemption without fear of being
</span><span class="ln">3704</span><span class="cm">		 * traced. The other to still record the preemption latency,
</span><span class="ln">3705</span><span class="cm">		 * which can also be traced by the function tracer.
</span><span class="ln">3706</span><span class="cm">		 */</span>
<span class="ln">3707</span>		<span class="n">preempt_disable_notrace</span><span class="p">();</span>
<span class="ln">3708</span>		<span class="n">preempt_latency_start</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">3709</span>		<span class="cm">/*
</span><span class="ln">3710</span><span class="cm">		 * Needs preempt disabled in case user_exit() is traced
</span><span class="ln">3711</span><span class="cm">		 * and the tracer calls preempt_enable_notrace() causing
</span><span class="ln">3712</span><span class="cm">		 * an infinite recursion.
</span><span class="ln">3713</span><span class="cm">		 */</span>
<span class="ln">3714</span>		<span class="n">prev_ctx</span> <span class="o">=</span> <span class="n">exception_enter</span><span class="p">();</span>
<span class="ln">3715</span>		<span class="n">__schedule</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="ln">3716</span>		<span class="n">exception_exit</span><span class="p">(</span><span class="n">prev_ctx</span><span class="p">);</span>
<span class="ln">3717</span>
<span class="ln">3718</span>		<span class="n">preempt_latency_stop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">3719</span>		<span class="n">preempt_enable_no_resched_notrace</span><span class="p">();</span>
<span class="ln">3720</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="ln">3721</span><span class="p">}</span>
<span class="ln">3722</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">preempt_schedule_notrace</span><span class="p">);</span>
<span class="ln">3723</span>
<span class="ln">3724</span><span class="cp">#endif </span><span class="cm">/* CONFIG_PREEMPT */</span><span class="cp">
</span><span class="ln">3725</span><span class="cp"></span>
<span class="ln">3726</span><span class="cm">/*
</span><span class="ln">3727</span><span class="cm"> * this is the entry point to schedule() from kernel preemption
</span><span class="ln">3728</span><span class="cm"> * off of irq context.
</span><span class="ln">3729</span><span class="cm"> * Note, that this is called and return with irqs disabled. This will
</span><span class="ln">3730</span><span class="cm"> * protect us against recursive calling from irq.
</span><span class="ln">3731</span><span class="cm"> */</span>
<span class="ln">3732</span><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">preempt_schedule_irq</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">3733</span><span class="p">{</span>
<span class="ln">3734</span>	<span class="k">enum</span> <span class="n">ctx_state</span> <span class="n">prev_state</span><span class="p">;</span>
<span class="ln">3735</span>
<span class="ln">3736</span>	<span class="cm">/* Catch callers which need to be fixed */</span>
<span class="ln">3737</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">preempt_count</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
<span class="ln">3738</span>
<span class="ln">3739</span>	<span class="n">prev_state</span> <span class="o">=</span> <span class="n">exception_enter</span><span class="p">();</span>
<span class="ln">3740</span>
<span class="ln">3741</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln">3742</span>		<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">3743</span>		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="ln">3744</span>		<span class="n">__schedule</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="ln">3745</span>		<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="ln">3746</span>		<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
<span class="ln">3747</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
<span class="ln">3748</span>
<span class="ln">3749</span>	<span class="n">exception_exit</span><span class="p">(</span><span class="n">prev_state</span><span class="p">);</span>
<span class="ln">3750</span><span class="p">}</span>
<span class="ln">3751</span>
<span class="ln">3752</span><span class="kt">int</span> <span class="nf">default_wake_function</span><span class="p">(</span><span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
<span class="ln">3753</span>			  <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="ln">3754</span><span class="p">{</span>
<span class="ln">3755</span>	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="ln">3756</span><span class="p">}</span>
<span class="ln">3757</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">default_wake_function</span><span class="p">);</span>
<span class="ln">3758</span>
<span class="ln">3759</span><span class="cp">#ifdef CONFIG_RT_MUTEXES
</span><span class="ln">3760</span><span class="cp"></span>
<span class="ln">3761</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__rt_effective_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pi_task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="ln">3762</span><span class="p">{</span>
<span class="ln">3763</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pi_task</span><span class="p">)</span>
<span class="ln">3764</span>		<span class="n">prio</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">prio</span><span class="p">,</span> <span class="n">pi_task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
<span class="ln">3765</span>
<span class="ln">3766</span>	<span class="k">return</span> <span class="n">prio</span><span class="p">;</span>
<span class="ln">3767</span><span class="p">}</span>
<span class="ln">3768</span>
<span class="ln">3769</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_effective_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="ln">3770</span><span class="p">{</span>
<span class="ln">3771</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pi_task</span> <span class="o">=</span> <span class="n">rt_mutex_get_top_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">3772</span>
<span class="ln">3773</span>	<span class="k">return</span> <span class="n">__rt_effective_prio</span><span class="p">(</span><span class="n">pi_task</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
<span class="ln">3774</span><span class="p">}</span>
<span class="ln">3775</span>
<span class="ln">3776</span><span class="cm">/*
</span><span class="ln">3777</span><span class="cm"> * rt_mutex_setprio - set the current priority of a task
</span><span class="ln">3778</span><span class="cm"> * @p: task to boost
</span><span class="ln">3779</span><span class="cm"> * @pi_task: donor task
</span><span class="ln">3780</span><span class="cm"> *
</span><span class="ln">3781</span><span class="cm"> * This function changes the &#39;effective&#39; priority of a task. It does
</span><span class="ln">3782</span><span class="cm"> * not touch -&gt;normal_prio like __setscheduler().
</span><span class="ln">3783</span><span class="cm"> *
</span><span class="ln">3784</span><span class="cm"> * Used by the rt_mutex code to implement priority inheritance
</span><span class="ln">3785</span><span class="cm"> * logic. Call site only calls if the priority of the task changed.
</span><span class="ln">3786</span><span class="cm"> */</span>
<span class="ln">3787</span><span class="kt">void</span> <span class="nf">rt_mutex_setprio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pi_task</span><span class="p">)</span>
<span class="ln">3788</span><span class="p">{</span>
<span class="ln">3789</span>	<span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">,</span> <span class="n">queued</span><span class="p">,</span> <span class="n">running</span><span class="p">,</span> <span class="n">queue_flag</span> <span class="o">=</span>
<span class="ln">3790</span>		<span class="n">DEQUEUE_SAVE</span> <span class="o">|</span> <span class="n">DEQUEUE_MOVE</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">;</span>
<span class="ln">3791</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">;</span>
<span class="ln">3792</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">3793</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">3794</span>
<span class="ln">3795</span>	<span class="cm">/* XXX used to be waiter-&gt;prio, not waiter-&gt;task-&gt;prio */</span>
<span class="ln">3796</span>	<span class="n">prio</span> <span class="o">=</span> <span class="n">__rt_effective_prio</span><span class="p">(</span><span class="n">pi_task</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">);</span>
<span class="ln">3797</span>
<span class="ln">3798</span>	<span class="cm">/*
</span><span class="ln">3799</span><span class="cm">	 * If nothing changed; bail early.
</span><span class="ln">3800</span><span class="cm">	 */</span>
<span class="ln">3801</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_top_task</span> <span class="o">==</span> <span class="n">pi_task</span> <span class="o">&amp;&amp;</span> <span class="n">prio</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">prio</span><span class="p">))</span>
<span class="ln">3802</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3803</span>
<span class="ln">3804</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3805</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3806</span>	<span class="cm">/*
</span><span class="ln">3807</span><span class="cm">	 * Set under pi_lock &amp;&amp; rq-&gt;lock, such that the value can be used under
</span><span class="ln">3808</span><span class="cm">	 * either lock.
</span><span class="ln">3809</span><span class="cm">	 *
</span><span class="ln">3810</span><span class="cm">	 * Note that there is loads of tricky to make this pointer cache work
</span><span class="ln">3811</span><span class="cm">	 * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to
</span><span class="ln">3812</span><span class="cm">	 * ensure a task is de-boosted (pi_task is set to NULL) before the
</span><span class="ln">3813</span><span class="cm">	 * task is allowed to run again (and can exit). This ensures the pointer
</span><span class="ln">3814</span><span class="cm">	 * points to a blocked task -- which guaratees the task is present.
</span><span class="ln">3815</span><span class="cm">	 */</span>
<span class="ln">3816</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_top_task</span> <span class="o">=</span> <span class="n">pi_task</span><span class="p">;</span>
<span class="ln">3817</span>
<span class="ln">3818</span>	<span class="cm">/*
</span><span class="ln">3819</span><span class="cm">	 * For FIFO/RR we only need to set prio, if that matches we&#39;re done.
</span><span class="ln">3820</span><span class="cm">	 */</span>
<span class="ln">3821</span>	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">prio</span><span class="p">))</span>
<span class="ln">3822</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">3823</span>
<span class="ln">3824</span>	<span class="cm">/*
</span><span class="ln">3825</span><span class="cm">	 * Idle task boosting is a nono in general. There is one
</span><span class="ln">3826</span><span class="cm">	 * exception, when PREEMPT_RT and NOHZ is active:
</span><span class="ln">3827</span><span class="cm">	 *
</span><span class="ln">3828</span><span class="cm">	 * The idle task calls get_next_timer_interrupt() and holds
</span><span class="ln">3829</span><span class="cm">	 * the timer wheel base-&gt;lock on the CPU and another CPU wants
</span><span class="ln">3830</span><span class="cm">	 * to access the timer (probably to cancel it). We can safely
</span><span class="ln">3831</span><span class="cm">	 * ignore the boosting request, as the idle CPU runs this code
</span><span class="ln">3832</span><span class="cm">	 * with interrupts disabled and will complete the lock
</span><span class="ln">3833</span><span class="cm">	 * protected section without being interrupted. So there is no
</span><span class="ln">3834</span><span class="cm">	 * real need to boost.
</span><span class="ln">3835</span><span class="cm">	 */</span>
<span class="ln">3836</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3837</span>		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="ln">3838</span>		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_blocked_on</span><span class="p">);</span>
<span class="ln">3839</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">3840</span>	<span class="p">}</span>
<span class="ln">3841</span>
<span class="ln">3842</span>	<span class="n">trace_sched_pi_setprio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pi_task</span><span class="p">);</span>
<span class="ln">3843</span>	<span class="n">oldprio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="ln">3844</span>
<span class="ln">3845</span>	<span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">==</span> <span class="n">prio</span><span class="p">)</span>
<span class="ln">3846</span>		<span class="n">queue_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEQUEUE_MOVE</span><span class="p">;</span>
<span class="ln">3847</span>
<span class="ln">3848</span>	<span class="n">prev_class</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
<span class="ln">3849</span>	<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">3850</span>	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">3851</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">3852</span>		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">queue_flag</span><span class="p">);</span>
<span class="ln">3853</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">3854</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">3855</span>
<span class="ln">3856</span>	<span class="cm">/*
</span><span class="ln">3857</span><span class="cm">	 * Boosting condition are:
</span><span class="ln">3858</span><span class="cm">	 * 1. -rt task is running and holds mutex A
</span><span class="ln">3859</span><span class="cm">	 *      --&gt; -dl task blocks on mutex A
</span><span class="ln">3860</span><span class="cm">	 *
</span><span class="ln">3861</span><span class="cm">	 * 2. -dl task is running and holds mutex A
</span><span class="ln">3862</span><span class="cm">	 *      --&gt; -dl task blocks on mutex A and could preempt the
</span><span class="ln">3863</span><span class="cm">	 *          running task
</span><span class="ln">3864</span><span class="cm">	 */</span>
<span class="ln">3865</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">prio</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3866</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">3867</span>		    <span class="p">(</span><span class="n">pi_task</span> <span class="o">&amp;&amp;</span> <span class="n">dl_prio</span><span class="p">(</span><span class="n">pi_task</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">3868</span>		     <span class="n">dl_entity_preempt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi_task</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">3869</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">.</span><span class="n">dl_boosted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">3870</span>			<span class="n">queue_flag</span> <span class="o">|=</span> <span class="n">ENQUEUE_REPLENISH</span><span class="p">;</span>
<span class="ln">3871</span>		<span class="p">}</span> <span class="k">else</span>
<span class="ln">3872</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">.</span><span class="n">dl_boosted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3873</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dl_sched_class</span><span class="p">;</span>
<span class="ln">3874</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">prio</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3875</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">oldprio</span><span class="p">))</span>
<span class="ln">3876</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">.</span><span class="n">dl_boosted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3877</span>		<span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">&lt;</span> <span class="n">prio</span><span class="p">)</span>
<span class="ln">3878</span>			<span class="n">queue_flag</span> <span class="o">|=</span> <span class="n">ENQUEUE_HEAD</span><span class="p">;</span>
<span class="ln">3879</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
<span class="ln">3880</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">3881</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">oldprio</span><span class="p">))</span>
<span class="ln">3882</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">.</span><span class="n">dl_boosted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3883</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">oldprio</span><span class="p">))</span>
<span class="ln">3884</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">3885</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>
<span class="ln">3886</span>	<span class="p">}</span>
<span class="ln">3887</span>
<span class="ln">3888</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>
<span class="ln">3889</span>
<span class="ln">3890</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">3891</span>		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">queue_flag</span><span class="p">);</span>
<span class="ln">3892</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">3893</span>		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">3894</span>
<span class="ln">3895</span>	<span class="n">check_class_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">prev_class</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">);</span>
<span class="ln">3896</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">3897</span>	<span class="cm">/* Avoid rq from going away on us: */</span>
<span class="ln">3898</span>	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">3899</span>	<span class="n">__task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3900</span>
<span class="ln">3901</span>	<span class="n">balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3902</span>	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="ln">3903</span><span class="p">}</span>
<span class="ln">3904</span><span class="cp">#else
</span><span class="ln">3905</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rt_effective_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="ln">3906</span><span class="p">{</span>
<span class="ln">3907</span>	<span class="k">return</span> <span class="n">prio</span><span class="p">;</span>
<span class="ln">3908</span><span class="p">}</span>
<span class="ln">3909</span><span class="cp">#endif
</span><span class="ln">3910</span><span class="cp"></span>
<span class="ln">3911</span><span class="kt">void</span> <span class="nf">set_user_nice</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nice</span><span class="p">)</span>
<span class="ln">3912</span><span class="p">{</span>
<span class="ln">3913</span>	<span class="kt">bool</span> <span class="n">queued</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
<span class="ln">3914</span>	<span class="kt">int</span> <span class="n">old_prio</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln">3915</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">3916</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">3917</span>
<span class="ln">3918</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">nice</span> <span class="o">||</span> <span class="n">nice</span> <span class="o">&lt;</span> <span class="n">MIN_NICE</span> <span class="o">||</span> <span class="n">nice</span> <span class="o">&gt;</span> <span class="n">MAX_NICE</span><span class="p">)</span>
<span class="ln">3919</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">3920</span>	<span class="cm">/*
</span><span class="ln">3921</span><span class="cm">	 * We have to be careful, if called from sys_setpriority(),
</span><span class="ln">3922</span><span class="cm">	 * the task might be in the middle of scheduling on another CPU.
</span><span class="ln">3923</span><span class="cm">	 */</span>
<span class="ln">3924</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3925</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3926</span>
<span class="ln">3927</span>	<span class="cm">/*
</span><span class="ln">3928</span><span class="cm">	 * The RT priorities are set via sched_setscheduler(), but we still
</span><span class="ln">3929</span><span class="cm">	 * allow the &#39;normal&#39; nice value to be set - but as expected
</span><span class="ln">3930</span><span class="cm">	 * it wont have any effect on scheduling until the task is
</span><span class="ln">3931</span><span class="cm">	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:
</span><span class="ln">3932</span><span class="cm">	 */</span>
<span class="ln">3933</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_dl_policy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">3934</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="n">nice</span><span class="p">);</span>
<span class="ln">3935</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">3936</span>	<span class="p">}</span>
<span class="ln">3937</span>	<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">3938</span>	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">3939</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">3940</span>		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">DEQUEUE_SAVE</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">3941</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">3942</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">3943</span>
<span class="ln">3944</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="n">nice</span><span class="p">);</span>
<span class="ln">3945</span>	<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">3946</span>	<span class="n">old_prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="ln">3947</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">effective_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">3948</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">-</span> <span class="n">old_prio</span><span class="p">;</span>
<span class="ln">3949</span>
<span class="ln">3950</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">3951</span>		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_RESTORE</span> <span class="o">|</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">3952</span>		<span class="cm">/*
</span><span class="ln">3953</span><span class="cm">		 * If the task increased its priority or is running and
</span><span class="ln">3954</span><span class="cm">		 * lowered its priority, then reschedule its CPU:
</span><span class="ln">3955</span><span class="cm">		 */</span>
<span class="ln">3956</span>		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">task_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
<span class="ln">3957</span>			<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">3958</span>	<span class="p">}</span>
<span class="ln">3959</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">3960</span>		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">3961</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">3962</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">3963</span><span class="p">}</span>
<span class="ln">3964</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_user_nice</span><span class="p">);</span>
<span class="ln">3965</span>
<span class="ln">3966</span><span class="cm">/*
</span><span class="ln">3967</span><span class="cm"> * can_nice - check if a task can reduce its nice value
</span><span class="ln">3968</span><span class="cm"> * @p: task
</span><span class="ln">3969</span><span class="cm"> * @nice: nice value
</span><span class="ln">3970</span><span class="cm"> */</span>
<span class="ln">3971</span><span class="kt">int</span> <span class="nf">can_nice</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nice</span><span class="p">)</span>
<span class="ln">3972</span><span class="p">{</span>
<span class="ln">3973</span>	<span class="cm">/* Convert nice value [19,-20] to rlimit style value [1,40]: */</span>
<span class="ln">3974</span>	<span class="kt">int</span> <span class="n">nice_rlim</span> <span class="o">=</span> <span class="n">nice_to_rlimit</span><span class="p">(</span><span class="n">nice</span><span class="p">);</span>
<span class="ln">3975</span>
<span class="ln">3976</span>	<span class="k">return</span> <span class="p">(</span><span class="n">nice_rlim</span> <span class="o">&lt;=</span> <span class="n">task_rlimit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_NICE</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">3977</span>		<span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">));</span>
<span class="ln">3978</span><span class="p">}</span>
<span class="ln">3979</span>
<span class="ln">3980</span><span class="cp">#ifdef __ARCH_WANT_SYS_NICE
</span><span class="ln">3981</span><span class="cp"></span>
<span class="ln">3982</span><span class="cm">/*
</span><span class="ln">3983</span><span class="cm"> * sys_nice - change the priority of the current process.
</span><span class="ln">3984</span><span class="cm"> * @increment: priority increment
</span><span class="ln">3985</span><span class="cm"> *
</span><span class="ln">3986</span><span class="cm"> * sys_setpriority is a more generic, but much slower function that
</span><span class="ln">3987</span><span class="cm"> * does similar things.
</span><span class="ln">3988</span><span class="cm"> */</span>
<span class="ln">3989</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">nice</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
<span class="ln">3990</span><span class="p">{</span>
<span class="ln">3991</span>	<span class="kt">long</span> <span class="n">nice</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">3992</span>
<span class="ln">3993</span>	<span class="cm">/*
</span><span class="ln">3994</span><span class="cm">	 * Setpriority might change our priority at the same moment.
</span><span class="ln">3995</span><span class="cm">	 * We don&#39;t have to worry. Conceptually one call occurs first
</span><span class="ln">3996</span><span class="cm">	 * and we have a single winner.
</span><span class="ln">3997</span><span class="cm">	 */</span>
<span class="ln">3998</span>	<span class="n">increment</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">increment</span><span class="p">,</span> <span class="o">-</span><span class="n">NICE_WIDTH</span><span class="p">,</span> <span class="n">NICE_WIDTH</span><span class="p">);</span>
<span class="ln">3999</span>	<span class="n">nice</span> <span class="o">=</span> <span class="n">task_nice</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="n">increment</span><span class="p">;</span>
<span class="ln">4000</span>
<span class="ln">4001</span>	<span class="n">nice</span> <span class="o">=</span> <span class="n">clamp_val</span><span class="p">(</span><span class="n">nice</span><span class="p">,</span> <span class="n">MIN_NICE</span><span class="p">,</span> <span class="n">MAX_NICE</span><span class="p">);</span>
<span class="ln">4002</span>	<span class="k">if</span> <span class="p">(</span><span class="n">increment</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">can_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">nice</span><span class="p">))</span>
<span class="ln">4003</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4004</span>
<span class="ln">4005</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_setnice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
<span class="ln">4006</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4007</span>		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4008</span>
<span class="ln">4009</span>	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
<span class="ln">4010</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4011</span><span class="p">}</span>
<span class="ln">4012</span>
<span class="ln">4013</span><span class="cp">#endif
</span><span class="ln">4014</span><span class="cp"></span>
<span class="ln">4015</span><span class="cm">/**
</span><span class="ln">4016</span><span class="cm"> * task_prio - return the priority value of a given task.
</span><span class="ln">4017</span><span class="cm"> * @p: the task in question.
</span><span class="ln">4018</span><span class="cm"> *
</span><span class="ln">4019</span><span class="cm"> * Return: The priority value as seen by users in /proc.
</span><span class="ln">4020</span><span class="cm"> * RT tasks are offset by -200. Normal tasks are centered
</span><span class="ln">4021</span><span class="cm"> * around 0, value goes from -16 to +15.
</span><span class="ln">4022</span><span class="cm"> */</span>
<span class="ln">4023</span><span class="kt">int</span> <span class="n">task_prio</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">4024</span><span class="p">{</span>
<span class="ln">4025</span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">-</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
<span class="ln">4026</span><span class="p">}</span>
<span class="ln">4027</span>
<span class="ln">4028</span><span class="cm">/**
</span><span class="ln">4029</span><span class="cm"> * idle_cpu - is a given CPU idle currently?
</span><span class="ln">4030</span><span class="cm"> * @cpu: the processor in question.
</span><span class="ln">4031</span><span class="cm"> *
</span><span class="ln">4032</span><span class="cm"> * Return: 1 if the CPU is currently idle. 0 otherwise.
</span><span class="ln">4033</span><span class="cm"> */</span>
<span class="ln">4034</span><span class="kt">int</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">4035</span><span class="p">{</span>
<span class="ln">4036</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">4037</span>
<span class="ln">4038</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">)</span>
<span class="ln">4039</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4040</span>
<span class="ln">4041</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
<span class="ln">4042</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4043</span>
<span class="ln">4044</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">4045</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">wake_list</span><span class="p">))</span>
<span class="ln">4046</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4047</span><span class="cp">#endif
</span><span class="ln">4048</span><span class="cp"></span>
<span class="ln">4049</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">4050</span><span class="p">}</span>
<span class="ln">4051</span>
<span class="ln">4052</span><span class="cm">/**
</span><span class="ln">4053</span><span class="cm"> * available_idle_cpu - is a given CPU idle for enqueuing work.
</span><span class="ln">4054</span><span class="cm"> * @cpu: the CPU in question.
</span><span class="ln">4055</span><span class="cm"> *
</span><span class="ln">4056</span><span class="cm"> * Return: 1 if the CPU is currently idle. 0 otherwise.
</span><span class="ln">4057</span><span class="cm"> */</span>
<span class="ln">4058</span><span class="kt">int</span> <span class="n">available_idle_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">4059</span><span class="p">{</span>
<span class="ln">4060</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln">4061</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4062</span>
<span class="ln">4063</span>	<span class="k">if</span> <span class="p">(</span><span class="n">vcpu_is_preempted</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln">4064</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4065</span>
<span class="ln">4066</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">4067</span><span class="p">}</span>
<span class="ln">4068</span>
<span class="ln">4069</span><span class="cm">/**
</span><span class="ln">4070</span><span class="cm"> * idle_task - return the idle task for a given CPU.
</span><span class="ln">4071</span><span class="cm"> * @cpu: the processor in question.
</span><span class="ln">4072</span><span class="cm"> *
</span><span class="ln">4073</span><span class="cm"> * Return: The idle task for the CPU @cpu.
</span><span class="ln">4074</span><span class="cm"> */</span>
<span class="ln">4075</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">4076</span><span class="p">{</span>
<span class="ln">4077</span>	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">;</span>
<span class="ln">4078</span><span class="p">}</span>
<span class="ln">4079</span>
<span class="ln">4080</span><span class="cm">/**
</span><span class="ln">4081</span><span class="cm"> * find_process_by_pid - find a process with a matching PID value.
</span><span class="ln">4082</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4083</span><span class="cm"> *
</span><span class="ln">4084</span><span class="cm"> * The task of @pid, if found. %NULL otherwise.
</span><span class="ln">4085</span><span class="cm"> */</span>
<span class="ln">4086</span><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="ln">4087</span><span class="p">{</span>
<span class="ln">4088</span>	<span class="k">return</span> <span class="n">pid</span> <span class="o">?</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="o">:</span> <span class="n">current</span><span class="p">;</span>
<span class="ln">4089</span><span class="p">}</span>
<span class="ln">4090</span>
<span class="ln">4091</span><span class="cm">/*
</span><span class="ln">4092</span><span class="cm"> * sched_setparam() passes in -1 for its policy, to let the functions
</span><span class="ln">4093</span><span class="cm"> * it calls know not to change it.
</span><span class="ln">4094</span><span class="cm"> */</span>
<span class="ln">4095</span><span class="cp">#define SETPARAM_POLICY	-1
</span><span class="ln">4096</span><span class="cp"></span>
<span class="ln">4097</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__setscheduler_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">4098</span>		<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="ln">4099</span><span class="p">{</span>
<span class="ln">4100</span>	<span class="kt">int</span> <span class="n">policy</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_policy</span><span class="p">;</span>
<span class="ln">4101</span>
<span class="ln">4102</span>	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SETPARAM_POLICY</span><span class="p">)</span>
<span class="ln">4103</span>		<span class="n">policy</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
<span class="ln">4104</span>
<span class="ln">4105</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">policy</span><span class="p">;</span>
<span class="ln">4106</span>
<span class="ln">4107</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dl_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span>
<span class="ln">4108</span>		<span class="n">__setparam_dl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
<span class="ln">4109</span>	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">fair_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span>
<span class="ln">4110</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_nice</span><span class="p">);</span>
<span class="ln">4111</span>
<span class="ln">4112</span>	<span class="cm">/*
</span><span class="ln">4113</span><span class="cm">	 * __sched_setscheduler() ensures attr-&gt;sched_priority == 0 when
</span><span class="ln">4114</span><span class="cm">	 * !rt_policy. Always setting this ensures that things like
</span><span class="ln">4115</span><span class="cm">	 * getparam()/getattr() don&#39;t report silly values for !rt tasks.
</span><span class="ln">4116</span><span class="cm">	 */</span>
<span class="ln">4117</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span><span class="p">;</span>
<span class="ln">4118</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4119</span>	<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">4120</span><span class="p">}</span>
<span class="ln">4121</span>
<span class="ln">4122</span><span class="cm">/* Actually do priority change: must hold pi &amp; rq lock. */</span>
<span class="ln">4123</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">4124</span>			   <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">keep_boost</span><span class="p">)</span>
<span class="ln">4125</span><span class="p">{</span>
<span class="ln">4126</span>	<span class="n">__setscheduler_params</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
<span class="ln">4127</span>
<span class="ln">4128</span>	<span class="cm">/*
</span><span class="ln">4129</span><span class="cm">	 * Keep a potential priority boosting if called from
</span><span class="ln">4130</span><span class="cm">	 * sched_setscheduler().
</span><span class="ln">4131</span><span class="cm">	 */</span>
<span class="ln">4132</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4133</span>	<span class="k">if</span> <span class="p">(</span><span class="n">keep_boost</span><span class="p">)</span>
<span class="ln">4134</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">rt_effective_prio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
<span class="ln">4135</span>
<span class="ln">4136</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
<span class="ln">4137</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dl_sched_class</span><span class="p">;</span>
<span class="ln">4138</span>	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
<span class="ln">4139</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
<span class="ln">4140</span>	<span class="k">else</span>
<span class="ln">4141</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>
<span class="ln">4142</span><span class="p">}</span>
<span class="ln">4143</span>
<span class="ln">4144</span><span class="cm">/*
</span><span class="ln">4145</span><span class="cm"> * Check the target process has a UID that matches the current process&#39;s:
</span><span class="ln">4146</span><span class="cm"> */</span>
<span class="ln">4147</span><span class="k">static</span> <span class="kt">bool</span> <span class="n">check_same_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">4148</span><span class="p">{</span>
<span class="ln">4149</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">(),</span> <span class="o">*</span><span class="n">pcred</span><span class="p">;</span>
<span class="ln">4150</span>	<span class="kt">bool</span> <span class="n">match</span><span class="p">;</span>
<span class="ln">4151</span>
<span class="ln">4152</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4153</span>	<span class="n">pcred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4154</span>	<span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">4155</span>		 <span class="n">uid_eq</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">,</span> <span class="n">pcred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">));</span>
<span class="ln">4156</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4157</span>	<span class="k">return</span> <span class="n">match</span><span class="p">;</span>
<span class="ln">4158</span><span class="p">}</span>
<span class="ln">4159</span>
<span class="ln">4160</span><span class="k">static</span> <span class="kt">int</span> <span class="n">__sched_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">4161</span>				<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
<span class="ln">4162</span>				<span class="kt">bool</span> <span class="n">user</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pi</span><span class="p">)</span>
<span class="ln">4163</span><span class="p">{</span>
<span class="ln">4164</span>	<span class="kt">int</span> <span class="n">newprio</span> <span class="o">=</span> <span class="n">dl_policy</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_policy</span><span class="p">)</span> <span class="o">?</span> <span class="n">MAX_DL_PRIO</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span>
<span class="ln">4165</span>		      <span class="n">MAX_RT_PRIO</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span><span class="p">;</span>
<span class="ln">4166</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">,</span> <span class="n">oldpolicy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">queued</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
<span class="ln">4167</span>	<span class="kt">int</span> <span class="n">new_effective_prio</span><span class="p">,</span> <span class="n">policy</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_policy</span><span class="p">;</span>
<span class="ln">4168</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">prev_class</span><span class="p">;</span>
<span class="ln">4169</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">4170</span>	<span class="kt">int</span> <span class="n">reset_on_fork</span><span class="p">;</span>
<span class="ln">4171</span>	<span class="kt">int</span> <span class="n">queue_flags</span> <span class="o">=</span> <span class="n">DEQUEUE_SAVE</span> <span class="o">|</span> <span class="n">DEQUEUE_MOVE</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">;</span>
<span class="ln">4172</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">4173</span>
<span class="ln">4174</span>	<span class="cm">/* The pi code expects interrupts enabled */</span>
<span class="ln">4175</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pi</span> <span class="o">&amp;&amp;</span> <span class="n">in_interrupt</span><span class="p">());</span>
<span class="ln">4176</span><span class="nl">recheck</span><span class="p">:</span>
<span class="ln">4177</span>	<span class="cm">/* Double check policy once rq lock held: */</span>
<span class="ln">4178</span>	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4179</span>		<span class="n">reset_on_fork</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">;</span>
<span class="ln">4180</span>		<span class="n">policy</span> <span class="o">=</span> <span class="n">oldpolicy</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
<span class="ln">4181</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">4182</span>		<span class="n">reset_on_fork</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_flags</span> <span class="o">&amp;</span> <span class="n">SCHED_FLAG_RESET_ON_FORK</span><span class="p">);</span>
<span class="ln">4183</span>
<span class="ln">4184</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span>
<span class="ln">4185</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4186</span>	<span class="p">}</span>
<span class="ln">4187</span>
<span class="ln">4188</span>	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SCHED_FLAG_ALL</span> <span class="o">|</span> <span class="n">SCHED_FLAG_SUGOV</span><span class="p">))</span>
<span class="ln">4189</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4190</span>
<span class="ln">4191</span>	<span class="cm">/*
</span><span class="ln">4192</span><span class="cm">	 * Valid priorities for SCHED_FIFO and SCHED_RR are
</span><span class="ln">4193</span><span class="cm">	 * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,
</span><span class="ln">4194</span><span class="cm">	 * SCHED_BATCH and SCHED_IDLE is 0.
</span><span class="ln">4195</span><span class="cm">	 */</span>
<span class="ln">4196</span>	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">MAX_USER_RT_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">4197</span>	    <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">MAX_RT_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="ln">4198</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4199</span>	<span class="k">if</span> <span class="p">((</span><span class="n">dl_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">__checkparam_dl</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span> <span class="o">||</span>
<span class="ln">4200</span>	    <span class="p">(</span><span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>
<span class="ln">4201</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4202</span>
<span class="ln">4203</span>	<span class="cm">/*
</span><span class="ln">4204</span><span class="cm">	 * Allow unprivileged RT tasks to decrease priority:
</span><span class="ln">4205</span><span class="cm">	 */</span>
<span class="ln">4206</span>	<span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_NICE</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4207</span>		<span class="k">if</span> <span class="p">(</span><span class="n">fair_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4208</span>			<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_nice</span> <span class="o">&lt;</span> <span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">4209</span>			    <span class="o">!</span><span class="n">can_nice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_nice</span><span class="p">))</span>
<span class="ln">4210</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4211</span>		<span class="p">}</span>
<span class="ln">4212</span>
<span class="ln">4213</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4214</span>			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim_rtprio</span> <span class="o">=</span>
<span class="ln">4215</span>					<span class="n">task_rlimit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">RLIMIT_RTPRIO</span><span class="p">);</span>
<span class="ln">4216</span>
<span class="ln">4217</span>			<span class="cm">/* Can&#39;t set/change the rt policy: */</span>
<span class="ln">4218</span>			<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rlim_rtprio</span><span class="p">)</span>
<span class="ln">4219</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4220</span>
<span class="ln">4221</span>			<span class="cm">/* Can&#39;t increase priority: */</span>
<span class="ln">4222</span>			<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">&amp;&amp;</span>
<span class="ln">4223</span>			    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">&gt;</span> <span class="n">rlim_rtprio</span><span class="p">)</span>
<span class="ln">4224</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4225</span>		<span class="p">}</span>
<span class="ln">4226</span>
<span class="ln">4227</span>		 <span class="cm">/*
</span><span class="ln">4228</span><span class="cm">		  * Can&#39;t set/change SCHED_DEADLINE policy at all for now
</span><span class="ln">4229</span><span class="cm">		  * (safest behavior); in the future we would like to allow
</span><span class="ln">4230</span><span class="cm">		  * unprivileged DL tasks to increase their relative deadline
</span><span class="ln">4231</span><span class="cm">		  * or reduce their runtime (both ways reducing utilization)
</span><span class="ln">4232</span><span class="cm">		  */</span>
<span class="ln">4233</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dl_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span>
<span class="ln">4234</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4235</span>
<span class="ln">4236</span>		<span class="cm">/*
</span><span class="ln">4237</span><span class="cm">		 * Treat SCHED_IDLE as nice 20. Only allow a switch to
</span><span class="ln">4238</span><span class="cm">		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.
</span><span class="ln">4239</span><span class="cm">		 */</span>
<span class="ln">4240</span>		<span class="k">if</span> <span class="p">(</span><span class="n">idle_policy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">idle_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4241</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_nice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
<span class="ln">4242</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4243</span>		<span class="p">}</span>
<span class="ln">4244</span>
<span class="ln">4245</span>		<span class="cm">/* Can&#39;t change other user&#39;s priorities: */</span>
<span class="ln">4246</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_same_owner</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">4247</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4248</span>
<span class="ln">4249</span>		<span class="cm">/* Normal users shall not reset the sched_reset_on_fork flag: */</span>
<span class="ln">4250</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reset_on_fork</span><span class="p">)</span>
<span class="ln">4251</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4252</span>	<span class="p">}</span>
<span class="ln">4253</span>
<span class="ln">4254</span>	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4255</span>		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_flags</span> <span class="o">&amp;</span> <span class="n">SCHED_FLAG_SUGOV</span><span class="p">)</span>
<span class="ln">4256</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4257</span>
<span class="ln">4258</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4259</span>		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4260</span>			<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4261</span>	<span class="p">}</span>
<span class="ln">4262</span>
<span class="ln">4263</span>	<span class="cm">/*
</span><span class="ln">4264</span><span class="cm">	 * Make sure no PI-waiters arrive (or leave) while we are
</span><span class="ln">4265</span><span class="cm">	 * changing the priority of the task:
</span><span class="ln">4266</span><span class="cm">	 *
</span><span class="ln">4267</span><span class="cm">	 * To be able to change p-&gt;policy safely, the appropriate
</span><span class="ln">4268</span><span class="cm">	 * runqueue lock must be held.
</span><span class="ln">4269</span><span class="cm">	 */</span>
<span class="ln">4270</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4271</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">4272</span>
<span class="ln">4273</span>	<span class="cm">/*
</span><span class="ln">4274</span><span class="cm">	 * Changing the policy of the stop threads its a very bad idea:
</span><span class="ln">4275</span><span class="cm">	 */</span>
<span class="ln">4276</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4277</span>		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4278</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4279</span>	<span class="p">}</span>
<span class="ln">4280</span>
<span class="ln">4281</span>	<span class="cm">/*
</span><span class="ln">4282</span><span class="cm">	 * If not changing anything there&#39;s no need to proceed further,
</span><span class="ln">4283</span><span class="cm">	 * but store a possible modification of reset_on_fork.
</span><span class="ln">4284</span><span class="cm">	 */</span>
<span class="ln">4285</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">policy</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4286</span>		<span class="k">if</span> <span class="p">(</span><span class="n">fair_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_nice</span> <span class="o">!=</span> <span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">4287</span>			<span class="k">goto</span> <span class="n">change</span><span class="p">;</span>
<span class="ln">4288</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_priority</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">)</span>
<span class="ln">4289</span>			<span class="k">goto</span> <span class="n">change</span><span class="p">;</span>
<span class="ln">4290</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dl_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dl_param_changed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
<span class="ln">4291</span>			<span class="k">goto</span> <span class="n">change</span><span class="p">;</span>
<span class="ln">4292</span>
<span class="ln">4293</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">=</span> <span class="n">reset_on_fork</span><span class="p">;</span>
<span class="ln">4294</span>		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4295</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4296</span>	<span class="p">}</span>
<span class="ln">4297</span><span class="nl">change</span><span class="p">:</span>
<span class="ln">4298</span>
<span class="ln">4299</span>	<span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4300</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">4301</span><span class="cp"></span>		<span class="cm">/*
</span><span class="ln">4302</span><span class="cm">		 * Do not allow realtime tasks into groups that have no runtime
</span><span class="ln">4303</span><span class="cm">		 * assigned.
</span><span class="ln">4304</span><span class="cm">		 */</span>
<span class="ln">4305</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rt_bandwidth_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">rt_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">4306</span>				<span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="ln">4307</span>				<span class="o">!</span><span class="n">task_group_is_autogroup</span><span class="p">(</span><span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">4308</span>			<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4309</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4310</span>		<span class="p">}</span>
<span class="ln">4311</span><span class="cp">#endif
</span><span class="ln">4312</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">4313</span><span class="cp"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">dl_bandwidth_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dl_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln">4314</span>				<span class="o">!</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_flags</span> <span class="o">&amp;</span> <span class="n">SCHED_FLAG_SUGOV</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4315</span>			<span class="n">cpumask_t</span> <span class="o">*</span><span class="n">span</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">;</span>
<span class="ln">4316</span>
<span class="ln">4317</span>			<span class="cm">/*
</span><span class="ln">4318</span><span class="cm">			 * Don&#39;t allow tasks with an affinity mask smaller than
</span><span class="ln">4319</span><span class="cm">			 * the entire root_domain to become SCHED_DEADLINE. We
</span><span class="ln">4320</span><span class="cm">			 * will also fail if there&#39;s no bandwidth available.
</span><span class="ln">4321</span><span class="cm">			 */</span>
<span class="ln">4322</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">4323</span>			    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dl_bw</span><span class="p">.</span><span class="n">bw</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4324</span>				<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4325</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4326</span>			<span class="p">}</span>
<span class="ln">4327</span>		<span class="p">}</span>
<span class="ln">4328</span><span class="cp">#endif
</span><span class="ln">4329</span><span class="cp"></span>	<span class="p">}</span>
<span class="ln">4330</span>
<span class="ln">4331</span>	<span class="cm">/* Re-check policy now with rq lock held: */</span>
<span class="ln">4332</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">oldpolicy</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">oldpolicy</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4333</span>		<span class="n">policy</span> <span class="o">=</span> <span class="n">oldpolicy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln">4334</span>		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4335</span>		<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
<span class="ln">4336</span>	<span class="p">}</span>
<span class="ln">4337</span>
<span class="ln">4338</span>	<span class="cm">/*
</span><span class="ln">4339</span><span class="cm">	 * If setscheduling to SCHED_DEADLINE (or changing the parameters
</span><span class="ln">4340</span><span class="cm">	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth
</span><span class="ln">4341</span><span class="cm">	 * is available.
</span><span class="ln">4342</span><span class="cm">	 */</span>
<span class="ln">4343</span>	<span class="k">if</span> <span class="p">((</span><span class="n">dl_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="o">||</span> <span class="n">dl_task</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">sched_dl_overflow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4344</span>		<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4345</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="ln">4346</span>	<span class="p">}</span>
<span class="ln">4347</span>
<span class="ln">4348</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">=</span> <span class="n">reset_on_fork</span><span class="p">;</span>
<span class="ln">4349</span>	<span class="n">oldprio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
<span class="ln">4350</span>
<span class="ln">4351</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4352</span>		<span class="cm">/*
</span><span class="ln">4353</span><span class="cm">		 * Take priority boosted tasks into account. If the new
</span><span class="ln">4354</span><span class="cm">		 * effective priority is unchanged, we just store the new
</span><span class="ln">4355</span><span class="cm">		 * normal parameters and do not touch the scheduler class and
</span><span class="ln">4356</span><span class="cm">		 * the runqueue. This will be done when the task deboost
</span><span class="ln">4357</span><span class="cm">		 * itself.
</span><span class="ln">4358</span><span class="cm">		 */</span>
<span class="ln">4359</span>		<span class="n">new_effective_prio</span> <span class="o">=</span> <span class="n">rt_effective_prio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">newprio</span><span class="p">);</span>
<span class="ln">4360</span>		<span class="k">if</span> <span class="p">(</span><span class="n">new_effective_prio</span> <span class="o">==</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="ln">4361</span>			<span class="n">queue_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEQUEUE_MOVE</span><span class="p">;</span>
<span class="ln">4362</span>	<span class="p">}</span>
<span class="ln">4363</span>
<span class="ln">4364</span>	<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4365</span>	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">4366</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">4367</span>		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">queue_flags</span><span class="p">);</span>
<span class="ln">4368</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">4369</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">4370</span>
<span class="ln">4371</span>	<span class="n">prev_class</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
<span class="ln">4372</span>	<span class="n">__setscheduler</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">pi</span><span class="p">);</span>
<span class="ln">4373</span>
<span class="ln">4374</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4375</span>		<span class="cm">/*
</span><span class="ln">4376</span><span class="cm">		 * We enqueue to tail when the priority of a task is
</span><span class="ln">4377</span><span class="cm">		 * increased (user space view).
</span><span class="ln">4378</span><span class="cm">		 */</span>
<span class="ln">4379</span>		<span class="k">if</span> <span class="p">(</span><span class="n">oldprio</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
<span class="ln">4380</span>			<span class="n">queue_flags</span> <span class="o">|=</span> <span class="n">ENQUEUE_HEAD</span><span class="p">;</span>
<span class="ln">4381</span>
<span class="ln">4382</span>		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">queue_flags</span><span class="p">);</span>
<span class="ln">4383</span>	<span class="p">}</span>
<span class="ln">4384</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">4385</span>		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">4386</span>
<span class="ln">4387</span>	<span class="n">check_class_changed</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">prev_class</span><span class="p">,</span> <span class="n">oldprio</span><span class="p">);</span>
<span class="ln">4388</span>
<span class="ln">4389</span>	<span class="cm">/* Avoid rq from going away on us: */</span>
<span class="ln">4390</span>	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">4391</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4392</span>
<span class="ln">4393</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="ln">4394</span>		<span class="n">rt_mutex_adjust_pi</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4395</span>
<span class="ln">4396</span>	<span class="cm">/* Run balance callbacks after we&#39;ve adjusted the PI chain: */</span>
<span class="ln">4397</span>	<span class="n">balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">4398</span>	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="ln">4399</span>
<span class="ln">4400</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4401</span><span class="p">}</span>
<span class="ln">4402</span>
<span class="ln">4403</span><span class="k">static</span> <span class="kt">int</span> <span class="n">_sched_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
<span class="ln">4404</span>			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">check</span><span class="p">)</span>
<span class="ln">4405</span><span class="p">{</span>
<span class="ln">4406</span>	<span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">4407</span>		<span class="p">.</span><span class="n">sched_policy</span>   <span class="o">=</span> <span class="n">policy</span><span class="p">,</span>
<span class="ln">4408</span>		<span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">sched_priority</span><span class="p">,</span>
<span class="ln">4409</span>		<span class="p">.</span><span class="n">sched_nice</span>	<span class="o">=</span> <span class="n">PRIO_TO_NICE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">),</span>
<span class="ln">4410</span>	<span class="p">};</span>
<span class="ln">4411</span>
<span class="ln">4412</span>	<span class="cm">/* Fixup the legacy SCHED_RESET_ON_FORK hack. */</span>
<span class="ln">4413</span>	<span class="k">if</span> <span class="p">((</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SETPARAM_POLICY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&amp;</span> <span class="n">SCHED_RESET_ON_FORK</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4414</span>		<span class="n">attr</span><span class="p">.</span><span class="n">sched_flags</span> <span class="o">|=</span> <span class="n">SCHED_FLAG_RESET_ON_FORK</span><span class="p">;</span>
<span class="ln">4415</span>		<span class="n">policy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SCHED_RESET_ON_FORK</span><span class="p">;</span>
<span class="ln">4416</span>		<span class="n">attr</span><span class="p">.</span><span class="n">sched_policy</span> <span class="o">=</span> <span class="n">policy</span><span class="p">;</span>
<span class="ln">4417</span>	<span class="p">}</span>
<span class="ln">4418</span>
<span class="ln">4419</span>	<span class="k">return</span> <span class="n">__sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">check</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">4420</span><span class="p">}</span>
<span class="ln">4421</span><span class="cm">/**
</span><span class="ln">4422</span><span class="cm"> * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.
</span><span class="ln">4423</span><span class="cm"> * @p: the task in question.
</span><span class="ln">4424</span><span class="cm"> * @policy: new policy.
</span><span class="ln">4425</span><span class="cm"> * @param: structure containing the new RT priority.
</span><span class="ln">4426</span><span class="cm"> *
</span><span class="ln">4427</span><span class="cm"> * Return: 0 on success. An error code otherwise.
</span><span class="ln">4428</span><span class="cm"> *
</span><span class="ln">4429</span><span class="cm"> * NOTE that the task may be already dead.
</span><span class="ln">4430</span><span class="cm"> */</span>
<span class="ln">4431</span><span class="kt">int</span> <span class="n">sched_setscheduler</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
<span class="ln">4432</span>		       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="ln">4433</span><span class="p">{</span>
<span class="ln">4434</span>	<span class="k">return</span> <span class="n">_sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">4435</span><span class="p">}</span>
<span class="ln">4436</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">);</span>
<span class="ln">4437</span>
<span class="ln">4438</span><span class="kt">int</span> <span class="nf">sched_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="ln">4439</span><span class="p">{</span>
<span class="ln">4440</span>	<span class="k">return</span> <span class="n">__sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">4441</span><span class="p">}</span>
<span class="ln">4442</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_setattr</span><span class="p">);</span>
<span class="ln">4443</span>
<span class="ln">4444</span><span class="kt">int</span> <span class="nf">sched_setattr_nocheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="ln">4445</span><span class="p">{</span>
<span class="ln">4446</span>	<span class="k">return</span> <span class="n">__sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">4447</span><span class="p">}</span>
<span class="ln">4448</span>
<span class="ln">4449</span><span class="cm">/**
</span><span class="ln">4450</span><span class="cm"> * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.
</span><span class="ln">4451</span><span class="cm"> * @p: the task in question.
</span><span class="ln">4452</span><span class="cm"> * @policy: new policy.
</span><span class="ln">4453</span><span class="cm"> * @param: structure containing the new RT priority.
</span><span class="ln">4454</span><span class="cm"> *
</span><span class="ln">4455</span><span class="cm"> * Just like sched_setscheduler, only don&#39;t bother checking if the
</span><span class="ln">4456</span><span class="cm"> * current context has permission.  For example, this is needed in
</span><span class="ln">4457</span><span class="cm"> * stop_machine(): we create temporary high priority worker threads,
</span><span class="ln">4458</span><span class="cm"> * but our caller might not have that capability.
</span><span class="ln">4459</span><span class="cm"> *
</span><span class="ln">4460</span><span class="cm"> * Return: 0 on success. An error code otherwise.
</span><span class="ln">4461</span><span class="cm"> */</span>
<span class="ln">4462</span><span class="kt">int</span> <span class="nf">sched_setscheduler_nocheck</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span>
<span class="ln">4463</span>			       <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="ln">4464</span><span class="p">{</span>
<span class="ln">4465</span>	<span class="k">return</span> <span class="n">_sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln">4466</span><span class="p">}</span>
<span class="ln">4467</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_setscheduler_nocheck</span><span class="p">);</span>
<span class="ln">4468</span>
<span class="ln">4469</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln">4470</span><span class="nf">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="ln">4471</span><span class="p">{</span>
<span class="ln">4472</span>	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">lparam</span><span class="p">;</span>
<span class="ln">4473</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4474</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4475</span>
<span class="ln">4476</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">4477</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4478</span>	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lparam</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_param</span><span class="p">)))</span>
<span class="ln">4479</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln">4480</span>
<span class="ln">4481</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4482</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4483</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4484</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="ln">4485</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lparam</span><span class="p">);</span>
<span class="ln">4486</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4487</span>
<span class="ln">4488</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4489</span><span class="p">}</span>
<span class="ln">4490</span>
<span class="ln">4491</span><span class="cm">/*
</span><span class="ln">4492</span><span class="cm"> * Mimics kernel/events/core.c perf_copy_attr().
</span><span class="ln">4493</span><span class="cm"> */</span>
<span class="ln">4494</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_copy_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uattr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="ln">4495</span><span class="p">{</span>
<span class="ln">4496</span>	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
<span class="ln">4497</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">4498</span>
<span class="ln">4499</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span> <span class="n">SCHED_ATTR_SIZE_VER0</span><span class="p">))</span>
<span class="ln">4500</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln">4501</span>
<span class="ln">4502</span>	<span class="cm">/* Zero the full structure, so that a short copy will be nice: */</span>
<span class="ln">4503</span>	<span class="n">memset</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">));</span>
<span class="ln">4504</span>
<span class="ln">4505</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="ln">4506</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">4507</span>		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">4508</span>
<span class="ln">4509</span>	<span class="cm">/* Bail out on silly large: */</span>
<span class="ln">4510</span>	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
<span class="ln">4511</span>		<span class="k">goto</span> <span class="n">err_size</span><span class="p">;</span>
<span class="ln">4512</span>
<span class="ln">4513</span>	<span class="cm">/* ABI compatibility quirk: */</span>
<span class="ln">4514</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
<span class="ln">4515</span>		<span class="n">size</span> <span class="o">=</span> <span class="n">SCHED_ATTR_SIZE_VER0</span><span class="p">;</span>
<span class="ln">4516</span>
<span class="ln">4517</span>	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">SCHED_ATTR_SIZE_VER0</span><span class="p">)</span>
<span class="ln">4518</span>		<span class="k">goto</span> <span class="n">err_size</span><span class="p">;</span>
<span class="ln">4519</span>
<span class="ln">4520</span>	<span class="cm">/*
</span><span class="ln">4521</span><span class="cm">	 * If we&#39;re handed a bigger struct than we know of,
</span><span class="ln">4522</span><span class="cm">	 * ensure all the unknown bits are 0 - i.e. new
</span><span class="ln">4523</span><span class="cm">	 * user-space does not rely on any kernel feature
</span><span class="ln">4524</span><span class="cm">	 * extensions we dont know about yet.
</span><span class="ln">4525</span><span class="cm">	 */</span>
<span class="ln">4526</span>	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4527</span>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
<span class="ln">4528</span>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
<span class="ln">4529</span>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">;</span>
<span class="ln">4530</span>
<span class="ln">4531</span>		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uattr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="ln">4532</span>		<span class="n">end</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uattr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
<span class="ln">4533</span>
<span class="ln">4534</span>		<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4535</span>			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="ln">4536</span>			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">4537</span>				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">4538</span>			<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="ln">4539</span>				<span class="k">goto</span> <span class="n">err_size</span><span class="p">;</span>
<span class="ln">4540</span>		<span class="p">}</span>
<span class="ln">4541</span>		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="ln">4542</span>	<span class="p">}</span>
<span class="ln">4543</span>
<span class="ln">4544</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="ln">4545</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">4546</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln">4547</span>
<span class="ln">4548</span>	<span class="cm">/*
</span><span class="ln">4549</span><span class="cm">	 * XXX: Do we want to be lenient like existing syscalls; or do we want
</span><span class="ln">4550</span><span class="cm">	 * to be strict and return an error on out-of-bounds values?
</span><span class="ln">4551</span><span class="cm">	 */</span>
<span class="ln">4552</span>	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_nice</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">sched_nice</span><span class="p">,</span> <span class="n">MIN_NICE</span><span class="p">,</span> <span class="n">MAX_NICE</span><span class="p">);</span>
<span class="ln">4553</span>
<span class="ln">4554</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4555</span>
<span class="ln">4556</span><span class="nl">err_size</span><span class="p">:</span>
<span class="ln">4557</span>	<span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">uattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="ln">4558</span>	<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
<span class="ln">4559</span><span class="p">}</span>
<span class="ln">4560</span>
<span class="ln">4561</span><span class="cm">/**
</span><span class="ln">4562</span><span class="cm"> * sys_sched_setscheduler - set/change the scheduler policy and RT priority
</span><span class="ln">4563</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4564</span><span class="cm"> * @policy: new policy.
</span><span class="ln">4565</span><span class="cm"> * @param: structure containing the new RT priority.
</span><span class="ln">4566</span><span class="cm"> *
</span><span class="ln">4567</span><span class="cm"> * Return: 0 on success. An error code otherwise.
</span><span class="ln">4568</span><span class="cm"> */</span>
<span class="ln">4569</span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="ln">4570</span><span class="p">{</span>
<span class="ln">4571</span>	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">4572</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4573</span>
<span class="ln">4574</span>	<span class="k">return</span> <span class="nf">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
<span class="ln">4575</span><span class="p">}</span>
<span class="ln">4576</span>
<span class="ln">4577</span><span class="cm">/**
</span><span class="ln">4578</span><span class="cm"> * sys_sched_setparam - set/change the RT priority of a thread
</span><span class="ln">4579</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4580</span><span class="cm"> * @param: structure containing the new RT priority.
</span><span class="ln">4581</span><span class="cm"> *
</span><span class="ln">4582</span><span class="cm"> * Return: 0 on success. An error code otherwise.
</span><span class="ln">4583</span><span class="cm"> */</span>
<span class="ln">4584</span><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_setparam</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="ln">4585</span><span class="p">{</span>
<span class="ln">4586</span>	<span class="k">return</span> <span class="n">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">SETPARAM_POLICY</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
<span class="ln">4587</span><span class="p">}</span>
<span class="ln">4588</span>
<span class="ln">4589</span><span class="cm">/**
</span><span class="ln">4590</span><span class="cm"> * sys_sched_setattr - same as above, but with extended sched_attr
</span><span class="ln">4591</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4592</span><span class="cm"> * @uattr: structure containing the extended parameters.
</span><span class="ln">4593</span><span class="cm"> * @flags: for future extension.
</span><span class="ln">4594</span><span class="cm"> */</span>
<span class="ln">4595</span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_setattr</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span>
<span class="ln">4596</span>			       <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln">4597</span><span class="p">{</span>
<span class="ln">4598</span>	<span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">attr</span><span class="p">;</span>
<span class="ln">4599</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4600</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4601</span>
<span class="ln">4602</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uattr</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln">4603</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4604</span>
<span class="ln">4605</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_copy_attr</span><span class="p">(</span><span class="n">uattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="ln">4606</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4607</span>		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4608</span>
<span class="ln">4609</span>	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">attr</span><span class="p">.</span><span class="n">sched_policy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">4610</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4611</span>
<span class="ln">4612</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4613</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4614</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4615</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="ln">4616</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_setattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="ln">4617</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4618</span>
<span class="ln">4619</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4620</span><span class="p">}</span>
<span class="ln">4621</span>
<span class="ln">4622</span><span class="cm">/**
</span><span class="ln">4623</span><span class="cm"> * sys_sched_getscheduler - get the policy (scheduling class) of a thread
</span><span class="ln">4624</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4625</span><span class="cm"> *
</span><span class="ln">4626</span><span class="cm"> * Return: On success, the policy of the thread. Otherwise, a negative error
</span><span class="ln">4627</span><span class="cm"> * code.
</span><span class="ln">4628</span><span class="cm"> */</span>
<span class="ln">4629</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sched_getscheduler</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>
<span class="ln">4630</span><span class="p">{</span>
<span class="ln">4631</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4632</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4633</span>
<span class="ln">4634</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">4635</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4636</span>
<span class="ln">4637</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4638</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4639</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4640</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4641</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4642</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4643</span>			<span class="n">retval</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span>
<span class="ln">4644</span>				<span class="o">|</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">?</span> <span class="nl">SCHED_RESET_ON_FORK</span> <span class="p">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">4645</span>	<span class="p">}</span>
<span class="ln">4646</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4647</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4648</span><span class="p">}</span>
<span class="ln">4649</span>
<span class="ln">4650</span><span class="cm">/**
</span><span class="ln">4651</span><span class="cm"> * sys_sched_getparam - get the RT priority of a thread
</span><span class="ln">4652</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4653</span><span class="cm"> * @param: structure containing the RT priority.
</span><span class="ln">4654</span><span class="cm"> *
</span><span class="ln">4655</span><span class="cm"> * Return: On success, 0 and the RT priority is in @param. Otherwise, an error
</span><span class="ln">4656</span><span class="cm"> * code.
</span><span class="ln">4657</span><span class="cm"> */</span>
<span class="ln">4658</span><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_getparam</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="ln">4659</span><span class="p">{</span>
<span class="ln">4660</span>	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">lp</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="ln">4661</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4662</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4663</span>
<span class="ln">4664</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">4665</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4666</span>
<span class="ln">4667</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4668</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4669</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4670</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
<span class="ln">4671</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">4672</span>
<span class="ln">4673</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4674</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4675</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">4676</span>
<span class="ln">4677</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">4678</span>		<span class="n">lp</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">;</span>
<span class="ln">4679</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4680</span>
<span class="ln">4681</span>	<span class="cm">/*
</span><span class="ln">4682</span><span class="cm">	 * This one might sleep, we cannot do it with a spinlock held ...
</span><span class="ln">4683</span><span class="cm">	 */</span>
<span class="ln">4684</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="nl">EFAULT</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4685</span>
<span class="ln">4686</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4687</span>
<span class="ln">4688</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">4689</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4690</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4691</span><span class="p">}</span>
<span class="ln">4692</span>
<span class="ln">4693</span><span class="k">static</span> <span class="kt">int</span> <span class="n">sched_read_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uattr</span><span class="p">,</span>
<span class="ln">4694</span>			   <span class="k">struct</span> <span class="n">sched_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
<span class="ln">4695</span>			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">usize</span><span class="p">)</span>
<span class="ln">4696</span><span class="p">{</span>
<span class="ln">4697</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">4698</span>
<span class="ln">4699</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span> <span class="n">usize</span><span class="p">))</span>
<span class="ln">4700</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln">4701</span>
<span class="ln">4702</span>	<span class="cm">/*
</span><span class="ln">4703</span><span class="cm">	 * If we&#39;re handed a smaller struct than we know of,
</span><span class="ln">4704</span><span class="cm">	 * ensure all the unknown bits are 0 - i.e. old
</span><span class="ln">4705</span><span class="cm">	 * user-space does not get uncomplete information.
</span><span class="ln">4706</span><span class="cm">	 */</span>
<span class="ln">4707</span>	<span class="k">if</span> <span class="p">(</span><span class="n">usize</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4708</span>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
<span class="ln">4709</span>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
<span class="ln">4710</span>
<span class="ln">4711</span>		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">attr</span> <span class="o">+</span> <span class="n">usize</span><span class="p">;</span>
<span class="ln">4712</span>		<span class="n">end</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">attr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="ln">4713</span>
<span class="ln">4714</span>		<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4715</span>			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="ln">4716</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
<span class="ln">4717</span>		<span class="p">}</span>
<span class="ln">4718</span>
<span class="ln">4719</span>		<span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">usize</span><span class="p">;</span>
<span class="ln">4720</span>	<span class="p">}</span>
<span class="ln">4721</span>
<span class="ln">4722</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">uattr</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="ln">4723</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">4724</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln">4725</span>
<span class="ln">4726</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4727</span><span class="p">}</span>
<span class="ln">4728</span>
<span class="ln">4729</span><span class="cm">/**
</span><span class="ln">4730</span><span class="cm"> * sys_sched_getattr - similar to sched_getparam, but with sched_attr
</span><span class="ln">4731</span><span class="cm"> * @pid: the pid in question.
</span><span class="ln">4732</span><span class="cm"> * @uattr: structure containing the extended parameters.
</span><span class="ln">4733</span><span class="cm"> * @size: sizeof(attr) for fwd/bwd comp.
</span><span class="ln">4734</span><span class="cm"> * @flags: for future extension.
</span><span class="ln">4735</span><span class="cm"> */</span>
<span class="ln">4736</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">sched_getattr</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uattr</span><span class="p">,</span>
<span class="ln">4737</span>		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln">4738</span><span class="p">{</span>
<span class="ln">4739</span>	<span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">4740</span>		<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_attr</span><span class="p">),</span>
<span class="ln">4741</span>	<span class="p">};</span>
<span class="ln">4742</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4743</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4744</span>
<span class="ln">4745</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uattr</span> <span class="o">||</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">||</span>
<span class="ln">4746</span>	    <span class="n">size</span> <span class="o">&lt;</span> <span class="n">SCHED_ATTR_SIZE_VER0</span> <span class="o">||</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln">4747</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4748</span>
<span class="ln">4749</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4750</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4751</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4752</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
<span class="ln">4753</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">4754</span>
<span class="ln">4755</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4756</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4757</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">4758</span>
<span class="ln">4759</span>	<span class="n">attr</span><span class="p">.</span><span class="n">sched_policy</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span><span class="p">;</span>
<span class="ln">4760</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">)</span>
<span class="ln">4761</span>		<span class="n">attr</span><span class="p">.</span><span class="n">sched_flags</span> <span class="o">|=</span> <span class="n">SCHED_FLAG_RESET_ON_FORK</span><span class="p">;</span>
<span class="ln">4762</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_dl_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">4763</span>		<span class="n">__getparam_dl</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="ln">4764</span>	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">4765</span>		<span class="n">attr</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span><span class="p">;</span>
<span class="ln">4766</span>	<span class="k">else</span>
<span class="ln">4767</span>		<span class="n">attr</span><span class="p">.</span><span class="n">sched_nice</span> <span class="o">=</span> <span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4768</span>
<span class="ln">4769</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4770</span>
<span class="ln">4771</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_read_attr</span><span class="p">(</span><span class="n">uattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="ln">4772</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4773</span>
<span class="ln">4774</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">4775</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4776</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4777</span><span class="p">}</span>
<span class="ln">4778</span>
<span class="ln">4779</span><span class="kt">long</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">in_mask</span><span class="p">)</span>
<span class="ln">4780</span><span class="p">{</span>
<span class="ln">4781</span>	<span class="n">cpumask_var_t</span> <span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">;</span>
<span class="ln">4782</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4783</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4784</span>
<span class="ln">4785</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4786</span>
<span class="ln">4787</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4788</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4789</span>		<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4790</span>		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4791</span>	<span class="p">}</span>
<span class="ln">4792</span>
<span class="ln">4793</span>	<span class="cm">/* Prevent p going away */</span>
<span class="ln">4794</span>	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4795</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4796</span>
<span class="ln">4797</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_NO_SETAFFINITY</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4798</span>		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4799</span>		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
<span class="ln">4800</span>	<span class="p">}</span>
<span class="ln">4801</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4802</span>		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="ln">4803</span>		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
<span class="ln">4804</span>	<span class="p">}</span>
<span class="ln">4805</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4806</span>		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="ln">4807</span>		<span class="k">goto</span> <span class="n">out_free_cpus_allowed</span><span class="p">;</span>
<span class="ln">4808</span>	<span class="p">}</span>
<span class="ln">4809</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="ln">4810</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_same_owner</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4811</span>		<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4812</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns_capable</span><span class="p">(</span><span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">CAP_SYS_NICE</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4813</span>			<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4814</span>			<span class="k">goto</span> <span class="n">out_free_new_mask</span><span class="p">;</span>
<span class="ln">4815</span>		<span class="p">}</span>
<span class="ln">4816</span>		<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4817</span>	<span class="p">}</span>
<span class="ln">4818</span>
<span class="ln">4819</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4820</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4821</span>		<span class="k">goto</span> <span class="n">out_free_new_mask</span><span class="p">;</span>
<span class="ln">4822</span>
<span class="ln">4823</span>
<span class="ln">4824</span>	<span class="n">cpuset_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln">4825</span>	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">in_mask</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln">4826</span>
<span class="ln">4827</span>	<span class="cm">/*
</span><span class="ln">4828</span><span class="cm">	 * Since bandwidth control happens on root_domain basis,
</span><span class="ln">4829</span><span class="cm">	 * if admission test is enabled, we only admit -deadline
</span><span class="ln">4830</span><span class="cm">	 * tasks allowed to run on all the CPUs in the task&#39;s
</span><span class="ln">4831</span><span class="cm">	 * root_domain.
</span><span class="ln">4832</span><span class="cm">	 */</span>
<span class="ln">4833</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">4834</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_has_dl_policy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dl_bandwidth_enabled</span><span class="p">())</span> <span class="p">{</span>
<span class="ln">4835</span>		<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4836</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4837</span>			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="ln">4838</span>			<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4839</span>			<span class="k">goto</span> <span class="n">out_free_new_mask</span><span class="p">;</span>
<span class="ln">4840</span>		<span class="p">}</span>
<span class="ln">4841</span>		<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4842</span>	<span class="p">}</span>
<span class="ln">4843</span><span class="cp">#endif
</span><span class="ln">4844</span><span class="cp"></span><span class="nl">again</span><span class="p">:</span>
<span class="ln">4845</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">__set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">4846</span>
<span class="ln">4847</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4848</span>		<span class="n">cpuset_cpus_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln">4849</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">4850</span>			<span class="cm">/*
</span><span class="ln">4851</span><span class="cm">			 * We must have raced with a concurrent cpuset
</span><span class="ln">4852</span><span class="cm">			 * update. Just reset the cpus_allowed to the
</span><span class="ln">4853</span><span class="cm">			 * cpuset&#39;s cpus_allowed
</span><span class="ln">4854</span><span class="cm">			 */</span>
<span class="ln">4855</span>			<span class="n">cpumask_copy</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln">4856</span>			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="ln">4857</span>		<span class="p">}</span>
<span class="ln">4858</span>	<span class="p">}</span>
<span class="ln">4859</span><span class="nl">out_free_new_mask</span><span class="p">:</span>
<span class="ln">4860</span>	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
<span class="ln">4861</span><span class="nl">out_free_cpus_allowed</span><span class="p">:</span>
<span class="ln">4862</span>	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln">4863</span><span class="nl">out_put_task</span><span class="p">:</span>
<span class="ln">4864</span>	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4865</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4866</span><span class="p">}</span>
<span class="ln">4867</span>
<span class="ln">4868</span><span class="k">static</span> <span class="kt">int</span> <span class="n">get_user_cpu_mask</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_mask_ptr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
<span class="ln">4869</span>			     <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">new_mask</span><span class="p">)</span>
<span class="ln">4870</span><span class="p">{</span>
<span class="ln">4871</span>	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">cpumask_size</span><span class="p">())</span>
<span class="ln">4872</span>		<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
<span class="ln">4873</span>	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">cpumask_size</span><span class="p">())</span>
<span class="ln">4874</span>		<span class="n">len</span> <span class="o">=</span> <span class="n">cpumask_size</span><span class="p">();</span>
<span class="ln">4875</span>
<span class="ln">4876</span>	<span class="k">return</span> <span class="nf">copy_from_user</span><span class="p">(</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">user_mask_ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="nl">EFAULT</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4877</span><span class="p">}</span>
<span class="ln">4878</span>
<span class="ln">4879</span><span class="cm">/**
</span><span class="ln">4880</span><span class="cm"> * sys_sched_setaffinity - set the CPU affinity of a process
</span><span class="ln">4881</span><span class="cm"> * @pid: pid of the process
</span><span class="ln">4882</span><span class="cm"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr
</span><span class="ln">4883</span><span class="cm"> * @user_mask_ptr: user-space pointer to the new CPU mask
</span><span class="ln">4884</span><span class="cm"> *
</span><span class="ln">4885</span><span class="cm"> * Return: 0 on success. An error code otherwise.
</span><span class="ln">4886</span><span class="cm"> */</span>
<span class="ln">4887</span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_setaffinity</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
<span class="ln">4888</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">user_mask_ptr</span><span class="p">)</span>
<span class="ln">4889</span><span class="p">{</span>
<span class="ln">4890</span>	<span class="n">cpumask_var_t</span> <span class="n">new_mask</span><span class="p">;</span>
<span class="ln">4891</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4892</span>
<span class="ln">4893</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
<span class="ln">4894</span>		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="ln">4895</span>
<span class="ln">4896</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">get_user_cpu_mask</span><span class="p">(</span><span class="n">user_mask_ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">4897</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">4898</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>
<span class="ln">4899</span>	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">new_mask</span><span class="p">);</span>
<span class="ln">4900</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4901</span><span class="p">}</span>
<span class="ln">4902</span>
<span class="ln">4903</span><span class="kt">long</span> <span class="n">sched_getaffinity</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="ln">4904</span><span class="p">{</span>
<span class="ln">4905</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">4906</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">4907</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4908</span>
<span class="ln">4909</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">4910</span>
<span class="ln">4911</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">4912</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">4913</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
<span class="ln">4914</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">4915</span>
<span class="ln">4916</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">4917</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">4918</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">4919</span>
<span class="ln">4920</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">4921</span>	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">,</span> <span class="n">cpu_active_mask</span><span class="p">);</span>
<span class="ln">4922</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">4923</span>
<span class="ln">4924</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">4925</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">4926</span>
<span class="ln">4927</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">4928</span><span class="p">}</span>
<span class="ln">4929</span>
<span class="ln">4930</span><span class="cm">/**
</span><span class="ln">4931</span><span class="cm"> * sys_sched_getaffinity - get the CPU affinity of a process
</span><span class="ln">4932</span><span class="cm"> * @pid: pid of the process
</span><span class="ln">4933</span><span class="cm"> * @len: length in bytes of the bitmask pointed to by user_mask_ptr
</span><span class="ln">4934</span><span class="cm"> * @user_mask_ptr: user-space pointer to hold the current CPU mask
</span><span class="ln">4935</span><span class="cm"> *
</span><span class="ln">4936</span><span class="cm"> * Return: size of CPU mask copied to user_mask_ptr on success. An
</span><span class="ln">4937</span><span class="cm"> * error code otherwise.
</span><span class="ln">4938</span><span class="cm"> */</span>
<span class="ln">4939</span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sched_getaffinity</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
<span class="ln">4940</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">user_mask_ptr</span><span class="p">)</span>
<span class="ln">4941</span><span class="p">{</span>
<span class="ln">4942</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">4943</span>	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>
<span class="ln">4944</span>
<span class="ln">4945</span>	<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">*</span> <span class="n">BITS_PER_BYTE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
<span class="ln">4946</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4947</span>	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="ln">4948</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">4949</span>
<span class="ln">4950</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
<span class="ln">4951</span>		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="ln">4952</span>
<span class="ln">4953</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">sched_getaffinity</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="ln">4954</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">4955</span>		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">cpumask_size</span><span class="p">());</span>
<span class="ln">4956</span>
<span class="ln">4957</span>		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_mask_ptr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">retlen</span><span class="p">))</span>
<span class="ln">4958</span>			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="ln">4959</span>		<span class="k">else</span>
<span class="ln">4960</span>			<span class="n">ret</span> <span class="o">=</span> <span class="n">retlen</span><span class="p">;</span>
<span class="ln">4961</span>	<span class="p">}</span>
<span class="ln">4962</span>	<span class="n">free_cpumask_var</span><span class="p">(</span><span class="n">mask</span><span class="p">);</span>
<span class="ln">4963</span>
<span class="ln">4964</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">4965</span><span class="p">}</span>
<span class="ln">4966</span>
<span class="ln">4967</span><span class="cm">/**
</span><span class="ln">4968</span><span class="cm"> * sys_sched_yield - yield the current processor to other threads.
</span><span class="ln">4969</span><span class="cm"> *
</span><span class="ln">4970</span><span class="cm"> * This function yields the current CPU to other tasks. If there are no
</span><span class="ln">4971</span><span class="cm"> * other threads running on this CPU then this function will return.
</span><span class="ln">4972</span><span class="cm"> *
</span><span class="ln">4973</span><span class="cm"> * Return: 0.
</span><span class="ln">4974</span><span class="cm"> */</span>
<span class="ln">4975</span><span class="k">static</span> <span class="kt">void</span> <span class="n">do_sched_yield</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">4976</span><span class="p">{</span>
<span class="ln">4977</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">4978</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">4979</span>
<span class="ln">4980</span>	<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="ln">4981</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln">4982</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4983</span>
<span class="ln">4984</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">yld_count</span><span class="p">);</span>
<span class="ln">4985</span>	<span class="n">current</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">yield_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">4986</span>
<span class="ln">4987</span>	<span class="n">preempt_disable</span><span class="p">();</span>
<span class="ln">4988</span>	<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">4989</span>	<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
<span class="ln">4990</span>
<span class="ln">4991</span>	<span class="n">schedule</span><span class="p">();</span>
<span class="ln">4992</span><span class="p">}</span>
<span class="ln">4993</span>
<span class="ln">4994</span><span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sched_yield</span><span class="p">)</span>
<span class="ln">4995</span><span class="p">{</span>
<span class="ln">4996</span>	<span class="n">do_sched_yield</span><span class="p">();</span>
<span class="ln">4997</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">4998</span><span class="p">}</span>
<span class="ln">4999</span>
<span class="ln">5000</span><span class="cp">#ifndef CONFIG_PREEMPT
</span><span class="ln">5001</span><span class="cp"></span><span class="kt">int</span> <span class="n">__sched</span> <span class="n">_cond_resched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5002</span><span class="p">{</span>
<span class="ln">5003</span>	<span class="k">if</span> <span class="p">(</span><span class="n">should_resched</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">5004</span>		<span class="n">preempt_schedule_common</span><span class="p">();</span>
<span class="ln">5005</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5006</span>	<span class="p">}</span>
<span class="ln">5007</span>	<span class="n">rcu_all_qs</span><span class="p">();</span>
<span class="ln">5008</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5009</span><span class="p">}</span>
<span class="ln">5010</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_cond_resched</span><span class="p">);</span>
<span class="ln">5011</span><span class="cp">#endif
</span><span class="ln">5012</span><span class="cp"></span>
<span class="ln">5013</span><span class="cm">/*
</span><span class="ln">5014</span><span class="cm"> * __cond_resched_lock() - if a reschedule is pending, drop the given lock,
</span><span class="ln">5015</span><span class="cm"> * call schedule, and on return reacquire the lock.
</span><span class="ln">5016</span><span class="cm"> *
</span><span class="ln">5017</span><span class="cm"> * This works OK both with and without CONFIG_PREEMPT. We do strange low-level
</span><span class="ln">5018</span><span class="cm"> * operations here to prevent schedule() from being called twice (once via
</span><span class="ln">5019</span><span class="cm"> * spin_unlock(), once by hand).
</span><span class="ln">5020</span><span class="cm"> */</span>
<span class="ln">5021</span><span class="kt">int</span> <span class="nf">__cond_resched_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="ln">5022</span><span class="p">{</span>
<span class="ln">5023</span>	<span class="kt">int</span> <span class="n">resched</span> <span class="o">=</span> <span class="n">should_resched</span><span class="p">(</span><span class="n">PREEMPT_LOCK_OFFSET</span><span class="p">);</span>
<span class="ln">5024</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5025</span>
<span class="ln">5026</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">5027</span>
<span class="ln">5028</span>	<span class="k">if</span> <span class="p">(</span><span class="n">spin_needbreak</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="o">||</span> <span class="n">resched</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5029</span>		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">5030</span>		<span class="k">if</span> <span class="p">(</span><span class="n">resched</span><span class="p">)</span>
<span class="ln">5031</span>			<span class="n">preempt_schedule_common</span><span class="p">();</span>
<span class="ln">5032</span>		<span class="k">else</span>
<span class="ln">5033</span>			<span class="n">cpu_relax</span><span class="p">();</span>
<span class="ln">5034</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5035</span>		<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">5036</span>	<span class="p">}</span>
<span class="ln">5037</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5038</span><span class="p">}</span>
<span class="ln">5039</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__cond_resched_lock</span><span class="p">);</span>
<span class="ln">5040</span>
<span class="ln">5041</span><span class="cm">/**
</span><span class="ln">5042</span><span class="cm"> * yield - yield the current processor to other threads.
</span><span class="ln">5043</span><span class="cm"> *
</span><span class="ln">5044</span><span class="cm"> * Do not ever use this function, there&#39;s a 99% chance you&#39;re doing it wrong.
</span><span class="ln">5045</span><span class="cm"> *
</span><span class="ln">5046</span><span class="cm"> * The scheduler is at all times free to pick the calling task as the most
</span><span class="ln">5047</span><span class="cm"> * eligible task to run, if removing the yield() call from your code breaks
</span><span class="ln">5048</span><span class="cm"> * it, its already broken.
</span><span class="ln">5049</span><span class="cm"> *
</span><span class="ln">5050</span><span class="cm"> * Typical broken usage is:
</span><span class="ln">5051</span><span class="cm"> *
</span><span class="ln">5052</span><span class="cm"> * while (!event)
</span><span class="ln">5053</span><span class="cm"> *	yield();
</span><span class="ln">5054</span><span class="cm"> *
</span><span class="ln">5055</span><span class="cm"> * where one assumes that yield() will let &#39;the other&#39; process run that will
</span><span class="ln">5056</span><span class="cm"> * make event true. If the current task is a SCHED_FIFO task that will never
</span><span class="ln">5057</span><span class="cm"> * happen. Never use yield() as a progress guarantee!!
</span><span class="ln">5058</span><span class="cm"> *
</span><span class="ln">5059</span><span class="cm"> * If you want to use yield() to wait for something, use wait_event().
</span><span class="ln">5060</span><span class="cm"> * If you want to use yield() to be &#39;nice&#39; for others, use cond_resched().
</span><span class="ln">5061</span><span class="cm"> * If you still want to use yield(), do not!
</span><span class="ln">5062</span><span class="cm"> */</span>
<span class="ln">5063</span><span class="kt">void</span> <span class="n">__sched</span> <span class="nf">yield</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5064</span><span class="p">{</span>
<span class="ln">5065</span>	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
<span class="ln">5066</span>	<span class="n">do_sched_yield</span><span class="p">();</span>
<span class="ln">5067</span><span class="p">}</span>
<span class="ln">5068</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">yield</span><span class="p">);</span>
<span class="ln">5069</span>
<span class="ln">5070</span><span class="cm">/**
</span><span class="ln">5071</span><span class="cm"> * yield_to - yield the current processor to another thread in
</span><span class="ln">5072</span><span class="cm"> * your thread group, or accelerate that thread toward the
</span><span class="ln">5073</span><span class="cm"> * processor it&#39;s on.
</span><span class="ln">5074</span><span class="cm"> * @p: target task
</span><span class="ln">5075</span><span class="cm"> * @preempt: whether task preemption is allowed or not
</span><span class="ln">5076</span><span class="cm"> *
</span><span class="ln">5077</span><span class="cm"> * It&#39;s the caller&#39;s job to ensure that the target task struct
</span><span class="ln">5078</span><span class="cm"> * can&#39;t go away on us before we can do any checks.
</span><span class="ln">5079</span><span class="cm"> *
</span><span class="ln">5080</span><span class="cm"> * Return:
</span><span class="ln">5081</span><span class="cm"> *	true (&gt;0) if we indeed boosted the target task.
</span><span class="ln">5082</span><span class="cm"> *	false (0) if we failed to boost the target.
</span><span class="ln">5083</span><span class="cm"> *	-ESRCH if there&#39;s no task to yield to.
</span><span class="ln">5084</span><span class="cm"> */</span>
<span class="ln">5085</span><span class="kt">int</span> <span class="n">__sched</span> <span class="nf">yield_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="ln">5086</span><span class="p">{</span>
<span class="ln">5087</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="ln">5088</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="o">*</span><span class="n">p_rq</span><span class="p">;</span>
<span class="ln">5089</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">5090</span>	<span class="kt">int</span> <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5091</span>
<span class="ln">5092</span>	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="ln">5093</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln">5094</span>
<span class="ln">5095</span><span class="nl">again</span><span class="p">:</span>
<span class="ln">5096</span>	<span class="n">p_rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5097</span>	<span class="cm">/*
</span><span class="ln">5098</span><span class="cm">	 * If we&#39;re the only runnable task on the rq and target rq also
</span><span class="ln">5099</span><span class="cm">	 * has only one task, there&#39;s absolutely no point in yielding.
</span><span class="ln">5100</span><span class="cm">	 */</span>
<span class="ln">5101</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">p_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5102</span>		<span class="n">yielded</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">5103</span>		<span class="k">goto</span> <span class="n">out_irq</span><span class="p">;</span>
<span class="ln">5104</span>	<span class="p">}</span>
<span class="ln">5105</span>
<span class="ln">5106</span>	<span class="n">double_rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p_rq</span><span class="p">);</span>
<span class="ln">5107</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">p_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5108</span>		<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p_rq</span><span class="p">);</span>
<span class="ln">5109</span>		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="ln">5110</span>	<span class="p">}</span>
<span class="ln">5111</span>
<span class="ln">5112</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">yield_to_task</span><span class="p">)</span>
<span class="ln">5113</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">5114</span>
<span class="ln">5115</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">)</span>
<span class="ln">5116</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">5117</span>
<span class="ln">5118</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">p_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
<span class="ln">5119</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">5120</span>
<span class="ln">5121</span>	<span class="n">yielded</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">yield_to_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">preempt</span><span class="p">);</span>
<span class="ln">5122</span>	<span class="k">if</span> <span class="p">(</span><span class="n">yielded</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5123</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">yld_count</span><span class="p">);</span>
<span class="ln">5124</span>		<span class="cm">/*
</span><span class="ln">5125</span><span class="cm">		 * Make p&#39;s CPU reschedule; pick_next_entity takes care of
</span><span class="ln">5126</span><span class="cm">		 * fairness.
</span><span class="ln">5127</span><span class="cm">		 */</span>
<span class="ln">5128</span>		<span class="k">if</span> <span class="p">(</span><span class="n">preempt</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span> <span class="o">!=</span> <span class="n">p_rq</span><span class="p">)</span>
<span class="ln">5129</span>			<span class="n">resched_curr</span><span class="p">(</span><span class="n">p_rq</span><span class="p">);</span>
<span class="ln">5130</span>	<span class="p">}</span>
<span class="ln">5131</span>
<span class="ln">5132</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">5133</span>	<span class="n">double_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p_rq</span><span class="p">);</span>
<span class="ln">5134</span><span class="nl">out_irq</span><span class="p">:</span>
<span class="ln">5135</span>	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="ln">5136</span>
<span class="ln">5137</span>	<span class="k">if</span> <span class="p">(</span><span class="n">yielded</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">5138</span>		<span class="n">schedule</span><span class="p">();</span>
<span class="ln">5139</span>
<span class="ln">5140</span>	<span class="k">return</span> <span class="n">yielded</span><span class="p">;</span>
<span class="ln">5141</span><span class="p">}</span>
<span class="ln">5142</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">yield_to</span><span class="p">);</span>
<span class="ln">5143</span>
<span class="ln">5144</span><span class="kt">int</span> <span class="nf">io_schedule_prepare</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5145</span><span class="p">{</span>
<span class="ln">5146</span>	<span class="kt">int</span> <span class="n">old_iowait</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">;</span>
<span class="ln">5147</span>
<span class="ln">5148</span>	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5149</span>	<span class="n">blk_schedule_flush_plug</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">5150</span>
<span class="ln">5151</span>	<span class="k">return</span> <span class="n">old_iowait</span><span class="p">;</span>
<span class="ln">5152</span><span class="p">}</span>
<span class="ln">5153</span>
<span class="ln">5154</span><span class="kt">void</span> <span class="nf">io_schedule_finish</span><span class="p">(</span><span class="kt">int</span> <span class="n">token</span><span class="p">)</span>
<span class="ln">5155</span><span class="p">{</span>
<span class="ln">5156</span>	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_iowait</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>
<span class="ln">5157</span><span class="p">}</span>
<span class="ln">5158</span>
<span class="ln">5159</span><span class="cm">/*
</span><span class="ln">5160</span><span class="cm"> * This task is about to go to sleep on IO. Increment rq-&gt;nr_iowait so
</span><span class="ln">5161</span><span class="cm"> * that process accounting knows that this is a task in IO wait state.
</span><span class="ln">5162</span><span class="cm"> */</span>
<span class="ln">5163</span><span class="kt">long</span> <span class="n">__sched</span> <span class="nf">io_schedule_timeout</span><span class="p">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="ln">5164</span><span class="p">{</span>
<span class="ln">5165</span>	<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>
<span class="ln">5166</span>	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5167</span>
<span class="ln">5168</span>	<span class="n">token</span> <span class="o">=</span> <span class="n">io_schedule_prepare</span><span class="p">();</span>
<span class="ln">5169</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
<span class="ln">5170</span>	<span class="n">io_schedule_finish</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
<span class="ln">5171</span>
<span class="ln">5172</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5173</span><span class="p">}</span>
<span class="ln">5174</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">io_schedule_timeout</span><span class="p">);</span>
<span class="ln">5175</span>
<span class="ln">5176</span><span class="kt">void</span> <span class="n">__sched</span> <span class="nf">io_schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5177</span><span class="p">{</span>
<span class="ln">5178</span>	<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>
<span class="ln">5179</span>
<span class="ln">5180</span>	<span class="n">token</span> <span class="o">=</span> <span class="n">io_schedule_prepare</span><span class="p">();</span>
<span class="ln">5181</span>	<span class="n">schedule</span><span class="p">();</span>
<span class="ln">5182</span>	<span class="n">io_schedule_finish</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
<span class="ln">5183</span><span class="p">}</span>
<span class="ln">5184</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">io_schedule</span><span class="p">);</span>
<span class="ln">5185</span>
<span class="ln">5186</span><span class="cm">/**
</span><span class="ln">5187</span><span class="cm"> * sys_sched_get_priority_max - return maximum RT priority.
</span><span class="ln">5188</span><span class="cm"> * @policy: scheduling class.
</span><span class="ln">5189</span><span class="cm"> *
</span><span class="ln">5190</span><span class="cm"> * Return: On success, this syscall returns the maximum
</span><span class="ln">5191</span><span class="cm"> * rt_priority that can be used by a given scheduling class.
</span><span class="ln">5192</span><span class="cm"> * On failure, a negative error code is returned.
</span><span class="ln">5193</span><span class="cm"> */</span>
<span class="ln">5194</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sched_get_priority_max</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
<span class="ln">5195</span><span class="p">{</span>
<span class="ln">5196</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">5197</span>
<span class="ln">5198</span>	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5199</span>	<span class="k">case</span> <span class="nl">SCHED_FIFO</span><span class="p">:</span>
<span class="ln">5200</span>	<span class="k">case</span> <span class="nl">SCHED_RR</span><span class="p">:</span>
<span class="ln">5201</span>		<span class="n">ret</span> <span class="o">=</span> <span class="n">MAX_USER_RT_PRIO</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln">5202</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">5203</span>	<span class="k">case</span> <span class="nl">SCHED_DEADLINE</span><span class="p">:</span>
<span class="ln">5204</span>	<span class="k">case</span> <span class="nl">SCHED_NORMAL</span><span class="p">:</span>
<span class="ln">5205</span>	<span class="k">case</span> <span class="nl">SCHED_BATCH</span><span class="p">:</span>
<span class="ln">5206</span>	<span class="k">case</span> <span class="nl">SCHED_IDLE</span><span class="p">:</span>
<span class="ln">5207</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5208</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">5209</span>	<span class="p">}</span>
<span class="ln">5210</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5211</span><span class="p">}</span>
<span class="ln">5212</span>
<span class="ln">5213</span><span class="cm">/**
</span><span class="ln">5214</span><span class="cm"> * sys_sched_get_priority_min - return minimum RT priority.
</span><span class="ln">5215</span><span class="cm"> * @policy: scheduling class.
</span><span class="ln">5216</span><span class="cm"> *
</span><span class="ln">5217</span><span class="cm"> * Return: On success, this syscall returns the minimum
</span><span class="ln">5218</span><span class="cm"> * rt_priority that can be used by a given scheduling class.
</span><span class="ln">5219</span><span class="cm"> * On failure, a negative error code is returned.
</span><span class="ln">5220</span><span class="cm"> */</span>
<span class="ln">5221</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sched_get_priority_min</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
<span class="ln">5222</span><span class="p">{</span>
<span class="ln">5223</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">5224</span>
<span class="ln">5225</span>	<span class="k">switch</span> <span class="p">(</span><span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5226</span>	<span class="k">case</span> <span class="nl">SCHED_FIFO</span><span class="p">:</span>
<span class="ln">5227</span>	<span class="k">case</span> <span class="nl">SCHED_RR</span><span class="p">:</span>
<span class="ln">5228</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5229</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">5230</span>	<span class="k">case</span> <span class="nl">SCHED_DEADLINE</span><span class="p">:</span>
<span class="ln">5231</span>	<span class="k">case</span> <span class="nl">SCHED_NORMAL</span><span class="p">:</span>
<span class="ln">5232</span>	<span class="k">case</span> <span class="nl">SCHED_BATCH</span><span class="p">:</span>
<span class="ln">5233</span>	<span class="k">case</span> <span class="nl">SCHED_IDLE</span><span class="p">:</span>
<span class="ln">5234</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5235</span>	<span class="p">}</span>
<span class="ln">5236</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5237</span><span class="p">}</span>
<span class="ln">5238</span>
<span class="ln">5239</span><span class="k">static</span> <span class="kt">int</span> <span class="n">sched_rr_get_interval</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec64</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="ln">5240</span><span class="p">{</span>
<span class="ln">5241</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">5242</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">time_slice</span><span class="p">;</span>
<span class="ln">5243</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">5244</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">5245</span>	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">5246</span>
<span class="ln">5247</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">5248</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">5249</span>
<span class="ln">5250</span>	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
<span class="ln">5251</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">5252</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
<span class="ln">5253</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
<span class="ln">5254</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">5255</span>
<span class="ln">5256</span>	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_task_getscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5257</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
<span class="ln">5258</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">5259</span>
<span class="ln">5260</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5261</span>	<span class="n">time_slice</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5262</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">get_rr_interval</span><span class="p">)</span>
<span class="ln">5263</span>		<span class="n">time_slice</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">get_rr_interval</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">5264</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5265</span>
<span class="ln">5266</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">5267</span>	<span class="n">jiffies_to_timespec64</span><span class="p">(</span><span class="n">time_slice</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="ln">5268</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5269</span>
<span class="ln">5270</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">5271</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">5272</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">5273</span><span class="p">}</span>
<span class="ln">5274</span>
<span class="ln">5275</span><span class="cm">/**
</span><span class="ln">5276</span><span class="cm"> * sys_sched_rr_get_interval - return the default timeslice of a process.
</span><span class="ln">5277</span><span class="cm"> * @pid: pid of the process.
</span><span class="ln">5278</span><span class="cm"> * @interval: userspace pointer to the timeslice value.
</span><span class="ln">5279</span><span class="cm"> *
</span><span class="ln">5280</span><span class="cm"> * this syscall writes the default timeslice value of a given process
</span><span class="ln">5281</span><span class="cm"> * into the user-space timespec buffer. A value of &#39;0&#39; means infinity.
</span><span class="ln">5282</span><span class="cm"> *
</span><span class="ln">5283</span><span class="cm"> * Return: On success, 0 and the timeslice is in @interval. Otherwise,
</span><span class="ln">5284</span><span class="cm"> * an error code.
</span><span class="ln">5285</span><span class="cm"> */</span>
<span class="ln">5286</span><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_rr_get_interval</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
<span class="ln">5287</span>		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
<span class="ln">5288</span><span class="p">{</span>
<span class="ln">5289</span>	<span class="k">struct</span> <span class="n">timespec64</span> <span class="n">t</span><span class="p">;</span>
<span class="ln">5290</span>	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">sched_rr_get_interval</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
<span class="ln">5291</span>
<span class="ln">5292</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">5293</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">put_timespec64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
<span class="ln">5294</span>
<span class="ln">5295</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">5296</span><span class="p">}</span>
<span class="ln">5297</span>
<span class="ln">5298</span><span class="cp">#ifdef CONFIG_COMPAT
</span><span class="ln">5299</span><span class="cp"></span><span class="n">COMPAT_SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">sched_rr_get_interval</span><span class="p">,</span>
<span class="ln">5300</span>		       <span class="n">compat_pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span>
<span class="ln">5301</span>		       <span class="k">struct</span> <span class="n">compat_timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
<span class="ln">5302</span><span class="p">{</span>
<span class="ln">5303</span>	<span class="k">struct</span> <span class="n">timespec64</span> <span class="n">t</span><span class="p">;</span>
<span class="ln">5304</span>	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">sched_rr_get_interval</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
<span class="ln">5305</span>
<span class="ln">5306</span>	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">5307</span>		<span class="n">retval</span> <span class="o">=</span> <span class="n">compat_put_timespec64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
<span class="ln">5308</span>	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="ln">5309</span><span class="p">}</span>
<span class="ln">5310</span><span class="cp">#endif
</span><span class="ln">5311</span><span class="cp"></span>
<span class="ln">5312</span><span class="kt">void</span> <span class="n">sched_show_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">5313</span><span class="p">{</span>
<span class="ln">5314</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5315</span>	<span class="kt">int</span> <span class="n">ppid</span><span class="p">;</span>
<span class="ln">5316</span>
<span class="ln">5317</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_get_task_stack</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">5318</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">5319</span>
<span class="ln">5320</span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&#34;%-15.15s %c&#34;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_state_to_char</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln">5321</span>
<span class="ln">5322</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_RUNNING</span><span class="p">)</span>
<span class="ln">5323</span>		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&#34;  running task    &#34;</span><span class="p">);</span>
<span class="ln">5324</span><span class="cp">#ifdef CONFIG_DEBUG_STACK_USAGE
</span><span class="ln">5325</span><span class="cp"></span>	<span class="n">free</span> <span class="o">=</span> <span class="n">stack_not_used</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5326</span><span class="cp">#endif
</span><span class="ln">5327</span><span class="cp"></span>	<span class="n">ppid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5328</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">5329</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pid_alive</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln">5330</span>		<span class="n">ppid</span> <span class="o">=</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">));</span>
<span class="ln">5331</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">5332</span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&#34;%5lu %5d %6d 0x%08lx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span>
<span class="ln">5333</span>		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">ppid</span><span class="p">,</span>
<span class="ln">5334</span>		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task_thread_info</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="ln">5335</span>
<span class="ln">5336</span>	<span class="n">print_worker_info</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">5337</span>	<span class="n">show_stack</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln">5338</span>	<span class="n">put_task_stack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5339</span><span class="p">}</span>
<span class="ln">5340</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_show_task</span><span class="p">);</span>
<span class="ln">5341</span>
<span class="ln">5342</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="ln">5343</span><span class="nf">state_filter_match</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state_filter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">5344</span><span class="p">{</span>
<span class="ln">5345</span>	<span class="cm">/* no filter, everything matches */</span>
<span class="ln">5346</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state_filter</span><span class="p">)</span>
<span class="ln">5347</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">5348</span>
<span class="ln">5349</span>	<span class="cm">/* filter, but doesn&#39;t match */</span>
<span class="ln">5350</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">state_filter</span><span class="p">))</span>
<span class="ln">5351</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln">5352</span>
<span class="ln">5353</span>	<span class="cm">/*
</span><span class="ln">5354</span><span class="cm">	 * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows
</span><span class="ln">5355</span><span class="cm">	 * TASK_KILLABLE).
</span><span class="ln">5356</span><span class="cm">	 */</span>
<span class="ln">5357</span>	<span class="k">if</span> <span class="p">(</span><span class="n">state_filter</span> <span class="o">==</span> <span class="n">TASK_UNINTERRUPTIBLE</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_IDLE</span><span class="p">)</span>
<span class="ln">5358</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln">5359</span>
<span class="ln">5360</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">5361</span><span class="p">}</span>
<span class="ln">5362</span>
<span class="ln">5363</span>
<span class="ln">5364</span><span class="kt">void</span> <span class="nf">show_state_filter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state_filter</span><span class="p">)</span>
<span class="ln">5365</span><span class="p">{</span>
<span class="ln">5366</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">5367</span>
<span class="ln">5368</span><span class="cp">#if BITS_PER_LONG == 32
</span><span class="ln">5369</span><span class="cp"></span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
<span class="ln">5370</span>		<span class="s">&#34;  task                PC stack   pid father</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">5371</span><span class="cp">#else
</span><span class="ln">5372</span><span class="cp"></span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
<span class="ln">5373</span>		<span class="s">&#34;  task                        PC stack   pid father</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">5374</span><span class="cp">#endif
</span><span class="ln">5375</span><span class="cp"></span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">5376</span>	<span class="n">for_each_process_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5377</span>		<span class="cm">/*
</span><span class="ln">5378</span><span class="cm">		 * reset the NMI-timeout, listing all files on a slow
</span><span class="ln">5379</span><span class="cm">		 * console might take a lot of time:
</span><span class="ln">5380</span><span class="cm">		 * Also, reset softlockup watchdogs on all CPUs, because
</span><span class="ln">5381</span><span class="cm">		 * another CPU might be blocked waiting for us to process
</span><span class="ln">5382</span><span class="cm">		 * an IPI.
</span><span class="ln">5383</span><span class="cm">		 */</span>
<span class="ln">5384</span>		<span class="n">touch_nmi_watchdog</span><span class="p">();</span>
<span class="ln">5385</span>		<span class="n">touch_all_softlockup_watchdogs</span><span class="p">();</span>
<span class="ln">5386</span>		<span class="k">if</span> <span class="p">(</span><span class="n">state_filter_match</span><span class="p">(</span><span class="n">state_filter</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
<span class="ln">5387</span>			<span class="n">sched_show_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5388</span>	<span class="p">}</span>
<span class="ln">5389</span>
<span class="ln">5390</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln">5391</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state_filter</span><span class="p">)</span>
<span class="ln">5392</span>		<span class="n">sysrq_sched_debug_show</span><span class="p">();</span>
<span class="ln">5393</span><span class="cp">#endif
</span><span class="ln">5394</span><span class="cp"></span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">5395</span>	<span class="cm">/*
</span><span class="ln">5396</span><span class="cm">	 * Only show locks if all tasks are dumped:
</span><span class="ln">5397</span><span class="cm">	 */</span>
<span class="ln">5398</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state_filter</span><span class="p">)</span>
<span class="ln">5399</span>		<span class="n">debug_show_all_locks</span><span class="p">();</span>
<span class="ln">5400</span><span class="p">}</span>
<span class="ln">5401</span>
<span class="ln">5402</span><span class="cm">/**
</span><span class="ln">5403</span><span class="cm"> * init_idle - set up an idle thread for a given CPU
</span><span class="ln">5404</span><span class="cm"> * @idle: task in question
</span><span class="ln">5405</span><span class="cm"> * @cpu: CPU the idle task belongs to
</span><span class="ln">5406</span><span class="cm"> *
</span><span class="ln">5407</span><span class="cm"> * NOTE: this function does not set the idle thread&#39;s NEED_RESCHED
</span><span class="ln">5408</span><span class="cm"> * flag, to make booting more robust.
</span><span class="ln">5409</span><span class="cm"> */</span>
<span class="ln">5410</span><span class="kt">void</span> <span class="nf">init_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">idle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5411</span><span class="p">{</span>
<span class="ln">5412</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5413</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">5414</span>
<span class="ln">5415</span>	<span class="n">__sched_fork</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idle</span><span class="p">);</span>
<span class="ln">5416</span>
<span class="ln">5417</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">5418</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">5419</span>
<span class="ln">5420</span>	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
<span class="ln">5421</span>	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">sched_clock</span><span class="p">();</span>
<span class="ln">5422</span>	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_IDLE</span><span class="p">;</span>
<span class="ln">5423</span>
<span class="ln">5424</span>	<span class="n">kasan_unpoison_task_stack</span><span class="p">(</span><span class="n">idle</span><span class="p">);</span>
<span class="ln">5425</span>
<span class="ln">5426</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">5427</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">5428</span><span class="cm">	 * Its possible that init_idle() gets called multiple times on a task,
</span><span class="ln">5429</span><span class="cm">	 * in that case do_set_cpus_allowed() will not do the right thing.
</span><span class="ln">5430</span><span class="cm">	 *
</span><span class="ln">5431</span><span class="cm">	 * And since this is boot we can forgo the serialization.
</span><span class="ln">5432</span><span class="cm">	 */</span>
<span class="ln">5433</span>	<span class="n">set_cpus_allowed_common</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpumask_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln">5434</span><span class="cp">#endif
</span><span class="ln">5435</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">5436</span><span class="cm">	 * We&#39;re having a chicken and egg problem, even though we are
</span><span class="ln">5437</span><span class="cm">	 * holding rq-&gt;lock, the CPU isn&#39;t yet set to this CPU so the
</span><span class="ln">5438</span><span class="cm">	 * lockdep check in task_group() will fail.
</span><span class="ln">5439</span><span class="cm">	 *
</span><span class="ln">5440</span><span class="cm">	 * Similar case to sched_fork(). / Alternatively we could
</span><span class="ln">5441</span><span class="cm">	 * use task_rq_lock() here and obtain the other rq-&gt;lock.
</span><span class="ln">5442</span><span class="cm">	 *
</span><span class="ln">5443</span><span class="cm">	 * Silence PROVE_RCU
</span><span class="ln">5444</span><span class="cm">	 */</span>
<span class="ln">5445</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">5446</span>	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">5447</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">5448</span>
<span class="ln">5449</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>
<span class="ln">5450</span>	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="ln">5451</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">5452</span><span class="cp"></span>	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">on_cpu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5453</span><span class="cp">#endif
</span><span class="ln">5454</span><span class="cp"></span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">5455</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">5456</span>
<span class="ln">5457</span>	<span class="cm">/* Set the preempt count _outside_ the spinlocks! */</span>
<span class="ln">5458</span>	<span class="n">init_idle_preempt_count</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">5459</span>
<span class="ln">5460</span>	<span class="cm">/*
</span><span class="ln">5461</span><span class="cm">	 * The idle tasks have their own, simple scheduling class:
</span><span class="ln">5462</span><span class="cm">	 */</span>
<span class="ln">5463</span>	<span class="n">idle</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">;</span>
<span class="ln">5464</span>	<span class="n">ftrace_graph_init_idle_task</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">5465</span>	<span class="n">vtime_init_idle</span><span class="p">(</span><span class="n">idle</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">5466</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">5467</span><span class="cp"></span>	<span class="n">sprintf</span><span class="p">(</span><span class="n">idle</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="s">&#34;%s/%d&#34;</span><span class="p">,</span> <span class="n">INIT_TASK_COMM</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">5468</span><span class="cp">#endif
</span><span class="ln">5469</span><span class="cp"></span><span class="p">}</span>
<span class="ln">5470</span>
<span class="ln">5471</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">5472</span><span class="cp"></span>
<span class="ln">5473</span><span class="kt">int</span> <span class="nf">cpuset_cpumask_can_shrink</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span>
<span class="ln">5474</span>			      <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">trial</span><span class="p">)</span>
<span class="ln">5475</span><span class="p">{</span>
<span class="ln">5476</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5477</span>
<span class="ln">5478</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span>
<span class="ln">5479</span>		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5480</span>
<span class="ln">5481</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">dl_cpuset_cpumask_can_shrink</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">trial</span><span class="p">);</span>
<span class="ln">5482</span>
<span class="ln">5483</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5484</span><span class="p">}</span>
<span class="ln">5485</span>
<span class="ln">5486</span><span class="kt">int</span> <span class="nf">task_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln">5487</span>		    <span class="k">const</span> <span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cs_cpus_allowed</span><span class="p">)</span>
<span class="ln">5488</span><span class="p">{</span>
<span class="ln">5489</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5490</span>
<span class="ln">5491</span>	<span class="cm">/*
</span><span class="ln">5492</span><span class="cm">	 * Kthreads which disallow setaffinity shouldn&#39;t be moved
</span><span class="ln">5493</span><span class="cm">	 * to a new cpuset; we don&#39;t want to change their CPU
</span><span class="ln">5494</span><span class="cm">	 * affinity and isolating such threads by their set of
</span><span class="ln">5495</span><span class="cm">	 * allowed nodes is unnecessary.  Thus, cpusets are not
</span><span class="ln">5496</span><span class="cm">	 * applicable for such threads.  This prevents checking for
</span><span class="ln">5497</span><span class="cm">	 * success of set_cpus_allowed_ptr() on all attached tasks
</span><span class="ln">5498</span><span class="cm">	 * before cpus_allowed may be changed.
</span><span class="ln">5499</span><span class="cm">	 */</span>
<span class="ln">5500</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_NO_SETAFFINITY</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5501</span>		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">5502</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln">5503</span>	<span class="p">}</span>
<span class="ln">5504</span>
<span class="ln">5505</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dl_task</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">,</span>
<span class="ln">5506</span>					      <span class="n">cs_cpus_allowed</span><span class="p">))</span>
<span class="ln">5507</span>		<span class="n">ret</span> <span class="o">=</span> <span class="n">dl_task_can_attach</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cs_cpus_allowed</span><span class="p">);</span>
<span class="ln">5508</span>
<span class="ln">5509</span><span class="nl">out</span><span class="p">:</span>
<span class="ln">5510</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5511</span><span class="p">}</span>
<span class="ln">5512</span>
<span class="ln">5513</span><span class="kt">bool</span> <span class="n">sched_smp_initialized</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="ln">5514</span>
<span class="ln">5515</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln">5516</span><span class="cp"></span><span class="cm">/* Migrate current task p to target_cpu */</span>
<span class="ln">5517</span><span class="kt">int</span> <span class="nf">migrate_task_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target_cpu</span><span class="p">)</span>
<span class="ln">5518</span><span class="p">{</span>
<span class="ln">5519</span>	<span class="k">struct</span> <span class="n">migration_arg</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">target_cpu</span> <span class="p">};</span>
<span class="ln">5520</span>	<span class="kt">int</span> <span class="n">curr_cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5521</span>
<span class="ln">5522</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr_cpu</span> <span class="o">==</span> <span class="n">target_cpu</span><span class="p">)</span>
<span class="ln">5523</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5524</span>
<span class="ln">5525</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln">5526</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">5527</span>
<span class="ln">5528</span>	<span class="cm">/* TODO: This is not properly updating schedstats */</span>
<span class="ln">5529</span>
<span class="ln">5530</span>	<span class="n">trace_sched_move_numa</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">curr_cpu</span><span class="p">,</span> <span class="n">target_cpu</span><span class="p">);</span>
<span class="ln">5531</span>	<span class="k">return</span> <span class="n">stop_one_cpu</span><span class="p">(</span><span class="n">curr_cpu</span><span class="p">,</span> <span class="n">migration_cpu_stop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="ln">5532</span><span class="p">}</span>
<span class="ln">5533</span>
<span class="ln">5534</span><span class="cm">/*
</span><span class="ln">5535</span><span class="cm"> * Requeue a task on a given node and accurately track the number of NUMA
</span><span class="ln">5536</span><span class="cm"> * tasks on the runqueues
</span><span class="ln">5537</span><span class="cm"> */</span>
<span class="ln">5538</span><span class="kt">void</span> <span class="nf">sched_setnuma</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln">5539</span><span class="p">{</span>
<span class="ln">5540</span>	<span class="kt">bool</span> <span class="n">queued</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
<span class="ln">5541</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">5542</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">5543</span>
<span class="ln">5544</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5545</span>	<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">5546</span>	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">5547</span>
<span class="ln">5548</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">5549</span>		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">DEQUEUE_SAVE</span><span class="p">);</span>
<span class="ln">5550</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">5551</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">5552</span>
<span class="ln">5553</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln">5554</span>
<span class="ln">5555</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">5556</span>		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_RESTORE</span> <span class="o">|</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln">5557</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">5558</span>		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln">5559</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5560</span><span class="p">}</span>
<span class="ln">5561</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA_BALANCING */</span><span class="cp">
</span><span class="ln">5562</span><span class="cp"></span>
<span class="ln">5563</span><span class="cp">#ifdef CONFIG_HOTPLUG_CPU
</span><span class="ln">5564</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">5565</span><span class="cm"> * Ensure that the idle task is using init_mm right before its CPU goes
</span><span class="ln">5566</span><span class="cm"> * offline.
</span><span class="ln">5567</span><span class="cm"> */</span>
<span class="ln">5568</span><span class="kt">void</span> <span class="nf">idle_task_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5569</span><span class="p">{</span>
<span class="ln">5570</span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
<span class="ln">5571</span>
<span class="ln">5572</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()));</span>
<span class="ln">5573</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">);</span>
<span class="ln">5574</span>
<span class="ln">5575</span>	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5576</span>		<span class="n">switch_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="ln">5577</span>		<span class="n">finish_arch_post_lock_switch</span><span class="p">();</span>
<span class="ln">5578</span>	<span class="p">}</span>
<span class="ln">5579</span>
<span class="ln">5580</span>	<span class="cm">/* finish_cpu(), as ran on the BP, will clean up the active_mm state */</span>
<span class="ln">5581</span><span class="p">}</span>
<span class="ln">5582</span>
<span class="ln">5583</span><span class="cm">/*
</span><span class="ln">5584</span><span class="cm"> * Since this CPU is going &#39;away&#39; for a while, fold any nr_active delta
</span><span class="ln">5585</span><span class="cm"> * we might have. Assumes we&#39;re called after migrate_tasks() so that the
</span><span class="ln">5586</span><span class="cm"> * nr_active count is stable. We need to take the teardown thread which
</span><span class="ln">5587</span><span class="cm"> * is calling this into account, so we hand in adjust = 1 to the load
</span><span class="ln">5588</span><span class="cm"> * calculation.
</span><span class="ln">5589</span><span class="cm"> *
</span><span class="ln">5590</span><span class="cm"> * Also see the comment &#34;Global load-average calculations&#34;.
</span><span class="ln">5591</span><span class="cm"> */</span>
<span class="ln">5592</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">calc_load_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">5593</span><span class="p">{</span>
<span class="ln">5594</span>	<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">calc_load_fold_active</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">5595</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="ln">5596</span>		<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc_load_tasks</span><span class="p">);</span>
<span class="ln">5597</span><span class="p">}</span>
<span class="ln">5598</span>
<span class="ln">5599</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_task_fake</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln">5600</span><span class="p">{</span>
<span class="ln">5601</span><span class="p">}</span>
<span class="ln">5602</span>
<span class="ln">5603</span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fake_sched_class</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">5604</span>	<span class="p">.</span><span class="n">put_prev_task</span> <span class="o">=</span> <span class="n">put_prev_task_fake</span><span class="p">,</span>
<span class="ln">5605</span><span class="p">};</span>
<span class="ln">5606</span>
<span class="ln">5607</span><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="n">fake_task</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">5608</span>	<span class="cm">/*
</span><span class="ln">5609</span><span class="cm">	 * Avoid pull_{rt,dl}_task()
</span><span class="ln">5610</span><span class="cm">	 */</span>
<span class="ln">5611</span>	<span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">MAX_PRIO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
<span class="ln">5612</span>	<span class="p">.</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fake_sched_class</span><span class="p">,</span>
<span class="ln">5613</span><span class="p">};</span>
<span class="ln">5614</span>
<span class="ln">5615</span><span class="cm">/*
</span><span class="ln">5616</span><span class="cm"> * Migrate all tasks from the rq, sleeping tasks will be migrated by
</span><span class="ln">5617</span><span class="cm"> * try_to_wake_up()-&gt;select_task_rq().
</span><span class="ln">5618</span><span class="cm"> *
</span><span class="ln">5619</span><span class="cm"> * Called with rq-&gt;lock held even though we&#39;er in stop_machine() and
</span><span class="ln">5620</span><span class="cm"> * there&#39;s no concurrency possible, we hold the required locks anyway
</span><span class="ln">5621</span><span class="cm"> * because of lock validation efforts.
</span><span class="ln">5622</span><span class="cm"> */</span>
<span class="ln">5623</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">migrate_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">dead_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln">5624</span><span class="p">{</span>
<span class="ln">5625</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">dead_rq</span><span class="p">;</span>
<span class="ln">5626</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">stop</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">;</span>
<span class="ln">5627</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">orf</span> <span class="o">=</span> <span class="o">*</span><span class="n">rf</span><span class="p">;</span>
<span class="ln">5628</span>	<span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">;</span>
<span class="ln">5629</span>
<span class="ln">5630</span>	<span class="cm">/*
</span><span class="ln">5631</span><span class="cm">	 * Fudge the rq selection such that the below task selection loop
</span><span class="ln">5632</span><span class="cm">	 * doesn&#39;t get stuck on the currently eligible stop task.
</span><span class="ln">5633</span><span class="cm">	 *
</span><span class="ln">5634</span><span class="cm">	 * We&#39;re currently inside stop_machine() and the rq is either stuck
</span><span class="ln">5635</span><span class="cm">	 * in the stop_machine_cpu_stop() loop, or we&#39;re executing this code,
</span><span class="ln">5636</span><span class="cm">	 * either way we should never end up calling schedule() until we&#39;re
</span><span class="ln">5637</span><span class="cm">	 * done here.
</span><span class="ln">5638</span><span class="cm">	 */</span>
<span class="ln">5639</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">5640</span>
<span class="ln">5641</span>	<span class="cm">/*
</span><span class="ln">5642</span><span class="cm">	 * put_prev_task() and pick_next_task() sched
</span><span class="ln">5643</span><span class="cm">	 * class method both need to have an up-to-date
</span><span class="ln">5644</span><span class="cm">	 * value of rq-&gt;clock[_task]
</span><span class="ln">5645</span><span class="cm">	 */</span>
<span class="ln">5646</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5647</span>
<span class="ln">5648</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln">5649</span>		<span class="cm">/*
</span><span class="ln">5650</span><span class="cm">		 * There&#39;s this thread running, bail when that&#39;s the only
</span><span class="ln">5651</span><span class="cm">		 * remaining thread:
</span><span class="ln">5652</span><span class="cm">		 */</span>
<span class="ln">5653</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln">5654</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">5655</span>
<span class="ln">5656</span>		<span class="cm">/*
</span><span class="ln">5657</span><span class="cm">		 * pick_next_task() assumes pinned rq-&gt;lock:
</span><span class="ln">5658</span><span class="cm">		 */</span>
<span class="ln">5659</span>		<span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_task</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">5660</span>		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">);</span>
<span class="ln">5661</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">5662</span>
<span class="ln">5663</span>		<span class="cm">/*
</span><span class="ln">5664</span><span class="cm">		 * Rules for changing task_struct::cpus_allowed are holding
</span><span class="ln">5665</span><span class="cm">		 * both pi_lock and rq-&gt;lock, such that holding either
</span><span class="ln">5666</span><span class="cm">		 * stabilizes the mask.
</span><span class="ln">5667</span><span class="cm">		 *
</span><span class="ln">5668</span><span class="cm">		 * Drop rq-&gt;lock is not quite as disastrous as it usually is
</span><span class="ln">5669</span><span class="cm">		 * because !cpu_active at this point, which means load-balance
</span><span class="ln">5670</span><span class="cm">		 * will not interfere. Also, stop-machine.
</span><span class="ln">5671</span><span class="cm">		 */</span>
<span class="ln">5672</span>		<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">5673</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">5674</span>		<span class="n">rq_relock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">5675</span>
<span class="ln">5676</span>		<span class="cm">/*
</span><span class="ln">5677</span><span class="cm">		 * Since we&#39;re inside stop-machine, _nothing_ should have
</span><span class="ln">5678</span><span class="cm">		 * changed the task, WARN if weird stuff happened, because in
</span><span class="ln">5679</span><span class="cm">		 * that case the above rq-&gt;lock drop is a fail too.
</span><span class="ln">5680</span><span class="cm">		 */</span>
<span class="ln">5681</span>		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq</span> <span class="o">||</span> <span class="o">!</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln">5682</span>			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">5683</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln">5684</span>		<span class="p">}</span>
<span class="ln">5685</span>
<span class="ln">5686</span>		<span class="cm">/* Find suitable destination for @next, with force if needed. */</span>
<span class="ln">5687</span>		<span class="n">dest_cpu</span> <span class="o">=</span> <span class="n">select_fallback_rq</span><span class="p">(</span><span class="n">dead_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="ln">5688</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">__migrate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">dest_cpu</span><span class="p">);</span>
<span class="ln">5689</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">!=</span> <span class="n">dead_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5690</span>			<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">5691</span>			<span class="n">rq</span> <span class="o">=</span> <span class="n">dead_rq</span><span class="p">;</span>
<span class="ln">5692</span>			<span class="o">*</span><span class="n">rf</span> <span class="o">=</span> <span class="n">orf</span><span class="p">;</span>
<span class="ln">5693</span>			<span class="n">rq_relock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln">5694</span>		<span class="p">}</span>
<span class="ln">5695</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">5696</span>	<span class="p">}</span>
<span class="ln">5697</span>
<span class="ln">5698</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">;</span>
<span class="ln">5699</span><span class="p">}</span>
<span class="ln">5700</span><span class="cp">#endif </span><span class="cm">/* CONFIG_HOTPLUG_CPU */</span><span class="cp">
</span><span class="ln">5701</span><span class="cp"></span>
<span class="ln">5702</span><span class="kt">void</span> <span class="nf">set_rq_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">5703</span><span class="p">{</span>
<span class="ln">5704</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5705</span>		<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
<span class="ln">5706</span>
<span class="ln">5707</span>		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">);</span>
<span class="ln">5708</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">5709</span>
<span class="ln">5710</span>		<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5711</span>			<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_online</span><span class="p">)</span>
<span class="ln">5712</span>				<span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_online</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5713</span>		<span class="p">}</span>
<span class="ln">5714</span>	<span class="p">}</span>
<span class="ln">5715</span><span class="p">}</span>
<span class="ln">5716</span>
<span class="ln">5717</span><span class="kt">void</span> <span class="nf">set_rq_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">5718</span><span class="p">{</span>
<span class="ln">5719</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5720</span>		<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
<span class="ln">5721</span>
<span class="ln">5722</span>		<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5723</span>			<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_offline</span><span class="p">)</span>
<span class="ln">5724</span>				<span class="n">class</span><span class="o">-&gt;</span><span class="n">rq_offline</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5725</span>		<span class="p">}</span>
<span class="ln">5726</span>
<span class="ln">5727</span>		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">online</span><span class="p">);</span>
<span class="ln">5728</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5729</span>	<span class="p">}</span>
<span class="ln">5730</span><span class="p">}</span>
<span class="ln">5731</span>
<span class="ln">5732</span><span class="cm">/*
</span><span class="ln">5733</span><span class="cm"> * used to mark begin/end of suspend/resume:
</span><span class="ln">5734</span><span class="cm"> */</span>
<span class="ln">5735</span><span class="k">static</span> <span class="kt">int</span> <span class="n">num_cpus_frozen</span><span class="p">;</span>
<span class="ln">5736</span>
<span class="ln">5737</span><span class="cm">/*
</span><span class="ln">5738</span><span class="cm"> * Update cpusets according to cpu_active mask.  If cpusets are
</span><span class="ln">5739</span><span class="cm"> * disabled, cpuset_update_active_cpus() becomes a simple wrapper
</span><span class="ln">5740</span><span class="cm"> * around partition_sched_domains().
</span><span class="ln">5741</span><span class="cm"> *
</span><span class="ln">5742</span><span class="cm"> * If we come here as part of a suspend/resume, don&#39;t touch cpusets because we
</span><span class="ln">5743</span><span class="cm"> * want to restore it back to its original state upon resume anyway.
</span><span class="ln">5744</span><span class="cm"> */</span>
<span class="ln">5745</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpuset_cpu_active</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5746</span><span class="p">{</span>
<span class="ln">5747</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpuhp_tasks_frozen</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5748</span>		<span class="cm">/*
</span><span class="ln">5749</span><span class="cm">		 * num_cpus_frozen tracks how many CPUs are involved in suspend
</span><span class="ln">5750</span><span class="cm">		 * resume sequence. As long as this is not the last online
</span><span class="ln">5751</span><span class="cm">		 * operation in the resume sequence, just build a single sched
</span><span class="ln">5752</span><span class="cm">		 * domain, ignoring cpusets.
</span><span class="ln">5753</span><span class="cm">		 */</span>
<span class="ln">5754</span>		<span class="n">partition_sched_domains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln">5755</span>		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">num_cpus_frozen</span><span class="p">)</span>
<span class="ln">5756</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln">5757</span>		<span class="cm">/*
</span><span class="ln">5758</span><span class="cm">		 * This is the last CPU online operation. So fall through and
</span><span class="ln">5759</span><span class="cm">		 * restore the original sched domains by considering the
</span><span class="ln">5760</span><span class="cm">		 * cpuset configurations.
</span><span class="ln">5761</span><span class="cm">		 */</span>
<span class="ln">5762</span>		<span class="n">cpuset_force_rebuild</span><span class="p">();</span>
<span class="ln">5763</span>	<span class="p">}</span>
<span class="ln">5764</span>	<span class="n">cpuset_update_active_cpus</span><span class="p">();</span>
<span class="ln">5765</span><span class="p">}</span>
<span class="ln">5766</span>
<span class="ln">5767</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpuset_cpu_inactive</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5768</span><span class="p">{</span>
<span class="ln">5769</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuhp_tasks_frozen</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5770</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dl_cpu_busy</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln">5771</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="ln">5772</span>		<span class="n">cpuset_update_active_cpus</span><span class="p">();</span>
<span class="ln">5773</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">5774</span>		<span class="n">num_cpus_frozen</span><span class="o">++</span><span class="p">;</span>
<span class="ln">5775</span>		<span class="n">partition_sched_domains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln">5776</span>	<span class="p">}</span>
<span class="ln">5777</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5778</span><span class="p">}</span>
<span class="ln">5779</span>
<span class="ln">5780</span><span class="kt">int</span> <span class="nf">sched_cpu_activate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5781</span><span class="p">{</span>
<span class="ln">5782</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5783</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">5784</span>
<span class="ln">5785</span><span class="cp">#ifdef CONFIG_SCHED_SMT
</span><span class="ln">5786</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">5787</span><span class="cm">	 * When going up, increment the number of cores with SMT present.
</span><span class="ln">5788</span><span class="cm">	 */</span>
<span class="ln">5789</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cpu_smt_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
<span class="ln">5790</span>		<span class="n">static_branch_inc_cpuslocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_smt_present</span><span class="p">);</span>
<span class="ln">5791</span><span class="cp">#endif
</span><span class="ln">5792</span><span class="cp"></span>	<span class="n">set_cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">5793</span>
<span class="ln">5794</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_smp_initialized</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5795</span>		<span class="n">sched_domains_numa_masks_set</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5796</span>		<span class="n">cpuset_cpu_active</span><span class="p">();</span>
<span class="ln">5797</span>	<span class="p">}</span>
<span class="ln">5798</span>
<span class="ln">5799</span>	<span class="cm">/*
</span><span class="ln">5800</span><span class="cm">	 * Put the rq online, if not already. This happens:
</span><span class="ln">5801</span><span class="cm">	 *
</span><span class="ln">5802</span><span class="cm">	 * 1) In the early boot process, because we build the real domains
</span><span class="ln">5803</span><span class="cm">	 *    after all CPUs have been brought up.
</span><span class="ln">5804</span><span class="cm">	 *
</span><span class="ln">5805</span><span class="cm">	 * 2) At runtime, if cpuset_cpu_active() fails to rebuild the
</span><span class="ln">5806</span><span class="cm">	 *    domains.
</span><span class="ln">5807</span><span class="cm">	 */</span>
<span class="ln">5808</span>	<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5809</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5810</span>		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">));</span>
<span class="ln">5811</span>		<span class="n">set_rq_online</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5812</span>	<span class="p">}</span>
<span class="ln">5813</span>	<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5814</span>
<span class="ln">5815</span>	<span class="n">update_max_interval</span><span class="p">();</span>
<span class="ln">5816</span>
<span class="ln">5817</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5818</span><span class="p">}</span>
<span class="ln">5819</span>
<span class="ln">5820</span><span class="kt">int</span> <span class="nf">sched_cpu_deactivate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5821</span><span class="p">{</span>
<span class="ln">5822</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5823</span>
<span class="ln">5824</span>	<span class="n">set_cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln">5825</span>	<span class="cm">/*
</span><span class="ln">5826</span><span class="cm">	 * We&#39;ve cleared cpu_active_mask, wait for all preempt-disabled and RCU
</span><span class="ln">5827</span><span class="cm">	 * users of this state to go away such that all new such users will
</span><span class="ln">5828</span><span class="cm">	 * observe it.
</span><span class="ln">5829</span><span class="cm">	 *
</span><span class="ln">5830</span><span class="cm">	 * Do sync before park smpboot threads to take care the rcu boost case.
</span><span class="ln">5831</span><span class="cm">	 */</span>
<span class="ln">5832</span>	<span class="n">synchronize_rcu_mult</span><span class="p">(</span><span class="n">call_rcu</span><span class="p">,</span> <span class="n">call_rcu_sched</span><span class="p">);</span>
<span class="ln">5833</span>
<span class="ln">5834</span><span class="cp">#ifdef CONFIG_SCHED_SMT
</span><span class="ln">5835</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln">5836</span><span class="cm">	 * When going down, decrement the number of cores with SMT present.
</span><span class="ln">5837</span><span class="cm">	 */</span>
<span class="ln">5838</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">cpu_smt_mask</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
<span class="ln">5839</span>		<span class="n">static_branch_dec_cpuslocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_smt_present</span><span class="p">);</span>
<span class="ln">5840</span><span class="cp">#endif
</span><span class="ln">5841</span><span class="cp"></span>
<span class="ln">5842</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_smp_initialized</span><span class="p">)</span>
<span class="ln">5843</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5844</span>
<span class="ln">5845</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">cpuset_cpu_inactive</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5846</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5847</span>		<span class="n">set_cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln">5848</span>		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">5849</span>	<span class="p">}</span>
<span class="ln">5850</span>	<span class="n">sched_domains_numa_masks_clear</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5851</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5852</span><span class="p">}</span>
<span class="ln">5853</span>
<span class="ln">5854</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_rq_cpu_starting</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5855</span><span class="p">{</span>
<span class="ln">5856</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5857</span>
<span class="ln">5858</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span> <span class="o">=</span> <span class="n">calc_load_update</span><span class="p">;</span>
<span class="ln">5859</span>	<span class="n">update_max_interval</span><span class="p">();</span>
<span class="ln">5860</span><span class="p">}</span>
<span class="ln">5861</span>
<span class="ln">5862</span><span class="kt">int</span> <span class="nf">sched_cpu_starting</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5863</span><span class="p">{</span>
<span class="ln">5864</span>	<span class="n">sched_rq_cpu_starting</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5865</span>	<span class="n">sched_tick_start</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5866</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5867</span><span class="p">}</span>
<span class="ln">5868</span>
<span class="ln">5869</span><span class="cp">#ifdef CONFIG_HOTPLUG_CPU
</span><span class="ln">5870</span><span class="cp"></span><span class="kt">int</span> <span class="nf">sched_cpu_dying</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">5871</span><span class="p">{</span>
<span class="ln">5872</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5873</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">5874</span>
<span class="ln">5875</span>	<span class="cm">/* Handle pending wakeups and then migrate everything off */</span>
<span class="ln">5876</span>	<span class="n">sched_ttwu_pending</span><span class="p">();</span>
<span class="ln">5877</span>	<span class="n">sched_tick_stop</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">5878</span>
<span class="ln">5879</span>	<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5880</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5881</span>		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">span</span><span class="p">));</span>
<span class="ln">5882</span>		<span class="n">set_rq_offline</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5883</span>	<span class="p">}</span>
<span class="ln">5884</span>	<span class="n">migrate_tasks</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5885</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">5886</span>	<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">5887</span>
<span class="ln">5888</span>	<span class="n">calc_load_migrate</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5889</span>	<span class="n">update_max_interval</span><span class="p">();</span>
<span class="ln">5890</span>	<span class="n">nohz_balance_exit_idle</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5891</span>	<span class="n">hrtick_clear</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">5892</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5893</span><span class="p">}</span>
<span class="ln">5894</span><span class="cp">#endif
</span><span class="ln">5895</span><span class="cp"></span>
<span class="ln">5896</span><span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5897</span><span class="p">{</span>
<span class="ln">5898</span>	<span class="n">sched_init_numa</span><span class="p">();</span>
<span class="ln">5899</span>
<span class="ln">5900</span>	<span class="cm">/*
</span><span class="ln">5901</span><span class="cm">	 * There&#39;s no userspace yet to cause hotplug operations; hence all the
</span><span class="ln">5902</span><span class="cm">	 * CPU masks are stable and all blatant races in the below code cannot
</span><span class="ln">5903</span><span class="cm">	 * happen. The hotplug lock is nevertheless taken to satisfy lockdep,
</span><span class="ln">5904</span><span class="cm">	 * but there won&#39;t be any contention on it.
</span><span class="ln">5905</span><span class="cm">	 */</span>
<span class="ln">5906</span>	<span class="n">cpus_read_lock</span><span class="p">();</span>
<span class="ln">5907</span>	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
<span class="ln">5908</span>	<span class="n">sched_init_domains</span><span class="p">(</span><span class="n">cpu_active_mask</span><span class="p">);</span>
<span class="ln">5909</span>	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
<span class="ln">5910</span>	<span class="n">cpus_read_unlock</span><span class="p">();</span>
<span class="ln">5911</span>
<span class="ln">5912</span>	<span class="cm">/* Move init over to a non-isolated CPU */</span>
<span class="ln">5913</span>	<span class="k">if</span> <span class="p">(</span><span class="n">set_cpus_allowed_ptr</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">housekeeping_cpumask</span><span class="p">(</span><span class="n">HK_FLAG_DOMAIN</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">5914</span>		<span class="n">BUG</span><span class="p">();</span>
<span class="ln">5915</span>	<span class="n">sched_init_granularity</span><span class="p">();</span>
<span class="ln">5916</span>
<span class="ln">5917</span>	<span class="n">init_sched_rt_class</span><span class="p">();</span>
<span class="ln">5918</span>	<span class="n">init_sched_dl_class</span><span class="p">();</span>
<span class="ln">5919</span>
<span class="ln">5920</span>	<span class="n">sched_smp_initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">5921</span><span class="p">}</span>
<span class="ln">5922</span>
<span class="ln">5923</span><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">migration_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5924</span><span class="p">{</span>
<span class="ln">5925</span>	<span class="n">sched_rq_cpu_starting</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">());</span>
<span class="ln">5926</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">5927</span><span class="p">}</span>
<span class="ln">5928</span><span class="n">early_initcall</span><span class="p">(</span><span class="n">migration_init</span><span class="p">);</span>
<span class="ln">5929</span>
<span class="ln">5930</span><span class="cp">#else
</span><span class="ln">5931</span><span class="cp"></span><span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init_smp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5932</span><span class="p">{</span>
<span class="ln">5933</span>	<span class="n">sched_init_granularity</span><span class="p">();</span>
<span class="ln">5934</span><span class="p">}</span>
<span class="ln">5935</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">5936</span><span class="cp"></span>
<span class="ln">5937</span><span class="kt">int</span> <span class="nf">in_sched_functions</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="ln">5938</span><span class="p">{</span>
<span class="ln">5939</span>	<span class="k">return</span> <span class="n">in_lock_functions</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">5940</span>		<span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__sched_text_start</span>
<span class="ln">5941</span>		<span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__sched_text_end</span><span class="p">);</span>
<span class="ln">5942</span><span class="p">}</span>
<span class="ln">5943</span>
<span class="ln">5944</span><span class="cp">#ifdef CONFIG_CGROUP_SCHED
</span><span class="ln">5945</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">5946</span><span class="cm"> * Default task group.
</span><span class="ln">5947</span><span class="cm"> * Every task in system belongs to this group at bootup.
</span><span class="ln">5948</span><span class="cm"> */</span>
<span class="ln">5949</span><span class="k">struct</span> <span class="n">task_group</span> <span class="n">root_task_group</span><span class="p">;</span>
<span class="ln">5950</span><span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">task_groups</span><span class="p">);</span>
<span class="ln">5951</span>
<span class="ln">5952</span><span class="cm">/* Cacheline aligned slab cache for task_group */</span>
<span class="ln">5953</span><span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">task_group_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="ln">5954</span><span class="cp">#endif
</span><span class="ln">5955</span><span class="cp"></span>
<span class="ln">5956</span><span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">load_balance_mask</span><span class="p">);</span>
<span class="ln">5957</span><span class="n">DECLARE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">select_idle_mask</span><span class="p">);</span>
<span class="ln">5958</span>
<span class="ln">5959</span><span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">5960</span><span class="p">{</span>
<span class="ln">5961</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<span class="ln">5962</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
<span class="ln">5963</span>
<span class="ln">5964</span>	<span class="n">wait_bit_init</span><span class="p">();</span>
<span class="ln">5965</span>
<span class="ln">5966</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">5967</span><span class="cp"></span>	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="ln">5968</span><span class="cp">#endif
</span><span class="ln">5969</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">5970</span><span class="cp"></span>	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="ln">5971</span><span class="cp">#endif
</span><span class="ln">5972</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5973</span>		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
<span class="ln">5974</span>
<span class="ln">5975</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">5976</span><span class="cp"></span>		<span class="n">root_task_group</span><span class="p">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
<span class="ln">5977</span>		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="ln">5978</span>
<span class="ln">5979</span>		<span class="n">root_task_group</span><span class="p">.</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
<span class="ln">5980</span>		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="ln">5981</span>
<span class="ln">5982</span><span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">5983</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">5984</span><span class="cp"></span>		<span class="n">root_task_group</span><span class="p">.</span><span class="n">rt_se</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
<span class="ln">5985</span>		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="ln">5986</span>
<span class="ln">5987</span>		<span class="n">root_task_group</span><span class="p">.</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">**</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
<span class="ln">5988</span>		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">);</span>
<span class="ln">5989</span>
<span class="ln">5990</span><span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">5991</span><span class="cp"></span>	<span class="p">}</span>
<span class="ln">5992</span><span class="cp">#ifdef CONFIG_CPUMASK_OFFSTACK
</span><span class="ln">5993</span><span class="cp"></span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">5994</span>		<span class="n">per_cpu</span><span class="p">(</span><span class="n">load_balance_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">)</span><span class="n">kzalloc_node</span><span class="p">(</span>
<span class="ln">5995</span>			<span class="n">cpumask_size</span><span class="p">(),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="ln">5996</span>		<span class="n">per_cpu</span><span class="p">(</span><span class="n">select_idle_mask</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">)</span><span class="n">kzalloc_node</span><span class="p">(</span>
<span class="ln">5997</span>			<span class="n">cpumask_size</span><span class="p">(),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="ln">5998</span>	<span class="p">}</span>
<span class="ln">5999</span><span class="cp">#endif </span><span class="cm">/* CONFIG_CPUMASK_OFFSTACK */</span><span class="cp">
</span><span class="ln">6000</span><span class="cp"></span>
<span class="ln">6001</span>	<span class="n">init_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_rt_bandwidth</span><span class="p">,</span> <span class="n">global_rt_period</span><span class="p">(),</span> <span class="n">global_rt_runtime</span><span class="p">());</span>
<span class="ln">6002</span>	<span class="n">init_dl_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_dl_bandwidth</span><span class="p">,</span> <span class="n">global_rt_period</span><span class="p">(),</span> <span class="n">global_rt_runtime</span><span class="p">());</span>
<span class="ln">6003</span>
<span class="ln">6004</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">6005</span><span class="cp"></span>	<span class="n">init_defrootdomain</span><span class="p">();</span>
<span class="ln">6006</span><span class="cp">#endif
</span><span class="ln">6007</span><span class="cp"></span>
<span class="ln">6008</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">6009</span><span class="cp"></span>	<span class="n">init_rt_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">rt_bandwidth</span><span class="p">,</span>
<span class="ln">6010</span>			<span class="n">global_rt_period</span><span class="p">(),</span> <span class="n">global_rt_runtime</span><span class="p">());</span>
<span class="ln">6011</span><span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">6012</span><span class="cp"></span>
<span class="ln">6013</span><span class="cp">#ifdef CONFIG_CGROUP_SCHED
</span><span class="ln">6014</span><span class="cp"></span>	<span class="n">task_group_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">task_group</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">6015</span>
<span class="ln">6016</span>	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">);</span>
<span class="ln">6017</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">children</span><span class="p">);</span>
<span class="ln">6018</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">siblings</span><span class="p">);</span>
<span class="ln">6019</span>	<span class="n">autogroup_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span>
<span class="ln">6020</span><span class="cp">#endif </span><span class="cm">/* CONFIG_CGROUP_SCHED */</span><span class="cp">
</span><span class="ln">6021</span><span class="cp"></span>
<span class="ln">6022</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6023</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">6024</span>
<span class="ln">6025</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln">6026</span>		<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">6027</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6028</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6029</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">calc_load_update</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>
<span class="ln">6030</span>		<span class="n">init_cfs_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">);</span>
<span class="ln">6031</span>		<span class="n">init_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">);</span>
<span class="ln">6032</span>		<span class="n">init_dl_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">);</span>
<span class="ln">6033</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">6034</span><span class="cp"></span>		<span class="n">root_task_group</span><span class="p">.</span><span class="n">shares</span> <span class="o">=</span> <span class="n">ROOT_TASK_GROUP_LOAD</span><span class="p">;</span>
<span class="ln">6035</span>		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
<span class="ln">6036</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">;</span>
<span class="ln">6037</span>		<span class="cm">/*
</span><span class="ln">6038</span><span class="cm">		 * How much CPU bandwidth does root_task_group get?
</span><span class="ln">6039</span><span class="cm">		 *
</span><span class="ln">6040</span><span class="cm">		 * In case of task-groups formed thr&#39; the cgroup filesystem, it
</span><span class="ln">6041</span><span class="cm">		 * gets 100% of the CPU resources in the system. This overall
</span><span class="ln">6042</span><span class="cm">		 * system CPU resource is divided among the tasks of
</span><span class="ln">6043</span><span class="cm">		 * root_task_group and its child task-groups in a fair manner,
</span><span class="ln">6044</span><span class="cm">		 * based on each entity&#39;s (task or task-group&#39;s) weight
</span><span class="ln">6045</span><span class="cm">		 * (se-&gt;load.weight).
</span><span class="ln">6046</span><span class="cm">		 *
</span><span class="ln">6047</span><span class="cm">		 * In other words, if root_task_group has 10 tasks of weight
</span><span class="ln">6048</span><span class="cm">		 * 1024) and two child groups A0 and A1 (of weight 1024 each),
</span><span class="ln">6049</span><span class="cm">		 * then A0&#39;s share of the CPU resource is:
</span><span class="ln">6050</span><span class="cm">		 *
</span><span class="ln">6051</span><span class="cm">		 *	A0&#39;s bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%
</span><span class="ln">6052</span><span class="cm">		 *
</span><span class="ln">6053</span><span class="cm">		 * We achieve this by letting root_task_group&#39;s tasks sit
</span><span class="ln">6054</span><span class="cm">		 * directly in rq-&gt;cfs (i.e root_task_group-&gt;se[] = NULL).
</span><span class="ln">6055</span><span class="cm">		 */</span>
<span class="ln">6056</span>		<span class="n">init_cfs_bandwidth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">cfs_bandwidth</span><span class="p">);</span>
<span class="ln">6057</span>		<span class="n">init_tg_cfs_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln">6058</span><span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">6059</span><span class="cp"></span>
<span class="ln">6060</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_runtime</span> <span class="o">=</span> <span class="n">def_rt_bandwidth</span><span class="p">.</span><span class="n">rt_runtime</span><span class="p">;</span>
<span class="ln">6061</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">6062</span><span class="cp"></span>		<span class="n">init_tg_rt_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln">6063</span><span class="cp">#endif
</span><span class="ln">6064</span><span class="cp"></span>
<span class="ln">6065</span>		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CPU_LOAD_IDX_MAX</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="ln">6066</span>			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6067</span>
<span class="ln">6068</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">6069</span><span class="cp"></span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">6070</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">rd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">6071</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_capacity</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_capacity_orig</span> <span class="o">=</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>
<span class="ln">6072</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">balance_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">6073</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">active_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6074</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln">6075</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">push_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6076</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">6077</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">online</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6078</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6079</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>
<span class="ln">6080</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">max_idle_balance_cost</span> <span class="o">=</span> <span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>
<span class="ln">6081</span>
<span class="ln">6082</span>		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">);</span>
<span class="ln">6083</span>
<span class="ln">6084</span>		<span class="n">rq_attach_root</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">def_root_domain</span><span class="p">);</span>
<span class="ln">6085</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln">6086</span><span class="cp"></span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln">6087</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_blocked_load_update_tick</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln">6088</span>		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">6089</span><span class="cp">#endif
</span><span class="ln">6090</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">6091</span><span class="cp"></span>		<span class="n">hrtick_rq_init</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">6092</span>		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">6093</span>	<span class="p">}</span>
<span class="ln">6094</span>
<span class="ln">6095</span>	<span class="n">set_load_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln">6096</span>
<span class="ln">6097</span>	<span class="cm">/*
</span><span class="ln">6098</span><span class="cm">	 * The boot idle thread does lazy MMU switching as well:
</span><span class="ln">6099</span><span class="cm">	 */</span>
<span class="ln">6100</span>	<span class="n">mmgrab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">);</span>
<span class="ln">6101</span>	<span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
<span class="ln">6102</span>
<span class="ln">6103</span>	<span class="cm">/*
</span><span class="ln">6104</span><span class="cm">	 * Make us the idle thread. Technically, schedule() should not be
</span><span class="ln">6105</span><span class="cm">	 * called from this thread, however somewhere below it might be,
</span><span class="ln">6106</span><span class="cm">	 * but because we are the idle thread, we just pick up running again
</span><span class="ln">6107</span><span class="cm">	 * when this runqueue becomes &#34;idle&#34;.
</span><span class="ln">6108</span><span class="cm">	 */</span>
<span class="ln">6109</span>	<span class="n">init_idle</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="ln">6110</span>
<span class="ln">6111</span>	<span class="n">calc_load_update</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">LOAD_FREQ</span><span class="p">;</span>
<span class="ln">6112</span>
<span class="ln">6113</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">6114</span><span class="cp"></span>	<span class="n">idle_thread_set_boot_cpu</span><span class="p">();</span>
<span class="ln">6115</span><span class="cp">#endif
</span><span class="ln">6116</span><span class="cp"></span>	<span class="n">init_sched_fair_class</span><span class="p">();</span>
<span class="ln">6117</span>
<span class="ln">6118</span>	<span class="n">init_schedstats</span><span class="p">();</span>
<span class="ln">6119</span>
<span class="ln">6120</span>	<span class="n">scheduler_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">6121</span><span class="p">}</span>
<span class="ln">6122</span>
<span class="ln">6123</span><span class="cp">#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
</span><span class="ln">6124</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">preempt_count_equals</span><span class="p">(</span><span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">)</span>
<span class="ln">6125</span><span class="p">{</span>
<span class="ln">6126</span>	<span class="kt">int</span> <span class="n">nested</span> <span class="o">=</span> <span class="n">preempt_count</span><span class="p">()</span> <span class="o">+</span> <span class="n">rcu_preempt_depth</span><span class="p">();</span>
<span class="ln">6127</span>
<span class="ln">6128</span>	<span class="k">return</span> <span class="p">(</span><span class="n">nested</span> <span class="o">==</span> <span class="n">preempt_offset</span><span class="p">);</span>
<span class="ln">6129</span><span class="p">}</span>
<span class="ln">6130</span>
<span class="ln">6131</span><span class="kt">void</span> <span class="nf">__might_sleep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">)</span>
<span class="ln">6132</span><span class="p">{</span>
<span class="ln">6133</span>	<span class="cm">/*
</span><span class="ln">6134</span><span class="cm">	 * Blocking primitives will set (and therefore destroy) current-&gt;state,
</span><span class="ln">6135</span><span class="cm">	 * since we will exit with TASK_RUNNING make sure we enter with it,
</span><span class="ln">6136</span><span class="cm">	 * otherwise we will destroy state.
</span><span class="ln">6137</span><span class="cm">	 */</span>
<span class="ln">6138</span>	<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TASK_RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">task_state_change</span><span class="p">,</span>
<span class="ln">6139</span>			<span class="s">&#34;do not call blocking ops when !TASK_RUNNING; &#34;</span>
<span class="ln">6140</span>			<span class="s">&#34;state=%lx set at [&lt;%p&gt;] %pS</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">6141</span>			<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span>
<span class="ln">6142</span>			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">task_state_change</span><span class="p">,</span>
<span class="ln">6143</span>			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">task_state_change</span><span class="p">);</span>
<span class="ln">6144</span>
<span class="ln">6145</span>	<span class="n">___might_sleep</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">preempt_offset</span><span class="p">);</span>
<span class="ln">6146</span><span class="p">}</span>
<span class="ln">6147</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__might_sleep</span><span class="p">);</span>
<span class="ln">6148</span>
<span class="ln">6149</span><span class="kt">void</span> <span class="nf">___might_sleep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preempt_offset</span><span class="p">)</span>
<span class="ln">6150</span><span class="p">{</span>
<span class="ln">6151</span>	<span class="cm">/* Ratelimiting timestamp: */</span>
<span class="ln">6152</span>	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prev_jiffy</span><span class="p">;</span>
<span class="ln">6153</span>
<span class="ln">6154</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">preempt_disable_ip</span><span class="p">;</span>
<span class="ln">6155</span>
<span class="ln">6156</span>	<span class="cm">/* WARN_ON_ONCE() by default, no rate limit required: */</span>
<span class="ln">6157</span>	<span class="n">rcu_sleep_check</span><span class="p">();</span>
<span class="ln">6158</span>
<span class="ln">6159</span>	<span class="k">if</span> <span class="p">((</span><span class="n">preempt_count_equals</span><span class="p">(</span><span class="n">preempt_offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">irqs_disabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="ln">6160</span>	     <span class="o">!</span><span class="n">is_idle_task</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="o">||</span>
<span class="ln">6161</span>	    <span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_BOOTING</span> <span class="o">||</span> <span class="n">system_state</span> <span class="o">&gt;</span> <span class="n">SYSTEM_RUNNING</span> <span class="o">||</span>
<span class="ln">6162</span>	    <span class="n">oops_in_progress</span><span class="p">)</span>
<span class="ln">6163</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">6164</span>
<span class="ln">6165</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">prev_jiffy</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">prev_jiffy</span><span class="p">)</span>
<span class="ln">6166</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">6167</span>	<span class="n">prev_jiffy</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln">6168</span>
<span class="ln">6169</span>	<span class="cm">/* Save this before calling printk(), since that will clobber it: */</span>
<span class="ln">6170</span>	<span class="n">preempt_disable_ip</span> <span class="o">=</span> <span class="n">get_preempt_disable_ip</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">6171</span>
<span class="ln">6172</span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
<span class="ln">6173</span>		<span class="s">&#34;BUG: sleeping function called from invalid context at %s:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">6174</span>			<span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="ln">6175</span>	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
<span class="ln">6176</span>		<span class="s">&#34;in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">6177</span>			<span class="n">in_atomic</span><span class="p">(),</span> <span class="n">irqs_disabled</span><span class="p">(),</span>
<span class="ln">6178</span>			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
<span class="ln">6179</span>
<span class="ln">6180</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_stack_end_corrupted</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
<span class="ln">6181</span>		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&#34;Thread overran stack, or stack corrupted</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">6182</span>
<span class="ln">6183</span>	<span class="n">debug_show_held_locks</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">6184</span>	<span class="k">if</span> <span class="p">(</span><span class="n">irqs_disabled</span><span class="p">())</span>
<span class="ln">6185</span>		<span class="n">print_irqtrace_events</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln">6186</span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_PREEMPT</span><span class="p">)</span>
<span class="ln">6187</span>	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">preempt_count_equals</span><span class="p">(</span><span class="n">preempt_offset</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">6188</span>		<span class="n">pr_err</span><span class="p">(</span><span class="s">&#34;Preemption disabled at:&#34;</span><span class="p">);</span>
<span class="ln">6189</span>		<span class="n">print_ip_sym</span><span class="p">(</span><span class="n">preempt_disable_ip</span><span class="p">);</span>
<span class="ln">6190</span>		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">6191</span>	<span class="p">}</span>
<span class="ln">6192</span>	<span class="n">dump_stack</span><span class="p">();</span>
<span class="ln">6193</span>	<span class="n">add_taint</span><span class="p">(</span><span class="n">TAINT_WARN</span><span class="p">,</span> <span class="n">LOCKDEP_STILL_OK</span><span class="p">);</span>
<span class="ln">6194</span><span class="p">}</span>
<span class="ln">6195</span><span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">___might_sleep</span><span class="p">);</span>
<span class="ln">6196</span><span class="cp">#endif
</span><span class="ln">6197</span><span class="cp"></span>
<span class="ln">6198</span><span class="cp">#ifdef CONFIG_MAGIC_SYSRQ
</span><span class="ln">6199</span><span class="cp"></span><span class="kt">void</span> <span class="nf">normalize_rt_tasks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">6200</span><span class="p">{</span>
<span class="ln">6201</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">6202</span>	<span class="k">struct</span> <span class="n">sched_attr</span> <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">6203</span>		<span class="p">.</span><span class="n">sched_policy</span> <span class="o">=</span> <span class="n">SCHED_NORMAL</span><span class="p">,</span>
<span class="ln">6204</span>	<span class="p">};</span>
<span class="ln">6205</span>
<span class="ln">6206</span>	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="ln">6207</span>	<span class="n">for_each_process_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6208</span>		<span class="cm">/*
</span><span class="ln">6209</span><span class="cm">		 * Only normalize user tasks:
</span><span class="ln">6210</span><span class="cm">		 */</span>
<span class="ln">6211</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">)</span>
<span class="ln">6212</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln">6213</span>
<span class="ln">6214</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6215</span>		<span class="n">schedstat_set</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">,</span>  <span class="mi">0</span><span class="p">);</span>
<span class="ln">6216</span>		<span class="n">schedstat_set</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">6217</span>		<span class="n">schedstat_set</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">6218</span>
<span class="ln">6219</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dl_task</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rt_task</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">6220</span>			<span class="cm">/*
</span><span class="ln">6221</span><span class="cm">			 * Renice negative nice level userspace
</span><span class="ln">6222</span><span class="cm">			 * tasks back to 0:
</span><span class="ln">6223</span><span class="cm">			 */</span>
<span class="ln">6224</span>			<span class="k">if</span> <span class="p">(</span><span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">6225</span>				<span class="n">set_user_nice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">6226</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln">6227</span>		<span class="p">}</span>
<span class="ln">6228</span>
<span class="ln">6229</span>		<span class="n">__sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln">6230</span>	<span class="p">}</span>
<span class="ln">6231</span>	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="ln">6232</span><span class="p">}</span>
<span class="ln">6233</span>
<span class="ln">6234</span><span class="cp">#endif </span><span class="cm">/* CONFIG_MAGIC_SYSRQ */</span><span class="cp">
</span><span class="ln">6235</span><span class="cp"></span>
<span class="ln">6236</span><span class="cp">#if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)
</span><span class="ln">6237</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">6238</span><span class="cm"> * These functions are only useful for the IA64 MCA handling, or kdb.
</span><span class="ln">6239</span><span class="cm"> *
</span><span class="ln">6240</span><span class="cm"> * They can only be called when the whole system has been
</span><span class="ln">6241</span><span class="cm"> * stopped - every CPU needs to be quiescent, and no scheduling
</span><span class="ln">6242</span><span class="cm"> * activity can take place. Using them for anything else would
</span><span class="ln">6243</span><span class="cm"> * be a serious bug, and as a result, they aren&#39;t even visible
</span><span class="ln">6244</span><span class="cm"> * under any other configuration.
</span><span class="ln">6245</span><span class="cm"> */</span>
<span class="ln">6246</span>
<span class="ln">6247</span><span class="cm">/**
</span><span class="ln">6248</span><span class="cm"> * curr_task - return the current task for a given CPU.
</span><span class="ln">6249</span><span class="cm"> * @cpu: the processor in question.
</span><span class="ln">6250</span><span class="cm"> *
</span><span class="ln">6251</span><span class="cm"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
</span><span class="ln">6252</span><span class="cm"> *
</span><span class="ln">6253</span><span class="cm"> * Return: The current task for @cpu.
</span><span class="ln">6254</span><span class="cm"> */</span>
<span class="ln">6255</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">curr_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">6256</span><span class="p">{</span>
<span class="ln">6257</span>	<span class="k">return</span> <span class="n">cpu_curr</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">6258</span><span class="p">}</span>
<span class="ln">6259</span>
<span class="ln">6260</span><span class="cp">#endif </span><span class="cm">/* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */</span><span class="cp">
</span><span class="ln">6261</span><span class="cp"></span>
<span class="ln">6262</span><span class="cp">#ifdef CONFIG_IA64
</span><span class="ln">6263</span><span class="cp"></span><span class="cm">/**
</span><span class="ln">6264</span><span class="cm"> * set_curr_task - set the current task for a given CPU.
</span><span class="ln">6265</span><span class="cm"> * @cpu: the processor in question.
</span><span class="ln">6266</span><span class="cm"> * @p: the task pointer to set.
</span><span class="ln">6267</span><span class="cm"> *
</span><span class="ln">6268</span><span class="cm"> * Description: This function must only be used when non-maskable interrupts
</span><span class="ln">6269</span><span class="cm"> * are serviced on a separate stack. It allows the architecture to switch the
</span><span class="ln">6270</span><span class="cm"> * notion of the current task on a CPU in a non-blocking manner. This function
</span><span class="ln">6271</span><span class="cm"> * must be called with all CPU&#39;s synchronized, and interrupts disabled, the
</span><span class="ln">6272</span><span class="cm"> * and caller must save the original value of the current task (see
</span><span class="ln">6273</span><span class="cm"> * curr_task() above) and restore that value before reenabling interrupts and
</span><span class="ln">6274</span><span class="cm"> * re-starting the system.
</span><span class="ln">6275</span><span class="cm"> *
</span><span class="ln">6276</span><span class="cm"> * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!
</span><span class="ln">6277</span><span class="cm"> */</span>
<span class="ln">6278</span><span class="kt">void</span> <span class="nf">ia64_set_curr_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">6279</span><span class="p">{</span>
<span class="ln">6280</span>	<span class="n">cpu_curr</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="ln">6281</span><span class="p">}</span>
<span class="ln">6282</span>
<span class="ln">6283</span><span class="cp">#endif
</span><span class="ln">6284</span><span class="cp"></span>
<span class="ln">6285</span><span class="cp">#ifdef CONFIG_CGROUP_SCHED
</span><span class="ln">6286</span><span class="cp"></span><span class="cm">/* task_group_lock serializes the addition/removal of task groups */</span>
<span class="ln">6287</span><span class="k">static</span> <span class="nf">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">task_group_lock</span><span class="p">);</span>
<span class="ln">6288</span>
<span class="ln">6289</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_free_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">6290</span><span class="p">{</span>
<span class="ln">6291</span>	<span class="n">free_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6292</span>	<span class="n">free_rt_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6293</span>	<span class="n">autogroup_free</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6294</span>	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">task_group_cache</span><span class="p">,</span> <span class="n">tg</span><span class="p">);</span>
<span class="ln">6295</span><span class="p">}</span>
<span class="ln">6296</span>
<span class="ln">6297</span><span class="cm">/* allocate runqueue etc for a new task group */</span>
<span class="ln">6298</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="nf">sched_create_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="ln">6299</span><span class="p">{</span>
<span class="ln">6300</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="ln">6301</span>
<span class="ln">6302</span>	<span class="n">tg</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">task_group_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
<span class="ln">6303</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">6304</span>		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="ln">6305</span>
<span class="ln">6306</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>
<span class="ln">6307</span>		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">6308</span>
<span class="ln">6309</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_rt_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>
<span class="ln">6310</span>		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">6311</span>
<span class="ln">6312</span>	<span class="k">return</span> <span class="n">tg</span><span class="p">;</span>
<span class="ln">6313</span>
<span class="ln">6314</span><span class="nl">err</span><span class="p">:</span>
<span class="ln">6315</span>	<span class="n">sched_free_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6316</span>	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="ln">6317</span><span class="p">}</span>
<span class="ln">6318</span>
<span class="ln">6319</span><span class="kt">void</span> <span class="nf">sched_online_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="ln">6320</span><span class="p">{</span>
<span class="ln">6321</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">6322</span>
<span class="ln">6323</span>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">6324</span>	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">);</span>
<span class="ln">6325</span>
<span class="ln">6326</span>	<span class="cm">/* Root should already exist: */</span>
<span class="ln">6327</span>	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">);</span>
<span class="ln">6328</span>
<span class="ln">6329</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
<span class="ln">6330</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
<span class="ln">6331</span>	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">);</span>
<span class="ln">6332</span>	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">6333</span>
<span class="ln">6334</span>	<span class="n">online_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6335</span><span class="p">}</span>
<span class="ln">6336</span>
<span class="ln">6337</span><span class="cm">/* rcu callback to free various structures associated with a task group */</span>
<span class="ln">6338</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_free_group_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rhp</span><span class="p">)</span>
<span class="ln">6339</span><span class="p">{</span>
<span class="ln">6340</span>	<span class="cm">/* Now it should be safe to free those cfs_rqs: */</span>
<span class="ln">6341</span>	<span class="n">sched_free_group</span><span class="p">(</span><span class="n">container_of</span><span class="p">(</span><span class="n">rhp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span><span class="p">,</span> <span class="n">rcu</span><span class="p">));</span>
<span class="ln">6342</span><span class="p">}</span>
<span class="ln">6343</span>
<span class="ln">6344</span><span class="kt">void</span> <span class="nf">sched_destroy_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">6345</span><span class="p">{</span>
<span class="ln">6346</span>	<span class="cm">/* Wait for possible concurrent references to cfs_rqs complete: */</span>
<span class="ln">6347</span>	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">sched_free_group_rcu</span><span class="p">);</span>
<span class="ln">6348</span><span class="p">}</span>
<span class="ln">6349</span>
<span class="ln">6350</span><span class="kt">void</span> <span class="nf">sched_offline_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">6351</span><span class="p">{</span>
<span class="ln">6352</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">6353</span>
<span class="ln">6354</span>	<span class="cm">/* End participation in shares distribution: */</span>
<span class="ln">6355</span>	<span class="n">unregister_fair_sched_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6356</span>
<span class="ln">6357</span>	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">6358</span>	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="ln">6359</span>	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">siblings</span><span class="p">);</span>
<span class="ln">6360</span>	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_group_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">6361</span><span class="p">}</span>
<span class="ln">6362</span>
<span class="ln">6363</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sched_change_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="ln">6364</span><span class="p">{</span>
<span class="ln">6365</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="ln">6366</span>
<span class="ln">6367</span>	<span class="cm">/*
</span><span class="ln">6368</span><span class="cm">	 * All callers are synchronized by task_rq_lock(); we do not use RCU
</span><span class="ln">6369</span><span class="cm">	 * which is pointless here. Thus, we pass &#34;true&#34; to task_css_check()
</span><span class="ln">6370</span><span class="cm">	 * to prevent lockdep warnings.
</span><span class="ln">6371</span><span class="cm">	 */</span>
<span class="ln">6372</span>	<span class="n">tg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">task_css_check</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cpu_cgrp_id</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
<span class="ln">6373</span>			  <span class="k">struct</span> <span class="n">task_group</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="ln">6374</span>	<span class="n">tg</span> <span class="o">=</span> <span class="n">autogroup_task_group</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tg</span><span class="p">);</span>
<span class="ln">6375</span>	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_task_group</span> <span class="o">=</span> <span class="n">tg</span><span class="p">;</span>
<span class="ln">6376</span>
<span class="ln">6377</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">6378</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_change_group</span><span class="p">)</span>
<span class="ln">6379</span>		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_change_group</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="ln">6380</span>	<span class="k">else</span>
<span class="ln">6381</span><span class="cp">#endif
</span><span class="ln">6382</span><span class="cp"></span>		<span class="n">set_task_rq</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
<span class="ln">6383</span><span class="p">}</span>
<span class="ln">6384</span>
<span class="ln">6385</span><span class="cm">/*
</span><span class="ln">6386</span><span class="cm"> * Change task&#39;s runqueue when it moves between groups.
</span><span class="ln">6387</span><span class="cm"> *
</span><span class="ln">6388</span><span class="cm"> * The caller of this function should have put the task in its new group by
</span><span class="ln">6389</span><span class="cm"> * now. This function just updates tsk-&gt;se.cfs_rq and tsk-&gt;se.parent to reflect
</span><span class="ln">6390</span><span class="cm"> * its new group.
</span><span class="ln">6391</span><span class="cm"> */</span>
<span class="ln">6392</span><span class="kt">void</span> <span class="nf">sched_move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="ln">6393</span><span class="p">{</span>
<span class="ln">6394</span>	<span class="kt">int</span> <span class="n">queued</span><span class="p">,</span> <span class="n">running</span><span class="p">,</span> <span class="n">queue_flags</span> <span class="o">=</span>
<span class="ln">6395</span>		<span class="n">DEQUEUE_SAVE</span> <span class="o">|</span> <span class="n">DEQUEUE_MOVE</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">;</span>
<span class="ln">6396</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">6397</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">6398</span>
<span class="ln">6399</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">6400</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">6401</span>
<span class="ln">6402</span>	<span class="n">running</span> <span class="o">=</span> <span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="ln">6403</span>	<span class="n">queued</span> <span class="o">=</span> <span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="ln">6404</span>
<span class="ln">6405</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">6406</span>		<span class="n">dequeue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">queue_flags</span><span class="p">);</span>
<span class="ln">6407</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">6408</span>		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="ln">6409</span>
<span class="ln">6410</span>	<span class="n">sched_change_group</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">TASK_MOVE_GROUP</span><span class="p">);</span>
<span class="ln">6411</span>
<span class="ln">6412</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span>
<span class="ln">6413</span>		<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">queue_flags</span><span class="p">);</span>
<span class="ln">6414</span>	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="ln">6415</span>		<span class="n">set_curr_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>
<span class="ln">6416</span>
<span class="ln">6417</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">6418</span><span class="p">}</span>
<span class="ln">6419</span>
<span class="ln">6420</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="nf">css_tg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="ln">6421</span><span class="p">{</span>
<span class="ln">6422</span>	<span class="k">return</span> <span class="n">css</span> <span class="o">?</span> <span class="n">container_of</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span><span class="p">,</span> <span class="n">css</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">6423</span><span class="p">}</span>
<span class="ln">6424</span>
<span class="ln">6425</span><span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span>
<span class="ln">6426</span><span class="nf">cpu_cgroup_css_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">parent_css</span><span class="p">)</span>
<span class="ln">6427</span><span class="p">{</span>
<span class="ln">6428</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">parent_css</span><span class="p">);</span>
<span class="ln">6429</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="ln">6430</span>
<span class="ln">6431</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6432</span>		<span class="cm">/* This is early initialization for the top cgroup */</span>
<span class="ln">6433</span>		<span class="k">return</span> <span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">.</span><span class="n">css</span><span class="p">;</span>
<span class="ln">6434</span>	<span class="p">}</span>
<span class="ln">6435</span>
<span class="ln">6436</span>	<span class="n">tg</span> <span class="o">=</span> <span class="n">sched_create_group</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="ln">6437</span>	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tg</span><span class="p">))</span>
<span class="ln">6438</span>		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="ln">6439</span>
<span class="ln">6440</span>	<span class="k">return</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">;</span>
<span class="ln">6441</span><span class="p">}</span>
<span class="ln">6442</span>
<span class="ln">6443</span><span class="cm">/* Expose task group only after completing cgroup initialization */</span>
<span class="ln">6444</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cgroup_css_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="ln">6445</span><span class="p">{</span>
<span class="ln">6446</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="ln">6447</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="ln">6448</span>
<span class="ln">6449</span>	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="ln">6450</span>		<span class="n">sched_online_group</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="ln">6451</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6452</span><span class="p">}</span>
<span class="ln">6453</span>
<span class="ln">6454</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_cgroup_css_released</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="ln">6455</span><span class="p">{</span>
<span class="ln">6456</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="ln">6457</span>
<span class="ln">6458</span>	<span class="n">sched_offline_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6459</span><span class="p">}</span>
<span class="ln">6460</span>
<span class="ln">6461</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_cgroup_css_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="ln">6462</span><span class="p">{</span>
<span class="ln">6463</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="ln">6464</span>
<span class="ln">6465</span>	<span class="cm">/*
</span><span class="ln">6466</span><span class="cm">	 * Relies on the RCU grace period between css_released() and this.
</span><span class="ln">6467</span><span class="cm">	 */</span>
<span class="ln">6468</span>	<span class="n">sched_free_group</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6469</span><span class="p">}</span>
<span class="ln">6470</span>
<span class="ln">6471</span><span class="cm">/*
</span><span class="ln">6472</span><span class="cm"> * This is called before wake_up_new_task(), therefore we really only
</span><span class="ln">6473</span><span class="cm"> * have to set its group bits, all the other stuff does not apply.
</span><span class="ln">6474</span><span class="cm"> */</span>
<span class="ln">6475</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_cgroup_fork</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="ln">6476</span><span class="p">{</span>
<span class="ln">6477</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">6478</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">6479</span>
<span class="ln">6480</span>	<span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq_lock</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">6481</span>
<span class="ln">6482</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">6483</span>	<span class="n">sched_change_group</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">TASK_SET_GROUP</span><span class="p">);</span>
<span class="ln">6484</span>
<span class="ln">6485</span>	<span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">6486</span><span class="p">}</span>
<span class="ln">6487</span>
<span class="ln">6488</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cgroup_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="ln">6489</span><span class="p">{</span>
<span class="ln">6490</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="ln">6491</span>	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>
<span class="ln">6492</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6493</span>
<span class="ln">6494</span>	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">css</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6495</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">6496</span><span class="cp"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_rt_can_attach</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">task</span><span class="p">))</span>
<span class="ln">6497</span>			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6498</span><span class="cp">#endif
</span><span class="ln">6499</span><span class="cp"></span>		<span class="cm">/*
</span><span class="ln">6500</span><span class="cm">		 * Serialize against wake_up_new_task() such that if its
</span><span class="ln">6501</span><span class="cm">		 * running, we&#39;re sure to observe its full state.
</span><span class="ln">6502</span><span class="cm">		 */</span>
<span class="ln">6503</span>		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">6504</span>		<span class="cm">/*
</span><span class="ln">6505</span><span class="cm">		 * Avoid calling sched_move_task() before wake_up_new_task()
</span><span class="ln">6506</span><span class="cm">		 * has happened. This would lead to problems with PELT, due to
</span><span class="ln">6507</span><span class="cm">		 * move wanting to detach+attach while we&#39;re not attached yet.
</span><span class="ln">6508</span><span class="cm">		 */</span>
<span class="ln">6509</span>		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_NEW</span><span class="p">)</span>
<span class="ln">6510</span>			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6511</span>		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
<span class="ln">6512</span>
<span class="ln">6513</span>		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">6514</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">6515</span>	<span class="p">}</span>
<span class="ln">6516</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">6517</span><span class="p">}</span>
<span class="ln">6518</span>
<span class="ln">6519</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_cgroup_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="ln">6520</span><span class="p">{</span>
<span class="ln">6521</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="ln">6522</span>	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>
<span class="ln">6523</span>
<span class="ln">6524</span>	<span class="n">cgroup_taskset_for_each</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">css</span><span class="p">,</span> <span class="n">tset</span><span class="p">)</span>
<span class="ln">6525</span>		<span class="n">sched_move_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="ln">6526</span><span class="p">}</span>
<span class="ln">6527</span>
<span class="ln">6528</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">6529</span><span class="cp"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_shares_write_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6530</span>				<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span> <span class="n">u64</span> <span class="n">shareval</span><span class="p">)</span>
<span class="ln">6531</span><span class="p">{</span>
<span class="ln">6532</span>	<span class="k">if</span> <span class="p">(</span><span class="n">shareval</span> <span class="o">&gt;</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">ULONG_MAX</span><span class="p">))</span>
<span class="ln">6533</span>		<span class="n">shareval</span> <span class="o">=</span> <span class="n">MAX_SHARES</span><span class="p">;</span>
<span class="ln">6534</span>	<span class="k">return</span> <span class="n">sched_group_set_shares</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">shareval</span><span class="p">));</span>
<span class="ln">6535</span><span class="p">}</span>
<span class="ln">6536</span>
<span class="ln">6537</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_shares_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6538</span>			       <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6539</span><span class="p">{</span>
<span class="ln">6540</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="ln">6541</span>
<span class="ln">6542</span>	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">);</span>
<span class="ln">6543</span><span class="p">}</span>
<span class="ln">6544</span>
<span class="ln">6545</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln">6546</span><span class="cp"></span><span class="k">static</span> <span class="nf">DEFINE_MUTEX</span><span class="p">(</span><span class="n">cfs_constraints_mutex</span><span class="p">);</span>
<span class="ln">6547</span>
<span class="ln">6548</span><span class="k">const</span> <span class="n">u64</span> <span class="n">max_cfs_quota_period</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">;</span> <span class="cm">/* 1s */</span>
<span class="ln">6549</span><span class="k">const</span> <span class="n">u64</span> <span class="n">min_cfs_quota_period</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span> <span class="cm">/* 1ms */</span>
<span class="ln">6550</span>
<span class="ln">6551</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">__cfs_schedulable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">runtime</span><span class="p">);</span>
<span class="ln">6552</span>
<span class="ln">6553</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">quota</span><span class="p">)</span>
<span class="ln">6554</span><span class="p">{</span>
<span class="ln">6555</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">runtime_enabled</span><span class="p">,</span> <span class="n">runtime_was_enabled</span><span class="p">;</span>
<span class="ln">6556</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln">6557</span>
<span class="ln">6558</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">)</span>
<span class="ln">6559</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6560</span>
<span class="ln">6561</span>	<span class="cm">/*
</span><span class="ln">6562</span><span class="cm">	 * Ensure we have at some amount of bandwidth every period.  This is
</span><span class="ln">6563</span><span class="cm">	 * to prevent reaching a state of large arrears when throttled via
</span><span class="ln">6564</span><span class="cm">	 * entity_tick() resulting in prolonged exit starvation.
</span><span class="ln">6565</span><span class="cm">	 */</span>
<span class="ln">6566</span>	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">&lt;</span> <span class="n">min_cfs_quota_period</span> <span class="o">||</span> <span class="n">period</span> <span class="o">&lt;</span> <span class="n">min_cfs_quota_period</span><span class="p">)</span>
<span class="ln">6567</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6568</span>
<span class="ln">6569</span>	<span class="cm">/*
</span><span class="ln">6570</span><span class="cm">	 * Likewise, bound things on the otherside by preventing insane quota
</span><span class="ln">6571</span><span class="cm">	 * periods.  This also allows us to normalize in computing quota
</span><span class="ln">6572</span><span class="cm">	 * feasibility.
</span><span class="ln">6573</span><span class="cm">	 */</span>
<span class="ln">6574</span>	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">max_cfs_quota_period</span><span class="p">)</span>
<span class="ln">6575</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6576</span>
<span class="ln">6577</span>	<span class="cm">/*
</span><span class="ln">6578</span><span class="cm">	 * Prevent race between setting of cfs_rq-&gt;runtime_enabled and
</span><span class="ln">6579</span><span class="cm">	 * unthrottle_offline_cfs_rqs().
</span><span class="ln">6580</span><span class="cm">	 */</span>
<span class="ln">6581</span>	<span class="n">get_online_cpus</span><span class="p">();</span>
<span class="ln">6582</span>	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_constraints_mutex</span><span class="p">);</span>
<span class="ln">6583</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">__cfs_schedulable</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="ln">6584</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">6585</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln">6586</span>
<span class="ln">6587</span>	<span class="n">runtime_enabled</span> <span class="o">=</span> <span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln">6588</span>	<span class="n">runtime_was_enabled</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln">6589</span>	<span class="cm">/*
</span><span class="ln">6590</span><span class="cm">	 * If we need to toggle cfs_bandwidth_used, off-&gt;on must occur
</span><span class="ln">6591</span><span class="cm">	 * before making related changes, and on-&gt;off must occur afterwards
</span><span class="ln">6592</span><span class="cm">	 */</span>
<span class="ln">6593</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">runtime_was_enabled</span><span class="p">)</span>
<span class="ln">6594</span>		<span class="n">cfs_bandwidth_usage_inc</span><span class="p">();</span>
<span class="ln">6595</span>	<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">6596</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">period</span><span class="p">);</span>
<span class="ln">6597</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">=</span> <span class="n">quota</span><span class="p">;</span>
<span class="ln">6598</span>
<span class="ln">6599</span>	<span class="n">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln">6600</span>
<span class="ln">6601</span>	<span class="cm">/* Restart the period timer (if active) to handle new period expiry: */</span>
<span class="ln">6602</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_enabled</span><span class="p">)</span>
<span class="ln">6603</span>		<span class="n">start_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln">6604</span>
<span class="ln">6605</span>	<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">6606</span>
<span class="ln">6607</span>	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6608</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln">6609</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">6610</span>		<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">6611</span>
<span class="ln">6612</span>		<span class="n">rq_lock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">6613</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">=</span> <span class="n">runtime_enabled</span><span class="p">;</span>
<span class="ln">6614</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6615</span>
<span class="ln">6616</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span><span class="p">)</span>
<span class="ln">6617</span>			<span class="n">unthrottle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">6618</span>		<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">6619</span>	<span class="p">}</span>
<span class="ln">6620</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_was_enabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">runtime_enabled</span><span class="p">)</span>
<span class="ln">6621</span>		<span class="n">cfs_bandwidth_usage_dec</span><span class="p">();</span>
<span class="ln">6622</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln">6623</span>	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_constraints_mutex</span><span class="p">);</span>
<span class="ln">6624</span>	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="ln">6625</span>
<span class="ln">6626</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">6627</span><span class="p">}</span>
<span class="ln">6628</span>
<span class="ln">6629</span><span class="kt">int</span> <span class="nf">tg_set_cfs_quota</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">long</span> <span class="n">cfs_quota_us</span><span class="p">)</span>
<span class="ln">6630</span><span class="p">{</span>
<span class="ln">6631</span>	<span class="n">u64</span> <span class="n">quota</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>
<span class="ln">6632</span>
<span class="ln">6633</span>	<span class="n">period</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">period</span><span class="p">);</span>
<span class="ln">6634</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_quota_us</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">6635</span>		<span class="n">quota</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln">6636</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cfs_quota_us</span> <span class="o">&lt;=</span> <span class="n">U64_MAX</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">)</span>
<span class="ln">6637</span>		<span class="n">quota</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">cfs_quota_us</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="ln">6638</span>	<span class="k">else</span>
<span class="ln">6639</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6640</span>
<span class="ln">6641</span>	<span class="k">return</span> <span class="n">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="ln">6642</span><span class="p">}</span>
<span class="ln">6643</span>
<span class="ln">6644</span><span class="kt">long</span> <span class="nf">tg_get_cfs_quota</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">6645</span><span class="p">{</span>
<span class="ln">6646</span>	<span class="n">u64</span> <span class="n">quota_us</span><span class="p">;</span>
<span class="ln">6647</span>
<span class="ln">6648</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
<span class="ln">6649</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln">6650</span>
<span class="ln">6651</span>	<span class="n">quota_us</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">quota</span><span class="p">;</span>
<span class="ln">6652</span>	<span class="n">do_div</span><span class="p">(</span><span class="n">quota_us</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
<span class="ln">6653</span>
<span class="ln">6654</span>	<span class="k">return</span> <span class="n">quota_us</span><span class="p">;</span>
<span class="ln">6655</span><span class="p">}</span>
<span class="ln">6656</span>
<span class="ln">6657</span><span class="kt">int</span> <span class="nf">tg_set_cfs_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">long</span> <span class="n">cfs_period_us</span><span class="p">)</span>
<span class="ln">6658</span><span class="p">{</span>
<span class="ln">6659</span>	<span class="n">u64</span> <span class="n">quota</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>
<span class="ln">6660</span>
<span class="ln">6661</span>	<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cfs_period_us</span> <span class="o">&gt;</span> <span class="n">U64_MAX</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">)</span>
<span class="ln">6662</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6663</span>
<span class="ln">6664</span>	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">cfs_period_us</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="ln">6665</span>	<span class="n">quota</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">quota</span><span class="p">;</span>
<span class="ln">6666</span>
<span class="ln">6667</span>	<span class="k">return</span> <span class="n">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="ln">6668</span><span class="p">}</span>
<span class="ln">6669</span>
<span class="ln">6670</span><span class="kt">long</span> <span class="nf">tg_get_cfs_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">6671</span><span class="p">{</span>
<span class="ln">6672</span>	<span class="n">u64</span> <span class="n">cfs_period_us</span><span class="p">;</span>
<span class="ln">6673</span>
<span class="ln">6674</span>	<span class="n">cfs_period_us</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">.</span><span class="n">period</span><span class="p">);</span>
<span class="ln">6675</span>	<span class="n">do_div</span><span class="p">(</span><span class="n">cfs_period_us</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
<span class="ln">6676</span>
<span class="ln">6677</span>	<span class="k">return</span> <span class="n">cfs_period_us</span><span class="p">;</span>
<span class="ln">6678</span><span class="p">}</span>
<span class="ln">6679</span>
<span class="ln">6680</span><span class="k">static</span> <span class="n">s64</span> <span class="nf">cpu_cfs_quota_read_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6681</span>				  <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6682</span><span class="p">{</span>
<span class="ln">6683</span>	<span class="k">return</span> <span class="n">tg_get_cfs_quota</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>
<span class="ln">6684</span><span class="p">}</span>
<span class="ln">6685</span>
<span class="ln">6686</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cfs_quota_write_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6687</span>				   <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span> <span class="n">s64</span> <span class="n">cfs_quota_us</span><span class="p">)</span>
<span class="ln">6688</span><span class="p">{</span>
<span class="ln">6689</span>	<span class="k">return</span> <span class="n">tg_set_cfs_quota</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">cfs_quota_us</span><span class="p">);</span>
<span class="ln">6690</span><span class="p">}</span>
<span class="ln">6691</span>
<span class="ln">6692</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_cfs_period_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6693</span>				   <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6694</span><span class="p">{</span>
<span class="ln">6695</span>	<span class="k">return</span> <span class="n">tg_get_cfs_period</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>
<span class="ln">6696</span><span class="p">}</span>
<span class="ln">6697</span>
<span class="ln">6698</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cfs_period_write_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6699</span>				    <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cfs_period_us</span><span class="p">)</span>
<span class="ln">6700</span><span class="p">{</span>
<span class="ln">6701</span>	<span class="k">return</span> <span class="n">tg_set_cfs_period</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">cfs_period_us</span><span class="p">);</span>
<span class="ln">6702</span><span class="p">}</span>
<span class="ln">6703</span>
<span class="ln">6704</span><span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="p">{</span>
<span class="ln">6705</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="ln">6706</span>	<span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">;</span>
<span class="ln">6707</span><span class="p">};</span>
<span class="ln">6708</span>
<span class="ln">6709</span><span class="cm">/*
</span><span class="ln">6710</span><span class="cm"> * normalize group quota/period to be quota/max_period
</span><span class="ln">6711</span><span class="cm"> * note: units are usecs
</span><span class="ln">6712</span><span class="cm"> */</span>
<span class="ln">6713</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">normalize_cfs_quota</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
<span class="ln">6714</span>			       <span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="ln">6715</span><span class="p">{</span>
<span class="ln">6716</span>	<span class="n">u64</span> <span class="n">quota</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>
<span class="ln">6717</span>
<span class="ln">6718</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6719</span>		<span class="n">period</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">;</span>
<span class="ln">6720</span>		<span class="n">quota</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">;</span>
<span class="ln">6721</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">6722</span>		<span class="n">period</span> <span class="o">=</span> <span class="n">tg_get_cfs_period</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6723</span>		<span class="n">quota</span> <span class="o">=</span> <span class="n">tg_get_cfs_quota</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">6724</span>	<span class="p">}</span>
<span class="ln">6725</span>
<span class="ln">6726</span>	<span class="cm">/* note: these should typically be equivalent */</span>
<span class="ln">6727</span>	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span> <span class="o">||</span> <span class="n">quota</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="ln">6728</span>		<span class="k">return</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln">6729</span>
<span class="ln">6730</span>	<span class="k">return</span> <span class="n">to_ratio</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="ln">6731</span><span class="p">}</span>
<span class="ln">6732</span>
<span class="ln">6733</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_cfs_schedulable_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln">6734</span><span class="p">{</span>
<span class="ln">6735</span>	<span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="ln">6736</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln">6737</span>	<span class="n">s64</span> <span class="n">quota</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">parent_quota</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln">6738</span>
<span class="ln">6739</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6740</span>		<span class="n">quota</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln">6741</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">6742</span>		<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">parent_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln">6743</span>
<span class="ln">6744</span>		<span class="n">quota</span> <span class="o">=</span> <span class="n">normalize_cfs_quota</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="ln">6745</span>		<span class="n">parent_quota</span> <span class="o">=</span> <span class="n">parent_b</span><span class="o">-&gt;</span><span class="n">hierarchical_quota</span><span class="p">;</span>
<span class="ln">6746</span>
<span class="ln">6747</span>		<span class="cm">/*
</span><span class="ln">6748</span><span class="cm">		 * Ensure max(child_quota) &lt;= parent_quota.  On cgroup2,
</span><span class="ln">6749</span><span class="cm">		 * always take the min.  On cgroup1, only inherit when no
</span><span class="ln">6750</span><span class="cm">		 * limit is set:
</span><span class="ln">6751</span><span class="cm">		 */</span>
<span class="ln">6752</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_subsys_on_dfl</span><span class="p">(</span><span class="n">cpu_cgrp_subsys</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">6753</span>			<span class="n">quota</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">quota</span><span class="p">,</span> <span class="n">parent_quota</span><span class="p">);</span>
<span class="ln">6754</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">6755</span>			<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
<span class="ln">6756</span>				<span class="n">quota</span> <span class="o">=</span> <span class="n">parent_quota</span><span class="p">;</span>
<span class="ln">6757</span>			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">parent_quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span> <span class="o">&amp;&amp;</span> <span class="n">quota</span> <span class="o">&gt;</span> <span class="n">parent_quota</span><span class="p">)</span>
<span class="ln">6758</span>				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6759</span>		<span class="p">}</span>
<span class="ln">6760</span>	<span class="p">}</span>
<span class="ln">6761</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">hierarchical_quota</span> <span class="o">=</span> <span class="n">quota</span><span class="p">;</span>
<span class="ln">6762</span>
<span class="ln">6763</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6764</span><span class="p">}</span>
<span class="ln">6765</span>
<span class="ln">6766</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">__cfs_schedulable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">u64</span> <span class="n">quota</span><span class="p">)</span>
<span class="ln">6767</span><span class="p">{</span>
<span class="ln">6768</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">6769</span>	<span class="k">struct</span> <span class="n">cfs_schedulable_data</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">6770</span>		<span class="p">.</span><span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="p">,</span>
<span class="ln">6771</span>		<span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">,</span>
<span class="ln">6772</span>		<span class="p">.</span><span class="n">quota</span> <span class="o">=</span> <span class="n">quota</span><span class="p">,</span>
<span class="ln">6773</span>	<span class="p">};</span>
<span class="ln">6774</span>
<span class="ln">6775</span>	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6776</span>		<span class="n">do_div</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">period</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
<span class="ln">6777</span>		<span class="n">do_div</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">quota</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
<span class="ln">6778</span>	<span class="p">}</span>
<span class="ln">6779</span>
<span class="ln">6780</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">6781</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_tg_tree</span><span class="p">(</span><span class="n">tg_cfs_schedulable_down</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="ln">6782</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">6783</span>
<span class="ln">6784</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">6785</span><span class="p">}</span>
<span class="ln">6786</span>
<span class="ln">6787</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_cfs_stat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="ln">6788</span><span class="p">{</span>
<span class="ln">6789</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">seq_css</span><span class="p">(</span><span class="n">sf</span><span class="p">));</span>
<span class="ln">6790</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln">6791</span>
<span class="ln">6792</span>	<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;nr_periods %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_periods</span><span class="p">);</span>
<span class="ln">6793</span>	<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;nr_throttled %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_throttled</span><span class="p">);</span>
<span class="ln">6794</span>	<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;throttled_time %llu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_time</span><span class="p">);</span>
<span class="ln">6795</span>
<span class="ln">6796</span>	<span class="k">if</span> <span class="p">(</span><span class="n">schedstat_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">tg</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6797</span>		<span class="n">u64</span> <span class="n">ws</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6798</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">6799</span>
<span class="ln">6800</span>		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="ln">6801</span>			<span class="n">ws</span> <span class="o">+=</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_sum</span><span class="p">);</span>
<span class="ln">6802</span>
<span class="ln">6803</span>		<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;wait_sum %llu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ws</span><span class="p">);</span>
<span class="ln">6804</span>	<span class="p">}</span>
<span class="ln">6805</span>
<span class="ln">6806</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6807</span><span class="p">}</span>
<span class="ln">6808</span><span class="cp">#endif </span><span class="cm">/* CONFIG_CFS_BANDWIDTH */</span><span class="cp">
</span><span class="ln">6809</span><span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">6810</span><span class="cp"></span>
<span class="ln">6811</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">6812</span><span class="cp"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_rt_runtime_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6813</span>				<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">s64</span> <span class="n">val</span><span class="p">)</span>
<span class="ln">6814</span><span class="p">{</span>
<span class="ln">6815</span>	<span class="k">return</span> <span class="n">sched_group_set_rt_runtime</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>
<span class="ln">6816</span><span class="p">}</span>
<span class="ln">6817</span>
<span class="ln">6818</span><span class="k">static</span> <span class="n">s64</span> <span class="nf">cpu_rt_runtime_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6819</span>			       <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6820</span><span class="p">{</span>
<span class="ln">6821</span>	<span class="k">return</span> <span class="n">sched_group_rt_runtime</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>
<span class="ln">6822</span><span class="p">}</span>
<span class="ln">6823</span>
<span class="ln">6824</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_rt_period_write_uint</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6825</span>				    <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cftype</span><span class="p">,</span> <span class="n">u64</span> <span class="n">rt_period_us</span><span class="p">)</span>
<span class="ln">6826</span><span class="p">{</span>
<span class="ln">6827</span>	<span class="k">return</span> <span class="n">sched_group_set_rt_period</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">rt_period_us</span><span class="p">);</span>
<span class="ln">6828</span><span class="p">}</span>
<span class="ln">6829</span>
<span class="ln">6830</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_rt_period_read_uint</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6831</span>				   <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6832</span><span class="p">{</span>
<span class="ln">6833</span>	<span class="k">return</span> <span class="n">sched_group_rt_period</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">));</span>
<span class="ln">6834</span><span class="p">}</span>
<span class="ln">6835</span><span class="cp">#endif </span><span class="cm">/* CONFIG_RT_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">6836</span><span class="cp"></span>
<span class="ln">6837</span><span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">cpu_legacy_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">6838</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">6839</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln">6840</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;shares&#34;</span><span class="p">,</span>
<span class="ln">6841</span>		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_shares_read_u64</span><span class="p">,</span>
<span class="ln">6842</span>		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_shares_write_u64</span><span class="p">,</span>
<span class="ln">6843</span>	<span class="p">},</span>
<span class="ln">6844</span><span class="cp">#endif
</span><span class="ln">6845</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln">6846</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln">6847</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;cfs_quota_us&#34;</span><span class="p">,</span>
<span class="ln">6848</span>		<span class="p">.</span><span class="n">read_s64</span> <span class="o">=</span> <span class="n">cpu_cfs_quota_read_s64</span><span class="p">,</span>
<span class="ln">6849</span>		<span class="p">.</span><span class="n">write_s64</span> <span class="o">=</span> <span class="n">cpu_cfs_quota_write_s64</span><span class="p">,</span>
<span class="ln">6850</span>	<span class="p">},</span>
<span class="ln">6851</span>	<span class="p">{</span>
<span class="ln">6852</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;cfs_period_us&#34;</span><span class="p">,</span>
<span class="ln">6853</span>		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_cfs_period_read_u64</span><span class="p">,</span>
<span class="ln">6854</span>		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_cfs_period_write_u64</span><span class="p">,</span>
<span class="ln">6855</span>	<span class="p">},</span>
<span class="ln">6856</span>	<span class="p">{</span>
<span class="ln">6857</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;stat&#34;</span><span class="p">,</span>
<span class="ln">6858</span>		<span class="p">.</span><span class="n">seq_show</span> <span class="o">=</span> <span class="n">cpu_cfs_stat_show</span><span class="p">,</span>
<span class="ln">6859</span>	<span class="p">},</span>
<span class="ln">6860</span><span class="cp">#endif
</span><span class="ln">6861</span><span class="cp">#ifdef CONFIG_RT_GROUP_SCHED
</span><span class="ln">6862</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln">6863</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;rt_runtime_us&#34;</span><span class="p">,</span>
<span class="ln">6864</span>		<span class="p">.</span><span class="n">read_s64</span> <span class="o">=</span> <span class="n">cpu_rt_runtime_read</span><span class="p">,</span>
<span class="ln">6865</span>		<span class="p">.</span><span class="n">write_s64</span> <span class="o">=</span> <span class="n">cpu_rt_runtime_write</span><span class="p">,</span>
<span class="ln">6866</span>	<span class="p">},</span>
<span class="ln">6867</span>	<span class="p">{</span>
<span class="ln">6868</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;rt_period_us&#34;</span><span class="p">,</span>
<span class="ln">6869</span>		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_rt_period_read_uint</span><span class="p">,</span>
<span class="ln">6870</span>		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_rt_period_write_uint</span><span class="p">,</span>
<span class="ln">6871</span>	<span class="p">},</span>
<span class="ln">6872</span><span class="cp">#endif
</span><span class="ln">6873</span><span class="cp"></span>	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* Terminate */</span>
<span class="ln">6874</span><span class="p">};</span>
<span class="ln">6875</span>
<span class="ln">6876</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_extra_stat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span>
<span class="ln">6877</span>			       <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">)</span>
<span class="ln">6878</span><span class="p">{</span>
<span class="ln">6879</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln">6880</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln">6881</span>		<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="ln">6882</span>		<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln">6883</span>		<span class="n">u64</span> <span class="n">throttled_usec</span><span class="p">;</span>
<span class="ln">6884</span>
<span class="ln">6885</span>		<span class="n">throttled_usec</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_time</span><span class="p">;</span>
<span class="ln">6886</span>		<span class="n">do_div</span><span class="p">(</span><span class="n">throttled_usec</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
<span class="ln">6887</span>
<span class="ln">6888</span>		<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;nr_periods %d</span><span class="se">\n</span><span class="s">&#34;</span>
<span class="ln">6889</span>			   <span class="s">&#34;nr_throttled %d</span><span class="se">\n</span><span class="s">&#34;</span>
<span class="ln">6890</span>			   <span class="s">&#34;throttled_usec %llu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln">6891</span>			   <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_periods</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_throttled</span><span class="p">,</span>
<span class="ln">6892</span>			   <span class="n">throttled_usec</span><span class="p">);</span>
<span class="ln">6893</span>	<span class="p">}</span>
<span class="ln">6894</span><span class="cp">#endif
</span><span class="ln">6895</span><span class="cp"></span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6896</span><span class="p">}</span>
<span class="ln">6897</span>
<span class="ln">6898</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">6899</span><span class="cp"></span><span class="k">static</span> <span class="n">u64</span> <span class="nf">cpu_weight_read_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6900</span>			       <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6901</span><span class="p">{</span>
<span class="ln">6902</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">);</span>
<span class="ln">6903</span>	<span class="n">u64</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">);</span>
<span class="ln">6904</span>
<span class="ln">6905</span>	<span class="k">return</span> <span class="n">DIV_ROUND_CLOSEST_ULL</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">CGROUP_WEIGHT_DFL</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
<span class="ln">6906</span><span class="p">}</span>
<span class="ln">6907</span>
<span class="ln">6908</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_weight_write_u64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6909</span>				<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">weight</span><span class="p">)</span>
<span class="ln">6910</span><span class="p">{</span>
<span class="ln">6911</span>	<span class="cm">/*
</span><span class="ln">6912</span><span class="cm">	 * cgroup weight knobs should use the common MIN, DFL and MAX
</span><span class="ln">6913</span><span class="cm">	 * values which are 1, 100 and 10000 respectively.  While it loses
</span><span class="ln">6914</span><span class="cm">	 * a bit of range on both ends, it maps pretty well onto the shares
</span><span class="ln">6915</span><span class="cm">	 * value used by scheduler and the round-trip conversions preserve
</span><span class="ln">6916</span><span class="cm">	 * the original value over the entire range.
</span><span class="ln">6917</span><span class="cm">	 */</span>
<span class="ln">6918</span>	<span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;</span> <span class="n">CGROUP_WEIGHT_MIN</span> <span class="o">||</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="n">CGROUP_WEIGHT_MAX</span><span class="p">)</span>
<span class="ln">6919</span>		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="ln">6920</span>
<span class="ln">6921</span>	<span class="n">weight</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST_ULL</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">CGROUP_WEIGHT_DFL</span><span class="p">);</span>
<span class="ln">6922</span>
<span class="ln">6923</span>	<span class="k">return</span> <span class="n">sched_group_set_shares</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">weight</span><span class="p">));</span>
<span class="ln">6924</span><span class="p">}</span>
<span class="ln">6925</span>
<span class="ln">6926</span><span class="k">static</span> <span class="n">s64</span> <span class="nf">cpu_weight_nice_read_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6927</span>				    <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="ln">6928</span><span class="p">{</span>
<span class="ln">6929</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">);</span>
<span class="ln">6930</span>	<span class="kt">int</span> <span class="n">last_delta</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
<span class="ln">6931</span>	<span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln">6932</span>
<span class="ln">6933</span>	<span class="cm">/* find the closest nice value to the current weight */</span>
<span class="ln">6934</span>	<span class="k">for</span> <span class="p">(</span><span class="n">prio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prio</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sched_prio_to_weight</span><span class="p">);</span> <span class="n">prio</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6935</span>		<span class="n">delta</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">sched_prio_to_weight</span><span class="p">[</span><span class="n">prio</span><span class="p">]</span> <span class="o">-</span> <span class="n">weight</span><span class="p">);</span>
<span class="ln">6936</span>		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;=</span> <span class="n">last_delta</span><span class="p">)</span>
<span class="ln">6937</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln">6938</span>		<span class="n">last_delta</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln">6939</span>	<span class="p">}</span>
<span class="ln">6940</span>
<span class="ln">6941</span>	<span class="k">return</span> <span class="n">PRIO_TO_NICE</span><span class="p">(</span><span class="n">prio</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">MAX_RT_PRIO</span><span class="p">);</span>
<span class="ln">6942</span><span class="p">}</span>
<span class="ln">6943</span>
<span class="ln">6944</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_weight_nice_write_s64</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">,</span>
<span class="ln">6945</span>				     <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">s64</span> <span class="n">nice</span><span class="p">)</span>
<span class="ln">6946</span><span class="p">{</span>
<span class="ln">6947</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">;</span>
<span class="ln">6948</span>	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
<span class="ln">6949</span>
<span class="ln">6950</span>	<span class="k">if</span> <span class="p">(</span><span class="n">nice</span> <span class="o">&lt;</span> <span class="n">MIN_NICE</span> <span class="o">||</span> <span class="n">nice</span> <span class="o">&gt;</span> <span class="n">MAX_NICE</span><span class="p">)</span>
<span class="ln">6951</span>		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="ln">6952</span>
<span class="ln">6953</span>	<span class="n">idx</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="n">nice</span><span class="p">)</span> <span class="o">-</span> <span class="n">MAX_RT_PRIO</span><span class="p">;</span>
<span class="ln">6954</span>	<span class="n">idx</span> <span class="o">=</span> <span class="n">array_index_nospec</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
<span class="ln">6955</span>	<span class="n">weight</span> <span class="o">=</span> <span class="n">sched_prio_to_weight</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="ln">6956</span>
<span class="ln">6957</span>	<span class="k">return</span> <span class="n">sched_group_set_shares</span><span class="p">(</span><span class="n">css_tg</span><span class="p">(</span><span class="n">css</span><span class="p">),</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">weight</span><span class="p">));</span>
<span class="ln">6958</span><span class="p">}</span>
<span class="ln">6959</span><span class="cp">#endif
</span><span class="ln">6960</span><span class="cp"></span>
<span class="ln">6961</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__maybe_unused</span> <span class="nf">cpu_period_quota_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span>
<span class="ln">6962</span>						  <span class="kt">long</span> <span class="n">period</span><span class="p">,</span> <span class="kt">long</span> <span class="n">quota</span><span class="p">)</span>
<span class="ln">6963</span><span class="p">{</span>
<span class="ln">6964</span>	<span class="k">if</span> <span class="p">(</span><span class="n">quota</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">6965</span>		<span class="n">seq_puts</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;max&#34;</span><span class="p">);</span>
<span class="ln">6966</span>	<span class="k">else</span>
<span class="ln">6967</span>		<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34;%ld&#34;</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="ln">6968</span>
<span class="ln">6969</span>	<span class="n">seq_printf</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="s">&#34; %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="ln">6970</span><span class="p">}</span>
<span class="ln">6971</span>
<span class="ln">6972</span><span class="cm">/* caller should put the current value in *@periodp before calling */</span>
<span class="ln">6973</span><span class="k">static</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="nf">cpu_period_quota_parse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
<span class="ln">6974</span>						 <span class="n">u64</span> <span class="o">*</span><span class="n">periodp</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">quotap</span><span class="p">)</span>
<span class="ln">6975</span><span class="p">{</span>
<span class="ln">6976</span>	<span class="kt">char</span> <span class="n">tok</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>	<span class="cm">/* U64_MAX */</span>
<span class="ln">6977</span>
<span class="ln">6978</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;%20s %llu&#34;</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">periodp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln">6979</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6980</span>
<span class="ln">6981</span>	<span class="o">*</span><span class="n">periodp</span> <span class="o">*=</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="ln">6982</span>
<span class="ln">6983</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">&#34;%llu&#34;</span><span class="p">,</span> <span class="n">quotap</span><span class="p">))</span>
<span class="ln">6984</span>		<span class="o">*</span><span class="n">quotap</span> <span class="o">*=</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="ln">6985</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">&#34;max&#34;</span><span class="p">))</span>
<span class="ln">6986</span>		<span class="o">*</span><span class="n">quotap</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln">6987</span>	<span class="k">else</span>
<span class="ln">6988</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">6989</span>
<span class="ln">6990</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">6991</span><span class="p">}</span>
<span class="ln">6992</span>
<span class="ln">6993</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln">6994</span><span class="cp"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">cpu_max_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">sf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="ln">6995</span><span class="p">{</span>
<span class="ln">6996</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">seq_css</span><span class="p">(</span><span class="n">sf</span><span class="p">));</span>
<span class="ln">6997</span>
<span class="ln">6998</span>	<span class="n">cpu_period_quota_print</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">tg_get_cfs_period</span><span class="p">(</span><span class="n">tg</span><span class="p">),</span> <span class="n">tg_get_cfs_quota</span><span class="p">(</span><span class="n">tg</span><span class="p">));</span>
<span class="ln">6999</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">7000</span><span class="p">}</span>
<span class="ln">7001</span>
<span class="ln">7002</span><span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">cpu_max_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kernfs_open_file</span> <span class="o">*</span><span class="n">of</span><span class="p">,</span>
<span class="ln">7003</span>			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">)</span>
<span class="ln">7004</span><span class="p">{</span>
<span class="ln">7005</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">css_tg</span><span class="p">(</span><span class="n">of_css</span><span class="p">(</span><span class="n">of</span><span class="p">));</span>
<span class="ln">7006</span>	<span class="n">u64</span> <span class="n">period</span> <span class="o">=</span> <span class="n">tg_get_cfs_period</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln">7007</span>	<span class="n">u64</span> <span class="n">quota</span><span class="p">;</span>
<span class="ln">7008</span>	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">7009</span>
<span class="ln">7010</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">cpu_period_quota_parse</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quota</span><span class="p">);</span>
<span class="ln">7011</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
<span class="ln">7012</span>		<span class="n">ret</span> <span class="o">=</span> <span class="n">tg_set_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">quota</span><span class="p">);</span>
<span class="ln">7013</span>	<span class="k">return</span> <span class="n">ret</span> <span class="o">?:</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="ln">7014</span><span class="p">}</span>
<span class="ln">7015</span><span class="cp">#endif
</span><span class="ln">7016</span><span class="cp"></span>
<span class="ln">7017</span><span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">cpu_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">7018</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">7019</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln">7020</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;weight&#34;</span><span class="p">,</span>
<span class="ln">7021</span>		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CFTYPE_NOT_ON_ROOT</span><span class="p">,</span>
<span class="ln">7022</span>		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">cpu_weight_read_u64</span><span class="p">,</span>
<span class="ln">7023</span>		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">cpu_weight_write_u64</span><span class="p">,</span>
<span class="ln">7024</span>	<span class="p">},</span>
<span class="ln">7025</span>	<span class="p">{</span>
<span class="ln">7026</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;weight.nice&#34;</span><span class="p">,</span>
<span class="ln">7027</span>		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CFTYPE_NOT_ON_ROOT</span><span class="p">,</span>
<span class="ln">7028</span>		<span class="p">.</span><span class="n">read_s64</span> <span class="o">=</span> <span class="n">cpu_weight_nice_read_s64</span><span class="p">,</span>
<span class="ln">7029</span>		<span class="p">.</span><span class="n">write_s64</span> <span class="o">=</span> <span class="n">cpu_weight_nice_write_s64</span><span class="p">,</span>
<span class="ln">7030</span>	<span class="p">},</span>
<span class="ln">7031</span><span class="cp">#endif
</span><span class="ln">7032</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln">7033</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln">7034</span>		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;max&#34;</span><span class="p">,</span>
<span class="ln">7035</span>		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">CFTYPE_NOT_ON_ROOT</span><span class="p">,</span>
<span class="ln">7036</span>		<span class="p">.</span><span class="n">seq_show</span> <span class="o">=</span> <span class="n">cpu_max_show</span><span class="p">,</span>
<span class="ln">7037</span>		<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">cpu_max_write</span><span class="p">,</span>
<span class="ln">7038</span>	<span class="p">},</span>
<span class="ln">7039</span><span class="cp">#endif
</span><span class="ln">7040</span><span class="cp"></span>	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate */</span>
<span class="ln">7041</span><span class="p">};</span>
<span class="ln">7042</span>
<span class="ln">7043</span><span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">cpu_cgrp_subsys</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">7044</span>	<span class="p">.</span><span class="n">css_alloc</span>	<span class="o">=</span> <span class="n">cpu_cgroup_css_alloc</span><span class="p">,</span>
<span class="ln">7045</span>	<span class="p">.</span><span class="n">css_online</span>	<span class="o">=</span> <span class="n">cpu_cgroup_css_online</span><span class="p">,</span>
<span class="ln">7046</span>	<span class="p">.</span><span class="n">css_released</span>	<span class="o">=</span> <span class="n">cpu_cgroup_css_released</span><span class="p">,</span>
<span class="ln">7047</span>	<span class="p">.</span><span class="n">css_free</span>	<span class="o">=</span> <span class="n">cpu_cgroup_css_free</span><span class="p">,</span>
<span class="ln">7048</span>	<span class="p">.</span><span class="n">css_extra_stat_show</span> <span class="o">=</span> <span class="n">cpu_extra_stat_show</span><span class="p">,</span>
<span class="ln">7049</span>	<span class="p">.</span><span class="n">fork</span>		<span class="o">=</span> <span class="n">cpu_cgroup_fork</span><span class="p">,</span>
<span class="ln">7050</span>	<span class="p">.</span><span class="n">can_attach</span>	<span class="o">=</span> <span class="n">cpu_cgroup_can_attach</span><span class="p">,</span>
<span class="ln">7051</span>	<span class="p">.</span><span class="n">attach</span>		<span class="o">=</span> <span class="n">cpu_cgroup_attach</span><span class="p">,</span>
<span class="ln">7052</span>	<span class="p">.</span><span class="n">legacy_cftypes</span>	<span class="o">=</span> <span class="n">cpu_legacy_files</span><span class="p">,</span>
<span class="ln">7053</span>	<span class="p">.</span><span class="n">dfl_cftypes</span>	<span class="o">=</span> <span class="n">cpu_files</span><span class="p">,</span>
<span class="ln">7054</span>	<span class="p">.</span><span class="n">early_init</span>	<span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="ln">7055</span>	<span class="p">.</span><span class="n">threaded</span>	<span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="ln">7056</span><span class="p">};</span>
<span class="ln">7057</span>
<span class="ln">7058</span><span class="cp">#endif	</span><span class="cm">/* CONFIG_CGROUP_SCHED */</span><span class="cp">
</span><span class="ln">7059</span><span class="cp"></span>
<span class="ln">7060</span><span class="kt">void</span> <span class="nf">dump_cpu_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">7061</span><span class="p">{</span>
<span class="ln">7062</span>	<span class="n">pr_info</span><span class="p">(</span><span class="s">&#34;Task dump for CPU %d:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">7063</span>	<span class="n">sched_show_task</span><span class="p">(</span><span class="n">cpu_curr</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln">7064</span><span class="p">}</span>
<span class="ln">7065</span>
<span class="ln">7066</span><span class="cm">/*
</span><span class="ln">7067</span><span class="cm"> * Nice levels are multiplicative, with a gentle 10% change for every
</span><span class="ln">7068</span><span class="cm"> * nice level changed. I.e. when a CPU-bound task goes from nice 0 to
</span><span class="ln">7069</span><span class="cm"> * nice 1, it will get ~10% less CPU time than another CPU-bound task
</span><span class="ln">7070</span><span class="cm"> * that remained on nice 0.
</span><span class="ln">7071</span><span class="cm"> *
</span><span class="ln">7072</span><span class="cm"> * The &#34;10% effect&#34; is relative and cumulative: from _any_ nice level,
</span><span class="ln">7073</span><span class="cm"> * if you go up 1 level, it&#39;s -10% CPU usage, if you go down 1 level
</span><span class="ln">7074</span><span class="cm"> * it&#39;s +10% CPU usage. (to achieve that we use a multiplier of 1.25.
</span><span class="ln">7075</span><span class="cm"> * If a task goes up by ~10% and another task goes down by ~10% then
</span><span class="ln">7076</span><span class="cm"> * the relative distance between them is ~25%.)
</span><span class="ln">7077</span><span class="cm"> */</span>
<span class="ln">7078</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sched_prio_to_weight</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">7079</span> <span class="cm">/* -20 */</span>     <span class="mi">88761</span><span class="p">,</span>     <span class="mi">71755</span><span class="p">,</span>     <span class="mi">56483</span><span class="p">,</span>     <span class="mi">46273</span><span class="p">,</span>     <span class="mi">36291</span><span class="p">,</span>
<span class="ln">7080</span> <span class="cm">/* -15 */</span>     <span class="mi">29154</span><span class="p">,</span>     <span class="mi">23254</span><span class="p">,</span>     <span class="mi">18705</span><span class="p">,</span>     <span class="mi">14949</span><span class="p">,</span>     <span class="mi">11916</span><span class="p">,</span>
<span class="ln">7081</span> <span class="cm">/* -10 */</span>      <span class="mi">9548</span><span class="p">,</span>      <span class="mi">7620</span><span class="p">,</span>      <span class="mi">6100</span><span class="p">,</span>      <span class="mi">4904</span><span class="p">,</span>      <span class="mi">3906</span><span class="p">,</span>
<span class="ln">7082</span> <span class="cm">/*  -5 */</span>      <span class="mi">3121</span><span class="p">,</span>      <span class="mi">2501</span><span class="p">,</span>      <span class="mi">1991</span><span class="p">,</span>      <span class="mi">1586</span><span class="p">,</span>      <span class="mi">1277</span><span class="p">,</span>
<span class="ln">7083</span> <span class="cm">/*   0 */</span>      <span class="mi">1024</span><span class="p">,</span>       <span class="mi">820</span><span class="p">,</span>       <span class="mi">655</span><span class="p">,</span>       <span class="mi">526</span><span class="p">,</span>       <span class="mi">423</span><span class="p">,</span>
<span class="ln">7084</span> <span class="cm">/*   5 */</span>       <span class="mi">335</span><span class="p">,</span>       <span class="mi">272</span><span class="p">,</span>       <span class="mi">215</span><span class="p">,</span>       <span class="mi">172</span><span class="p">,</span>       <span class="mi">137</span><span class="p">,</span>
<span class="ln">7085</span> <span class="cm">/*  10 */</span>       <span class="mi">110</span><span class="p">,</span>        <span class="mi">87</span><span class="p">,</span>        <span class="mi">70</span><span class="p">,</span>        <span class="mi">56</span><span class="p">,</span>        <span class="mi">45</span><span class="p">,</span>
<span class="ln">7086</span> <span class="cm">/*  15 */</span>        <span class="mi">36</span><span class="p">,</span>        <span class="mi">29</span><span class="p">,</span>        <span class="mi">23</span><span class="p">,</span>        <span class="mi">18</span><span class="p">,</span>        <span class="mi">15</span><span class="p">,</span>
<span class="ln">7087</span><span class="p">};</span>
<span class="ln">7088</span>
<span class="ln">7089</span><span class="cm">/*
</span><span class="ln">7090</span><span class="cm"> * Inverse (2^32/x) values of the sched_prio_to_weight[] array, precalculated.
</span><span class="ln">7091</span><span class="cm"> *
</span><span class="ln">7092</span><span class="cm"> * In cases where the weight does not change often, we can use the
</span><span class="ln">7093</span><span class="cm"> * precalculated inverse to speed up arithmetics by turning divisions
</span><span class="ln">7094</span><span class="cm"> * into multiplications:
</span><span class="ln">7095</span><span class="cm"> */</span>
<span class="ln">7096</span><span class="k">const</span> <span class="n">u32</span> <span class="n">sched_prio_to_wmult</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">7097</span> <span class="cm">/* -20 */</span>     <span class="mi">48388</span><span class="p">,</span>     <span class="mi">59856</span><span class="p">,</span>     <span class="mi">76040</span><span class="p">,</span>     <span class="mi">92818</span><span class="p">,</span>    <span class="mi">118348</span><span class="p">,</span>
<span class="ln">7098</span> <span class="cm">/* -15 */</span>    <span class="mi">147320</span><span class="p">,</span>    <span class="mi">184698</span><span class="p">,</span>    <span class="mi">229616</span><span class="p">,</span>    <span class="mi">287308</span><span class="p">,</span>    <span class="mi">360437</span><span class="p">,</span>
<span class="ln">7099</span> <span class="cm">/* -10 */</span>    <span class="mi">449829</span><span class="p">,</span>    <span class="mi">563644</span><span class="p">,</span>    <span class="mi">704093</span><span class="p">,</span>    <span class="mi">875809</span><span class="p">,</span>   <span class="mi">1099582</span><span class="p">,</span>
<span class="ln">7100</span> <span class="cm">/*  -5 */</span>   <span class="mi">1376151</span><span class="p">,</span>   <span class="mi">1717300</span><span class="p">,</span>   <span class="mi">2157191</span><span class="p">,</span>   <span class="mi">2708050</span><span class="p">,</span>   <span class="mi">3363326</span><span class="p">,</span>
<span class="ln">7101</span> <span class="cm">/*   0 */</span>   <span class="mi">4194304</span><span class="p">,</span>   <span class="mi">5237765</span><span class="p">,</span>   <span class="mi">6557202</span><span class="p">,</span>   <span class="mi">8165337</span><span class="p">,</span>  <span class="mi">10153587</span><span class="p">,</span>
<span class="ln">7102</span> <span class="cm">/*   5 */</span>  <span class="mi">12820798</span><span class="p">,</span>  <span class="mi">15790321</span><span class="p">,</span>  <span class="mi">19976592</span><span class="p">,</span>  <span class="mi">24970740</span><span class="p">,</span>  <span class="mi">31350126</span><span class="p">,</span>
<span class="ln">7103</span> <span class="cm">/*  10 */</span>  <span class="mi">39045157</span><span class="p">,</span>  <span class="mi">49367440</span><span class="p">,</span>  <span class="mi">61356676</span><span class="p">,</span>  <span class="mi">76695844</span><span class="p">,</span>  <span class="mi">95443717</span><span class="p">,</span>
<span class="ln">7104</span> <span class="cm">/*  15 */</span> <span class="mi">119304647</span><span class="p">,</span> <span class="mi">148102320</span><span class="p">,</span> <span class="mi">186737708</span><span class="p">,</span> <span class="mi">238609294</span><span class="p">,</span> <span class="mi">286331153</span><span class="p">,</span>
<span class="ln">7105</span><span class="p">};</span>
<span class="ln">7106</span>
<span class="ln">7107</span><span class="cp">#undef CREATE_TRACE_POINTS
</span></code></pre></div></div><hr /><div class="post-navs d-flex mb-3 justify-content-evenly">
  <div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-left"></i>
    <a href="https://mengdemao.github.io/posts/rime/">Rime
</a>
  </div><div class="post-nav post-next">
    <a href="https://mengdemao.github.io/posts/task/">任务管理
</a>
    <i class="fas fa-fw fa-chevron-right"></i>
  </div></div><section class="related-posts-wrapper">
    <h3>相关文章</h3>
    <ul class="related-posts"><li><a href="https://mengdemao.github.io/posts/drivermodel/">驱动模型
</a></li></ul>
  </section></div>
    </article></div>
</div><aside class="col-lg-4 sidebar d-flex">
  <div class="container">
    
    <section class="card row text-center profile component">
  <div class="card-body">
    <div class="col-12 d-flex align-items-center justify-content-center"><img class="profile-avatar rounded-circle" alt="MengDemao" src="https://mengdemao.github.io/images/profile.webp" loading="lazy"
   width="400" height="400"
   />
</div>
    <div class="col-12 profile-meta"><div class="profile-name">MengDemao</div><div class="profile-bio">面向玄学编程</div><div class="profile-company"><i class="fas fa-fw fa-building"></i>Company</div><div class="profile-location"><i class="fas fa-fw fa-map-marker-alt"></i>Earth</div><div class="profile-about"><i class="fas fa-fw fa-user"></i><a href="https://mengdemao.github.io/about/">About</a></div></div>
  </div>
</section>
  <section class="recent-posts row card component">
  <div class="card-body">
    <h2 class="card-title">最近文章</h2>
    <ul><li><a href="https://mengdemao.github.io/posts/idle/">Idle
</a></li><li><a href="https://mengdemao.github.io/posts/fair/">Fair
</a></li><li><a href="https://mengdemao.github.io/posts/tkinter/">Tkinter
</a></li><li><a href="https://mengdemao.github.io/posts/javascript/">Javascript
</a></li><li><a href="https://mengdemao.github.io/posts/css/">Css
</a></li></ul>
  </div>
</section><section class="taxonomies row card component">
      <div class="card-body">
        <h2 class="card-title">
          <a href="https://mengdemao.github.io/categories">分类</a>
        </h2>
        <div><a href="https://mengdemao.github.io/categories/linux/" class="badge bg-primary text-white rounded post-taxonomy" title="linux">
            linux
          </a><a href="https://mengdemao.github.io/categories/python/" class="badge bg-primary text-white rounded post-taxonomy" title="python">
            python
          </a></div>
      </div>
    </section><section class="taxonomies row card component">
      <div class="card-body">
        <h2 class="card-title">
          <a href="https://mengdemao.github.io/tags">标签</a>
        </h2>
        <div><a href="https://mengdemao.github.io/tags/kernel/" class="badge bg-primary text-white rounded post-taxonomy" title="kernel">
            kernel
          </a><a href="https://mengdemao.github.io/tags/compiler/" class="badge bg-primary text-white rounded post-taxonomy" title="compiler">
            compiler
          </a><a href="https://mengdemao.github.io/tags/nfs/" class="badge bg-primary text-white rounded post-taxonomy" title="nfs">
            nfs
          </a><a href="https://mengdemao.github.io/tags/%E6%8A%80%E5%B7%A7/" class="badge bg-primary text-white rounded post-taxonomy" title="技巧">
            技巧
          </a><a href="https://mengdemao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="badge bg-primary text-white rounded post-taxonomy" title="编译原理">
            编译原理
          </a></div>
      </div>
    </section>
    
  </div>
</aside>
</div>
    </main><footer class="footer mt-auto py-3 text-center container"><nav class="social-links nav my-2 justify-content-center"></nav>
<div class="copyright mb-2">
  Copyright © 2020-2021 Meng Demao. All Rights Reserved.
</div>
<div class="powered-by mb-2">
  Powered by <a href="https://gohugo.io" target="_blank" rel="noopener noreferrer">Hugo</a> and the <a href="https://github.com/razonyang/hugo-theme-bootstrap" target="_blank" rel="noopener noreferrer">Bootstrap</a> theme.
</div></footer>
<script src="https://mengdemao.github.io/js/bundle.min.ff86187495d811f9ac53ffd5a4f5e354a1d40eae69710942f01287b2b63e20c6.js" integrity="sha256-/4YYdJXYEfmsU//VpPXjVKHUDq5pcQlC8BKHsrY&#43;IMY=" crossorigin="anonymous" defer></script><script defer src="https://mengdemao.github.io/js/viewer.min.2f6511f1e2b87cdacb7bdeedeadc1dcf2fc9f22db69f89b70fd5d91224f892a4.js" integrity="sha256-L2UR8eK4fNrLe97t6twdzy/J8i22n4m3D9XZEiT4kqQ=" crossorigin="anonymous"></script>
</body>
</html>

<!doctype html><html lang="zh-cn"
  >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Fair - 编程日志</title><link rel="apple-touch-icon" href="https://mengdemao.github.io/images/favicons/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="https://mengdemao.github.io/images/favicons/favicon-32x32.png" sizes="32x32" type="image/png">
<link rel="icon" href="https://mengdemao.github.io/images/favicons/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="https://mengdemao.github.io/images/favicons/manifest.json">
<link rel="icon" href="https://mengdemao.github.io/images/favicons/favicon.ico">
<meta name="keywords" content="sched" />
<meta name="description" content="" /><meta itemprop="name" content="Fair">
<meta itemprop="description" content="1// SPDX-License-Identifier: GPL-2.0 2/* 3* Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH) 4* 5* Copyright (C) 2007 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt; 6* 7* Interactivity improvements by Mike Galbraith 8* (C) 2007 Mike Galbraith &lt;efault@gmx.de&gt; 9* 10* Various enhancements by Dmitry Adamushko. 11* (C) 2007 Dmitry Adamushko &lt;dmitry.adamushko@gmail.com&gt; 12* 13* Group scheduling enhancements by Srivatsa Vaddagiri 14* Copyright IBM Corporation, 2007 15* Author: Srivatsa Vaddagiri &lt;vatsa@linux.vnet.ibm.com&gt; 16* 17* Scaled math optimizations by Thomas Gleixner 18* Copyright (C) 2007, Thomas Gleixner &lt;tglx@linutronix."><meta itemprop="datePublished" content="2021-10-28T07:40:31+08:00" />
<meta itemprop="dateModified" content="2021-10-28T07:40:31+08:00" />
<meta itemprop="wordCount" content="42417">
<meta itemprop="keywords" content="kernel," /><meta property="og:title" content="Fair" />
<meta property="og:description" content="1// SPDX-License-Identifier: GPL-2.0 2/* 3* Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH) 4* 5* Copyright (C) 2007 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt; 6* 7* Interactivity improvements by Mike Galbraith 8* (C) 2007 Mike Galbraith &lt;efault@gmx.de&gt; 9* 10* Various enhancements by Dmitry Adamushko. 11* (C) 2007 Dmitry Adamushko &lt;dmitry.adamushko@gmail.com&gt; 12* 13* Group scheduling enhancements by Srivatsa Vaddagiri 14* Copyright IBM Corporation, 2007 15* Author: Srivatsa Vaddagiri &lt;vatsa@linux.vnet.ibm.com&gt; 16* 17* Scaled math optimizations by Thomas Gleixner 18* Copyright (C) 2007, Thomas Gleixner &lt;tglx@linutronix." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mengdemao.github.io/posts/fair/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-28T07:40:31+08:00" />
<meta property="article:modified_time" content="2021-10-28T07:40:31+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fair"/>
<meta name="twitter:description" content="1// SPDX-License-Identifier: GPL-2.0 2/* 3* Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH) 4* 5* Copyright (C) 2007 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt; 6* 7* Interactivity improvements by Mike Galbraith 8* (C) 2007 Mike Galbraith &lt;efault@gmx.de&gt; 9* 10* Various enhancements by Dmitry Adamushko. 11* (C) 2007 Dmitry Adamushko &lt;dmitry.adamushko@gmail.com&gt; 12* 13* Group scheduling enhancements by Srivatsa Vaddagiri 14* Copyright IBM Corporation, 2007 15* Author: Srivatsa Vaddagiri &lt;vatsa@linux.vnet.ibm.com&gt; 16* 17* Scaled math optimizations by Thomas Gleixner 18* Copyright (C) 2007, Thomas Gleixner &lt;tglx@linutronix."/>
<link rel="preload" href="https://mengdemao.github.io/css/bundle.min.89b15c76d23b1055e418eed718cb78886010e537918653f0a43661ed56307392.css" integrity="sha256-ibFcdtI7EFXkGO7XGMt4iGAQ5TeRhlPwpDZh7VYwc5I=" crossorigin="anonymous" as="style" onload="this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://mengdemao.github.io/css/bundle.min.89b15c76d23b1055e418eed718cb78886010e537918653f0a43661ed56307392.css" integrity="sha256-ibFcdtI7EFXkGO7XGMt4iGAQ5TeRhlPwpDZh7VYwc5I=" crossorigin="anonymous"></noscript></head>
  <body><script src="https://mengdemao.github.io/js/bootstrap.min.b5d86dd3a5f60c90be38a252bb65fc1a2732f32e71dc12c051720f0c7aef3cde.js" integrity="sha256-tdht06X2DJC&#43;OKJSu2X8Gicy8y5x3BLAUXIPDHrvPN4=" crossorigin="anonymous"></script><header><nav class="navbar top-app-bar top-app-bar-expand-lg fixed-top">
  <div class="container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <i class="fas fa-bars"></i>
    </button><a class="navbar-brand me-3" href="https://mengdemao.github.io/"><img class="logo" alt="Logo" src="https://mengdemao.github.io/images/logo.webp" loading="lazy"
   width="136" height="69"
   />
编程日志
    </a>
    <button class="navbar-social-share" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSocialShare"
  aria-controls="offcanvasSocialShare" aria-label="Toggle social share">
  <i class="fas fa-share-alt"></i>
</button>

<div class="offcanvas offcanvas-bottom surface" tabindex="-1" id="offcanvasSocialShare" aria-labelledby="offcanvasSocialShare">
  <div class="offcanvas-header">
    <h3 class="offcanvas-title">Share</h3>
    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="offcanvas-body">
    <a class="btn btn-sm btn-outline-primary social-share-button" rel="noopener noreferrer" aria-label="Twitter Share Button"
      target="_blank" href="https://twitter.com/intent/tweet?title=Fair&url=https%3a%2f%2fmengdemao.github.io%2fposts%2ffair%2f">
      <i class="fab fa-fw fa-twitter"></i> Twitter
    </a>
    <a class="btn btn-sm btn-outline-primary social-share-button" rel="noopener noreferrer" aria-label="Facebook Share Button"
      target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmengdemao.github.io%2fposts%2ffair%2f">
      <i class="fab fa-fw fa-facebook-f"></i> Facebook
    </a>
  </div>
</div>

    <button class="navbar-settings" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSettings"
  aria-controls="offcanvasSettings" aria-label="Toggle settings">
  <i class="fas fa-ellipsis-v"></i>
</button>

<div class="offcanvas offcanvas-end surface h-100" tabindex="-1" id="offcanvasSettings" aria-labelledby="offcanvasSettings">
  <div class="offcanvas-header">
    <h3 class="offcanvas-title">设置</h3>
    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-dismiss="offcanvas" aria-label="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>
  <div class="offcanvas-body">

<section class="setting">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-adjust"></i> 模式</label>
    </div>
    <div class="col-auto ms-auto">
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="modeSwitcher">
      </div>
    </div>
  </form>
</section>

<section class="setting">
  <form class="font-size-switcher-form row">
    <div class="col-auto">
      <label for="fontSize" class="form-label"><i class="fas fa-fw fa-font"></i> 字体大小</label>
    </div>
    <div class="col-auto ms-auto">
      <input type="range" class="form-range" min="-2" max="2" id="fontSize">
    </div>
  </form>
</section>


<section class="setting palettes">
  <form class="row">
    <div class="col-auto">
      <label><i class="fas fa-fw fa-palette"></i> 配色</label>
    </div>
    <div class="col-auto ms-auto">
      <a id="btnPalette" class="btn btn-sm btn-outline-primary" role="button" aria-label="palettePicker">
        <i class="fas fa-eye-dropper"></i>
      </a>
    </div>
  </form>
  <div class="mt-2 d-flex visually-hidden" id="palettePicker"><button type="button" id="palette-blue" aria-label="蓝色"
        class="btn btn-sm palette" data-palette="blue">
      </button><button type="button" id="palette-blue-gray" aria-label="蓝灰色"
        class="btn btn-sm palette" data-palette="blue-gray">
      </button><button type="button" id="palette-brown" aria-label="棕色"
        class="btn btn-sm palette" data-palette="brown">
      </button></div>
</section>
</div>
</div>

    <div class="collapse navbar-collapse" tabindex="-1" id="navbarSupportedContent" aria-labelledby="navbarSupportedContent">
      <form class="search-bar my-1" action="https://mengdemao.github.io/search">
  <div class="input-group input-group-sm">
    <span class="btn btn-search disabled position-absolute left-0"><i class="fas fa-fw fa-search"></i></span>
    <input class="form-control rounded-pill" name="q" type="search" aria-label="Search">
  </div>
</form>

      <ul class="navbar-nav ms-auto"><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/archives/">
            <i class="fas fa-fw fa-file-archive"></i>归档
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/categories/">
            <i class="fas fa-fw fa-folder"></i>分类
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/tags/">
            <i class="fas fa-fw fa-tags"></i>标签
          </a>
        </li><li class="nav-item">
          <a class="nav-link" href="https://mengdemao.github.io/series/">
            <i class="fas fa-fw fa-columns"></i>专栏
          </a>
        </li><li class="nav-item dropdown">
          <a class="nav-link" id="navbarDropdown-dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            <i class="fas fa-fw fa-chevron-circle-down"></i>下拉菜单
          </a>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown-dropdown"><li>
              <a class="dropdown-item"
                href="https://github.com/mengdemao/mengdemao.github.io" target="_blank" rel="noopener noreferrer">
                <i class="fab fa-fw fa-github"></i>Github
              </a>
            </li><li>
              <a class="dropdown-item"
                href="https://mengdemao.github.io/zh-cn/series/manual">
                用户手册
              </a>
            </li></ul>
        </li></ul>
    </div>
  </div>
</nav>
</header>
<main role="main" class="container">
      <div class="row content">
<div class="col-lg-8">
  <div class="container"><nav class="row card component" aria-label="breadcrumb">
  <div class="card-body">
    <ol class="breadcrumb "><li class="breadcrumb-item"><a href="https://mengdemao.github.io/">主页</a></li><li class="breadcrumb-item"><a href="https://mengdemao.github.io/posts/">文章</a></li><li class="breadcrumb-item active">Fair</li></ol>
  </div>
</nav>    <article class="row card component mb-4 post"><div class="post-panel-wrapper">
  <div class="d-flex flex-column component rounded post-panel">
    
    <a id="sidebarToggler" class="action d-none d-lg-block" role="button">
  <i class="fas fa-fw fa-expand-alt" data-fa-transform="rotate-45"></i>
</a>
  
    

    
    <a class="action" data-bs-container="body" data-bs-toggle="popover" data-bs-html="true" data-bs-placement="bottom"
  data-bs-trigger="focus" tabindex="0" role="button" aria-label="Copyright" 
  data-bs-content="&lt;a target=&#34;_blank&#34; rel=&#34;license noopener noreferrer&#34; href=&#34;https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&#34;&gt;CC BY-NC-ND 4.0 &lt;i class=&#34;fab fa-fw fa-creative-commons&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-by&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-nc&#34;&gt;&lt;/i&gt;&lt;i class=&#34;fab fa-fw fa-creative-commons-nd&#34;&gt;&lt;/i&gt;&lt;/a&gt;
">
  <i class="fas fa-fw fa-copyright"></i>
</a>
    
    
  </div>
</div>
<div class="card-body">
        <h1 class="card-title my-3">Fair
</h1><div class="post-meta"><span class="post-date" title="created on">
    <i class="fas fa-fw fa-calendar-alt"></i>Oct 28, 2021
  </span><span class="post-reading-time" title="reading time">
    <i class="fas fa-fw fa-coffee"></i>200 分钟阅读
  </span><a href="https://mengdemao.github.io/categories/linux/" class="badge rounded-pill text-white bg-primary post-taxonomy">linux</a><a href="https://mengdemao.github.io/tags/kernel/" class="badge rounded-pill text-white bg-primary post-taxonomy">kernel</a></div>
<div class="post-content mb-3"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="ln">    1</span><span class="c1">// SPDX-License-Identifier: GPL-2.0
</span><span class="ln">    2</span><span class="c1"></span><span class="cm">/*
</span><span class="ln">    3</span><span class="cm"> * Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH)
</span><span class="ln">    4</span><span class="cm"> *
</span><span class="ln">    5</span><span class="cm"> *  Copyright (C) 2007 Red Hat, Inc., Ingo Molnar &lt;mingo@redhat.com&gt;
</span><span class="ln">    6</span><span class="cm"> *
</span><span class="ln">    7</span><span class="cm"> *  Interactivity improvements by Mike Galbraith
</span><span class="ln">    8</span><span class="cm"> *  (C) 2007 Mike Galbraith &lt;efault@gmx.de&gt;
</span><span class="ln">    9</span><span class="cm"> *
</span><span class="ln">   10</span><span class="cm"> *  Various enhancements by Dmitry Adamushko.
</span><span class="ln">   11</span><span class="cm"> *  (C) 2007 Dmitry Adamushko &lt;dmitry.adamushko@gmail.com&gt;
</span><span class="ln">   12</span><span class="cm"> *
</span><span class="ln">   13</span><span class="cm"> *  Group scheduling enhancements by Srivatsa Vaddagiri
</span><span class="ln">   14</span><span class="cm"> *  Copyright IBM Corporation, 2007
</span><span class="ln">   15</span><span class="cm"> *  Author: Srivatsa Vaddagiri &lt;vatsa@linux.vnet.ibm.com&gt;
</span><span class="ln">   16</span><span class="cm"> *
</span><span class="ln">   17</span><span class="cm"> *  Scaled math optimizations by Thomas Gleixner
</span><span class="ln">   18</span><span class="cm"> *  Copyright (C) 2007, Thomas Gleixner &lt;tglx@linutronix.de&gt;
</span><span class="ln">   19</span><span class="cm"> *
</span><span class="ln">   20</span><span class="cm"> *  Adaptive scheduling granularity, math enhancements by Peter Zijlstra
</span><span class="ln">   21</span><span class="cm"> *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra
</span><span class="ln">   22</span><span class="cm"> */</span>
<span class="ln">   23</span><span class="cp">#include</span> <span class="cpf">&#34;sched.h&#34;</span><span class="cp">
</span><span class="ln">   24</span><span class="cp"></span>
<span class="ln">   25</span><span class="cp">#include</span> <span class="cpf">&lt;trace/events/sched.h&gt;</span><span class="cp">
</span><span class="ln">   26</span><span class="cp"></span>
<span class="ln">   27</span><span class="cm">/*
</span><span class="ln">   28</span><span class="cm"> * Targeted preemption latency for CPU-bound tasks:
</span><span class="ln">   29</span><span class="cm"> *
</span><span class="ln">   30</span><span class="cm"> * NOTE: this latency value is not the same as the concept of
</span><span class="ln">   31</span><span class="cm"> * &#39;timeslice length&#39; - timeslices in CFS are of variable length
</span><span class="ln">   32</span><span class="cm"> * and have no persistent notion like in traditional, time-slice
</span><span class="ln">   33</span><span class="cm"> * based scheduling concepts.
</span><span class="ln">   34</span><span class="cm"> *
</span><span class="ln">   35</span><span class="cm"> * (to see the precise effective timeslice length of your workload,
</span><span class="ln">   36</span><span class="cm"> *  run vmstat and monitor the context-switches (cs) field)
</span><span class="ln">   37</span><span class="cm"> *
</span><span class="ln">   38</span><span class="cm"> * (default: 6ms * (1 + ilog(ncpus)), units: nanoseconds)
</span><span class="ln">   39</span><span class="cm"> */</span>
<span class="ln">   40</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_latency</span>			<span class="o">=</span> <span class="mi">6000000ULL</span><span class="p">;</span>
<span class="ln">   41</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">normalized_sysctl_sched_latency</span>		<span class="o">=</span> <span class="mi">6000000ULL</span><span class="p">;</span>
<span class="ln">   42</span>
<span class="ln">   43</span><span class="cm">/*
</span><span class="ln">   44</span><span class="cm"> * The initial- and re-scaling of tunables is configurable
</span><span class="ln">   45</span><span class="cm"> *
</span><span class="ln">   46</span><span class="cm"> * Options are:
</span><span class="ln">   47</span><span class="cm"> *
</span><span class="ln">   48</span><span class="cm"> *   SCHED_TUNABLESCALING_NONE - unscaled, always *1
</span><span class="ln">   49</span><span class="cm"> *   SCHED_TUNABLESCALING_LOG - scaled logarithmical, *1+ilog(ncpus)
</span><span class="ln">   50</span><span class="cm"> *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus
</span><span class="ln">   51</span><span class="cm"> *
</span><span class="ln">   52</span><span class="cm"> * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))
</span><span class="ln">   53</span><span class="cm"> */</span>
<span class="ln">   54</span><span class="k">enum</span> <span class="n">sched_tunable_scaling</span> <span class="n">sysctl_sched_tunable_scaling</span> <span class="o">=</span> <span class="n">SCHED_TUNABLESCALING_LOG</span><span class="p">;</span>
<span class="ln">   55</span>
<span class="ln">   56</span><span class="cm">/*
</span><span class="ln">   57</span><span class="cm"> * Minimal preemption granularity for CPU-bound tasks:
</span><span class="ln">   58</span><span class="cm"> *
</span><span class="ln">   59</span><span class="cm"> * (default: 0.75 msec * (1 + ilog(ncpus)), units: nanoseconds)
</span><span class="ln">   60</span><span class="cm"> */</span>
<span class="ln">   61</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_min_granularity</span>		<span class="o">=</span> <span class="mi">750000ULL</span><span class="p">;</span>
<span class="ln">   62</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">normalized_sysctl_sched_min_granularity</span>	<span class="o">=</span> <span class="mi">750000ULL</span><span class="p">;</span>
<span class="ln">   63</span>
<span class="ln">   64</span><span class="cm">/*
</span><span class="ln">   65</span><span class="cm"> * This value is kept at sysctl_sched_latency/sysctl_sched_min_granularity
</span><span class="ln">   66</span><span class="cm"> */</span>
<span class="ln">   67</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sched_nr_latency</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="ln">   68</span>
<span class="ln">   69</span><span class="cm">/*
</span><span class="ln">   70</span><span class="cm"> * After fork, child runs first. If set to 0 (default) then
</span><span class="ln">   71</span><span class="cm"> * parent will (try to) run first.
</span><span class="ln">   72</span><span class="cm"> */</span>
<span class="ln">   73</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_child_runs_first</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="ln">   74</span>
<span class="ln">   75</span><span class="cm">/*
</span><span class="ln">   76</span><span class="cm"> * SCHED_OTHER wake-up granularity.
</span><span class="ln">   77</span><span class="cm"> *
</span><span class="ln">   78</span><span class="cm"> * This option delays the preemption effects of decoupled workloads
</span><span class="ln">   79</span><span class="cm"> * and reduces their over-scheduling. Synchronous workloads will still
</span><span class="ln">   80</span><span class="cm"> * have immediate wakeup/sleep latencies.
</span><span class="ln">   81</span><span class="cm"> *
</span><span class="ln">   82</span><span class="cm"> * (default: 1 msec * (1 + ilog(ncpus)), units: nanoseconds)
</span><span class="ln">   83</span><span class="cm"> */</span>
<span class="ln">   84</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_wakeup_granularity</span>		<span class="o">=</span> <span class="mi">1000000UL</span><span class="p">;</span>
<span class="ln">   85</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">normalized_sysctl_sched_wakeup_granularity</span>	<span class="o">=</span> <span class="mi">1000000UL</span><span class="p">;</span>
<span class="ln">   86</span>
<span class="ln">   87</span><span class="n">const_debug</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_migration_cost</span>	<span class="o">=</span> <span class="mi">500000UL</span><span class="p">;</span>
<span class="ln">   88</span>
<span class="ln">   89</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">   90</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">   91</span><span class="cm"> * For asym packing, by default the lower numbered CPU has higher priority.
</span><span class="ln">   92</span><span class="cm"> */</span>
<span class="ln">   93</span><span class="kt">int</span> <span class="n">__weak</span> <span class="nf">arch_asym_cpu_priority</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">   94</span><span class="p">{</span>
<span class="ln">   95</span>	<span class="k">return</span> <span class="o">-</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln">   96</span><span class="p">}</span>
<span class="ln">   97</span><span class="cp">#endif
</span><span class="ln">   98</span><span class="cp"></span>
<span class="ln">   99</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln">  100</span><span class="cp"></span><span class="cm">/*
</span><span class="ln">  101</span><span class="cm"> * Amount of runtime to allocate from global (tg) to local (per-cfs_rq) pool
</span><span class="ln">  102</span><span class="cm"> * each time a cfs_rq requests quota.
</span><span class="ln">  103</span><span class="cm"> *
</span><span class="ln">  104</span><span class="cm"> * Note: in the case that the slice exceeds the runtime remaining (either due
</span><span class="ln">  105</span><span class="cm"> * to consumption or the quota being specified to be smaller than the slice)
</span><span class="ln">  106</span><span class="cm"> * we will always only issue the remaining available time.
</span><span class="ln">  107</span><span class="cm"> *
</span><span class="ln">  108</span><span class="cm"> * (default: 5 msec, units: microseconds)
</span><span class="ln">  109</span><span class="cm"> */</span>
<span class="ln">  110</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_sched_cfs_bandwidth_slice</span>		<span class="o">=</span> <span class="mi">5000UL</span><span class="p">;</span>
<span class="ln">  111</span><span class="cp">#endif
</span><span class="ln">  112</span><span class="cp"></span>
<span class="ln">  113</span><span class="cm">/*
</span><span class="ln">  114</span><span class="cm"> * The margin used when comparing utilization with CPU capacity:
</span><span class="ln">  115</span><span class="cm"> * util * margin &lt; capacity * 1024
</span><span class="ln">  116</span><span class="cm"> *
</span><span class="ln">  117</span><span class="cm"> * (default: ~20%)
</span><span class="ln">  118</span><span class="cm"> */</span>
<span class="ln">  119</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">capacity_margin</span>				<span class="o">=</span> <span class="mi">1280</span><span class="p">;</span>
<span class="ln">  120</span>
<span class="ln">  121</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_load_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">lw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inc</span><span class="p">)</span>
<span class="ln">  122</span><span class="p">{</span>
<span class="ln">  123</span>	<span class="n">lw</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
<span class="ln">  124</span>	<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  125</span><span class="p">}</span>
<span class="ln">  126</span>
<span class="ln">  127</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_load_sub</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">lw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dec</span><span class="p">)</span>
<span class="ln">  128</span><span class="p">{</span>
<span class="ln">  129</span>	<span class="n">lw</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">-=</span> <span class="n">dec</span><span class="p">;</span>
<span class="ln">  130</span>	<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  131</span><span class="p">}</span>
<span class="ln">  132</span>
<span class="ln">  133</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_load_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">lw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">w</span><span class="p">)</span>
<span class="ln">  134</span><span class="p">{</span>
<span class="ln">  135</span>	<span class="n">lw</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
<span class="ln">  136</span>	<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  137</span><span class="p">}</span>
<span class="ln">  138</span>
<span class="ln">  139</span><span class="cm">/*
</span><span class="ln">  140</span><span class="cm"> * Increase the granularity value when there are more CPUs,
</span><span class="ln">  141</span><span class="cm"> * because with more CPUs the &#39;effective latency&#39; as visible
</span><span class="ln">  142</span><span class="cm"> * to users decreases. But the relationship is not linear,
</span><span class="ln">  143</span><span class="cm"> * so pick a second-best guess by going with the log2 of the
</span><span class="ln">  144</span><span class="cm"> * number of CPUs.
</span><span class="ln">  145</span><span class="cm"> *
</span><span class="ln">  146</span><span class="cm"> * This idea comes from the SD scheduler of Con Kolivas:
</span><span class="ln">  147</span><span class="cm"> */</span>
<span class="ln">  148</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_update_sysctl_factor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">  149</span><span class="p">{</span>
<span class="ln">  150</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpus</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">(),</span> <span class="mi">8</span><span class="p">);</span>
<span class="ln">  151</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>
<span class="ln">  152</span>
<span class="ln">  153</span>	<span class="k">switch</span> <span class="p">(</span><span class="n">sysctl_sched_tunable_scaling</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  154</span>	<span class="k">case</span> <span class="nl">SCHED_TUNABLESCALING_NONE</span><span class="p">:</span>
<span class="ln">  155</span>		<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">  156</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">  157</span>	<span class="k">case</span> <span class="nl">SCHED_TUNABLESCALING_LINEAR</span><span class="p">:</span>
<span class="ln">  158</span>		<span class="n">factor</span> <span class="o">=</span> <span class="n">cpus</span><span class="p">;</span>
<span class="ln">  159</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">  160</span>	<span class="k">case</span> <span class="nl">SCHED_TUNABLESCALING_LOG</span><span class="p">:</span>
<span class="ln">  161</span>	<span class="k">default</span><span class="o">:</span>
<span class="ln">  162</span>		<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">cpus</span><span class="p">);</span>
<span class="ln">  163</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">  164</span>	<span class="p">}</span>
<span class="ln">  165</span>
<span class="ln">  166</span>	<span class="k">return</span> <span class="n">factor</span><span class="p">;</span>
<span class="ln">  167</span><span class="p">}</span>
<span class="ln">  168</span>
<span class="ln">  169</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_sysctl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">  170</span><span class="p">{</span>
<span class="ln">  171</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">get_update_sysctl_factor</span><span class="p">();</span>
<span class="ln">  172</span>
<span class="ln">  173</span><span class="cp">#define SET_SYSCTL(name) \
</span><span class="ln">  174</span><span class="cp">	(sysctl_##name = (factor) * normalized_sysctl_##name)
</span><span class="ln">  175</span><span class="cp"></span>	<span class="n">SET_SYSCTL</span><span class="p">(</span><span class="n">sched_min_granularity</span><span class="p">);</span>
<span class="ln">  176</span>	<span class="n">SET_SYSCTL</span><span class="p">(</span><span class="n">sched_latency</span><span class="p">);</span>
<span class="ln">  177</span>	<span class="n">SET_SYSCTL</span><span class="p">(</span><span class="n">sched_wakeup_granularity</span><span class="p">);</span>
<span class="ln">  178</span><span class="cp">#undef SET_SYSCTL
</span><span class="ln">  179</span><span class="cp"></span><span class="p">}</span>
<span class="ln">  180</span>
<span class="ln">  181</span><span class="kt">void</span> <span class="nf">sched_init_granularity</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">  182</span><span class="p">{</span>
<span class="ln">  183</span>	<span class="n">update_sysctl</span><span class="p">();</span>
<span class="ln">  184</span><span class="p">}</span>
<span class="ln">  185</span>
<span class="ln">  186</span><span class="cp">#define WMULT_CONST	(~0U)
</span><span class="ln">  187</span><span class="cp">#define WMULT_SHIFT	32
</span><span class="ln">  188</span><span class="cp"></span>
<span class="ln">  189</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__update_inv_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">lw</span><span class="p">)</span>
<span class="ln">  190</span><span class="p">{</span>
<span class="ln">  191</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">w</span><span class="p">;</span>
<span class="ln">  192</span>
<span class="ln">  193</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span><span class="p">))</span>
<span class="ln">  194</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  195</span>
<span class="ln">  196</span>	<span class="n">w</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">lw</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span>
<span class="ln">  197</span>
<span class="ln">  198</span>	<span class="k">if</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">&gt;</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="n">WMULT_CONST</span><span class="p">))</span>
<span class="ln">  199</span>		<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">  200</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">w</span><span class="p">))</span>
<span class="ln">  201</span>		<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">WMULT_CONST</span><span class="p">;</span>
<span class="ln">  202</span>	<span class="k">else</span>
<span class="ln">  203</span>		<span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">WMULT_CONST</span> <span class="o">/</span> <span class="n">w</span><span class="p">;</span>
<span class="ln">  204</span><span class="p">}</span>
<span class="ln">  205</span>
<span class="ln">  206</span><span class="cm">/*
</span><span class="ln">  207</span><span class="cm"> * delta_exec * weight / lw.weight
</span><span class="ln">  208</span><span class="cm"> *   OR
</span><span class="ln">  209</span><span class="cm"> * (delta_exec * (weight * lw-&gt;inv_weight)) &gt;&gt; WMULT_SHIFT
</span><span class="ln">  210</span><span class="cm"> *
</span><span class="ln">  211</span><span class="cm"> * Either weight := NICE_0_LOAD and lw \e sched_prio_to_wmult[], in which case
</span><span class="ln">  212</span><span class="cm"> * we&#39;re guaranteed shift stays positive because inv_weight is guaranteed to
</span><span class="ln">  213</span><span class="cm"> * fit 32 bits, and NICE_0_LOAD gives another 10 bits; therefore shift &gt;= 22.
</span><span class="ln">  214</span><span class="cm"> *
</span><span class="ln">  215</span><span class="cm"> * Or, weight =&lt; lw.weight (because lw.weight is the runqueue weight), thus
</span><span class="ln">  216</span><span class="cm"> * weight/lw.weight &lt;= 1, and therefore our shift will also be positive.
</span><span class="ln">  217</span><span class="cm"> */</span>
<span class="ln">  218</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">__calc_delta</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta_exec</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">,</span> <span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">lw</span><span class="p">)</span>
<span class="ln">  219</span><span class="p">{</span>
<span class="ln">  220</span>	<span class="n">u64</span> <span class="n">fact</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
<span class="ln">  221</span>	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">WMULT_SHIFT</span><span class="p">;</span>
<span class="ln">  222</span>
<span class="ln">  223</span>	<span class="n">__update_inv_weight</span><span class="p">(</span><span class="n">lw</span><span class="p">);</span>
<span class="ln">  224</span>
<span class="ln">  225</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fact</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  226</span>		<span class="k">while</span> <span class="p">(</span><span class="n">fact</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  227</span>			<span class="n">fact</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">  228</span>			<span class="n">shift</span><span class="o">--</span><span class="p">;</span>
<span class="ln">  229</span>		<span class="p">}</span>
<span class="ln">  230</span>	<span class="p">}</span>
<span class="ln">  231</span>
<span class="ln">  232</span>	<span class="cm">/* hint to use a 32x32-&gt;64 mul */</span>
<span class="ln">  233</span>	<span class="n">fact</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="n">u32</span><span class="p">)</span><span class="n">fact</span> <span class="o">*</span> <span class="n">lw</span><span class="o">-&gt;</span><span class="n">inv_weight</span><span class="p">;</span>
<span class="ln">  234</span>
<span class="ln">  235</span>	<span class="k">while</span> <span class="p">(</span><span class="n">fact</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  236</span>		<span class="n">fact</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">  237</span>		<span class="n">shift</span><span class="o">--</span><span class="p">;</span>
<span class="ln">  238</span>	<span class="p">}</span>
<span class="ln">  239</span>
<span class="ln">  240</span>	<span class="k">return</span> <span class="n">mul_u64_u32_shr</span><span class="p">(</span><span class="n">delta_exec</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
<span class="ln">  241</span><span class="p">}</span>
<span class="ln">  242</span>
<span class="ln">  243</span>
<span class="ln">  244</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fair_sched_class</span><span class="p">;</span>
<span class="ln">  245</span>
<span class="ln">  246</span><span class="cm">/**************************************************************
</span><span class="ln">  247</span><span class="cm"> * CFS operations on generic schedulable entities:
</span><span class="ln">  248</span><span class="cm"> */</span>
<span class="ln">  249</span>
<span class="ln">  250</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">  251</span><span class="cp"></span>
<span class="ln">  252</span><span class="cm">/* cpu runqueue to which this cfs_rq is attached */</span>
<span class="ln">  253</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  254</span><span class="p">{</span>
<span class="ln">  255</span>	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">  256</span><span class="p">}</span>
<span class="ln">  257</span>
<span class="ln">  258</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">task_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  259</span><span class="p">{</span>
<span class="ln">  260</span>	<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="ln">  261</span>	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln">  262</span><span class="p">}</span>
<span class="ln">  263</span>
<span class="ln">  264</span><span class="cm">/* Walk up scheduling entities hierarchy */</span>
<span class="ln">  265</span><span class="cp">#define for_each_sched_entity(se) \
</span><span class="ln">  266</span><span class="cp">		for (; se; se = se-&gt;parent)
</span><span class="ln">  267</span><span class="cp"></span>
<span class="ln">  268</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">task_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">  269</span><span class="p">{</span>
<span class="ln">  270</span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln">  271</span><span class="p">}</span>
<span class="ln">  272</span>
<span class="ln">  273</span><span class="cm">/* runqueue on which this entity is (to be) queued */</span>
<span class="ln">  274</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">cfs_rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  275</span><span class="p">{</span>
<span class="ln">  276</span>	<span class="k">return</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln">  277</span><span class="p">}</span>
<span class="ln">  278</span>
<span class="ln">  279</span><span class="cm">/* runqueue &#34;owned&#34; by this group */</span>
<span class="ln">  280</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">group_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="ln">  281</span><span class="p">{</span>
<span class="ln">  282</span>	<span class="k">return</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">;</span>
<span class="ln">  283</span><span class="p">}</span>
<span class="ln">  284</span>
<span class="ln">  285</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  286</span><span class="p">{</span>
<span class="ln">  287</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">  288</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">  289</span>
<span class="ln">  290</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span>
<span class="ln">  291</span>		<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">;</span>
<span class="ln">  292</span>
<span class="ln">  293</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">  294</span>
<span class="ln">  295</span>	<span class="cm">/*
</span><span class="ln">  296</span><span class="cm">	 * Ensure we either appear before our parent (if already
</span><span class="ln">  297</span><span class="cm">	 * enqueued) or force our parent to appear after us when it is
</span><span class="ln">  298</span><span class="cm">	 * enqueued. The fact that we always enqueue bottom-up
</span><span class="ln">  299</span><span class="cm">	 * reduces this to two cases and a special case for the root
</span><span class="ln">  300</span><span class="cm">	 * cfs_rq. Furthermore, it also means that we will always reset
</span><span class="ln">  301</span><span class="cm">	 * tmp_alone_branch either when the branch is connected
</span><span class="ln">  302</span><span class="cm">	 * to a tree or when we reach the top of the tree
</span><span class="ln">  303</span><span class="cm">	 */</span>
<span class="ln">  304</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span>
<span class="ln">  305</span>	    <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  306</span>		<span class="cm">/*
</span><span class="ln">  307</span><span class="cm">		 * If parent is already on the list, we add the child
</span><span class="ln">  308</span><span class="cm">		 * just before. Thanks to circular linked property of
</span><span class="ln">  309</span><span class="cm">		 * the list, this means to put the child at the tail
</span><span class="ln">  310</span><span class="cm">		 * of the list that starts by parent.
</span><span class="ln">  311</span><span class="cm">		 */</span>
<span class="ln">  312</span>		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">,</span>
<span class="ln">  313</span>			<span class="o">&amp;</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">));</span>
<span class="ln">  314</span>		<span class="cm">/*
</span><span class="ln">  315</span><span class="cm">		 * The branch is now connected to its tree so we can
</span><span class="ln">  316</span><span class="cm">		 * reset tmp_alone_branch to the beginning of the
</span><span class="ln">  317</span><span class="cm">		 * list.
</span><span class="ln">  318</span><span class="cm">		 */</span>
<span class="ln">  319</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">;</span>
<span class="ln">  320</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">  321</span>	<span class="p">}</span>
<span class="ln">  322</span>
<span class="ln">  323</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  324</span>		<span class="cm">/*
</span><span class="ln">  325</span><span class="cm">		 * cfs rq without parent should be put
</span><span class="ln">  326</span><span class="cm">		 * at the tail of the list.
</span><span class="ln">  327</span><span class="cm">		 */</span>
<span class="ln">  328</span>		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">,</span>
<span class="ln">  329</span>			<span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
<span class="ln">  330</span>		<span class="cm">/*
</span><span class="ln">  331</span><span class="cm">		 * We have reach the top of a tree so we can reset
</span><span class="ln">  332</span><span class="cm">		 * tmp_alone_branch to the beginning of the list.
</span><span class="ln">  333</span><span class="cm">		 */</span>
<span class="ln">  334</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">;</span>
<span class="ln">  335</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">  336</span>	<span class="p">}</span>
<span class="ln">  337</span>
<span class="ln">  338</span>	<span class="cm">/*
</span><span class="ln">  339</span><span class="cm">	 * The parent has not already been added so we want to
</span><span class="ln">  340</span><span class="cm">	 * make sure that it will be put after us.
</span><span class="ln">  341</span><span class="cm">	 * tmp_alone_branch points to the begin of the branch
</span><span class="ln">  342</span><span class="cm">	 * where we will add parent.
</span><span class="ln">  343</span><span class="cm">	 */</span>
<span class="ln">  344</span>	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span><span class="p">);</span>
<span class="ln">  345</span>	<span class="cm">/*
</span><span class="ln">  346</span><span class="cm">	 * update tmp_alone_branch to points to the new begin
</span><span class="ln">  347</span><span class="cm">	 * of the branch
</span><span class="ln">  348</span><span class="cm">	 */</span>
<span class="ln">  349</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">;</span>
<span class="ln">  350</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln">  351</span><span class="p">}</span>
<span class="ln">  352</span>
<span class="ln">  353</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  354</span><span class="p">{</span>
<span class="ln">  355</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  356</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">  357</span>
<span class="ln">  358</span>		<span class="cm">/*
</span><span class="ln">  359</span><span class="cm">		 * With cfs_rq being unthrottled/throttled during an enqueue,
</span><span class="ln">  360</span><span class="cm">		 * it can happen the tmp_alone_branch points the a leaf that
</span><span class="ln">  361</span><span class="cm">		 * we finally want to del. In this case, tmp_alone_branch moves
</span><span class="ln">  362</span><span class="cm">		 * to the prev element but it will point to rq-&gt;leaf_cfs_rq_list
</span><span class="ln">  363</span><span class="cm">		 * at the end of the enqueue.
</span><span class="ln">  364</span><span class="cm">		 */</span>
<span class="ln">  365</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">)</span>
<span class="ln">  366</span>			<span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
<span class="ln">  367</span>
<span class="ln">  368</span>		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
<span class="ln">  369</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">on_list</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  370</span>	<span class="p">}</span>
<span class="ln">  371</span><span class="p">}</span>
<span class="ln">  372</span>
<span class="ln">  373</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">assert_list_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">  374</span><span class="p">{</span>
<span class="ln">  375</span>	<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">tmp_alone_branch</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">leaf_cfs_rq_list</span><span class="p">);</span>
<span class="ln">  376</span><span class="p">}</span>
<span class="ln">  377</span>
<span class="ln">  378</span><span class="cm">/* Iterate thr&#39; all leaf cfs_rq&#39;s on a runqueue */</span>
<span class="ln">  379</span><span class="cp">#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)			\
</span><span class="ln">  380</span><span class="cp">	list_for_each_entry_safe(cfs_rq, pos, &amp;rq-&gt;leaf_cfs_rq_list,	\
</span><span class="ln">  381</span><span class="cp">				 leaf_cfs_rq_list)
</span><span class="ln">  382</span><span class="cp"></span>
<span class="ln">  383</span><span class="cm">/* Do the two (enqueued) entities belong to the same group ? */</span>
<span class="ln">  384</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span>
<span class="ln">  385</span><span class="nf">is_same_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">pse</span><span class="p">)</span>
<span class="ln">  386</span><span class="p">{</span>
<span class="ln">  387</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">==</span> <span class="n">pse</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  388</span>		<span class="k">return</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln">  389</span>
<span class="ln">  390</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  391</span><span class="p">}</span>
<span class="ln">  392</span>
<span class="ln">  393</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">parent_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  394</span><span class="p">{</span>
<span class="ln">  395</span>	<span class="k">return</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="ln">  396</span><span class="p">}</span>
<span class="ln">  397</span>
<span class="ln">  398</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln">  399</span><span class="nf">find_matching_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">pse</span><span class="p">)</span>
<span class="ln">  400</span><span class="p">{</span>
<span class="ln">  401</span>	<span class="kt">int</span> <span class="n">se_depth</span><span class="p">,</span> <span class="n">pse_depth</span><span class="p">;</span>
<span class="ln">  402</span>
<span class="ln">  403</span>	<span class="cm">/*
</span><span class="ln">  404</span><span class="cm">	 * preemption test can be made between sibling entities who are in the
</span><span class="ln">  405</span><span class="cm">	 * same cfs_rq i.e who have a common parent. Walk up the hierarchy of
</span><span class="ln">  406</span><span class="cm">	 * both tasks until we find their ancestors who are siblings of common
</span><span class="ln">  407</span><span class="cm">	 * parent.
</span><span class="ln">  408</span><span class="cm">	 */</span>
<span class="ln">  409</span>
<span class="ln">  410</span>	<span class="cm">/* First walk up until both entities are at same depth */</span>
<span class="ln">  411</span>	<span class="n">se_depth</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
<span class="ln">  412</span>	<span class="n">pse_depth</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pse</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
<span class="ln">  413</span>
<span class="ln">  414</span>	<span class="k">while</span> <span class="p">(</span><span class="n">se_depth</span> <span class="o">&gt;</span> <span class="n">pse_depth</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  415</span>		<span class="n">se_depth</span><span class="o">--</span><span class="p">;</span>
<span class="ln">  416</span>		<span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  417</span>	<span class="p">}</span>
<span class="ln">  418</span>
<span class="ln">  419</span>	<span class="k">while</span> <span class="p">(</span><span class="n">pse_depth</span> <span class="o">&gt;</span> <span class="n">se_depth</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  420</span>		<span class="n">pse_depth</span><span class="o">--</span><span class="p">;</span>
<span class="ln">  421</span>		<span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">pse</span><span class="p">);</span>
<span class="ln">  422</span>	<span class="p">}</span>
<span class="ln">  423</span>
<span class="ln">  424</span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_same_group</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="o">*</span><span class="n">pse</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  425</span>		<span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  426</span>		<span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="o">*</span><span class="n">pse</span><span class="p">);</span>
<span class="ln">  427</span>	<span class="p">}</span>
<span class="ln">  428</span><span class="p">}</span>
<span class="ln">  429</span>
<span class="ln">  430</span><span class="cp">#else	</span><span class="cm">/* !CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">  431</span><span class="cp"></span>
<span class="ln">  432</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">task_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  433</span><span class="p">{</span>
<span class="ln">  434</span>	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln">  435</span><span class="p">}</span>
<span class="ln">  436</span>
<span class="ln">  437</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  438</span><span class="p">{</span>
<span class="ln">  439</span>	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span><span class="p">,</span> <span class="n">cfs</span><span class="p">);</span>
<span class="ln">  440</span><span class="p">}</span>
<span class="ln">  441</span>
<span class="ln">  442</span>
<span class="ln">  443</span><span class="cp">#define for_each_sched_entity(se) \
</span><span class="ln">  444</span><span class="cp">		for (; se; se = NULL)
</span><span class="ln">  445</span><span class="cp"></span>
<span class="ln">  446</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">task_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">  447</span><span class="p">{</span>
<span class="ln">  448</span>	<span class="k">return</span> <span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln">  449</span><span class="p">}</span>
<span class="ln">  450</span>
<span class="ln">  451</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">cfs_rq_of</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  452</span><span class="p">{</span>
<span class="ln">  453</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  454</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">  455</span>
<span class="ln">  456</span>	<span class="k">return</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln">  457</span><span class="p">}</span>
<span class="ln">  458</span>
<span class="ln">  459</span><span class="cm">/* runqueue &#34;owned&#34; by this group */</span>
<span class="ln">  460</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="nf">group_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="ln">  461</span><span class="p">{</span>
<span class="ln">  462</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  463</span><span class="p">}</span>
<span class="ln">  464</span>
<span class="ln">  465</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  466</span><span class="p">{</span>
<span class="ln">  467</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">  468</span><span class="p">}</span>
<span class="ln">  469</span>
<span class="ln">  470</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  471</span><span class="p">{</span>
<span class="ln">  472</span><span class="p">}</span>
<span class="ln">  473</span>
<span class="ln">  474</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">assert_list_leaf_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">  475</span><span class="p">{</span>
<span class="ln">  476</span><span class="p">}</span>
<span class="ln">  477</span>
<span class="ln">  478</span><span class="cp">#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)	\
</span><span class="ln">  479</span><span class="cp">		for (cfs_rq = &amp;rq-&gt;cfs, pos = NULL; cfs_rq; cfs_rq = pos)
</span><span class="ln">  480</span><span class="cp"></span>
<span class="ln">  481</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">parent_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  482</span><span class="p">{</span>
<span class="ln">  483</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  484</span><span class="p">}</span>
<span class="ln">  485</span>
<span class="ln">  486</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">  487</span><span class="nf">find_matching_se</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">**</span><span class="n">pse</span><span class="p">)</span>
<span class="ln">  488</span><span class="p">{</span>
<span class="ln">  489</span><span class="p">}</span>
<span class="ln">  490</span>
<span class="ln">  491</span><span class="cp">#endif	</span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">  492</span><span class="cp"></span>
<span class="ln">  493</span><span class="k">static</span> <span class="n">__always_inline</span>
<span class="ln">  494</span><span class="kt">void</span> <span class="nf">account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="ln">  495</span>
<span class="ln">  496</span><span class="cm">/**************************************************************
</span><span class="ln">  497</span><span class="cm"> * Scheduling class tree data structure manipulation methods:
</span><span class="ln">  498</span><span class="cm"> */</span>
<span class="ln">  499</span>
<span class="ln">  500</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">max_vruntime</span><span class="p">(</span><span class="n">u64</span> <span class="n">max_vruntime</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vruntime</span><span class="p">)</span>
<span class="ln">  501</span><span class="p">{</span>
<span class="ln">  502</span>	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">max_vruntime</span><span class="p">);</span>
<span class="ln">  503</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">  504</span>		<span class="n">max_vruntime</span> <span class="o">=</span> <span class="n">vruntime</span><span class="p">;</span>
<span class="ln">  505</span>
<span class="ln">  506</span>	<span class="k">return</span> <span class="n">max_vruntime</span><span class="p">;</span>
<span class="ln">  507</span><span class="p">}</span>
<span class="ln">  508</span>
<span class="ln">  509</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">min_vruntime</span><span class="p">(</span><span class="n">u64</span> <span class="n">min_vruntime</span><span class="p">,</span> <span class="n">u64</span> <span class="n">vruntime</span><span class="p">)</span>
<span class="ln">  510</span><span class="p">{</span>
<span class="ln">  511</span>	<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">min_vruntime</span><span class="p">);</span>
<span class="ln">  512</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">  513</span>		<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">vruntime</span><span class="p">;</span>
<span class="ln">  514</span>
<span class="ln">  515</span>	<span class="k">return</span> <span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln">  516</span><span class="p">}</span>
<span class="ln">  517</span>
<span class="ln">  518</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">entity_before</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
<span class="ln">  519</span>				<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="ln">  520</span><span class="p">{</span>
<span class="ln">  521</span>	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  522</span><span class="p">}</span>
<span class="ln">  523</span>
<span class="ln">  524</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_min_vruntime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  525</span><span class="p">{</span>
<span class="ln">  526</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">  527</span>	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">leftmost</span> <span class="o">=</span> <span class="n">rb_first_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">);</span>
<span class="ln">  528</span>
<span class="ln">  529</span>	<span class="n">u64</span> <span class="n">vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln">  530</span>
<span class="ln">  531</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  532</span>		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln">  533</span>			<span class="n">vruntime</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
<span class="ln">  534</span>		<span class="k">else</span>
<span class="ln">  535</span>			<span class="n">curr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  536</span>	<span class="p">}</span>
<span class="ln">  537</span>
<span class="ln">  538</span>	<span class="k">if</span> <span class="p">(</span><span class="n">leftmost</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* non-empty tree */</span>
<span class="ln">  539</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln">  540</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">leftmost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="ln">  541</span>
<span class="ln">  542</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">)</span>
<span class="ln">  543</span>			<span class="n">vruntime</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
<span class="ln">  544</span>		<span class="k">else</span>
<span class="ln">  545</span>			<span class="n">vruntime</span> <span class="o">=</span> <span class="n">min_vruntime</span><span class="p">(</span><span class="n">vruntime</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span>
<span class="ln">  546</span>	<span class="p">}</span>
<span class="ln">  547</span>
<span class="ln">  548</span>	<span class="cm">/* ensure we never gain time by being placed backwards. */</span>
<span class="ln">  549</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">max_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">,</span> <span class="n">vruntime</span><span class="p">);</span>
<span class="ln">  550</span><span class="cp">#ifndef CONFIG_64BIT
</span><span class="ln">  551</span><span class="cp"></span>	<span class="n">smp_wmb</span><span class="p">();</span>
<span class="ln">  552</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln">  553</span><span class="cp">#endif
</span><span class="ln">  554</span><span class="cp"></span><span class="p">}</span>
<span class="ln">  555</span>
<span class="ln">  556</span><span class="cm">/*
</span><span class="ln">  557</span><span class="cm"> * Enqueue an entity into the rb-tree:
</span><span class="ln">  558</span><span class="cm"> */</span>
<span class="ln">  559</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__enqueue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  560</span><span class="p">{</span>
<span class="ln">  561</span>	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">.</span><span class="n">rb_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
<span class="ln">  562</span>	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  563</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="ln">  564</span>	<span class="kt">bool</span> <span class="n">leftmost</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln">  565</span>
<span class="ln">  566</span>	<span class="cm">/*
</span><span class="ln">  567</span><span class="cm">	 * Find the right place in the rbtree:
</span><span class="ln">  568</span><span class="cm">	 */</span>
<span class="ln">  569</span>	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  570</span>		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
<span class="ln">  571</span>		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="ln">  572</span>		<span class="cm">/*
</span><span class="ln">  573</span><span class="cm">		 * We dont care about collisions. Nodes with
</span><span class="ln">  574</span><span class="cm">		 * the same key stay together.
</span><span class="ln">  575</span><span class="cm">		 */</span>
<span class="ln">  576</span>		<span class="k">if</span> <span class="p">(</span><span class="n">entity_before</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  577</span>			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
<span class="ln">  578</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">  579</span>			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
<span class="ln">  580</span>			<span class="n">leftmost</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln">  581</span>		<span class="p">}</span>
<span class="ln">  582</span>	<span class="p">}</span>
<span class="ln">  583</span>
<span class="ln">  584</span>	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
<span class="ln">  585</span>	<span class="n">rb_insert_color_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">,</span>
<span class="ln">  586</span>			       <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">,</span> <span class="n">leftmost</span><span class="p">);</span>
<span class="ln">  587</span><span class="p">}</span>
<span class="ln">  588</span>
<span class="ln">  589</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__dequeue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  590</span><span class="p">{</span>
<span class="ln">  591</span>	<span class="n">rb_erase_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">);</span>
<span class="ln">  592</span><span class="p">}</span>
<span class="ln">  593</span>
<span class="ln">  594</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">__pick_first_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  595</span><span class="p">{</span>
<span class="ln">  596</span>	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">rb_first_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">);</span>
<span class="ln">  597</span>
<span class="ln">  598</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span>
<span class="ln">  599</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  600</span>
<span class="ln">  601</span>	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="ln">  602</span><span class="p">}</span>
<span class="ln">  603</span>
<span class="ln">  604</span><span class="k">static</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">__pick_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  605</span><span class="p">{</span>
<span class="ln">  606</span>	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">run_node</span><span class="p">);</span>
<span class="ln">  607</span>
<span class="ln">  608</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
<span class="ln">  609</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  610</span>
<span class="ln">  611</span>	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="ln">  612</span><span class="p">}</span>
<span class="ln">  613</span>
<span class="ln">  614</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln">  615</span><span class="cp"></span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="nf">__pick_last_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  616</span><span class="p">{</span>
<span class="ln">  617</span>	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span><span class="p">.</span><span class="n">rb_root</span><span class="p">);</span>
<span class="ln">  618</span>
<span class="ln">  619</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last</span><span class="p">)</span>
<span class="ln">  620</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  621</span>
<span class="ln">  622</span>	<span class="k">return</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span><span class="p">,</span> <span class="n">run_node</span><span class="p">);</span>
<span class="ln">  623</span><span class="p">}</span>
<span class="ln">  624</span>
<span class="ln">  625</span><span class="cm">/**************************************************************
</span><span class="ln">  626</span><span class="cm"> * Scheduling class statistics methods:
</span><span class="ln">  627</span><span class="cm"> */</span>
<span class="ln">  628</span>
<span class="ln">  629</span><span class="kt">int</span> <span class="nf">sched_proc_update_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
<span class="ln">  630</span>		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
<span class="ln">  631</span>		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="ln">  632</span><span class="p">{</span>
<span class="ln">  633</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="ln">  634</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">get_update_sysctl_factor</span><span class="p">();</span>
<span class="ln">  635</span>
<span class="ln">  636</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">write</span><span class="p">)</span>
<span class="ln">  637</span>		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln">  638</span>
<span class="ln">  639</span>	<span class="n">sched_nr_latency</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">sysctl_sched_latency</span><span class="p">,</span>
<span class="ln">  640</span>					<span class="n">sysctl_sched_min_granularity</span><span class="p">);</span>
<span class="ln">  641</span>
<span class="ln">  642</span><span class="cp">#define WRT_SYSCTL(name) \
</span><span class="ln">  643</span><span class="cp">	(normalized_sysctl_##name = sysctl_##name / (factor))
</span><span class="ln">  644</span><span class="cp"></span>	<span class="n">WRT_SYSCTL</span><span class="p">(</span><span class="n">sched_min_granularity</span><span class="p">);</span>
<span class="ln">  645</span>	<span class="n">WRT_SYSCTL</span><span class="p">(</span><span class="n">sched_latency</span><span class="p">);</span>
<span class="ln">  646</span>	<span class="n">WRT_SYSCTL</span><span class="p">(</span><span class="n">sched_wakeup_granularity</span><span class="p">);</span>
<span class="ln">  647</span><span class="cp">#undef WRT_SYSCTL
</span><span class="ln">  648</span><span class="cp"></span>
<span class="ln">  649</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  650</span><span class="p">}</span>
<span class="ln">  651</span><span class="cp">#endif
</span><span class="ln">  652</span><span class="cp"></span>
<span class="ln">  653</span><span class="cm">/*
</span><span class="ln">  654</span><span class="cm"> * delta /= w
</span><span class="ln">  655</span><span class="cm"> */</span>
<span class="ln">  656</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">calc_delta_fair</span><span class="p">(</span><span class="n">u64</span> <span class="n">delta</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  657</span><span class="p">{</span>
<span class="ln">  658</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">!=</span> <span class="n">NICE_0_LOAD</span><span class="p">))</span>
<span class="ln">  659</span>		<span class="n">delta</span> <span class="o">=</span> <span class="n">__calc_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">NICE_0_LOAD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">);</span>
<span class="ln">  660</span>
<span class="ln">  661</span>	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln">  662</span><span class="p">}</span>
<span class="ln">  663</span>
<span class="ln">  664</span><span class="cm">/*
</span><span class="ln">  665</span><span class="cm"> * The idea is to set a period in which each task runs once.
</span><span class="ln">  666</span><span class="cm"> *
</span><span class="ln">  667</span><span class="cm"> * When there are too many tasks (sched_nr_latency) we have to stretch
</span><span class="ln">  668</span><span class="cm"> * this period because otherwise the slices get too small.
</span><span class="ln">  669</span><span class="cm"> *
</span><span class="ln">  670</span><span class="cm"> * p = (nr &lt;= nl) ? l : l*nr/nl
</span><span class="ln">  671</span><span class="cm"> */</span>
<span class="ln">  672</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">__sched_period</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span><span class="p">)</span>
<span class="ln">  673</span><span class="p">{</span>
<span class="ln">  674</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="n">sched_nr_latency</span><span class="p">))</span>
<span class="ln">  675</span>		<span class="k">return</span> <span class="n">nr_running</span> <span class="o">*</span> <span class="n">sysctl_sched_min_granularity</span><span class="p">;</span>
<span class="ln">  676</span>	<span class="k">else</span>
<span class="ln">  677</span>		<span class="k">return</span> <span class="n">sysctl_sched_latency</span><span class="p">;</span>
<span class="ln">  678</span><span class="p">}</span>
<span class="ln">  679</span>
<span class="ln">  680</span><span class="cm">/*
</span><span class="ln">  681</span><span class="cm"> * We calculate the wall-time slice from the period by taking a part
</span><span class="ln">  682</span><span class="cm"> * proportional to the weight.
</span><span class="ln">  683</span><span class="cm"> *
</span><span class="ln">  684</span><span class="cm"> * s = p*P[w/rw]
</span><span class="ln">  685</span><span class="cm"> */</span>
<span class="ln">  686</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">sched_slice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  687</span><span class="p">{</span>
<span class="ln">  688</span>	<span class="n">u64</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">__sched_period</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">+</span> <span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">);</span>
<span class="ln">  689</span>
<span class="ln">  690</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  691</span>		<span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">load</span><span class="p">;</span>
<span class="ln">  692</span>		<span class="k">struct</span> <span class="n">load_weight</span> <span class="n">lw</span><span class="p">;</span>
<span class="ln">  693</span>
<span class="ln">  694</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  695</span>		<span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>
<span class="ln">  696</span>
<span class="ln">  697</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  698</span>			<span class="n">lw</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>
<span class="ln">  699</span>
<span class="ln">  700</span>			<span class="n">update_load_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lw</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="ln">  701</span>			<span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lw</span><span class="p">;</span>
<span class="ln">  702</span>		<span class="p">}</span>
<span class="ln">  703</span>		<span class="n">slice</span> <span class="o">=</span> <span class="n">__calc_delta</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">load</span><span class="p">);</span>
<span class="ln">  704</span>	<span class="p">}</span>
<span class="ln">  705</span>	<span class="k">return</span> <span class="n">slice</span><span class="p">;</span>
<span class="ln">  706</span><span class="p">}</span>
<span class="ln">  707</span>
<span class="ln">  708</span><span class="cm">/*
</span><span class="ln">  709</span><span class="cm"> * We calculate the vruntime slice of a to-be-inserted task.
</span><span class="ln">  710</span><span class="cm"> *
</span><span class="ln">  711</span><span class="cm"> * vs = s/w
</span><span class="ln">  712</span><span class="cm"> */</span>
<span class="ln">  713</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">sched_vslice</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  714</span><span class="p">{</span>
<span class="ln">  715</span>	<span class="k">return</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">);</span>
<span class="ln">  716</span><span class="p">}</span>
<span class="ln">  717</span>
<span class="ln">  718</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">  719</span><span class="cp">#include</span> <span class="cpf">&#34;pelt.h&#34;</span><span class="cp">
</span><span class="ln">  720</span><span class="cp">#include</span> <span class="cpf">&#34;sched-pelt.h&#34;</span><span class="cp">
</span><span class="ln">  721</span><span class="cp"></span>
<span class="ln">  722</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_idle_sibling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln">  723</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="ln">  724</span>
<span class="ln">  725</span><span class="cm">/* Give new sched_entity start runnable values to heavy its load in infant time */</span>
<span class="ln">  726</span><span class="kt">void</span> <span class="nf">init_entity_runnable_average</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  727</span><span class="p">{</span>
<span class="ln">  728</span>	<span class="k">struct</span> <span class="n">sched_avg</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">;</span>
<span class="ln">  729</span>
<span class="ln">  730</span>	<span class="n">memset</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">));</span>
<span class="ln">  731</span>
<span class="ln">  732</span>	<span class="cm">/*
</span><span class="ln">  733</span><span class="cm">	 * Tasks are intialized with full load to be seen as heavy tasks until
</span><span class="ln">  734</span><span class="cm">	 * they get a chance to stabilize to their real load level.
</span><span class="ln">  735</span><span class="cm">	 * Group entities are intialized with zero load to reflect the fact that
</span><span class="ln">  736</span><span class="cm">	 * nothing has been attached to the task group yet.
</span><span class="ln">  737</span><span class="cm">	 */</span>
<span class="ln">  738</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln">  739</span>		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">runnable_load_avg</span> <span class="o">=</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">load_avg</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="ln">  740</span>
<span class="ln">  741</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">runnable_weight</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="ln">  742</span>
<span class="ln">  743</span>	<span class="cm">/* when this task enqueue&#39;ed, it will contribute to its cfs_rq&#39;s load_avg */</span>
<span class="ln">  744</span><span class="p">}</span>
<span class="ln">  745</span>
<span class="ln">  746</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cfs_rq_clock_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">  747</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_entity_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  748</span>
<span class="ln">  749</span><span class="cm">/*
</span><span class="ln">  750</span><span class="cm"> * With new tasks being created, their initial util_avgs are extrapolated
</span><span class="ln">  751</span><span class="cm"> * based on the cfs_rq&#39;s current util_avg:
</span><span class="ln">  752</span><span class="cm"> *
</span><span class="ln">  753</span><span class="cm"> *   util_avg = cfs_rq-&gt;util_avg / (cfs_rq-&gt;load_avg + 1) * se.load.weight
</span><span class="ln">  754</span><span class="cm"> *
</span><span class="ln">  755</span><span class="cm"> * However, in many cases, the above util_avg does not give a desired
</span><span class="ln">  756</span><span class="cm"> * value. Moreover, the sum of the util_avgs may be divergent, such
</span><span class="ln">  757</span><span class="cm"> * as when the series is a harmonic series.
</span><span class="ln">  758</span><span class="cm"> *
</span><span class="ln">  759</span><span class="cm"> * To solve this problem, we also cap the util_avg of successive tasks to
</span><span class="ln">  760</span><span class="cm"> * only 1/2 of the left utilization budget:
</span><span class="ln">  761</span><span class="cm"> *
</span><span class="ln">  762</span><span class="cm"> *   util_avg_cap = (cpu_scale - cfs_rq-&gt;avg.util_avg) / 2^n
</span><span class="ln">  763</span><span class="cm"> *
</span><span class="ln">  764</span><span class="cm"> * where n denotes the nth task and cpu_scale the CPU capacity.
</span><span class="ln">  765</span><span class="cm"> *
</span><span class="ln">  766</span><span class="cm"> * For example, for a CPU with 1024 of capacity, a simplest series from
</span><span class="ln">  767</span><span class="cm"> * the beginning would be like:
</span><span class="ln">  768</span><span class="cm"> *
</span><span class="ln">  769</span><span class="cm"> *  task  util_avg: 512, 256, 128,  64,  32,   16,    8, ...
</span><span class="ln">  770</span><span class="cm"> * cfs_rq util_avg: 512, 768, 896, 960, 992, 1008, 1016, ...
</span><span class="ln">  771</span><span class="cm"> *
</span><span class="ln">  772</span><span class="cm"> * Finally, that extrapolated util_avg is clamped to the cap (util_avg_cap)
</span><span class="ln">  773</span><span class="cm"> * if util_avg &gt; util_avg_cap.
</span><span class="ln">  774</span><span class="cm"> */</span>
<span class="ln">  775</span><span class="kt">void</span> <span class="nf">post_init_entity_util_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  776</span><span class="p">{</span>
<span class="ln">  777</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  778</span>	<span class="k">struct</span> <span class="n">sched_avg</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">;</span>
<span class="ln">  779</span>	<span class="kt">long</span> <span class="n">cpu_scale</span> <span class="o">=</span> <span class="n">arch_scale_cpu_capacity</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)));</span>
<span class="ln">  780</span>	<span class="kt">long</span> <span class="n">cap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">cpu_scale</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln">  781</span>
<span class="ln">  782</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  783</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  784</span>			<span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_avg</span>  <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="ln">  785</span>			<span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_avg</span> <span class="o">/=</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">  786</span>
<span class="ln">  787</span>			<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_avg</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="p">)</span>
<span class="ln">  788</span>				<span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_avg</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
<span class="ln">  789</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">  790</span>			<span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_avg</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
<span class="ln">  791</span>		<span class="p">}</span>
<span class="ln">  792</span>	<span class="p">}</span>
<span class="ln">  793</span>
<span class="ln">  794</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  795</span>		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  796</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  797</span>			<span class="cm">/*
</span><span class="ln">  798</span><span class="cm">			 * For !fair tasks do:
</span><span class="ln">  799</span><span class="cm">			 *
</span><span class="ln">  800</span><span class="cm">			update_cfs_rq_load_avg(now, cfs_rq);
</span><span class="ln">  801</span><span class="cm">			attach_entity_load_avg(cfs_rq, se, 0);
</span><span class="ln">  802</span><span class="cm">			switched_from_fair(rq, p);
</span><span class="ln">  803</span><span class="cm">			 *
</span><span class="ln">  804</span><span class="cm">			 * such that the next switched_to_fair() has the
</span><span class="ln">  805</span><span class="cm">			 * expected state.
</span><span class="ln">  806</span><span class="cm">			 */</span>
<span class="ln">  807</span>			<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">=</span> <span class="n">cfs_rq_clock_task</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">  808</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln">  809</span>		<span class="p">}</span>
<span class="ln">  810</span>	<span class="p">}</span>
<span class="ln">  811</span>
<span class="ln">  812</span>	<span class="n">attach_entity_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  813</span><span class="p">}</span>
<span class="ln">  814</span>
<span class="ln">  815</span><span class="cp">#else </span><span class="cm">/* !CONFIG_SMP */</span><span class="cp">
</span><span class="ln">  816</span><span class="cp"></span><span class="kt">void</span> <span class="nf">init_entity_runnable_average</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  817</span><span class="p">{</span>
<span class="ln">  818</span><span class="p">}</span>
<span class="ln">  819</span><span class="kt">void</span> <span class="nf">post_init_entity_util_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  820</span><span class="p">{</span>
<span class="ln">  821</span><span class="p">}</span>
<span class="ln">  822</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_tg_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="ln">  823</span><span class="p">{</span>
<span class="ln">  824</span><span class="p">}</span>
<span class="ln">  825</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln">  826</span><span class="cp"></span>
<span class="ln">  827</span><span class="cm">/*
</span><span class="ln">  828</span><span class="cm"> * Update the current task&#39;s runtime statistics.
</span><span class="ln">  829</span><span class="cm"> */</span>
<span class="ln">  830</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">  831</span><span class="p">{</span>
<span class="ln">  832</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln">  833</span>	<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln">  834</span>	<span class="n">u64</span> <span class="n">delta_exec</span><span class="p">;</span>
<span class="ln">  835</span>
<span class="ln">  836</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">))</span>
<span class="ln">  837</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  838</span>
<span class="ln">  839</span>	<span class="n">delta_exec</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span><span class="p">;</span>
<span class="ln">  840</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta_exec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
<span class="ln">  841</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  842</span>
<span class="ln">  843</span>	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="ln">  844</span>
<span class="ln">  845</span>	<span class="n">schedstat_set</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">exec_max</span><span class="p">,</span>
<span class="ln">  846</span>		      <span class="n">max</span><span class="p">(</span><span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">exec_max</span><span class="p">));</span>
<span class="ln">  847</span>
<span class="ln">  848</span>	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">+=</span> <span class="n">delta_exec</span><span class="p">;</span>
<span class="ln">  849</span>	<span class="n">schedstat_add</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">exec_clock</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="ln">  850</span>
<span class="ln">  851</span>	<span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln">  852</span>	<span class="n">update_min_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">  853</span>
<span class="ln">  854</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  855</span>		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curtask</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln">  856</span>
<span class="ln">  857</span>		<span class="n">trace_sched_stat_runtime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span>
<span class="ln">  858</span>		<span class="n">cgroup_account_cputime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="ln">  859</span>		<span class="n">account_group_exec_runtime</span><span class="p">(</span><span class="n">curtask</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="ln">  860</span>	<span class="p">}</span>
<span class="ln">  861</span>
<span class="ln">  862</span>	<span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="ln">  863</span><span class="p">}</span>
<span class="ln">  864</span>
<span class="ln">  865</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_curr_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">  866</span><span class="p">{</span>
<span class="ln">  867</span>	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">));</span>
<span class="ln">  868</span><span class="p">}</span>
<span class="ln">  869</span>
<span class="ln">  870</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">  871</span><span class="nf">update_stats_wait_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  872</span><span class="p">{</span>
<span class="ln">  873</span>	<span class="n">u64</span> <span class="n">wait_start</span><span class="p">,</span> <span class="n">prev_wait_start</span><span class="p">;</span>
<span class="ln">  874</span>
<span class="ln">  875</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln">  876</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  877</span>
<span class="ln">  878</span>	<span class="n">wait_start</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln">  879</span>	<span class="n">prev_wait_start</span> <span class="o">=</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">);</span>
<span class="ln">  880</span>
<span class="ln">  881</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
<span class="ln">  882</span>	    <span class="n">likely</span><span class="p">(</span><span class="n">wait_start</span> <span class="o">&gt;</span> <span class="n">prev_wait_start</span><span class="p">))</span>
<span class="ln">  883</span>		<span class="n">wait_start</span> <span class="o">-=</span> <span class="n">prev_wait_start</span><span class="p">;</span>
<span class="ln">  884</span>
<span class="ln">  885</span>	<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">,</span> <span class="n">wait_start</span><span class="p">);</span>
<span class="ln">  886</span><span class="p">}</span>
<span class="ln">  887</span>
<span class="ln">  888</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">  889</span><span class="nf">update_stats_wait_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  890</span><span class="p">{</span>
<span class="ln">  891</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln">  892</span>	<span class="n">u64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln">  893</span>
<span class="ln">  894</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln">  895</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  896</span>
<span class="ln">  897</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">);</span>
<span class="ln">  898</span>
<span class="ln">  899</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  900</span>		<span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  901</span>		<span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_migrating</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  902</span>			<span class="cm">/*
</span><span class="ln">  903</span><span class="cm">			 * Preserve migrating task&#39;s wait time so wait_start
</span><span class="ln">  904</span><span class="cm">			 * time stamp can be adjusted to accumulate wait time
</span><span class="ln">  905</span><span class="cm">			 * prior to migration.
</span><span class="ln">  906</span><span class="cm">			 */</span>
<span class="ln">  907</span>			<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  908</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln">  909</span>		<span class="p">}</span>
<span class="ln">  910</span>		<span class="n">trace_sched_stat_wait</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  911</span>	<span class="p">}</span>
<span class="ln">  912</span>
<span class="ln">  913</span>	<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_max</span><span class="p">,</span>
<span class="ln">  914</span>		      <span class="n">max</span><span class="p">(</span><span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_max</span><span class="p">),</span> <span class="n">delta</span><span class="p">));</span>
<span class="ln">  915</span>	<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_count</span><span class="p">);</span>
<span class="ln">  916</span>	<span class="n">__schedstat_add</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_sum</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  917</span>	<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">wait_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">  918</span><span class="p">}</span>
<span class="ln">  919</span>
<span class="ln">  920</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">  921</span><span class="nf">update_stats_enqueue_sleeper</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln">  922</span><span class="p">{</span>
<span class="ln">  923</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">  924</span>	<span class="n">u64</span> <span class="n">sleep_start</span><span class="p">,</span> <span class="n">block_start</span><span class="p">;</span>
<span class="ln">  925</span>
<span class="ln">  926</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln">  927</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  928</span>
<span class="ln">  929</span>	<span class="n">sleep_start</span> <span class="o">=</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span><span class="p">);</span>
<span class="ln">  930</span>	<span class="n">block_start</span> <span class="o">=</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span><span class="p">);</span>
<span class="ln">  931</span>
<span class="ln">  932</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln">  933</span>		<span class="n">tsk</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">  934</span>
<span class="ln">  935</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sleep_start</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  936</span>		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">sleep_start</span><span class="p">;</span>
<span class="ln">  937</span>
<span class="ln">  938</span>		<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">  939</span>			<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  940</span>
<span class="ln">  941</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_max</span><span class="p">)))</span>
<span class="ln">  942</span>			<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_max</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  943</span>
<span class="ln">  944</span>		<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">  945</span>		<span class="n">__schedstat_add</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sum_sleep_runtime</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  946</span>
<span class="ln">  947</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  948</span>			<span class="n">account_scheduler_latency</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">  949</span>			<span class="n">trace_sched_stat_sleep</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  950</span>		<span class="p">}</span>
<span class="ln">  951</span>	<span class="p">}</span>
<span class="ln">  952</span>	<span class="k">if</span> <span class="p">(</span><span class="n">block_start</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  953</span>		<span class="n">u64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">block_start</span><span class="p">;</span>
<span class="ln">  954</span>
<span class="ln">  955</span>		<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln">  956</span>			<span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">  957</span>
<span class="ln">  958</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_max</span><span class="p">)))</span>
<span class="ln">  959</span>			<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_max</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  960</span>
<span class="ln">  961</span>		<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">  962</span>		<span class="n">__schedstat_add</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sum_sleep_runtime</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  963</span>
<span class="ln">  964</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  965</span>			<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">  966</span>				<span class="n">__schedstat_add</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">iowait_sum</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  967</span>				<span class="n">__schedstat_inc</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">iowait_count</span><span class="p">);</span>
<span class="ln">  968</span>				<span class="n">trace_sched_stat_iowait</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  969</span>			<span class="p">}</span>
<span class="ln">  970</span>
<span class="ln">  971</span>			<span class="n">trace_sched_stat_blocked</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln">  972</span>
<span class="ln">  973</span>			<span class="cm">/*
</span><span class="ln">  974</span><span class="cm">			 * Blocking time is in units of nanosecs, so shift by
</span><span class="ln">  975</span><span class="cm">			 * 20 to get a milliseconds-range estimation of the
</span><span class="ln">  976</span><span class="cm">			 * amount of time that the task spent sleeping:
</span><span class="ln">  977</span><span class="cm">			 */</span>
<span class="ln">  978</span>			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prof_on</span> <span class="o">==</span> <span class="n">SLEEP_PROFILING</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">  979</span>				<span class="n">profile_hits</span><span class="p">(</span><span class="n">SLEEP_PROFILING</span><span class="p">,</span>
<span class="ln">  980</span>						<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_wchan</span><span class="p">(</span><span class="n">tsk</span><span class="p">),</span>
<span class="ln">  981</span>						<span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="ln">  982</span>			<span class="p">}</span>
<span class="ln">  983</span>			<span class="n">account_scheduler_latency</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">delta</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">  984</span>		<span class="p">}</span>
<span class="ln">  985</span>	<span class="p">}</span>
<span class="ln">  986</span><span class="p">}</span>
<span class="ln">  987</span>
<span class="ln">  988</span><span class="cm">/*
</span><span class="ln">  989</span><span class="cm"> * Task is being enqueued - update stats:
</span><span class="ln">  990</span><span class="cm"> */</span>
<span class="ln">  991</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln">  992</span><span class="nf">update_stats_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln">  993</span><span class="p">{</span>
<span class="ln">  994</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln">  995</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">  996</span>
<span class="ln">  997</span>	<span class="cm">/*
</span><span class="ln">  998</span><span class="cm">	 * Are we enqueueing a waiting task? (for current tasks
</span><span class="ln">  999</span><span class="cm">	 * a dequeue/enqueue event is a NOP)
</span><span class="ln"> 1000</span><span class="cm">	 */</span>
<span class="ln"> 1001</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 1002</span>		<span class="n">update_stats_wait_start</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 1003</span>
<span class="ln"> 1004</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span>
<span class="ln"> 1005</span>		<span class="n">update_stats_enqueue_sleeper</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 1006</span><span class="p">}</span>
<span class="ln"> 1007</span>
<span class="ln"> 1008</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 1009</span><span class="nf">update_stats_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 1010</span><span class="p">{</span>
<span class="ln"> 1011</span>
<span class="ln"> 1012</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln"> 1013</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1014</span>
<span class="ln"> 1015</span>	<span class="cm">/*
</span><span class="ln"> 1016</span><span class="cm">	 * Mark the end of the wait period if dequeueing a
</span><span class="ln"> 1017</span><span class="cm">	 * waiting task:
</span><span class="ln"> 1018</span><span class="cm">	 */</span>
<span class="ln"> 1019</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 1020</span>		<span class="n">update_stats_wait_end</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 1021</span>
<span class="ln"> 1022</span>	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 1023</span>		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 1024</span>
<span class="ln"> 1025</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">)</span>
<span class="ln"> 1026</span>			<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">sleep_start</span><span class="p">,</span>
<span class="ln"> 1027</span>				      <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)));</span>
<span class="ln"> 1028</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">)</span>
<span class="ln"> 1029</span>			<span class="n">__schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">block_start</span><span class="p">,</span>
<span class="ln"> 1030</span>				      <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)));</span>
<span class="ln"> 1031</span>	<span class="p">}</span>
<span class="ln"> 1032</span><span class="p">}</span>
<span class="ln"> 1033</span>
<span class="ln"> 1034</span><span class="cm">/*
</span><span class="ln"> 1035</span><span class="cm"> * We are picking a new current task - update its stats:
</span><span class="ln"> 1036</span><span class="cm"> */</span>
<span class="ln"> 1037</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 1038</span><span class="nf">update_stats_curr_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 1039</span><span class="p">{</span>
<span class="ln"> 1040</span>	<span class="cm">/*
</span><span class="ln"> 1041</span><span class="cm">	 * We are starting a new run period:
</span><span class="ln"> 1042</span><span class="cm">	 */</span>
<span class="ln"> 1043</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln"> 1044</span><span class="p">}</span>
<span class="ln"> 1045</span>
<span class="ln"> 1046</span><span class="cm">/**************************************************
</span><span class="ln"> 1047</span><span class="cm"> * Scheduling class queueing methods:
</span><span class="ln"> 1048</span><span class="cm"> */</span>
<span class="ln"> 1049</span>
<span class="ln"> 1050</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln"> 1051</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 1052</span><span class="cm"> * Approximate time to scan a full NUMA task in ms. The task scan period is
</span><span class="ln"> 1053</span><span class="cm"> * calculated based on the tasks virtual memory size and
</span><span class="ln"> 1054</span><span class="cm"> * numa_balancing_scan_size.
</span><span class="ln"> 1055</span><span class="cm"> */</span>
<span class="ln"> 1056</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_numa_balancing_scan_period_min</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="ln"> 1057</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_numa_balancing_scan_period_max</span> <span class="o">=</span> <span class="mi">60000</span><span class="p">;</span>
<span class="ln"> 1058</span>
<span class="ln"> 1059</span><span class="cm">/* Portion of address space to scan in MB */</span>
<span class="ln"> 1060</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_numa_balancing_scan_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="ln"> 1061</span>
<span class="ln"> 1062</span><span class="cm">/* Scan @scan_size MB every @scan_period after an initial @scan_delay in ms */</span>
<span class="ln"> 1063</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sysctl_numa_balancing_scan_delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="ln"> 1064</span>
<span class="ln"> 1065</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="p">{</span>
<span class="ln"> 1066</span>	<span class="n">atomic_t</span> <span class="n">refcount</span><span class="p">;</span>
<span class="ln"> 1067</span>
<span class="ln"> 1068</span>	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span> <span class="cm">/* nr_tasks, tasks */</span>
<span class="ln"> 1069</span>	<span class="kt">int</span> <span class="n">nr_tasks</span><span class="p">;</span>
<span class="ln"> 1070</span>	<span class="n">pid_t</span> <span class="n">gid</span><span class="p">;</span>
<span class="ln"> 1071</span>	<span class="kt">int</span> <span class="n">active_nodes</span><span class="p">;</span>
<span class="ln"> 1072</span>
<span class="ln"> 1073</span>	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="ln"> 1074</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 1075</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_faults_cpu</span><span class="p">;</span>
<span class="ln"> 1076</span>	<span class="cm">/*
</span><span class="ln"> 1077</span><span class="cm">	 * Faults_cpu is used to decide whether memory should move
</span><span class="ln"> 1078</span><span class="cm">	 * towards the CPU. As a consequence, these stats are weighted
</span><span class="ln"> 1079</span><span class="cm">	 * more by CPU use than by memory faults.
</span><span class="ln"> 1080</span><span class="cm">	 */</span>
<span class="ln"> 1081</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">faults_cpu</span><span class="p">;</span>
<span class="ln"> 1082</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="ln"> 1083</span><span class="p">};</span>
<span class="ln"> 1084</span>
<span class="ln"> 1085</span><span class="cm">/*
</span><span class="ln"> 1086</span><span class="cm"> * For functions that can be called in multiple contexts that permit reading
</span><span class="ln"> 1087</span><span class="cm"> * -&gt;numa_group (see struct task_struct for locking rules).
</span><span class="ln"> 1088</span><span class="cm"> */</span>
<span class="ln"> 1089</span><span class="k">static</span> <span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="nf">deref_task_numa_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1090</span><span class="p">{</span>
<span class="ln"> 1091</span>	<span class="k">return</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">,</span> <span class="n">p</span> <span class="o">==</span> <span class="n">current</span> <span class="o">||</span>
<span class="ln"> 1092</span>		<span class="p">(</span><span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_cpu</span><span class="p">)));</span>
<span class="ln"> 1093</span><span class="p">}</span>
<span class="ln"> 1094</span>
<span class="ln"> 1095</span><span class="k">static</span> <span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="nf">deref_curr_numa_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1096</span><span class="p">{</span>
<span class="ln"> 1097</span>	<span class="k">return</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">,</span> <span class="n">p</span> <span class="o">==</span> <span class="n">current</span><span class="p">);</span>
<span class="ln"> 1098</span><span class="p">}</span>
<span class="ln"> 1099</span>
<span class="ln"> 1100</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_faults_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 1101</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_faults_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 1102</span>
<span class="ln"> 1103</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">task_nr_scan_windows</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1104</span><span class="p">{</span>
<span class="ln"> 1105</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rss</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1106</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scan_pages</span><span class="p">;</span>
<span class="ln"> 1107</span>
<span class="ln"> 1108</span>	<span class="cm">/*
</span><span class="ln"> 1109</span><span class="cm">	 * Calculations based on RSS as non-present and empty pages are skipped
</span><span class="ln"> 1110</span><span class="cm">	 * by the PTE scanner and NUMA hinting faults should be trapped based
</span><span class="ln"> 1111</span><span class="cm">	 * on resident pages
</span><span class="ln"> 1112</span><span class="cm">	 */</span>
<span class="ln"> 1113</span>	<span class="n">nr_scan_pages</span> <span class="o">=</span> <span class="n">sysctl_numa_balancing_scan_size</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="ln"> 1114</span>	<span class="n">rss</span> <span class="o">=</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="ln"> 1115</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rss</span><span class="p">)</span>
<span class="ln"> 1116</span>		<span class="n">rss</span> <span class="o">=</span> <span class="n">nr_scan_pages</span><span class="p">;</span>
<span class="ln"> 1117</span>
<span class="ln"> 1118</span>	<span class="n">rss</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">rss</span><span class="p">,</span> <span class="n">nr_scan_pages</span><span class="p">);</span>
<span class="ln"> 1119</span>	<span class="k">return</span> <span class="n">rss</span> <span class="o">/</span> <span class="n">nr_scan_pages</span><span class="p">;</span>
<span class="ln"> 1120</span><span class="p">}</span>
<span class="ln"> 1121</span>
<span class="ln"> 1122</span><span class="cm">/* For sanitys sake, never scan more PTEs than MAX_SCAN_WINDOW MB/sec. */</span>
<span class="ln"> 1123</span><span class="cp">#define MAX_SCAN_WINDOW 2560
</span><span class="ln"> 1124</span><span class="cp"></span>
<span class="ln"> 1125</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">task_scan_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1126</span><span class="p">{</span>
<span class="ln"> 1127</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_size</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">sysctl_numa_balancing_scan_size</span><span class="p">);</span>
<span class="ln"> 1128</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan</span><span class="p">,</span> <span class="n">floor</span><span class="p">;</span>
<span class="ln"> 1129</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">windows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 1130</span>
<span class="ln"> 1131</span>	<span class="k">if</span> <span class="p">(</span><span class="n">scan_size</span> <span class="o">&lt;</span> <span class="n">MAX_SCAN_WINDOW</span><span class="p">)</span>
<span class="ln"> 1132</span>		<span class="n">windows</span> <span class="o">=</span> <span class="n">MAX_SCAN_WINDOW</span> <span class="o">/</span> <span class="n">scan_size</span><span class="p">;</span>
<span class="ln"> 1133</span>	<span class="n">floor</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">windows</span><span class="p">;</span>
<span class="ln"> 1134</span>
<span class="ln"> 1135</span>	<span class="n">scan</span> <span class="o">=</span> <span class="n">sysctl_numa_balancing_scan_period_min</span> <span class="o">/</span> <span class="n">task_nr_scan_windows</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1136</span>	<span class="k">return</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">scan</span><span class="p">);</span>
<span class="ln"> 1137</span><span class="p">}</span>
<span class="ln"> 1138</span>
<span class="ln"> 1139</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">task_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1140</span><span class="p">{</span>
<span class="ln"> 1141</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smin</span> <span class="o">=</span> <span class="n">task_scan_min</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1142</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">period</span> <span class="o">=</span> <span class="n">smin</span><span class="p">;</span>
<span class="ln"> 1143</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln"> 1144</span>
<span class="ln"> 1145</span>	<span class="cm">/* Scale the maximum scan period with the amount of shared memory. */</span>
<span class="ln"> 1146</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 1147</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln"> 1148</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1149</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">group_faults_shared</span><span class="p">(</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 1150</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span> <span class="o">=</span> <span class="n">group_faults_priv</span><span class="p">(</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 1151</span>
<span class="ln"> 1152</span>		<span class="n">period</span> <span class="o">*=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ng</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="ln"> 1153</span>		<span class="n">period</span> <span class="o">*=</span> <span class="n">shared</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 1154</span>		<span class="n">period</span> <span class="o">/=</span> <span class="n">private</span> <span class="o">+</span> <span class="n">shared</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 1155</span>	<span class="p">}</span>
<span class="ln"> 1156</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 1157</span>
<span class="ln"> 1158</span>	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">smin</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="ln"> 1159</span><span class="p">}</span>
<span class="ln"> 1160</span>
<span class="ln"> 1161</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">task_scan_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1162</span><span class="p">{</span>
<span class="ln"> 1163</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smin</span> <span class="o">=</span> <span class="n">task_scan_min</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1164</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">smax</span><span class="p">;</span>
<span class="ln"> 1165</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln"> 1166</span>
<span class="ln"> 1167</span>	<span class="cm">/* Watch for min being lower than max due to floor calculations */</span>
<span class="ln"> 1168</span>	<span class="n">smax</span> <span class="o">=</span> <span class="n">sysctl_numa_balancing_scan_period_max</span> <span class="o">/</span> <span class="n">task_nr_scan_windows</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1169</span>
<span class="ln"> 1170</span>	<span class="cm">/* Scale the maximum scan period with the amount of shared memory. */</span>
<span class="ln"> 1171</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1172</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1173</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">group_faults_shared</span><span class="p">(</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 1174</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span> <span class="o">=</span> <span class="n">group_faults_priv</span><span class="p">(</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 1175</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">period</span> <span class="o">=</span> <span class="n">smax</span><span class="p">;</span>
<span class="ln"> 1176</span>
<span class="ln"> 1177</span>		<span class="n">period</span> <span class="o">*=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ng</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="ln"> 1178</span>		<span class="n">period</span> <span class="o">*=</span> <span class="n">shared</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 1179</span>		<span class="n">period</span> <span class="o">/=</span> <span class="n">private</span> <span class="o">+</span> <span class="n">shared</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 1180</span>
<span class="ln"> 1181</span>		<span class="n">smax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">smax</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="ln"> 1182</span>	<span class="p">}</span>
<span class="ln"> 1183</span>
<span class="ln"> 1184</span>	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">smin</span><span class="p">,</span> <span class="n">smax</span><span class="p">);</span>
<span class="ln"> 1185</span><span class="p">}</span>
<span class="ln"> 1186</span>
<span class="ln"> 1187</span><span class="kt">void</span> <span class="nf">init_numa_balancing</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1188</span><span class="p">{</span>
<span class="ln"> 1189</span>	<span class="kt">int</span> <span class="n">mm_users</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1190</span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
<span class="ln"> 1191</span>
<span class="ln"> 1192</span>	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1193</span>		<span class="n">mm_users</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">);</span>
<span class="ln"> 1194</span>		<span class="k">if</span> <span class="p">(</span><span class="n">mm_users</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1195</span>			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sysctl_numa_balancing_scan_delay</span><span class="p">);</span>
<span class="ln"> 1196</span>			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1197</span>		<span class="p">}</span>
<span class="ln"> 1198</span>	<span class="p">}</span>
<span class="ln"> 1199</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">node_stamp</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1200</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span>		<span class="o">=</span> <span class="n">mm</span> <span class="o">?</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="nl">numa_scan_seq</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1201</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span>		<span class="o">=</span> <span class="n">sysctl_numa_balancing_scan_delay</span><span class="p">;</span>
<span class="ln"> 1202</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_work</span><span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_work</span><span class="p">;</span>
<span class="ln"> 1203</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span>			<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 1204</span>	<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 1205</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">last_task_numa_placement</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1206</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">last_sum_exec_runtime</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1207</span>
<span class="ln"> 1208</span>	<span class="cm">/* New address space, reset the preferred nid */</span>
<span class="ln"> 1209</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VM</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 1210</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 1211</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1212</span>	<span class="p">}</span>
<span class="ln"> 1213</span>
<span class="ln"> 1214</span>	<span class="cm">/*
</span><span class="ln"> 1215</span><span class="cm">	 * New thread, keep existing numa_preferred_nid which should be copied
</span><span class="ln"> 1216</span><span class="cm">	 * already by arch_dup_task_struct but stagger when scans start.
</span><span class="ln"> 1217</span><span class="cm">	 */</span>
<span class="ln"> 1218</span>	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1219</span>		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delay</span><span class="p">;</span>
<span class="ln"> 1220</span>
<span class="ln"> 1221</span>		<span class="n">delay</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">task_scan_max</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
<span class="ln"> 1222</span>			<span class="n">current</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">*</span> <span class="n">mm_users</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">);</span>
<span class="ln"> 1223</span>		<span class="n">delay</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">;</span>
<span class="ln"> 1224</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">node_stamp</span> <span class="o">=</span> <span class="n">delay</span><span class="p">;</span>
<span class="ln"> 1225</span>	<span class="p">}</span>
<span class="ln"> 1226</span><span class="p">}</span>
<span class="ln"> 1227</span>
<span class="ln"> 1228</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">account_numa_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1229</span><span class="p">{</span>
<span class="ln"> 1230</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_numa_running</span> <span class="o">+=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="ln"> 1231</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span> <span class="o">+=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">==</span> <span class="n">task_node</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 1232</span><span class="p">}</span>
<span class="ln"> 1233</span>
<span class="ln"> 1234</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">account_numa_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1235</span><span class="p">{</span>
<span class="ln"> 1236</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_numa_running</span> <span class="o">-=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="ln"> 1237</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span> <span class="o">-=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">==</span> <span class="n">task_node</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 1238</span><span class="p">}</span>
<span class="ln"> 1239</span>
<span class="ln"> 1240</span><span class="cm">/* Shared or private faults. */</span>
<span class="ln"> 1241</span><span class="cp">#define NR_NUMA_HINT_FAULT_TYPES 2
</span><span class="ln"> 1242</span><span class="cp"></span>
<span class="ln"> 1243</span><span class="cm">/* Memory and CPU locality */</span>
<span class="ln"> 1244</span><span class="cp">#define NR_NUMA_HINT_FAULT_STATS (NR_NUMA_HINT_FAULT_TYPES * 2)
</span><span class="ln"> 1245</span><span class="cp"></span>
<span class="ln"> 1246</span><span class="cm">/* Averaged statistics, and temporary buffers. */</span>
<span class="ln"> 1247</span><span class="cp">#define NR_NUMA_HINT_FAULT_BUCKETS (NR_NUMA_HINT_FAULT_STATS * 2)
</span><span class="ln"> 1248</span><span class="cp"></span>
<span class="ln"> 1249</span><span class="n">pid_t</span> <span class="nf">task_numa_group_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1250</span><span class="p">{</span>
<span class="ln"> 1251</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln"> 1252</span>	<span class="n">pid_t</span> <span class="n">gid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1253</span>
<span class="ln"> 1254</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 1255</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln"> 1256</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1257</span>		<span class="n">gid</span> <span class="o">=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
<span class="ln"> 1258</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 1259</span>
<span class="ln"> 1260</span>	<span class="k">return</span> <span class="n">gid</span><span class="p">;</span>
<span class="ln"> 1261</span><span class="p">}</span>
<span class="ln"> 1262</span>
<span class="ln"> 1263</span><span class="cm">/*
</span><span class="ln"> 1264</span><span class="cm"> * The averaged statistics, shared &amp; private, memory &amp; CPU,
</span><span class="ln"> 1265</span><span class="cm"> * occupy the first half of the array. The second half of the
</span><span class="ln"> 1266</span><span class="cm"> * array is for current counters, which are averaged into the
</span><span class="ln"> 1267</span><span class="cm"> * first set by task_numa_placement.
</span><span class="ln"> 1268</span><span class="cm"> */</span>
<span class="ln"> 1269</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">task_faults_idx</span><span class="p">(</span><span class="k">enum</span> <span class="n">numa_faults_stats</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priv</span><span class="p">)</span>
<span class="ln"> 1270</span><span class="p">{</span>
<span class="ln"> 1271</span>	<span class="k">return</span> <span class="n">NR_NUMA_HINT_FAULT_TYPES</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">nr_node_ids</span> <span class="o">+</span> <span class="n">nid</span><span class="p">)</span> <span class="o">+</span> <span class="n">priv</span><span class="p">;</span>
<span class="ln"> 1272</span><span class="p">}</span>
<span class="ln"> 1273</span>
<span class="ln"> 1274</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_faults</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln"> 1275</span><span class="p">{</span>
<span class="ln"> 1276</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">)</span>
<span class="ln"> 1277</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1278</span>
<span class="ln"> 1279</span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span>
<span class="ln"> 1280</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
<span class="ln"> 1281</span><span class="p">}</span>
<span class="ln"> 1282</span>
<span class="ln"> 1283</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_faults</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln"> 1284</span><span class="p">{</span>
<span class="ln"> 1285</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span> <span class="o">=</span> <span class="n">deref_task_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1286</span>
<span class="ln"> 1287</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1288</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1289</span>
<span class="ln"> 1290</span>	<span class="k">return</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span>
<span class="ln"> 1291</span>		<span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
<span class="ln"> 1292</span><span class="p">}</span>
<span class="ln"> 1293</span>
<span class="ln"> 1294</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_faults_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln"> 1295</span><span class="p">{</span>
<span class="ln"> 1296</span>	<span class="k">return</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">faults_cpu</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span>
<span class="ln"> 1297</span>		<span class="n">group</span><span class="o">-&gt;</span><span class="n">faults_cpu</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
<span class="ln"> 1298</span><span class="p">}</span>
<span class="ln"> 1299</span>
<span class="ln"> 1300</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_faults_priv</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1301</span><span class="p">{</span>
<span class="ln"> 1302</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1303</span>	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<span class="ln"> 1304</span>
<span class="ln"> 1305</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1306</span>		<span class="n">faults</span> <span class="o">+=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
<span class="ln"> 1307</span>	<span class="p">}</span>
<span class="ln"> 1308</span>
<span class="ln"> 1309</span>	<span class="k">return</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 1310</span><span class="p">}</span>
<span class="ln"> 1311</span>
<span class="ln"> 1312</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_faults_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1313</span><span class="p">{</span>
<span class="ln"> 1314</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1315</span>	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<span class="ln"> 1316</span>
<span class="ln"> 1317</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1318</span>		<span class="n">faults</span> <span class="o">+=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
<span class="ln"> 1319</span>	<span class="p">}</span>
<span class="ln"> 1320</span>
<span class="ln"> 1321</span>	<span class="k">return</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 1322</span><span class="p">}</span>
<span class="ln"> 1323</span>
<span class="ln"> 1324</span><span class="cm">/*
</span><span class="ln"> 1325</span><span class="cm"> * A node triggering more than 1/3 as many NUMA faults as the maximum is
</span><span class="ln"> 1326</span><span class="cm"> * considered part of a numa group&#39;s pseudo-interleaving set. Migrations
</span><span class="ln"> 1327</span><span class="cm"> * between these nodes are slowed down, to allow things to settle down.
</span><span class="ln"> 1328</span><span class="cm"> */</span>
<span class="ln"> 1329</span><span class="cp">#define ACTIVE_NODE_FRACTION 3
</span><span class="ln"> 1330</span><span class="cp"></span>
<span class="ln"> 1331</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">numa_is_active_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1332</span><span class="p">{</span>
<span class="ln"> 1333</span>	<span class="k">return</span> <span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">nid</span><span class="p">)</span> <span class="o">*</span> <span class="n">ACTIVE_NODE_FRACTION</span> <span class="o">&gt;</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">max_faults_cpu</span><span class="p">;</span>
<span class="ln"> 1334</span><span class="p">}</span>
<span class="ln"> 1335</span>
<span class="ln"> 1336</span><span class="cm">/* Handle placement on systems where not all nodes are directly connected. */</span>
<span class="ln"> 1337</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">score_nearby_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
<span class="ln"> 1338</span>					<span class="kt">int</span> <span class="n">maxdist</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">task</span><span class="p">)</span>
<span class="ln"> 1339</span><span class="p">{</span>
<span class="ln"> 1340</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1341</span>	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<span class="ln"> 1342</span>
<span class="ln"> 1343</span>	<span class="cm">/*
</span><span class="ln"> 1344</span><span class="cm">	 * All nodes are directly connected, and the same distance
</span><span class="ln"> 1345</span><span class="cm">	 * from each other. No need for fancy placement algorithms.
</span><span class="ln"> 1346</span><span class="cm">	 */</span>
<span class="ln"> 1347</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_numa_topology_type</span> <span class="o">==</span> <span class="n">NUMA_DIRECT</span><span class="p">)</span>
<span class="ln"> 1348</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1349</span>
<span class="ln"> 1350</span>	<span class="cm">/*
</span><span class="ln"> 1351</span><span class="cm">	 * This code is called for each node, introducing N^2 complexity,
</span><span class="ln"> 1352</span><span class="cm">	 * which should be ok given the number of nodes rarely exceeds 8.
</span><span class="ln"> 1353</span><span class="cm">	 */</span>
<span class="ln"> 1354</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1355</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 1356</span>		<span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="ln"> 1357</span>
<span class="ln"> 1358</span>		<span class="cm">/*
</span><span class="ln"> 1359</span><span class="cm">		 * The furthest away nodes in the system are not interesting
</span><span class="ln"> 1360</span><span class="cm">		 * for placement; nid was already counted.
</span><span class="ln"> 1361</span><span class="cm">		 */</span>
<span class="ln"> 1362</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">sched_max_numa_distance</span> <span class="o">||</span> <span class="n">node</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln"> 1363</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 1364</span>
<span class="ln"> 1365</span>		<span class="cm">/*
</span><span class="ln"> 1366</span><span class="cm">		 * On systems with a backplane NUMA topology, compare groups
</span><span class="ln"> 1367</span><span class="cm">		 * of nodes, and move tasks towards the group with the most
</span><span class="ln"> 1368</span><span class="cm">		 * memory accesses. When comparing two nodes at distance
</span><span class="ln"> 1369</span><span class="cm">		 * &#34;hoplimit&#34;, only nodes closer by than &#34;hoplimit&#34; are part
</span><span class="ln"> 1370</span><span class="cm">		 * of each group. Skip other nodes.
</span><span class="ln"> 1371</span><span class="cm">		 */</span>
<span class="ln"> 1372</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sched_numa_topology_type</span> <span class="o">==</span> <span class="n">NUMA_BACKPLANE</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 1373</span>					<span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">maxdist</span><span class="p">)</span>
<span class="ln"> 1374</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 1375</span>
<span class="ln"> 1376</span>		<span class="cm">/* Add up the faults from nearby nodes. */</span>
<span class="ln"> 1377</span>		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
<span class="ln"> 1378</span>			<span class="n">faults</span> <span class="o">=</span> <span class="n">task_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="ln"> 1379</span>		<span class="k">else</span>
<span class="ln"> 1380</span>			<span class="n">faults</span> <span class="o">=</span> <span class="n">group_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="ln"> 1381</span>
<span class="ln"> 1382</span>		<span class="cm">/*
</span><span class="ln"> 1383</span><span class="cm">		 * On systems with a glueless mesh NUMA topology, there are
</span><span class="ln"> 1384</span><span class="cm">		 * no fixed &#34;groups of nodes&#34;. Instead, nodes that are not
</span><span class="ln"> 1385</span><span class="cm">		 * directly connected bounce traffic through intermediate
</span><span class="ln"> 1386</span><span class="cm">		 * nodes; a numa_group can occupy any set of nodes.
</span><span class="ln"> 1387</span><span class="cm">		 * The further away a node is, the less the faults count.
</span><span class="ln"> 1388</span><span class="cm">		 * This seems to result in good task placement.
</span><span class="ln"> 1389</span><span class="cm">		 */</span>
<span class="ln"> 1390</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sched_numa_topology_type</span> <span class="o">==</span> <span class="n">NUMA_GLUELESS_MESH</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1391</span>			<span class="n">faults</span> <span class="o">*=</span> <span class="p">(</span><span class="n">sched_max_numa_distance</span> <span class="o">-</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1392</span>			<span class="n">faults</span> <span class="o">/=</span> <span class="p">(</span><span class="n">sched_max_numa_distance</span> <span class="o">-</span> <span class="n">LOCAL_DISTANCE</span><span class="p">);</span>
<span class="ln"> 1393</span>		<span class="p">}</span>
<span class="ln"> 1394</span>
<span class="ln"> 1395</span>		<span class="n">score</span> <span class="o">+=</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 1396</span>	<span class="p">}</span>
<span class="ln"> 1397</span>
<span class="ln"> 1398</span>	<span class="k">return</span> <span class="n">score</span><span class="p">;</span>
<span class="ln"> 1399</span><span class="p">}</span>
<span class="ln"> 1400</span>
<span class="ln"> 1401</span><span class="cm">/*
</span><span class="ln"> 1402</span><span class="cm"> * These return the fraction of accesses done by a particular task, or
</span><span class="ln"> 1403</span><span class="cm"> * task group, on a particular numa node.  The group weight is given a
</span><span class="ln"> 1404</span><span class="cm"> * larger multiplier, in order to group tasks together that are almost
</span><span class="ln"> 1405</span><span class="cm"> * evenly spread out between numa nodes.
</span><span class="ln"> 1406</span><span class="cm"> */</span>
<span class="ln"> 1407</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
<span class="ln"> 1408</span>					<span class="kt">int</span> <span class="n">dist</span><span class="p">)</span>
<span class="ln"> 1409</span><span class="p">{</span>
<span class="ln"> 1410</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span><span class="p">,</span> <span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 1411</span>
<span class="ln"> 1412</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">)</span>
<span class="ln"> 1413</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1414</span>
<span class="ln"> 1415</span>	<span class="n">total_faults</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span><span class="p">;</span>
<span class="ln"> 1416</span>
<span class="ln"> 1417</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_faults</span><span class="p">)</span>
<span class="ln"> 1418</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1419</span>
<span class="ln"> 1420</span>	<span class="n">faults</span> <span class="o">=</span> <span class="n">task_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="ln"> 1421</span>	<span class="n">faults</span> <span class="o">+=</span> <span class="n">score_nearby_nodes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln"> 1422</span>
<span class="ln"> 1423</span>	<span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">faults</span> <span class="o">/</span> <span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 1424</span><span class="p">}</span>
<span class="ln"> 1425</span>
<span class="ln"> 1426</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">group_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span>
<span class="ln"> 1427</span>					 <span class="kt">int</span> <span class="n">dist</span><span class="p">)</span>
<span class="ln"> 1428</span><span class="p">{</span>
<span class="ln"> 1429</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span> <span class="o">=</span> <span class="n">deref_task_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1430</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span><span class="p">,</span> <span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 1431</span>
<span class="ln"> 1432</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1433</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1434</span>
<span class="ln"> 1435</span>	<span class="n">total_faults</span> <span class="o">=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 1436</span>
<span class="ln"> 1437</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_faults</span><span class="p">)</span>
<span class="ln"> 1438</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1439</span>
<span class="ln"> 1440</span>	<span class="n">faults</span> <span class="o">=</span> <span class="n">group_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="ln"> 1441</span>	<span class="n">faults</span> <span class="o">+=</span> <span class="n">score_nearby_nodes</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln"> 1442</span>
<span class="ln"> 1443</span>	<span class="k">return</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">faults</span> <span class="o">/</span> <span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 1444</span><span class="p">}</span>
<span class="ln"> 1445</span>
<span class="ln"> 1446</span><span class="kt">bool</span> <span class="nf">should_numa_migrate_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span> <span class="n">page</span><span class="p">,</span>
<span class="ln"> 1447</span>				<span class="kt">int</span> <span class="n">src_nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dst_cpu</span><span class="p">)</span>
<span class="ln"> 1448</span><span class="p">{</span>
<span class="ln"> 1449</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1450</span>	<span class="kt">int</span> <span class="n">dst_nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 1451</span>	<span class="kt">int</span> <span class="n">last_cpupid</span><span class="p">,</span> <span class="n">this_cpupid</span><span class="p">;</span>
<span class="ln"> 1452</span>
<span class="ln"> 1453</span>	<span class="n">this_cpupid</span> <span class="o">=</span> <span class="n">cpu_pid_to_cpupid</span><span class="p">(</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="ln"> 1454</span>	<span class="n">last_cpupid</span> <span class="o">=</span> <span class="n">page_cpupid_xchg_last</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">this_cpupid</span><span class="p">);</span>
<span class="ln"> 1455</span>
<span class="ln"> 1456</span>	<span class="cm">/*
</span><span class="ln"> 1457</span><span class="cm">	 * Allow first faults or private faults to migrate immediately early in
</span><span class="ln"> 1458</span><span class="cm">	 * the lifetime of a task. The magic number 4 is based on waiting for
</span><span class="ln"> 1459</span><span class="cm">	 * two full passes of the &#34;multi-stage node selection&#34; test that is
</span><span class="ln"> 1460</span><span class="cm">	 * executed below.
</span><span class="ln"> 1461</span><span class="cm">	 */</span>
<span class="ln"> 1462</span>	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 1463</span>	    <span class="p">(</span><span class="n">cpupid_pid_unset</span><span class="p">(</span><span class="n">last_cpupid</span><span class="p">)</span> <span class="o">||</span> <span class="n">cpupid_match_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last_cpupid</span><span class="p">)))</span>
<span class="ln"> 1464</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 1465</span>
<span class="ln"> 1466</span>	<span class="cm">/*
</span><span class="ln"> 1467</span><span class="cm">	 * Multi-stage node selection is used in conjunction with a periodic
</span><span class="ln"> 1468</span><span class="cm">	 * migration fault to build a temporal task&lt;-&gt;page relation. By using
</span><span class="ln"> 1469</span><span class="cm">	 * a two-stage filter we remove short/unlikely relations.
</span><span class="ln"> 1470</span><span class="cm">	 *
</span><span class="ln"> 1471</span><span class="cm">	 * Using P(p) ~ n_p / n_t as per frequentist probability, we can equate
</span><span class="ln"> 1472</span><span class="cm">	 * a task&#39;s usage of a particular page (n_p) per total usage of this
</span><span class="ln"> 1473</span><span class="cm">	 * page (n_t) (in a given time-span) to a probability.
</span><span class="ln"> 1474</span><span class="cm">	 *
</span><span class="ln"> 1475</span><span class="cm">	 * Our periodic faults will sample this probability and getting the
</span><span class="ln"> 1476</span><span class="cm">	 * same result twice in a row, given these samples are fully
</span><span class="ln"> 1477</span><span class="cm">	 * independent, is then given by P(n)^2, provided our sample period
</span><span class="ln"> 1478</span><span class="cm">	 * is sufficiently short compared to the usage pattern.
</span><span class="ln"> 1479</span><span class="cm">	 *
</span><span class="ln"> 1480</span><span class="cm">	 * This quadric squishes small probabilities, making it less likely we
</span><span class="ln"> 1481</span><span class="cm">	 * act on an unlikely task&lt;-&gt;page relation.
</span><span class="ln"> 1482</span><span class="cm">	 */</span>
<span class="ln"> 1483</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpupid_pid_unset</span><span class="p">(</span><span class="n">last_cpupid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 1484</span>				<span class="n">cpupid_to_nid</span><span class="p">(</span><span class="n">last_cpupid</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dst_nid</span><span class="p">)</span>
<span class="ln"> 1485</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 1486</span>
<span class="ln"> 1487</span>	<span class="cm">/* Always allow migrate on private faults */</span>
<span class="ln"> 1488</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpupid_match_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last_cpupid</span><span class="p">))</span>
<span class="ln"> 1489</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 1490</span>
<span class="ln"> 1491</span>	<span class="cm">/* A shared fault, but p-&gt;numa_group has not been set up yet. */</span>
<span class="ln"> 1492</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ng</span><span class="p">)</span>
<span class="ln"> 1493</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 1494</span>
<span class="ln"> 1495</span>	<span class="cm">/*
</span><span class="ln"> 1496</span><span class="cm">	 * Destination node is much more heavily used than the source
</span><span class="ln"> 1497</span><span class="cm">	 * node? Allow migration.
</span><span class="ln"> 1498</span><span class="cm">	 */</span>
<span class="ln"> 1499</span>	<span class="k">if</span> <span class="p">(</span><span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">src_nid</span><span class="p">)</span> <span class="o">*</span>
<span class="ln"> 1500</span>					<span class="n">ACTIVE_NODE_FRACTION</span><span class="p">)</span>
<span class="ln"> 1501</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 1502</span>
<span class="ln"> 1503</span>	<span class="cm">/*
</span><span class="ln"> 1504</span><span class="cm">	 * Distribute memory according to CPU &amp; memory use on each node,
</span><span class="ln"> 1505</span><span class="cm">	 * with 3/4 hysteresis to avoid unnecessary memory migrations:
</span><span class="ln"> 1506</span><span class="cm">	 *
</span><span class="ln"> 1507</span><span class="cm">	 * faults_cpu(dst)   3   faults_cpu(src)
</span><span class="ln"> 1508</span><span class="cm">	 * --------------- * - &gt; ---------------
</span><span class="ln"> 1509</span><span class="cm">	 * faults_mem(dst)   4   faults_mem(src)
</span><span class="ln"> 1510</span><span class="cm">	 */</span>
<span class="ln"> 1511</span>	<span class="k">return</span> <span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">)</span> <span class="o">*</span> <span class="n">group_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">src_nid</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&gt;</span>
<span class="ln"> 1512</span>	       <span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">src_nid</span><span class="p">)</span> <span class="o">*</span> <span class="n">group_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
<span class="ln"> 1513</span><span class="p">}</span>
<span class="ln"> 1514</span>
<span class="ln"> 1515</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">weighted_cpuload</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 1516</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">source_load</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="ln"> 1517</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">target_load</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="ln"> 1518</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">capacity_of</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 1519</span>
<span class="ln"> 1520</span><span class="cm">/* Cached statistics for all CPUs within a node */</span>
<span class="ln"> 1521</span><span class="k">struct</span> <span class="n">numa_stats</span> <span class="p">{</span>
<span class="ln"> 1522</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1523</span>
<span class="ln"> 1524</span>	<span class="cm">/* Total compute capacity of CPUs on a node */</span>
<span class="ln"> 1525</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">compute_capacity</span><span class="p">;</span>
<span class="ln"> 1526</span>
<span class="ln"> 1527</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_running</span><span class="p">;</span>
<span class="ln"> 1528</span><span class="p">};</span>
<span class="ln"> 1529</span>
<span class="ln"> 1530</span><span class="cm">/*
</span><span class="ln"> 1531</span><span class="cm"> * XXX borrowed from update_sg_lb_stats
</span><span class="ln"> 1532</span><span class="cm"> */</span>
<span class="ln"> 1533</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_numa_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_stats</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln"> 1534</span><span class="p">{</span>
<span class="ln"> 1535</span>	<span class="kt">int</span> <span class="n">smt</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cpus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1536</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 1537</span>
<span class="ln"> 1538</span>	<span class="n">memset</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ns</span><span class="p">));</span>
<span class="ln"> 1539</span>	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 1540</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 1541</span>
<span class="ln"> 1542</span>		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">+=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">;</span>
<span class="ln"> 1543</span>		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">load</span> <span class="o">+=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 1544</span>		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">compute_capacity</span> <span class="o">+=</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 1545</span>
<span class="ln"> 1546</span>		<span class="n">cpus</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 1547</span>	<span class="p">}</span>
<span class="ln"> 1548</span>
<span class="ln"> 1549</span>	<span class="cm">/*
</span><span class="ln"> 1550</span><span class="cm">	 * If we raced with hotplug and there are no CPUs left in our mask
</span><span class="ln"> 1551</span><span class="cm">	 * the @ns structure is NULL&#39;ed and task_numa_compare() will
</span><span class="ln"> 1552</span><span class="cm">	 * not find this node attractive.
</span><span class="ln"> 1553</span><span class="cm">	 *
</span><span class="ln"> 1554</span><span class="cm">	 * We&#39;ll detect a huge imbalance and bail there.
</span><span class="ln"> 1555</span><span class="cm">	 */</span>
<span class="ln"> 1556</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpus</span><span class="p">)</span>
<span class="ln"> 1557</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1558</span>
<span class="ln"> 1559</span>	<span class="cm">/* smt := ceil(cpus / capacity), assumes: 1 &lt; smt_power &lt; 2 */</span>
<span class="ln"> 1560</span>	<span class="n">smt</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">SCHED_CAPACITY_SCALE</span> <span class="o">*</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">compute_capacity</span><span class="p">);</span>
<span class="ln"> 1561</span>	<span class="n">capacity</span> <span class="o">=</span> <span class="n">cpus</span> <span class="o">/</span> <span class="n">smt</span><span class="p">;</span> <span class="cm">/* cores */</span>
<span class="ln"> 1562</span>
<span class="ln"> 1563</span>	<span class="n">capacity</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
<span class="ln"> 1564</span>		<span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">compute_capacity</span><span class="p">,</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">));</span>
<span class="ln"> 1565</span><span class="p">}</span>
<span class="ln"> 1566</span>
<span class="ln"> 1567</span><span class="k">struct</span> <span class="n">task_numa_env</span> <span class="p">{</span>
<span class="ln"> 1568</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln"> 1569</span>
<span class="ln"> 1570</span>	<span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="n">src_nid</span><span class="p">;</span>
<span class="ln"> 1571</span>	<span class="kt">int</span> <span class="n">dst_cpu</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">;</span>
<span class="ln"> 1572</span>
<span class="ln"> 1573</span>	<span class="k">struct</span> <span class="n">numa_stats</span> <span class="n">src_stats</span><span class="p">,</span> <span class="n">dst_stats</span><span class="p">;</span>
<span class="ln"> 1574</span>
<span class="ln"> 1575</span>	<span class="kt">int</span> <span class="n">imbalance_pct</span><span class="p">;</span>
<span class="ln"> 1576</span>	<span class="kt">int</span> <span class="n">dist</span><span class="p">;</span>
<span class="ln"> 1577</span>
<span class="ln"> 1578</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">best_task</span><span class="p">;</span>
<span class="ln"> 1579</span>	<span class="kt">long</span> <span class="n">best_imp</span><span class="p">;</span>
<span class="ln"> 1580</span>	<span class="kt">int</span> <span class="n">best_cpu</span><span class="p">;</span>
<span class="ln"> 1581</span><span class="p">};</span>
<span class="ln"> 1582</span>
<span class="ln"> 1583</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_numa_assign</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_numa_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
<span class="ln"> 1584</span>			     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">imp</span><span class="p">)</span>
<span class="ln"> 1585</span><span class="p">{</span>
<span class="ln"> 1586</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 1587</span>
<span class="ln"> 1588</span>	<span class="cm">/* Bail out if run-queue part of active NUMA balance. */</span>
<span class="ln"> 1589</span>	<span class="k">if</span> <span class="p">(</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">numa_migrate_on</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="ln"> 1590</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1591</span>
<span class="ln"> 1592</span>	<span class="cm">/*
</span><span class="ln"> 1593</span><span class="cm">	 * Clear previous best_cpu/rq numa-migrate flag, since task now
</span><span class="ln"> 1594</span><span class="cm">	 * found a better CPU to move/swap.
</span><span class="ln"> 1595</span><span class="cm">	 */</span>
<span class="ln"> 1596</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">best_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1597</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">best_cpu</span><span class="p">);</span>
<span class="ln"> 1598</span>		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">numa_migrate_on</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 1599</span>	<span class="p">}</span>
<span class="ln"> 1600</span>
<span class="ln"> 1601</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">best_task</span><span class="p">)</span>
<span class="ln"> 1602</span>		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">best_task</span><span class="p">);</span>
<span class="ln"> 1603</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1604</span>		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1605</span>
<span class="ln"> 1606</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">best_task</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="ln"> 1607</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">best_imp</span> <span class="o">=</span> <span class="n">imp</span><span class="p">;</span>
<span class="ln"> 1608</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">best_cpu</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">;</span>
<span class="ln"> 1609</span><span class="p">}</span>
<span class="ln"> 1610</span>
<span class="ln"> 1611</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">load_too_imbalanced</span><span class="p">(</span><span class="kt">long</span> <span class="n">src_load</span><span class="p">,</span> <span class="kt">long</span> <span class="n">dst_load</span><span class="p">,</span>
<span class="ln"> 1612</span>				<span class="k">struct</span> <span class="n">task_numa_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 1613</span><span class="p">{</span>
<span class="ln"> 1614</span>	<span class="kt">long</span> <span class="n">imb</span><span class="p">,</span> <span class="n">old_imb</span><span class="p">;</span>
<span class="ln"> 1615</span>	<span class="kt">long</span> <span class="n">orig_src_load</span><span class="p">,</span> <span class="n">orig_dst_load</span><span class="p">;</span>
<span class="ln"> 1616</span>	<span class="kt">long</span> <span class="n">src_capacity</span><span class="p">,</span> <span class="n">dst_capacity</span><span class="p">;</span>
<span class="ln"> 1617</span>
<span class="ln"> 1618</span>	<span class="cm">/*
</span><span class="ln"> 1619</span><span class="cm">	 * The load is corrected for the CPU capacity available on each node.
</span><span class="ln"> 1620</span><span class="cm">	 *
</span><span class="ln"> 1621</span><span class="cm">	 * src_load        dst_load
</span><span class="ln"> 1622</span><span class="cm">	 * ------------ vs ---------
</span><span class="ln"> 1623</span><span class="cm">	 * src_capacity    dst_capacity
</span><span class="ln"> 1624</span><span class="cm">	 */</span>
<span class="ln"> 1625</span>	<span class="n">src_capacity</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_stats</span><span class="p">.</span><span class="n">compute_capacity</span><span class="p">;</span>
<span class="ln"> 1626</span>	<span class="n">dst_capacity</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_stats</span><span class="p">.</span><span class="n">compute_capacity</span><span class="p">;</span>
<span class="ln"> 1627</span>
<span class="ln"> 1628</span>	<span class="n">imb</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">dst_load</span> <span class="o">*</span> <span class="n">src_capacity</span> <span class="o">-</span> <span class="n">src_load</span> <span class="o">*</span> <span class="n">dst_capacity</span><span class="p">);</span>
<span class="ln"> 1629</span>
<span class="ln"> 1630</span>	<span class="n">orig_src_load</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_stats</span><span class="p">.</span><span class="n">load</span><span class="p">;</span>
<span class="ln"> 1631</span>	<span class="n">orig_dst_load</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_stats</span><span class="p">.</span><span class="n">load</span><span class="p">;</span>
<span class="ln"> 1632</span>
<span class="ln"> 1633</span>	<span class="n">old_imb</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">orig_dst_load</span> <span class="o">*</span> <span class="n">src_capacity</span> <span class="o">-</span> <span class="n">orig_src_load</span> <span class="o">*</span> <span class="n">dst_capacity</span><span class="p">);</span>
<span class="ln"> 1634</span>
<span class="ln"> 1635</span>	<span class="cm">/* Would this change make things worse? */</span>
<span class="ln"> 1636</span>	<span class="k">return</span> <span class="p">(</span><span class="n">imb</span> <span class="o">&gt;</span> <span class="n">old_imb</span><span class="p">);</span>
<span class="ln"> 1637</span><span class="p">}</span>
<span class="ln"> 1638</span>
<span class="ln"> 1639</span><span class="cm">/*
</span><span class="ln"> 1640</span><span class="cm"> * Maximum NUMA importance can be 1998 (2*999);
</span><span class="ln"> 1641</span><span class="cm"> * SMALLIMP @ 30 would be close to 1998/64.
</span><span class="ln"> 1642</span><span class="cm"> * Used to deter task migration.
</span><span class="ln"> 1643</span><span class="cm"> */</span>
<span class="ln"> 1644</span><span class="cp">#define SMALLIMP	30
</span><span class="ln"> 1645</span><span class="cp"></span>
<span class="ln"> 1646</span><span class="cm">/*
</span><span class="ln"> 1647</span><span class="cm"> * This checks if the overall compute and NUMA accesses of the system would
</span><span class="ln"> 1648</span><span class="cm"> * be improved if the source tasks was migrated to the target dst_cpu taking
</span><span class="ln"> 1649</span><span class="cm"> * into account that it might be best if task running on the dst_cpu should
</span><span class="ln"> 1650</span><span class="cm"> * be exchanged with the source task
</span><span class="ln"> 1651</span><span class="cm"> */</span>
<span class="ln"> 1652</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_numa_compare</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_numa_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
<span class="ln"> 1653</span>			      <span class="kt">long</span> <span class="n">taskimp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">groupimp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">maymove</span><span class="p">)</span>
<span class="ln"> 1654</span><span class="p">{</span>
<span class="ln"> 1655</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">cur_ng</span><span class="p">,</span> <span class="o">*</span><span class="n">p_ng</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1656</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">dst_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 1657</span>	<span class="kt">long</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">p_ng</span> <span class="o">?</span> <span class="nl">groupimp</span> <span class="p">:</span> <span class="n">taskimp</span><span class="p">;</span>
<span class="ln"> 1658</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
<span class="ln"> 1659</span>	<span class="kt">long</span> <span class="n">src_load</span><span class="p">,</span> <span class="n">dst_load</span><span class="p">;</span>
<span class="ln"> 1660</span>	<span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dist</span><span class="p">;</span>
<span class="ln"> 1661</span>	<span class="kt">long</span> <span class="n">moveimp</span> <span class="o">=</span> <span class="n">imp</span><span class="p">;</span>
<span class="ln"> 1662</span>	<span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1663</span>
<span class="ln"> 1664</span>	<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">dst_rq</span><span class="o">-&gt;</span><span class="n">numa_migrate_on</span><span class="p">))</span>
<span class="ln"> 1665</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1666</span>
<span class="ln"> 1667</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 1668</span>	<span class="n">cur</span> <span class="o">=</span> <span class="n">task_rcu_dereference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 1669</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="o">||</span> <span class="n">is_idle_task</span><span class="p">(</span><span class="n">cur</span><span class="p">)))</span>
<span class="ln"> 1670</span>		<span class="n">cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 1671</span>
<span class="ln"> 1672</span>	<span class="cm">/*
</span><span class="ln"> 1673</span><span class="cm">	 * Because we have preemption enabled we can get migrated around and
</span><span class="ln"> 1674</span><span class="cm">	 * end try selecting ourselves (current == env-&gt;p) as a swap candidate.
</span><span class="ln"> 1675</span><span class="cm">	 */</span>
<span class="ln"> 1676</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1677</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 1678</span>
<span class="ln"> 1679</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1680</span>		<span class="k">if</span> <span class="p">(</span><span class="n">maymove</span> <span class="o">&amp;&amp;</span> <span class="n">moveimp</span> <span class="o">&gt;=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">best_imp</span><span class="p">)</span>
<span class="ln"> 1681</span>			<span class="k">goto</span> <span class="n">assign</span><span class="p">;</span>
<span class="ln"> 1682</span>		<span class="k">else</span>
<span class="ln"> 1683</span>			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 1684</span>	<span class="p">}</span>
<span class="ln"> 1685</span>
<span class="ln"> 1686</span>	<span class="cm">/*
</span><span class="ln"> 1687</span><span class="cm">	 * &#34;imp&#34; is the fault differential for the source task between the
</span><span class="ln"> 1688</span><span class="cm">	 * source and destination node. Calculate the total differential for
</span><span class="ln"> 1689</span><span class="cm">	 * the source task and potential destination task. The more negative
</span><span class="ln"> 1690</span><span class="cm">	 * the value is, the more remote accesses that would be expected to
</span><span class="ln"> 1691</span><span class="cm">	 * be incurred if the tasks were swapped.
</span><span class="ln"> 1692</span><span class="cm">	 */</span>
<span class="ln"> 1693</span>	<span class="cm">/* Skip this swap candidate if cannot move to the source cpu */</span>
<span class="ln"> 1694</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 1695</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 1696</span>
<span class="ln"> 1697</span>	<span class="cm">/*
</span><span class="ln"> 1698</span><span class="cm">	 * If dst and source tasks are in the same NUMA group, or not
</span><span class="ln"> 1699</span><span class="cm">	 * in any group then look only at task weights.
</span><span class="ln"> 1700</span><span class="cm">	 */</span>
<span class="ln"> 1701</span>	<span class="n">cur_ng</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln"> 1702</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ng</span> <span class="o">==</span> <span class="n">p_ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1703</span>		<span class="n">imp</span> <span class="o">=</span> <span class="n">taskimp</span> <span class="o">+</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span>
<span class="ln"> 1704</span>		      <span class="n">task_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1705</span>		<span class="cm">/*
</span><span class="ln"> 1706</span><span class="cm">		 * Add some hysteresis to prevent swapping the
</span><span class="ln"> 1707</span><span class="cm">		 * tasks within a group over tiny differences.
</span><span class="ln"> 1708</span><span class="cm">		 */</span>
<span class="ln"> 1709</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cur_ng</span><span class="p">)</span>
<span class="ln"> 1710</span>			<span class="n">imp</span> <span class="o">-=</span> <span class="n">imp</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
<span class="ln"> 1711</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 1712</span>		<span class="cm">/*
</span><span class="ln"> 1713</span><span class="cm">		 * Compare the group weights. If a task is all by itself
</span><span class="ln"> 1714</span><span class="cm">		 * (not part of a group), use the task weight instead.
</span><span class="ln"> 1715</span><span class="cm">		 */</span>
<span class="ln"> 1716</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cur_ng</span> <span class="o">&amp;&amp;</span> <span class="n">p_ng</span><span class="p">)</span>
<span class="ln"> 1717</span>			<span class="n">imp</span> <span class="o">+=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span>
<span class="ln"> 1718</span>			       <span class="n">group_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1719</span>		<span class="k">else</span>
<span class="ln"> 1720</span>			<span class="n">imp</span> <span class="o">+=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span>
<span class="ln"> 1721</span>			       <span class="n">task_weight</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1722</span>	<span class="p">}</span>
<span class="ln"> 1723</span>
<span class="ln"> 1724</span>	<span class="k">if</span> <span class="p">(</span><span class="n">maymove</span> <span class="o">&amp;&amp;</span> <span class="n">moveimp</span> <span class="o">&gt;</span> <span class="n">imp</span> <span class="o">&amp;&amp;</span> <span class="n">moveimp</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">best_imp</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1725</span>		<span class="n">imp</span> <span class="o">=</span> <span class="n">moveimp</span><span class="p">;</span>
<span class="ln"> 1726</span>		<span class="n">cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 1727</span>		<span class="k">goto</span> <span class="n">assign</span><span class="p">;</span>
<span class="ln"> 1728</span>	<span class="p">}</span>
<span class="ln"> 1729</span>
<span class="ln"> 1730</span>	<span class="cm">/*
</span><span class="ln"> 1731</span><span class="cm">	 * If the NUMA importance is less than SMALLIMP,
</span><span class="ln"> 1732</span><span class="cm">	 * task migration might only result in ping pong
</span><span class="ln"> 1733</span><span class="cm">	 * of tasks and also hurt performance due to cache
</span><span class="ln"> 1734</span><span class="cm">	 * misses.
</span><span class="ln"> 1735</span><span class="cm">	 */</span>
<span class="ln"> 1736</span>	<span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">&lt;</span> <span class="n">SMALLIMP</span> <span class="o">||</span> <span class="n">imp</span> <span class="o">&lt;=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">best_imp</span> <span class="o">+</span> <span class="n">SMALLIMP</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="ln"> 1737</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 1738</span>
<span class="ln"> 1739</span>	<span class="cm">/*
</span><span class="ln"> 1740</span><span class="cm">	 * In the overloaded case, try and keep the load balanced.
</span><span class="ln"> 1741</span><span class="cm">	 */</span>
<span class="ln"> 1742</span>	<span class="n">load</span> <span class="o">=</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
<span class="ln"> 1743</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load</span><span class="p">)</span>
<span class="ln"> 1744</span>		<span class="k">goto</span> <span class="n">assign</span><span class="p">;</span>
<span class="ln"> 1745</span>
<span class="ln"> 1746</span>	<span class="n">dst_load</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_stats</span><span class="p">.</span><span class="n">load</span> <span class="o">+</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1747</span>	<span class="n">src_load</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_stats</span><span class="p">.</span><span class="n">load</span> <span class="o">-</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1748</span>
<span class="ln"> 1749</span>	<span class="k">if</span> <span class="p">(</span><span class="n">load_too_imbalanced</span><span class="p">(</span><span class="n">src_load</span><span class="p">,</span> <span class="n">dst_load</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
<span class="ln"> 1750</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 1751</span>
<span class="ln"> 1752</span><span class="nl">assign</span><span class="p">:</span>
<span class="ln"> 1753</span>	<span class="cm">/*
</span><span class="ln"> 1754</span><span class="cm">	 * One idle CPU per node is evaluated for a task numa move.
</span><span class="ln"> 1755</span><span class="cm">	 * Call select_idle_sibling to maybe find a better one.
</span><span class="ln"> 1756</span><span class="cm">	 */</span>
<span class="ln"> 1757</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1758</span>		<span class="cm">/*
</span><span class="ln"> 1759</span><span class="cm">		 * select_idle_siblings() uses an per-CPU cpumask that
</span><span class="ln"> 1760</span><span class="cm">		 * can be used from IRQ context.
</span><span class="ln"> 1761</span><span class="cm">		 */</span>
<span class="ln"> 1762</span>		<span class="n">local_irq_disable</span><span class="p">();</span>
<span class="ln"> 1763</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span> <span class="o">=</span> <span class="n">select_idle_sibling</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">,</span>
<span class="ln"> 1764</span>						   <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 1765</span>		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="ln"> 1766</span>	<span class="p">}</span>
<span class="ln"> 1767</span>
<span class="ln"> 1768</span>	<span class="n">task_numa_assign</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">imp</span><span class="p">);</span>
<span class="ln"> 1769</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln"> 1770</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 1771</span><span class="p">}</span>
<span class="ln"> 1772</span>
<span class="ln"> 1773</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_numa_find_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_numa_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
<span class="ln"> 1774</span>				<span class="kt">long</span> <span class="n">taskimp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">groupimp</span><span class="p">)</span>
<span class="ln"> 1775</span><span class="p">{</span>
<span class="ln"> 1776</span>	<span class="kt">long</span> <span class="n">src_load</span><span class="p">,</span> <span class="n">dst_load</span><span class="p">,</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1777</span>	<span class="kt">bool</span> <span class="n">maymove</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 1778</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 1779</span>
<span class="ln"> 1780</span>	<span class="n">load</span> <span class="o">=</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1781</span>	<span class="n">dst_load</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_stats</span><span class="p">.</span><span class="n">load</span> <span class="o">+</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1782</span>	<span class="n">src_load</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_stats</span><span class="p">.</span><span class="n">load</span> <span class="o">-</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 1783</span>
<span class="ln"> 1784</span>	<span class="cm">/*
</span><span class="ln"> 1785</span><span class="cm">	 * If the improvement from just moving env-&gt;p direction is better
</span><span class="ln"> 1786</span><span class="cm">	 * than swapping tasks around, check if a move is possible.
</span><span class="ln"> 1787</span><span class="cm">	 */</span>
<span class="ln"> 1788</span>	<span class="n">maymove</span> <span class="o">=</span> <span class="o">!</span><span class="n">load_too_imbalanced</span><span class="p">(</span><span class="n">src_load</span><span class="p">,</span> <span class="n">dst_load</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
<span class="ln"> 1789</span>
<span class="ln"> 1790</span>	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpumask_of_node</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_nid</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 1791</span>		<span class="cm">/* Skip this CPU if the source task cannot migrate */</span>
<span class="ln"> 1792</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 1793</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 1794</span>
<span class="ln"> 1795</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 1796</span>		<span class="n">task_numa_compare</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">taskimp</span><span class="p">,</span> <span class="n">groupimp</span><span class="p">,</span> <span class="n">maymove</span><span class="p">);</span>
<span class="ln"> 1797</span>	<span class="p">}</span>
<span class="ln"> 1798</span><span class="p">}</span>
<span class="ln"> 1799</span>
<span class="ln"> 1800</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">task_numa_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1801</span><span class="p">{</span>
<span class="ln"> 1802</span>	<span class="k">struct</span> <span class="n">task_numa_env</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 1803</span>		<span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span>
<span class="ln"> 1804</span>
<span class="ln"> 1805</span>		<span class="p">.</span><span class="n">src_cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
<span class="ln"> 1806</span>		<span class="p">.</span><span class="n">src_nid</span> <span class="o">=</span> <span class="n">task_node</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
<span class="ln"> 1807</span>
<span class="ln"> 1808</span>		<span class="p">.</span><span class="n">imbalance_pct</span> <span class="o">=</span> <span class="mi">112</span><span class="p">,</span>
<span class="ln"> 1809</span>
<span class="ln"> 1810</span>		<span class="p">.</span><span class="n">best_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="ln"> 1811</span>		<span class="p">.</span><span class="n">best_imp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="ln"> 1812</span>		<span class="p">.</span><span class="n">best_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="ln"> 1813</span>	<span class="p">};</span>
<span class="ln"> 1814</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">taskweight</span><span class="p">,</span> <span class="n">groupweight</span><span class="p">;</span>
<span class="ln"> 1815</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 1816</span>	<span class="kt">long</span> <span class="n">taskimp</span><span class="p">,</span> <span class="n">groupimp</span><span class="p">;</span>
<span class="ln"> 1817</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln"> 1818</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">best_rq</span><span class="p">;</span>
<span class="ln"> 1819</span>	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">dist</span><span class="p">;</span>
<span class="ln"> 1820</span>
<span class="ln"> 1821</span>	<span class="cm">/*
</span><span class="ln"> 1822</span><span class="cm">	 * Pick the lowest SD_NUMA domain, as that would have the smallest
</span><span class="ln"> 1823</span><span class="cm">	 * imbalance and would be the first to start moving tasks about.
</span><span class="ln"> 1824</span><span class="cm">	 *
</span><span class="ln"> 1825</span><span class="cm">	 * And we want to avoid any moving of tasks about, as that would create
</span><span class="ln"> 1826</span><span class="cm">	 * random movement of tasks -- counter the numa conditions we&#39;re trying
</span><span class="ln"> 1827</span><span class="cm">	 * to satisfy here.
</span><span class="ln"> 1828</span><span class="cm">	 */</span>
<span class="ln"> 1829</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 1830</span>	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_numa</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">));</span>
<span class="ln"> 1831</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span>
<span class="ln"> 1832</span>		<span class="n">env</span><span class="p">.</span><span class="n">imbalance_pct</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 1833</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 1834</span>
<span class="ln"> 1835</span>	<span class="cm">/*
</span><span class="ln"> 1836</span><span class="cm">	 * Cpusets can break the scheduler domain tree into smaller
</span><span class="ln"> 1837</span><span class="cm">	 * balance domains, some of which do not cross NUMA boundaries.
</span><span class="ln"> 1838</span><span class="cm">	 * Tasks that are &#34;trapped&#34; in such domains cannot be migrated
</span><span class="ln"> 1839</span><span class="cm">	 * elsewhere, so there is no point in (re)trying.
</span><span class="ln"> 1840</span><span class="cm">	 */</span>
<span class="ln"> 1841</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 1842</span>		<span class="n">sched_setnuma</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_node</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 1843</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln"> 1844</span>	<span class="p">}</span>
<span class="ln"> 1845</span>
<span class="ln"> 1846</span>	<span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">;</span>
<span class="ln"> 1847</span>	<span class="n">dist</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span><span class="p">);</span>
<span class="ln"> 1848</span>	<span class="n">taskweight</span> <span class="o">=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1849</span>	<span class="n">groupweight</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1850</span>	<span class="n">update_numa_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">.</span><span class="n">src_stats</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">);</span>
<span class="ln"> 1851</span>	<span class="n">taskimp</span> <span class="o">=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span> <span class="n">taskweight</span><span class="p">;</span>
<span class="ln"> 1852</span>	<span class="n">groupimp</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span> <span class="n">groupweight</span><span class="p">;</span>
<span class="ln"> 1853</span>	<span class="n">update_numa_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">.</span><span class="n">dst_stats</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span><span class="p">);</span>
<span class="ln"> 1854</span>
<span class="ln"> 1855</span>	<span class="cm">/* Try to find a spot on the preferred nid. */</span>
<span class="ln"> 1856</span>	<span class="n">task_numa_find_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">taskimp</span><span class="p">,</span> <span class="n">groupimp</span><span class="p">);</span>
<span class="ln"> 1857</span>
<span class="ln"> 1858</span>	<span class="cm">/*
</span><span class="ln"> 1859</span><span class="cm">	 * Look at other nodes in these cases:
</span><span class="ln"> 1860</span><span class="cm">	 * - there is no space available on the preferred_nid
</span><span class="ln"> 1861</span><span class="cm">	 * - the task is part of a numa_group that is interleaved across
</span><span class="ln"> 1862</span><span class="cm">	 *   multiple NUMA nodes; in order to better consolidate the group,
</span><span class="ln"> 1863</span><span class="cm">	 *   we need to check other locations.
</span><span class="ln"> 1864</span><span class="cm">	 */</span>
<span class="ln"> 1865</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1866</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">ng</span> <span class="o">&amp;&amp;</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">active_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 1867</span>		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1868</span>			<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span> <span class="o">||</span> <span class="n">nid</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">)</span>
<span class="ln"> 1869</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 1870</span>
<span class="ln"> 1871</span>			<span class="n">dist</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span><span class="p">);</span>
<span class="ln"> 1872</span>			<span class="k">if</span> <span class="p">(</span><span class="n">sched_numa_topology_type</span> <span class="o">==</span> <span class="n">NUMA_BACKPLANE</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 1873</span>						<span class="n">dist</span> <span class="o">!=</span> <span class="n">env</span><span class="p">.</span><span class="n">dist</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1874</span>				<span class="n">taskweight</span> <span class="o">=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1875</span>				<span class="n">groupweight</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 1876</span>			<span class="p">}</span>
<span class="ln"> 1877</span>
<span class="ln"> 1878</span>			<span class="cm">/* Only consider nodes where both task and groups benefit */</span>
<span class="ln"> 1879</span>			<span class="n">taskimp</span> <span class="o">=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span> <span class="n">taskweight</span><span class="p">;</span>
<span class="ln"> 1880</span>			<span class="n">groupimp</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="o">-</span> <span class="n">groupweight</span><span class="p">;</span>
<span class="ln"> 1881</span>			<span class="k">if</span> <span class="p">(</span><span class="n">taskimp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">groupimp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 1882</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 1883</span>
<span class="ln"> 1884</span>			<span class="n">env</span><span class="p">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">;</span>
<span class="ln"> 1885</span>			<span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln"> 1886</span>			<span class="n">update_numa_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">.</span><span class="n">dst_stats</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_nid</span><span class="p">);</span>
<span class="ln"> 1887</span>			<span class="n">task_numa_find_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">taskimp</span><span class="p">,</span> <span class="n">groupimp</span><span class="p">);</span>
<span class="ln"> 1888</span>		<span class="p">}</span>
<span class="ln"> 1889</span>	<span class="p">}</span>
<span class="ln"> 1890</span>
<span class="ln"> 1891</span>	<span class="cm">/*
</span><span class="ln"> 1892</span><span class="cm">	 * If the task is part of a workload that spans multiple NUMA nodes,
</span><span class="ln"> 1893</span><span class="cm">	 * and is migrating into one of the workload&#39;s active nodes, remember
</span><span class="ln"> 1894</span><span class="cm">	 * this node as the task&#39;s preferred numa node, so the workload can
</span><span class="ln"> 1895</span><span class="cm">	 * settle down.
</span><span class="ln"> 1896</span><span class="cm">	 * A task that migrated to a second choice node will be better off
</span><span class="ln"> 1897</span><span class="cm">	 * trying for a better one later. Do not set the preferred node here.
</span><span class="ln"> 1898</span><span class="cm">	 */</span>
<span class="ln"> 1899</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1900</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="ln"> 1901</span>			<span class="n">nid</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="n">src_nid</span><span class="p">;</span>
<span class="ln"> 1902</span>		<span class="k">else</span>
<span class="ln"> 1903</span>			<span class="n">nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span><span class="p">);</span>
<span class="ln"> 1904</span>
<span class="ln"> 1905</span>		<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">)</span>
<span class="ln"> 1906</span>			<span class="n">sched_setnuma</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="ln"> 1907</span>	<span class="p">}</span>
<span class="ln"> 1908</span>
<span class="ln"> 1909</span>	<span class="cm">/* No better CPU than the current one was found. */</span>
<span class="ln"> 1910</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="ln"> 1911</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="ln"> 1912</span>
<span class="ln"> 1913</span>	<span class="n">best_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span><span class="p">);</span>
<span class="ln"> 1914</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1915</span>		<span class="n">ret</span> <span class="o">=</span> <span class="n">migrate_task_to</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span><span class="p">);</span>
<span class="ln"> 1916</span>		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">best_rq</span><span class="o">-&gt;</span><span class="n">numa_migrate_on</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 1917</span>		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 1918</span>			<span class="n">trace_sched_stick_numa</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span><span class="p">);</span>
<span class="ln"> 1919</span>		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 1920</span>	<span class="p">}</span>
<span class="ln"> 1921</span>
<span class="ln"> 1922</span>	<span class="n">ret</span> <span class="o">=</span> <span class="n">migrate_swap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">best_task</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">best_cpu</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">);</span>
<span class="ln"> 1923</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">best_rq</span><span class="o">-&gt;</span><span class="n">numa_migrate_on</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 1924</span>
<span class="ln"> 1925</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 1926</span>		<span class="n">trace_sched_stick_numa</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_task</span><span class="p">));</span>
<span class="ln"> 1927</span>	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">best_task</span><span class="p">);</span>
<span class="ln"> 1928</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 1929</span><span class="p">}</span>
<span class="ln"> 1930</span>
<span class="ln"> 1931</span><span class="cm">/* Attempt to migrate a task to a CPU on the preferred node. */</span>
<span class="ln"> 1932</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">numa_migrate_preferred</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 1933</span><span class="p">{</span>
<span class="ln"> 1934</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
<span class="ln"> 1935</span>
<span class="ln"> 1936</span>	<span class="cm">/* This task has no NUMA fault statistics yet */</span>
<span class="ln"> 1937</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">))</span>
<span class="ln"> 1938</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1939</span>
<span class="ln"> 1940</span>	<span class="cm">/* Periodically retry migrating the task to the preferred node */</span>
<span class="ln"> 1941</span>	<span class="n">interval</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
<span class="ln"> 1942</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_migrate_retry</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 1943</span>
<span class="ln"> 1944</span>	<span class="cm">/* Success if task is already running on preferred CPU */</span>
<span class="ln"> 1945</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_node</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">)</span>
<span class="ln"> 1946</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 1947</span>
<span class="ln"> 1948</span>	<span class="cm">/* Otherwise, try migrate to a CPU on the preferred node */</span>
<span class="ln"> 1949</span>	<span class="n">task_numa_migrate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 1950</span><span class="p">}</span>
<span class="ln"> 1951</span>
<span class="ln"> 1952</span><span class="cm">/*
</span><span class="ln"> 1953</span><span class="cm"> * Find out how many nodes on the workload is actively running on. Do this by
</span><span class="ln"> 1954</span><span class="cm"> * tracking the nodes from which NUMA hinting faults are triggered. This can
</span><span class="ln"> 1955</span><span class="cm"> * be different from the set of nodes where the workload&#39;s memory is currently
</span><span class="ln"> 1956</span><span class="cm"> * located.
</span><span class="ln"> 1957</span><span class="cm"> */</span>
<span class="ln"> 1958</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">numa_group_count_active_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">numa_group</span><span class="p">)</span>
<span class="ln"> 1959</span><span class="p">{</span>
<span class="ln"> 1960</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span><span class="p">,</span> <span class="n">max_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1961</span>	<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">active_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 1962</span>
<span class="ln"> 1963</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1964</span>		<span class="n">faults</span> <span class="o">=</span> <span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">numa_group</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="ln"> 1965</span>		<span class="k">if</span> <span class="p">(</span><span class="n">faults</span> <span class="o">&gt;</span> <span class="n">max_faults</span><span class="p">)</span>
<span class="ln"> 1966</span>			<span class="n">max_faults</span> <span class="o">=</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 1967</span>	<span class="p">}</span>
<span class="ln"> 1968</span>
<span class="ln"> 1969</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 1970</span>		<span class="n">faults</span> <span class="o">=</span> <span class="n">group_faults_cpu</span><span class="p">(</span><span class="n">numa_group</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
<span class="ln"> 1971</span>		<span class="k">if</span> <span class="p">(</span><span class="n">faults</span> <span class="o">*</span> <span class="n">ACTIVE_NODE_FRACTION</span> <span class="o">&gt;</span> <span class="n">max_faults</span><span class="p">)</span>
<span class="ln"> 1972</span>			<span class="n">active_nodes</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 1973</span>	<span class="p">}</span>
<span class="ln"> 1974</span>
<span class="ln"> 1975</span>	<span class="n">numa_group</span><span class="o">-&gt;</span><span class="n">max_faults_cpu</span> <span class="o">=</span> <span class="n">max_faults</span><span class="p">;</span>
<span class="ln"> 1976</span>	<span class="n">numa_group</span><span class="o">-&gt;</span><span class="n">active_nodes</span> <span class="o">=</span> <span class="n">active_nodes</span><span class="p">;</span>
<span class="ln"> 1977</span><span class="p">}</span>
<span class="ln"> 1978</span>
<span class="ln"> 1979</span><span class="cm">/*
</span><span class="ln"> 1980</span><span class="cm"> * When adapting the scan rate, the period is divided into NUMA_PERIOD_SLOTS
</span><span class="ln"> 1981</span><span class="cm"> * increments. The more local the fault statistics are, the higher the scan
</span><span class="ln"> 1982</span><span class="cm"> * period will be for the next scan window. If local/(local+remote) ratio is
</span><span class="ln"> 1983</span><span class="cm"> * below NUMA_PERIOD_THRESHOLD (where range of ratio is 1..NUMA_PERIOD_SLOTS)
</span><span class="ln"> 1984</span><span class="cm"> * the scan period will decrease. Aim for 70% local accesses.
</span><span class="ln"> 1985</span><span class="cm"> */</span>
<span class="ln"> 1986</span><span class="cp">#define NUMA_PERIOD_SLOTS 10
</span><span class="ln"> 1987</span><span class="cp">#define NUMA_PERIOD_THRESHOLD 7
</span><span class="ln"> 1988</span><span class="cp"></span>
<span class="ln"> 1989</span><span class="cm">/*
</span><span class="ln"> 1990</span><span class="cm"> * Increase the scan period (slow down scanning) if the majority of
</span><span class="ln"> 1991</span><span class="cm"> * our memory is already on our local node, or if the majority of
</span><span class="ln"> 1992</span><span class="cm"> * the page accesses are shared with other processes.
</span><span class="ln"> 1993</span><span class="cm"> * Otherwise, decrease the scan period.
</span><span class="ln"> 1994</span><span class="cm"> */</span>
<span class="ln"> 1995</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_task_scan_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 1996</span>			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">)</span>
<span class="ln"> 1997</span><span class="p">{</span>
<span class="ln"> 1998</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">period_slot</span><span class="p">;</span>
<span class="ln"> 1999</span>	<span class="kt">int</span> <span class="n">lr_ratio</span><span class="p">,</span> <span class="n">ps_ratio</span><span class="p">;</span>
<span class="ln"> 2000</span>	<span class="kt">int</span> <span class="n">diff</span><span class="p">;</span>
<span class="ln"> 2001</span>
<span class="ln"> 2002</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remote</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="ln"> 2003</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">local</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="ln"> 2004</span>
<span class="ln"> 2005</span>	<span class="cm">/*
</span><span class="ln"> 2006</span><span class="cm">	 * If there were no record hinting faults then either the task is
</span><span class="ln"> 2007</span><span class="cm">	 * completely idle or all activity is areas that are not of interest
</span><span class="ln"> 2008</span><span class="cm">	 * to automatic numa balancing. Related to that, if there were failed
</span><span class="ln"> 2009</span><span class="cm">	 * migration then it implies we are migrating too quickly or the local
</span><span class="ln"> 2010</span><span class="cm">	 * node is overloaded. In either case, scan slower
</span><span class="ln"> 2011</span><span class="cm">	 */</span>
<span class="ln"> 2012</span>	<span class="k">if</span> <span class="p">(</span><span class="n">local</span> <span class="o">+</span> <span class="n">shared</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
<span class="ln"> 2013</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period_max</span><span class="p">,</span>
<span class="ln"> 2014</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 2015</span>
<span class="ln"> 2016</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
<span class="ln"> 2017</span>			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span><span class="p">);</span>
<span class="ln"> 2018</span>
<span class="ln"> 2019</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2020</span>	<span class="p">}</span>
<span class="ln"> 2021</span>
<span class="ln"> 2022</span>	<span class="cm">/*
</span><span class="ln"> 2023</span><span class="cm">	 * Prepare to scale scan period relative to the current period.
</span><span class="ln"> 2024</span><span class="cm">	 *	 == NUMA_PERIOD_THRESHOLD scan period stays the same
</span><span class="ln"> 2025</span><span class="cm">	 *       &lt;  NUMA_PERIOD_THRESHOLD scan period decreases (scan faster)
</span><span class="ln"> 2026</span><span class="cm">	 *	 &gt;= NUMA_PERIOD_THRESHOLD scan period increases (scan slower)
</span><span class="ln"> 2027</span><span class="cm">	 */</span>
<span class="ln"> 2028</span>	<span class="n">period_slot</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span><span class="p">,</span> <span class="n">NUMA_PERIOD_SLOTS</span><span class="p">);</span>
<span class="ln"> 2029</span>	<span class="n">lr_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">local</span> <span class="o">*</span> <span class="n">NUMA_PERIOD_SLOTS</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">local</span> <span class="o">+</span> <span class="n">remote</span><span class="p">);</span>
<span class="ln"> 2030</span>	<span class="n">ps_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">private</span> <span class="o">*</span> <span class="n">NUMA_PERIOD_SLOTS</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">private</span> <span class="o">+</span> <span class="n">shared</span><span class="p">);</span>
<span class="ln"> 2031</span>
<span class="ln"> 2032</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ps_ratio</span> <span class="o">&gt;=</span> <span class="n">NUMA_PERIOD_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2033</span>		<span class="cm">/*
</span><span class="ln"> 2034</span><span class="cm">		 * Most memory accesses are local. There is no need to
</span><span class="ln"> 2035</span><span class="cm">		 * do fast NUMA scanning, since memory is already local.
</span><span class="ln"> 2036</span><span class="cm">		 */</span>
<span class="ln"> 2037</span>		<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">ps_ratio</span> <span class="o">-</span> <span class="n">NUMA_PERIOD_THRESHOLD</span><span class="p">;</span>
<span class="ln"> 2038</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="p">)</span>
<span class="ln"> 2039</span>			<span class="n">slot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 2040</span>		<span class="n">diff</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">*</span> <span class="n">period_slot</span><span class="p">;</span>
<span class="ln"> 2041</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lr_ratio</span> <span class="o">&gt;=</span> <span class="n">NUMA_PERIOD_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2042</span>		<span class="cm">/*
</span><span class="ln"> 2043</span><span class="cm">		 * Most memory accesses are shared with other tasks.
</span><span class="ln"> 2044</span><span class="cm">		 * There is no point in continuing fast NUMA scanning,
</span><span class="ln"> 2045</span><span class="cm">		 * since other tasks may just move the memory elsewhere.
</span><span class="ln"> 2046</span><span class="cm">		 */</span>
<span class="ln"> 2047</span>		<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">lr_ratio</span> <span class="o">-</span> <span class="n">NUMA_PERIOD_THRESHOLD</span><span class="p">;</span>
<span class="ln"> 2048</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="p">)</span>
<span class="ln"> 2049</span>			<span class="n">slot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 2050</span>		<span class="n">diff</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">*</span> <span class="n">period_slot</span><span class="p">;</span>
<span class="ln"> 2051</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 2052</span>		<span class="cm">/*
</span><span class="ln"> 2053</span><span class="cm">		 * Private memory faults exceed (SLOTS-THRESHOLD)/SLOTS,
</span><span class="ln"> 2054</span><span class="cm">		 * yet they are not on the local NUMA node. Speed up
</span><span class="ln"> 2055</span><span class="cm">		 * NUMA scanning to get the memory moved over.
</span><span class="ln"> 2056</span><span class="cm">		 */</span>
<span class="ln"> 2057</span>		<span class="kt">int</span> <span class="n">ratio</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">lr_ratio</span><span class="p">,</span> <span class="n">ps_ratio</span><span class="p">);</span>
<span class="ln"> 2058</span>		<span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">NUMA_PERIOD_THRESHOLD</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">)</span> <span class="o">*</span> <span class="n">period_slot</span><span class="p">;</span>
<span class="ln"> 2059</span>	<span class="p">}</span>
<span class="ln"> 2060</span>
<span class="ln"> 2061</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">+</span> <span class="n">diff</span><span class="p">,</span>
<span class="ln"> 2062</span>			<span class="n">task_scan_min</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">task_scan_max</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 2063</span>	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">));</span>
<span class="ln"> 2064</span><span class="p">}</span>
<span class="ln"> 2065</span>
<span class="ln"> 2066</span><span class="cm">/*
</span><span class="ln"> 2067</span><span class="cm"> * Get the fraction of time the task has been running since the last
</span><span class="ln"> 2068</span><span class="cm"> * NUMA placement cycle. The scheduler keeps similar statistics, but
</span><span class="ln"> 2069</span><span class="cm"> * decays those on a 32ms period, which is orders of magnitude off
</span><span class="ln"> 2070</span><span class="cm"> * from the dozens-of-seconds NUMA balancing period. Use the scheduler
</span><span class="ln"> 2071</span><span class="cm"> * stats only if the task is so new there are no NUMA statistics yet.
</span><span class="ln"> 2072</span><span class="cm"> */</span>
<span class="ln"> 2073</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">numa_get_avg_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">period</span><span class="p">)</span>
<span class="ln"> 2074</span><span class="p">{</span>
<span class="ln"> 2075</span>	<span class="n">u64</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>
<span class="ln"> 2076</span>	<span class="cm">/* Use the start of this time slice to avoid calculations. */</span>
<span class="ln"> 2077</span>	<span class="n">now</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="p">;</span>
<span class="ln"> 2078</span>	<span class="n">runtime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 2079</span>
<span class="ln"> 2080</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">last_task_numa_placement</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2081</span>		<span class="n">delta</span> <span class="o">=</span> <span class="n">runtime</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">last_sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 2082</span>		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">last_task_numa_placement</span><span class="p">;</span>
<span class="ln"> 2083</span>
<span class="ln"> 2084</span>		<span class="cm">/* Avoid time going backwards, prevent potential divide error: */</span>
<span class="ln"> 2085</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="o">*</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
<span class="ln"> 2086</span>			<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2087</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 2088</span>		<span class="n">delta</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span>
<span class="ln"> 2089</span>		<span class="o">*</span><span class="n">period</span> <span class="o">=</span> <span class="n">LOAD_AVG_MAX</span><span class="p">;</span>
<span class="ln"> 2090</span>	<span class="p">}</span>
<span class="ln"> 2091</span>
<span class="ln"> 2092</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">last_sum_exec_runtime</span> <span class="o">=</span> <span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 2093</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">last_task_numa_placement</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="ln"> 2094</span>
<span class="ln"> 2095</span>	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 2096</span><span class="p">}</span>
<span class="ln"> 2097</span>
<span class="ln"> 2098</span><span class="cm">/*
</span><span class="ln"> 2099</span><span class="cm"> * Determine the preferred nid for a task in a numa_group. This needs to
</span><span class="ln"> 2100</span><span class="cm"> * be done in a way that produces consistent results with group_weight,
</span><span class="ln"> 2101</span><span class="cm"> * otherwise workloads might not converge.
</span><span class="ln"> 2102</span><span class="cm"> */</span>
<span class="ln"> 2103</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">preferred_group_nid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="ln"> 2104</span><span class="p">{</span>
<span class="ln"> 2105</span>	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>
<span class="ln"> 2106</span>	<span class="kt">int</span> <span class="n">dist</span><span class="p">;</span>
<span class="ln"> 2107</span>
<span class="ln"> 2108</span>	<span class="cm">/* Direct connections between all NUMA nodes. */</span>
<span class="ln"> 2109</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_numa_topology_type</span> <span class="o">==</span> <span class="n">NUMA_DIRECT</span><span class="p">)</span>
<span class="ln"> 2110</span>		<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln"> 2111</span>
<span class="ln"> 2112</span>	<span class="cm">/*
</span><span class="ln"> 2113</span><span class="cm">	 * On a system with glueless mesh NUMA topology, group_weight
</span><span class="ln"> 2114</span><span class="cm">	 * scores nodes according to the number of NUMA hinting faults on
</span><span class="ln"> 2115</span><span class="cm">	 * both the node itself, and on nearby nodes.
</span><span class="ln"> 2116</span><span class="cm">	 */</span>
<span class="ln"> 2117</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_numa_topology_type</span> <span class="o">==</span> <span class="n">NUMA_GLUELESS_MESH</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2118</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">score</span><span class="p">,</span> <span class="n">max_score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2119</span>		<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">max_node</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln"> 2120</span>
<span class="ln"> 2121</span>		<span class="n">dist</span> <span class="o">=</span> <span class="n">sched_max_numa_distance</span><span class="p">;</span>
<span class="ln"> 2122</span>
<span class="ln"> 2123</span>		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2124</span>			<span class="n">score</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 2125</span>			<span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">max_score</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2126</span>				<span class="n">max_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
<span class="ln"> 2127</span>				<span class="n">max_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="ln"> 2128</span>			<span class="p">}</span>
<span class="ln"> 2129</span>		<span class="p">}</span>
<span class="ln"> 2130</span>		<span class="k">return</span> <span class="n">max_node</span><span class="p">;</span>
<span class="ln"> 2131</span>	<span class="p">}</span>
<span class="ln"> 2132</span>
<span class="ln"> 2133</span>	<span class="cm">/*
</span><span class="ln"> 2134</span><span class="cm">	 * Finding the preferred nid in a system with NUMA backplane
</span><span class="ln"> 2135</span><span class="cm">	 * interconnect topology is more involved. The goal is to locate
</span><span class="ln"> 2136</span><span class="cm">	 * tasks from numa_groups near each other in the system, and
</span><span class="ln"> 2137</span><span class="cm">	 * untangle workloads from different sides of the system. This requires
</span><span class="ln"> 2138</span><span class="cm">	 * searching down the hierarchy of node groups, recursively searching
</span><span class="ln"> 2139</span><span class="cm">	 * inside the highest scoring group of nodes. The nodemask tricks
</span><span class="ln"> 2140</span><span class="cm">	 * keep the complexity of the search down.
</span><span class="ln"> 2141</span><span class="cm">	 */</span>
<span class="ln"> 2142</span>	<span class="n">nodes</span> <span class="o">=</span> <span class="n">node_online_map</span><span class="p">;</span>
<span class="ln"> 2143</span>	<span class="k">for</span> <span class="p">(</span><span class="n">dist</span> <span class="o">=</span> <span class="n">sched_max_numa_distance</span><span class="p">;</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">LOCAL_DISTANCE</span><span class="p">;</span> <span class="n">dist</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2144</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2145</span>		<span class="n">nodemask_t</span> <span class="n">max_group</span> <span class="o">=</span> <span class="n">NODE_MASK_NONE</span><span class="p">;</span>
<span class="ln"> 2146</span>		<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="ln"> 2147</span>
<span class="ln"> 2148</span>		<span class="cm">/* Are there nodes at this distance from each other? */</span>
<span class="ln"> 2149</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">find_numa_distance</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
<span class="ln"> 2150</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 2151</span>
<span class="ln"> 2152</span>		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2153</span>			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2154</span>			<span class="n">nodemask_t</span> <span class="n">this_group</span><span class="p">;</span>
<span class="ln"> 2155</span>			<span class="n">nodes_clear</span><span class="p">(</span><span class="n">this_group</span><span class="p">);</span>
<span class="ln"> 2156</span>
<span class="ln"> 2157</span>			<span class="cm">/* Sum group&#39;s NUMA faults; includes a==b case. */</span>
<span class="ln"> 2158</span>			<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2159</span>				<span class="k">if</span> <span class="p">(</span><span class="n">node_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2160</span>					<span class="n">faults</span> <span class="o">+=</span> <span class="n">group_faults</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="ln"> 2161</span>					<span class="n">node_set</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">this_group</span><span class="p">);</span>
<span class="ln"> 2162</span>					<span class="n">node_clear</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
<span class="ln"> 2163</span>				<span class="p">}</span>
<span class="ln"> 2164</span>			<span class="p">}</span>
<span class="ln"> 2165</span>
<span class="ln"> 2166</span>			<span class="cm">/* Remember the top group. */</span>
<span class="ln"> 2167</span>			<span class="k">if</span> <span class="p">(</span><span class="n">faults</span> <span class="o">&gt;</span> <span class="n">max_faults</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2168</span>				<span class="n">max_faults</span> <span class="o">=</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 2169</span>				<span class="n">max_group</span> <span class="o">=</span> <span class="n">this_group</span><span class="p">;</span>
<span class="ln"> 2170</span>				<span class="cm">/*
</span><span class="ln"> 2171</span><span class="cm">				 * subtle: at the smallest distance there is
</span><span class="ln"> 2172</span><span class="cm">				 * just one node left in each &#34;group&#34;, the
</span><span class="ln"> 2173</span><span class="cm">				 * winner is the preferred nid.
</span><span class="ln"> 2174</span><span class="cm">				 */</span>
<span class="ln"> 2175</span>				<span class="n">nid</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="ln"> 2176</span>			<span class="p">}</span>
<span class="ln"> 2177</span>		<span class="p">}</span>
<span class="ln"> 2178</span>		<span class="cm">/* Next round, evaluate the nodes within max_group. */</span>
<span class="ln"> 2179</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_faults</span><span class="p">)</span>
<span class="ln"> 2180</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 2181</span>		<span class="n">nodes</span> <span class="o">=</span> <span class="n">max_group</span><span class="p">;</span>
<span class="ln"> 2182</span>	<span class="p">}</span>
<span class="ln"> 2183</span>	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln"> 2184</span><span class="p">}</span>
<span class="ln"> 2185</span>
<span class="ln"> 2186</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_numa_placement</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 2187</span><span class="p">{</span>
<span class="ln"> 2188</span>	<span class="kt">int</span> <span class="n">seq</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">max_nid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 2189</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2190</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fault_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
<span class="ln"> 2191</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_faults</span><span class="p">;</span>
<span class="ln"> 2192</span>	<span class="n">u64</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">period</span><span class="p">;</span>
<span class="ln"> 2193</span>	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">group_lock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 2194</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln"> 2195</span>
<span class="ln"> 2196</span>	<span class="cm">/*
</span><span class="ln"> 2197</span><span class="cm">	 * The p-&gt;mm-&gt;numa_scan_seq field gets updated without
</span><span class="ln"> 2198</span><span class="cm">	 * exclusive access. Use READ_ONCE() here to ensure
</span><span class="ln"> 2199</span><span class="cm">	 * that the field is read in a single access:
</span><span class="ln"> 2200</span><span class="cm">	 */</span>
<span class="ln"> 2201</span>	<span class="n">seq</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span><span class="p">);</span>
<span class="ln"> 2202</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span> <span class="o">==</span> <span class="n">seq</span><span class="p">)</span>
<span class="ln"> 2203</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2204</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
<span class="ln"> 2205</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period_max</span> <span class="o">=</span> <span class="n">task_scan_max</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2206</span>
<span class="ln"> 2207</span>	<span class="n">total_faults</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
<span class="ln"> 2208</span>		       <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="ln"> 2209</span>	<span class="n">runtime</span> <span class="o">=</span> <span class="n">numa_get_avg_runtime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">period</span><span class="p">);</span>
<span class="ln"> 2210</span>
<span class="ln"> 2211</span>	<span class="cm">/* If the task is part of a group prevent parallel updates to group stats */</span>
<span class="ln"> 2212</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2213</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2214</span>		<span class="n">group_lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ng</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
<span class="ln"> 2215</span>		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">group_lock</span><span class="p">);</span>
<span class="ln"> 2216</span>	<span class="p">}</span>
<span class="ln"> 2217</span>
<span class="ln"> 2218</span>	<span class="cm">/* Find the node with the highest number of faults */</span>
<span class="ln"> 2219</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2220</span>		<span class="cm">/* Keep track of the offsets in numa_faults array */</span>
<span class="ln"> 2221</span>		<span class="kt">int</span> <span class="n">mem_idx</span><span class="p">,</span> <span class="n">membuf_idx</span><span class="p">,</span> <span class="n">cpu_idx</span><span class="p">,</span> <span class="n">cpubuf_idx</span><span class="p">;</span>
<span class="ln"> 2222</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">group_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2223</span>		<span class="kt">int</span> <span class="n">priv</span><span class="p">;</span>
<span class="ln"> 2224</span>
<span class="ln"> 2225</span>		<span class="k">for</span> <span class="p">(</span><span class="n">priv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">priv</span> <span class="o">&lt;</span> <span class="n">NR_NUMA_HINT_FAULT_TYPES</span><span class="p">;</span> <span class="n">priv</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2226</span>			<span class="kt">long</span> <span class="n">diff</span><span class="p">,</span> <span class="n">f_diff</span><span class="p">,</span> <span class="n">f_weight</span><span class="p">;</span>
<span class="ln"> 2227</span>
<span class="ln"> 2228</span>			<span class="n">mem_idx</span> <span class="o">=</span> <span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
<span class="ln"> 2229</span>			<span class="n">membuf_idx</span> <span class="o">=</span> <span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEMBUF</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
<span class="ln"> 2230</span>			<span class="n">cpu_idx</span> <span class="o">=</span> <span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_CPU</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
<span class="ln"> 2231</span>			<span class="n">cpubuf_idx</span> <span class="o">=</span> <span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_CPUBUF</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
<span class="ln"> 2232</span>
<span class="ln"> 2233</span>			<span class="cm">/* Decay existing window, copy faults since last scan */</span>
<span class="ln"> 2234</span>			<span class="n">diff</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">membuf_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">mem_idx</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 2235</span>			<span class="n">fault_types</span><span class="p">[</span><span class="n">priv</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">membuf_idx</span><span class="p">];</span>
<span class="ln"> 2236</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">membuf_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2237</span>
<span class="ln"> 2238</span>			<span class="cm">/*
</span><span class="ln"> 2239</span><span class="cm">			 * Normalize the faults_from, so all tasks in a group
</span><span class="ln"> 2240</span><span class="cm">			 * count according to CPU use, instead of by the raw
</span><span class="ln"> 2241</span><span class="cm">			 * number of faults. Tasks with little runtime have
</span><span class="ln"> 2242</span><span class="cm">			 * little over-all impact on throughput, and thus their
</span><span class="ln"> 2243</span><span class="cm">			 * faults are less important.
</span><span class="ln"> 2244</span><span class="cm">			 */</span>
<span class="ln"> 2245</span>			<span class="n">f_weight</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">runtime</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">period</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 2246</span>			<span class="n">f_weight</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_weight</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">cpubuf_idx</span><span class="p">])</span> <span class="o">/</span>
<span class="ln"> 2247</span>				   <span class="p">(</span><span class="n">total_faults</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 2248</span>			<span class="n">f_diff</span> <span class="o">=</span> <span class="n">f_weight</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">cpu_idx</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 2249</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">cpubuf_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2250</span>
<span class="ln"> 2251</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">mem_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
<span class="ln"> 2252</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">cpu_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f_diff</span><span class="p">;</span>
<span class="ln"> 2253</span>			<span class="n">faults</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">mem_idx</span><span class="p">];</span>
<span class="ln"> 2254</span>			<span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
<span class="ln"> 2255</span>			<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2256</span>				<span class="cm">/*
</span><span class="ln"> 2257</span><span class="cm">				 * safe because we can only change our own group
</span><span class="ln"> 2258</span><span class="cm">				 *
</span><span class="ln"> 2259</span><span class="cm">				 * mem_idx represents the offset for a given
</span><span class="ln"> 2260</span><span class="cm">				 * nid and priv in a specific region because it
</span><span class="ln"> 2261</span><span class="cm">				 * is at the beginning of the numa_faults array.
</span><span class="ln"> 2262</span><span class="cm">				 */</span>
<span class="ln"> 2263</span>				<span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">mem_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
<span class="ln"> 2264</span>				<span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults_cpu</span><span class="p">[</span><span class="n">mem_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f_diff</span><span class="p">;</span>
<span class="ln"> 2265</span>				<span class="n">ng</span><span class="o">-&gt;</span><span class="n">total_faults</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>
<span class="ln"> 2266</span>				<span class="n">group_faults</span> <span class="o">+=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">mem_idx</span><span class="p">];</span>
<span class="ln"> 2267</span>			<span class="p">}</span>
<span class="ln"> 2268</span>		<span class="p">}</span>
<span class="ln"> 2269</span>
<span class="ln"> 2270</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2271</span>			<span class="k">if</span> <span class="p">(</span><span class="n">faults</span> <span class="o">&gt;</span> <span class="n">max_faults</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2272</span>				<span class="n">max_faults</span> <span class="o">=</span> <span class="n">faults</span><span class="p">;</span>
<span class="ln"> 2273</span>				<span class="n">max_nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln"> 2274</span>			<span class="p">}</span>
<span class="ln"> 2275</span>		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">group_faults</span> <span class="o">&gt;</span> <span class="n">max_faults</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2276</span>			<span class="n">max_faults</span> <span class="o">=</span> <span class="n">group_faults</span><span class="p">;</span>
<span class="ln"> 2277</span>			<span class="n">max_nid</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
<span class="ln"> 2278</span>		<span class="p">}</span>
<span class="ln"> 2279</span>	<span class="p">}</span>
<span class="ln"> 2280</span>
<span class="ln"> 2281</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2282</span>		<span class="n">numa_group_count_active_nodes</span><span class="p">(</span><span class="n">ng</span><span class="p">);</span>
<span class="ln"> 2283</span>		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">group_lock</span><span class="p">);</span>
<span class="ln"> 2284</span>		<span class="n">max_nid</span> <span class="o">=</span> <span class="n">preferred_group_nid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">max_nid</span><span class="p">);</span>
<span class="ln"> 2285</span>	<span class="p">}</span>
<span class="ln"> 2286</span>
<span class="ln"> 2287</span>	<span class="k">if</span> <span class="p">(</span><span class="n">max_faults</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2288</span>		<span class="cm">/* Set the new preferred node */</span>
<span class="ln"> 2289</span>		<span class="k">if</span> <span class="p">(</span><span class="n">max_nid</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">)</span>
<span class="ln"> 2290</span>			<span class="n">sched_setnuma</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">max_nid</span><span class="p">);</span>
<span class="ln"> 2291</span>	<span class="p">}</span>
<span class="ln"> 2292</span>
<span class="ln"> 2293</span>	<span class="n">update_task_scan_period</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">fault_types</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fault_types</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="ln"> 2294</span><span class="p">}</span>
<span class="ln"> 2295</span>
<span class="ln"> 2296</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_numa_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="ln"> 2297</span><span class="p">{</span>
<span class="ln"> 2298</span>	<span class="k">return</span> <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="ln"> 2299</span><span class="p">}</span>
<span class="ln"> 2300</span>
<span class="ln"> 2301</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_numa_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">)</span>
<span class="ln"> 2302</span><span class="p">{</span>
<span class="ln"> 2303</span>	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span>
<span class="ln"> 2304</span>		<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">grp</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
<span class="ln"> 2305</span><span class="p">}</span>
<span class="ln"> 2306</span>
<span class="ln"> 2307</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_numa_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpupid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<span class="ln"> 2308</span>			<span class="kt">int</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="ln"> 2309</span><span class="p">{</span>
<span class="ln"> 2310</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">grp</span><span class="p">,</span> <span class="o">*</span><span class="n">my_grp</span><span class="p">;</span>
<span class="ln"> 2311</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
<span class="ln"> 2312</span>	<span class="kt">bool</span> <span class="n">join</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 2313</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpupid_to_cpu</span><span class="p">(</span><span class="n">cpupid</span><span class="p">);</span>
<span class="ln"> 2314</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 2315</span>
<span class="ln"> 2316</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 2317</span>		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">numa_group</span><span class="p">)</span> <span class="o">+</span>
<span class="ln"> 2318</span>				    <span class="mi">4</span><span class="o">*</span><span class="n">nr_node_ids</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="ln"> 2319</span>
<span class="ln"> 2320</span>		<span class="n">grp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
<span class="ln"> 2321</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grp</span><span class="p">)</span>
<span class="ln"> 2322</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2323</span>
<span class="ln"> 2324</span>		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 2325</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">active_nodes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 2326</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">max_faults_cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2327</span>		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 2328</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="ln"> 2329</span>		<span class="cm">/* Second half of the array tracks nids where faults happen */</span>
<span class="ln"> 2330</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">faults_cpu</span> <span class="o">=</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">faults</span> <span class="o">+</span> <span class="n">NR_NUMA_HINT_FAULT_TYPES</span> <span class="o">*</span>
<span class="ln"> 2331</span>						<span class="n">nr_node_ids</span><span class="p">;</span>
<span class="ln"> 2332</span>
<span class="ln"> 2333</span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_NUMA_HINT_FAULT_STATS</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln"> 2334</span>			<span class="n">grp</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 2335</span>
<span class="ln"> 2336</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">total_faults</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span><span class="p">;</span>
<span class="ln"> 2337</span>
<span class="ln"> 2338</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 2339</span>		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
<span class="ln"> 2340</span>	<span class="p">}</span>
<span class="ln"> 2341</span>
<span class="ln"> 2342</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 2343</span>	<span class="n">tsk</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 2344</span>
<span class="ln"> 2345</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpupid_match_pid</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">cpupid</span><span class="p">))</span>
<span class="ln"> 2346</span>		<span class="k">goto</span> <span class="n">no_join</span><span class="p">;</span>
<span class="ln"> 2347</span>
<span class="ln"> 2348</span>	<span class="n">grp</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln"> 2349</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grp</span><span class="p">)</span>
<span class="ln"> 2350</span>		<span class="k">goto</span> <span class="n">no_join</span><span class="p">;</span>
<span class="ln"> 2351</span>
<span class="ln"> 2352</span>	<span class="n">my_grp</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2353</span>	<span class="k">if</span> <span class="p">(</span><span class="n">grp</span> <span class="o">==</span> <span class="n">my_grp</span><span class="p">)</span>
<span class="ln"> 2354</span>		<span class="k">goto</span> <span class="n">no_join</span><span class="p">;</span>
<span class="ln"> 2355</span>
<span class="ln"> 2356</span>	<span class="cm">/*
</span><span class="ln"> 2357</span><span class="cm">	 * Only join the other group if its bigger; if we&#39;re the bigger group,
</span><span class="ln"> 2358</span><span class="cm">	 * the other task will join us.
</span><span class="ln"> 2359</span><span class="cm">	 */</span>
<span class="ln"> 2360</span>	<span class="k">if</span> <span class="p">(</span><span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span> <span class="o">&gt;</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="p">)</span>
<span class="ln"> 2361</span>		<span class="k">goto</span> <span class="n">no_join</span><span class="p">;</span>
<span class="ln"> 2362</span>
<span class="ln"> 2363</span>	<span class="cm">/*
</span><span class="ln"> 2364</span><span class="cm">	 * Tie-break on the grp address.
</span><span class="ln"> 2365</span><span class="cm">	 */</span>
<span class="ln"> 2366</span>	<span class="k">if</span> <span class="p">(</span><span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span> <span class="o">==</span> <span class="n">grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span> <span class="o">&amp;&amp;</span> <span class="n">my_grp</span> <span class="o">&gt;</span> <span class="n">grp</span><span class="p">)</span>
<span class="ln"> 2367</span>		<span class="k">goto</span> <span class="n">no_join</span><span class="p">;</span>
<span class="ln"> 2368</span>
<span class="ln"> 2369</span>	<span class="cm">/* Always join threads in the same process. */</span>
<span class="ln"> 2370</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
<span class="ln"> 2371</span>		<span class="n">join</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 2372</span>
<span class="ln"> 2373</span>	<span class="cm">/* Simple filter to avoid false positives due to PID collisions */</span>
<span class="ln"> 2374</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TNF_SHARED</span><span class="p">)</span>
<span class="ln"> 2375</span>		<span class="n">join</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 2376</span>
<span class="ln"> 2377</span>	<span class="cm">/* Update priv based on whether false sharing was detected */</span>
<span class="ln"> 2378</span>	<span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="o">!</span><span class="n">join</span><span class="p">;</span>
<span class="ln"> 2379</span>
<span class="ln"> 2380</span>	<span class="k">if</span> <span class="p">(</span><span class="n">join</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">get_numa_group</span><span class="p">(</span><span class="n">grp</span><span class="p">))</span>
<span class="ln"> 2381</span>		<span class="k">goto</span> <span class="n">no_join</span><span class="p">;</span>
<span class="ln"> 2382</span>
<span class="ln"> 2383</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 2384</span>
<span class="ln"> 2385</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">join</span><span class="p">)</span>
<span class="ln"> 2386</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2387</span>
<span class="ln"> 2388</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
<span class="ln"> 2389</span>	<span class="n">double_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 2390</span>
<span class="ln"> 2391</span>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_NUMA_HINT_FAULT_STATS</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2392</span>		<span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 2393</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 2394</span>	<span class="p">}</span>
<span class="ln"> 2395</span>	<span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">total_faults</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span><span class="p">;</span>
<span class="ln"> 2396</span>	<span class="n">grp</span><span class="o">-&gt;</span><span class="n">total_faults</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span><span class="p">;</span>
<span class="ln"> 2397</span>
<span class="ln"> 2398</span>	<span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 2399</span>	<span class="n">grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 2400</span>
<span class="ln"> 2401</span>	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 2402</span>	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 2403</span>
<span class="ln"> 2404</span>	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">,</span> <span class="n">grp</span><span class="p">);</span>
<span class="ln"> 2405</span>
<span class="ln"> 2406</span>	<span class="n">put_numa_group</span><span class="p">(</span><span class="n">my_grp</span><span class="p">);</span>
<span class="ln"> 2407</span>	<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2408</span>
<span class="ln"> 2409</span><span class="nl">no_join</span><span class="p">:</span>
<span class="ln"> 2410</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 2411</span>	<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2412</span><span class="p">}</span>
<span class="ln"> 2413</span>
<span class="ln"> 2414</span><span class="cm">/*
</span><span class="ln"> 2415</span><span class="cm"> * Get rid of NUMA staticstics associated with a task (either current or dead).
</span><span class="ln"> 2416</span><span class="cm"> * If @final is set, the task is dead and has reached refcount zero, so we can
</span><span class="ln"> 2417</span><span class="cm"> * safely free all relevant data structures. Otherwise, there might be
</span><span class="ln"> 2418</span><span class="cm"> * concurrent reads from places like load balancing and procfs, and we should
</span><span class="ln"> 2419</span><span class="cm"> * reset the data back to default state without freeing -&gt;numa_faults.
</span><span class="ln"> 2420</span><span class="cm"> */</span>
<span class="ln"> 2421</span><span class="kt">void</span> <span class="nf">task_numa_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">final</span><span class="p">)</span>
<span class="ln"> 2422</span><span class="p">{</span>
<span class="ln"> 2423</span>	<span class="cm">/* safe: p either is current or is being freed by current */</span>
<span class="ln"> 2424</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">grp</span> <span class="o">=</span> <span class="n">rcu_dereference_raw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln"> 2425</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">numa_faults</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">;</span>
<span class="ln"> 2426</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln"> 2427</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 2428</span>
<span class="ln"> 2429</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numa_faults</span><span class="p">)</span>
<span class="ln"> 2430</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2431</span>
<span class="ln"> 2432</span>	<span class="k">if</span> <span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2433</span>		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 2434</span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_NUMA_HINT_FAULT_STATS</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln"> 2435</span>			<span class="n">grp</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 2436</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">total_faults</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span><span class="p">;</span>
<span class="ln"> 2437</span>
<span class="ln"> 2438</span>		<span class="n">grp</span><span class="o">-&gt;</span><span class="n">nr_tasks</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 2439</span>		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 2440</span>		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 2441</span>		<span class="n">put_numa_group</span><span class="p">(</span><span class="n">grp</span><span class="p">);</span>
<span class="ln"> 2442</span>	<span class="p">}</span>
<span class="ln"> 2443</span>
<span class="ln"> 2444</span>	<span class="k">if</span> <span class="p">(</span><span class="n">final</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2445</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 2446</span>		<span class="n">kfree</span><span class="p">(</span><span class="n">numa_faults</span><span class="p">);</span>
<span class="ln"> 2447</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 2448</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2449</span>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_NUMA_HINT_FAULT_STATS</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln"> 2450</span>			<span class="n">numa_faults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2451</span>	<span class="p">}</span>
<span class="ln"> 2452</span><span class="p">}</span>
<span class="ln"> 2453</span>
<span class="ln"> 2454</span><span class="cm">/*
</span><span class="ln"> 2455</span><span class="cm"> * Got a PROT_NONE fault for a page on @node.
</span><span class="ln"> 2456</span><span class="cm"> */</span>
<span class="ln"> 2457</span><span class="kt">void</span> <span class="nf">task_numa_fault</span><span class="p">(</span><span class="kt">int</span> <span class="n">last_cpupid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mem_node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 2458</span><span class="p">{</span>
<span class="ln"> 2459</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="ln"> 2460</span>	<span class="kt">bool</span> <span class="n">migrated</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TNF_MIGRATED</span><span class="p">;</span>
<span class="ln"> 2461</span>	<span class="kt">int</span> <span class="n">cpu_node</span> <span class="o">=</span> <span class="n">task_node</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln"> 2462</span>	<span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TNF_FAULT_LOCAL</span><span class="p">);</span>
<span class="ln"> 2463</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln"> 2464</span>	<span class="kt">int</span> <span class="n">priv</span><span class="p">;</span>
<span class="ln"> 2465</span>
<span class="ln"> 2466</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">))</span>
<span class="ln"> 2467</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2468</span>
<span class="ln"> 2469</span>	<span class="cm">/* for example, ksmd faulting in a user&#39;s mm */</span>
<span class="ln"> 2470</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
<span class="ln"> 2471</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2472</span>
<span class="ln"> 2473</span>	<span class="cm">/* Allocate buffer to track faults on a per-node basis */</span>
<span class="ln"> 2474</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2475</span>		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">)</span> <span class="o">*</span>
<span class="ln"> 2476</span>			   <span class="n">NR_NUMA_HINT_FAULT_BUCKETS</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">;</span>
<span class="ln"> 2477</span>
<span class="ln"> 2478</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="p">);</span>
<span class="ln"> 2479</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">)</span>
<span class="ln"> 2480</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2481</span>
<span class="ln"> 2482</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">total_numa_faults</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2483</span>		<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">));</span>
<span class="ln"> 2484</span>	<span class="p">}</span>
<span class="ln"> 2485</span>
<span class="ln"> 2486</span>	<span class="cm">/*
</span><span class="ln"> 2487</span><span class="cm">	 * First accesses are treated as private, otherwise consider accesses
</span><span class="ln"> 2488</span><span class="cm">	 * to be private if the accessing pid has not changed
</span><span class="ln"> 2489</span><span class="cm">	 */</span>
<span class="ln"> 2490</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">last_cpupid</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">LAST_CPUPID_MASK</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 2491</span>		<span class="n">priv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 2492</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 2493</span>		<span class="n">priv</span> <span class="o">=</span> <span class="n">cpupid_match_pid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last_cpupid</span><span class="p">);</span>
<span class="ln"> 2494</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TNF_NO_GROUP</span><span class="p">))</span>
<span class="ln"> 2495</span>			<span class="n">task_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">last_cpupid</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="p">);</span>
<span class="ln"> 2496</span>	<span class="p">}</span>
<span class="ln"> 2497</span>
<span class="ln"> 2498</span>	<span class="cm">/*
</span><span class="ln"> 2499</span><span class="cm">	 * If a workload spans multiple NUMA nodes, a shared fault that
</span><span class="ln"> 2500</span><span class="cm">	 * occurs wholly within the set of nodes that the workload is
</span><span class="ln"> 2501</span><span class="cm">	 * actively using should be counted as local. This allows the
</span><span class="ln"> 2502</span><span class="cm">	 * scan rate to slow down when a workload has settled down.
</span><span class="ln"> 2503</span><span class="cm">	 */</span>
<span class="ln"> 2504</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">deref_curr_numa_group</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2505</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">local</span> <span class="o">&amp;&amp;</span> <span class="n">ng</span> <span class="o">&amp;&amp;</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">active_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 2506</span>				<span class="n">numa_is_active_node</span><span class="p">(</span><span class="n">cpu_node</span><span class="p">,</span> <span class="n">ng</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 2507</span>				<span class="n">numa_is_active_node</span><span class="p">(</span><span class="n">mem_node</span><span class="p">,</span> <span class="n">ng</span><span class="p">))</span>
<span class="ln"> 2508</span>		<span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 2509</span>
<span class="ln"> 2510</span>	<span class="cm">/*
</span><span class="ln"> 2511</span><span class="cm">	 * Retry task to preferred node migration periodically, in case it
</span><span class="ln"> 2512</span><span class="cm">	 * case it previously failed, or the scheduler moved us.
</span><span class="ln"> 2513</span><span class="cm">	 */</span>
<span class="ln"> 2514</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_migrate_retry</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2515</span>		<span class="n">task_numa_placement</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2516</span>		<span class="n">numa_migrate_preferred</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2517</span>	<span class="p">}</span>
<span class="ln"> 2518</span>
<span class="ln"> 2519</span>	<span class="k">if</span> <span class="p">(</span><span class="n">migrated</span><span class="p">)</span>
<span class="ln"> 2520</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_pages_migrated</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
<span class="ln"> 2521</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TNF_MIGRATE_FAIL</span><span class="p">)</span>
<span class="ln"> 2522</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
<span class="ln"> 2523</span>
<span class="ln"> 2524</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEMBUF</span><span class="p">,</span> <span class="n">mem_node</span><span class="p">,</span> <span class="n">priv</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
<span class="ln"> 2525</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_CPUBUF</span><span class="p">,</span> <span class="n">cpu_node</span><span class="p">,</span> <span class="n">priv</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
<span class="ln"> 2526</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults_locality</span><span class="p">[</span><span class="n">local</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
<span class="ln"> 2527</span><span class="p">}</span>
<span class="ln"> 2528</span>
<span class="ln"> 2529</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_ptenuma_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 2530</span><span class="p">{</span>
<span class="ln"> 2531</span>	<span class="cm">/*
</span><span class="ln"> 2532</span><span class="cm">	 * We only did a read acquisition of the mmap sem, so
</span><span class="ln"> 2533</span><span class="cm">	 * p-&gt;mm-&gt;numa_scan_seq is written to without exclusive access
</span><span class="ln"> 2534</span><span class="cm">	 * and the update is not guaranteed to be atomic. That&#39;s not
</span><span class="ln"> 2535</span><span class="cm">	 * much of an issue though, since this is just used for
</span><span class="ln"> 2536</span><span class="cm">	 * statistical sampling. Use READ_ONCE/WRITE_ONCE, which are not
</span><span class="ln"> 2537</span><span class="cm">	 * expensive, to avoid any form of compiler optimizations:
</span><span class="ln"> 2538</span><span class="cm">	 */</span>
<span class="ln"> 2539</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span><span class="p">,</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 2540</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2541</span><span class="p">}</span>
<span class="ln"> 2542</span>
<span class="ln"> 2543</span><span class="cm">/*
</span><span class="ln"> 2544</span><span class="cm"> * The expensive part of numa migration is done from task_work context.
</span><span class="ln"> 2545</span><span class="cm"> * Triggered from task_tick_numa().
</span><span class="ln"> 2546</span><span class="cm"> */</span>
<span class="ln"> 2547</span><span class="kt">void</span> <span class="nf">task_numa_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">callback_head</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="ln"> 2548</span><span class="p">{</span>
<span class="ln"> 2549</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">migrate</span><span class="p">,</span> <span class="n">next_scan</span><span class="p">,</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 2550</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
<span class="ln"> 2551</span>	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
<span class="ln"> 2552</span>	<span class="n">u64</span> <span class="n">runtime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 2553</span>	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
<span class="ln"> 2554</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
<span class="ln"> 2555</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pte_updates</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2556</span>	<span class="kt">long</span> <span class="n">pages</span><span class="p">,</span> <span class="n">virtpages</span><span class="p">;</span>
<span class="ln"> 2557</span>
<span class="ln"> 2558</span>	<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">numa_work</span><span class="p">));</span>
<span class="ln"> 2559</span>
<span class="ln"> 2560</span>	<span class="n">work</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">work</span><span class="p">;</span> <span class="cm">/* protect against double add */</span>
<span class="ln"> 2561</span>	<span class="cm">/*
</span><span class="ln"> 2562</span><span class="cm">	 * Who cares about NUMA placement when they&#39;re dying.
</span><span class="ln"> 2563</span><span class="cm">	 *
</span><span class="ln"> 2564</span><span class="cm">	 * NOTE: make sure not to dereference p-&gt;mm before this check,
</span><span class="ln"> 2565</span><span class="cm">	 * exit_task_work() happens _after_ exit_mm() so we could be called
</span><span class="ln"> 2566</span><span class="cm">	 * without p-&gt;mm even though we still had it when we enqueued this
</span><span class="ln"> 2567</span><span class="cm">	 * work.
</span><span class="ln"> 2568</span><span class="cm">	 */</span>
<span class="ln"> 2569</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span>
<span class="ln"> 2570</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2571</span>
<span class="ln"> 2572</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2573</span>		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span>
<span class="ln"> 2574</span>			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sysctl_numa_balancing_scan_delay</span><span class="p">);</span>
<span class="ln"> 2575</span>	<span class="p">}</span>
<span class="ln"> 2576</span>
<span class="ln"> 2577</span>	<span class="cm">/*
</span><span class="ln"> 2578</span><span class="cm">	 * Enforce maximal scan/migration frequency..
</span><span class="ln"> 2579</span><span class="cm">	 */</span>
<span class="ln"> 2580</span>	<span class="n">migrate</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span><span class="p">;</span>
<span class="ln"> 2581</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">migrate</span><span class="p">))</span>
<span class="ln"> 2582</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2583</span>
<span class="ln"> 2584</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2585</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period_max</span> <span class="o">=</span> <span class="n">task_scan_max</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2586</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">=</span> <span class="n">task_scan_start</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2587</span>	<span class="p">}</span>
<span class="ln"> 2588</span>
<span class="ln"> 2589</span>	<span class="n">next_scan</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span><span class="p">);</span>
<span class="ln"> 2590</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span><span class="p">,</span> <span class="n">migrate</span><span class="p">,</span> <span class="n">next_scan</span><span class="p">)</span> <span class="o">!=</span> <span class="n">migrate</span><span class="p">)</span>
<span class="ln"> 2591</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2592</span>
<span class="ln"> 2593</span>	<span class="cm">/*
</span><span class="ln"> 2594</span><span class="cm">	 * Delay this task enough that another task of this mm will likely win
</span><span class="ln"> 2595</span><span class="cm">	 * the next time around.
</span><span class="ln"> 2596</span><span class="cm">	 */</span>
<span class="ln"> 2597</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">node_stamp</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">TICK_NSEC</span><span class="p">;</span>
<span class="ln"> 2598</span>
<span class="ln"> 2599</span>	<span class="n">start</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_offset</span><span class="p">;</span>
<span class="ln"> 2600</span>	<span class="n">pages</span> <span class="o">=</span> <span class="n">sysctl_numa_balancing_scan_size</span><span class="p">;</span>
<span class="ln"> 2601</span>	<span class="n">pages</span> <span class="o">&lt;&lt;=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span> <span class="cm">/* MB in pages */</span>
<span class="ln"> 2602</span>	<span class="n">virtpages</span> <span class="o">=</span> <span class="n">pages</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>	   <span class="cm">/* Scan up to this much virtual space */</span>
<span class="ln"> 2603</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
<span class="ln"> 2604</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2605</span>
<span class="ln"> 2606</span>
<span class="ln"> 2607</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">))</span>
<span class="ln"> 2608</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2609</span>	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
<span class="ln"> 2610</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2611</span>		<span class="n">reset_ptenuma_scan</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2612</span>		<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 2613</span>		<span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>
<span class="ln"> 2614</span>	<span class="p">}</span>
<span class="ln"> 2615</span>	<span class="k">for</span> <span class="p">(;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2616</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma_migratable</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">vma_policy_mof</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span>
<span class="ln"> 2617</span>			<span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MIXEDMAP</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2618</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 2619</span>		<span class="p">}</span>
<span class="ln"> 2620</span>
<span class="ln"> 2621</span>		<span class="cm">/*
</span><span class="ln"> 2622</span><span class="cm">		 * Shared library pages mapped by multiple processes are not
</span><span class="ln"> 2623</span><span class="cm">		 * migrated as it is expected they are cache replicated. Avoid
</span><span class="ln"> 2624</span><span class="cm">		 * hinting faults in read-only file-backed mappings or the vdso
</span><span class="ln"> 2625</span><span class="cm">		 * as migrating the pages will be of marginal benefit.
</span><span class="ln"> 2626</span><span class="cm">		 */</span>
<span class="ln"> 2627</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">||</span>
<span class="ln"> 2628</span>		    <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_READ</span><span class="o">|</span><span class="n">VM_WRITE</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">VM_READ</span><span class="p">)))</span>
<span class="ln"> 2629</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 2630</span>
<span class="ln"> 2631</span>		<span class="cm">/*
</span><span class="ln"> 2632</span><span class="cm">		 * Skip inaccessible VMAs to avoid any confusion between
</span><span class="ln"> 2633</span><span class="cm">		 * PROT_NONE and NUMA hinting ptes
</span><span class="ln"> 2634</span><span class="cm">		 */</span>
<span class="ln"> 2635</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_EXEC</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">)))</span>
<span class="ln"> 2636</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 2637</span>
<span class="ln"> 2638</span>		<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 2639</span>			<span class="n">start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
<span class="ln"> 2640</span>			<span class="n">end</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">),</span> <span class="n">HPAGE_SIZE</span><span class="p">);</span>
<span class="ln"> 2641</span>			<span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
<span class="ln"> 2642</span>			<span class="n">nr_pte_updates</span> <span class="o">=</span> <span class="n">change_prot_numa</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="ln"> 2643</span>
<span class="ln"> 2644</span>			<span class="cm">/*
</span><span class="ln"> 2645</span><span class="cm">			 * Try to scan sysctl_numa_balancing_size worth of
</span><span class="ln"> 2646</span><span class="cm">			 * hpages that have at least one present PTE that
</span><span class="ln"> 2647</span><span class="cm">			 * is not already pte-numa. If the VMA contains
</span><span class="ln"> 2648</span><span class="cm">			 * areas that are unused or already full of prot_numa
</span><span class="ln"> 2649</span><span class="cm">			 * PTEs, scan up to virtpages, to skip through those
</span><span class="ln"> 2650</span><span class="cm">			 * areas faster.
</span><span class="ln"> 2651</span><span class="cm">			 */</span>
<span class="ln"> 2652</span>			<span class="k">if</span> <span class="p">(</span><span class="n">nr_pte_updates</span><span class="p">)</span>
<span class="ln"> 2653</span>				<span class="n">pages</span> <span class="o">-=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="ln"> 2654</span>			<span class="n">virtpages</span> <span class="o">-=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="ln"> 2655</span>
<span class="ln"> 2656</span>			<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
<span class="ln"> 2657</span>			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">virtpages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 2658</span>				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 2659</span>
<span class="ln"> 2660</span>			<span class="n">cond_resched</span><span class="p">();</span>
<span class="ln"> 2661</span>		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
<span class="ln"> 2662</span>	<span class="p">}</span>
<span class="ln"> 2663</span>
<span class="ln"> 2664</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 2665</span>	<span class="cm">/*
</span><span class="ln"> 2666</span><span class="cm">	 * It is possible to reach the end of the VMA list but the last few
</span><span class="ln"> 2667</span><span class="cm">	 * VMAs are not guaranteed to the vma_migratable. If they are not, we
</span><span class="ln"> 2668</span><span class="cm">	 * would find the !migratable VMA on the next scan but not reset the
</span><span class="ln"> 2669</span><span class="cm">	 * scanner to the start so check it now.
</span><span class="ln"> 2670</span><span class="cm">	 */</span>
<span class="ln"> 2671</span>	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
<span class="ln"> 2672</span>		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_scan_offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
<span class="ln"> 2673</span>	<span class="k">else</span>
<span class="ln"> 2674</span>		<span class="n">reset_ptenuma_scan</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2675</span>	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="ln"> 2676</span>
<span class="ln"> 2677</span>	<span class="cm">/*
</span><span class="ln"> 2678</span><span class="cm">	 * Make sure tasks use at least 32x as much time to run other code
</span><span class="ln"> 2679</span><span class="cm">	 * than they used here, to limit NUMA PTE scanning overhead to 3% max.
</span><span class="ln"> 2680</span><span class="cm">	 * Usually update_task_scan_period slows down scanning enough; on an
</span><span class="ln"> 2681</span><span class="cm">	 * overloaded system we need to limit overhead on a per task basis.
</span><span class="ln"> 2682</span><span class="cm">	 */</span>
<span class="ln"> 2683</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">!=</span> <span class="n">runtime</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2684</span>		<span class="n">u64</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 2685</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">node_stamp</span> <span class="o">+=</span> <span class="mi">32</span> <span class="o">*</span> <span class="n">diff</span><span class="p">;</span>
<span class="ln"> 2686</span>	<span class="p">}</span>
<span class="ln"> 2687</span><span class="p">}</span>
<span class="ln"> 2688</span>
<span class="ln"> 2689</span><span class="cm">/*
</span><span class="ln"> 2690</span><span class="cm"> * Drive the periodic memory faults..
</span><span class="ln"> 2691</span><span class="cm"> */</span>
<span class="ln"> 2692</span><span class="kt">void</span> <span class="nf">task_tick_numa</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 2693</span><span class="p">{</span>
<span class="ln"> 2694</span>	<span class="k">struct</span> <span class="n">callback_head</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">numa_work</span><span class="p">;</span>
<span class="ln"> 2695</span>	<span class="n">u64</span> <span class="n">period</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>
<span class="ln"> 2696</span>
<span class="ln"> 2697</span>	<span class="cm">/*
</span><span class="ln"> 2698</span><span class="cm">	 * We don&#39;t care about NUMA placement if we don&#39;t have memory.
</span><span class="ln"> 2699</span><span class="cm">	 */</span>
<span class="ln"> 2700</span>	<span class="k">if</span> <span class="p">((</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PF_EXITING</span> <span class="o">|</span> <span class="n">PF_KTHREAD</span><span class="p">))</span> <span class="o">||</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">work</span><span class="p">)</span>
<span class="ln"> 2701</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2702</span>
<span class="ln"> 2703</span>	<span class="cm">/*
</span><span class="ln"> 2704</span><span class="cm">	 * Using runtime rather than walltime has the dual advantage that
</span><span class="ln"> 2705</span><span class="cm">	 * we (mostly) drive the selection from busy threads and that the
</span><span class="ln"> 2706</span><span class="cm">	 * task needs to have done some actual work before we bother with
</span><span class="ln"> 2707</span><span class="cm">	 * NUMA placement.
</span><span class="ln"> 2708</span><span class="cm">	 */</span>
<span class="ln"> 2709</span>	<span class="n">now</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 2710</span>	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="ln"> 2711</span>
<span class="ln"> 2712</span>	<span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">node_stamp</span> <span class="o">+</span> <span class="n">period</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2713</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">node_stamp</span><span class="p">)</span>
<span class="ln"> 2714</span>			<span class="n">curr</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">=</span> <span class="n">task_scan_start</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 2715</span>		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">node_stamp</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
<span class="ln"> 2716</span>
<span class="ln"> 2717</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">numa_next_scan</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2718</span>			<span class="n">init_task_work</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">task_numa_work</span><span class="p">);</span> <span class="cm">/* TODO: move this into sched_fork() */</span>
<span class="ln"> 2719</span>			<span class="n">task_work_add</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln"> 2720</span>		<span class="p">}</span>
<span class="ln"> 2721</span>	<span class="p">}</span>
<span class="ln"> 2722</span><span class="p">}</span>
<span class="ln"> 2723</span>
<span class="ln"> 2724</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_scan_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_cpu</span><span class="p">)</span>
<span class="ln"> 2725</span><span class="p">{</span>
<span class="ln"> 2726</span>	<span class="kt">int</span> <span class="n">src_nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 2727</span>	<span class="kt">int</span> <span class="n">dst_nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">new_cpu</span><span class="p">);</span>
<span class="ln"> 2728</span>
<span class="ln"> 2729</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">))</span>
<span class="ln"> 2730</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2731</span>
<span class="ln"> 2732</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span> <span class="o">||</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">))</span>
<span class="ln"> 2733</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2734</span>
<span class="ln"> 2735</span>	<span class="k">if</span> <span class="p">(</span><span class="n">src_nid</span> <span class="o">==</span> <span class="n">dst_nid</span><span class="p">)</span>
<span class="ln"> 2736</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2737</span>
<span class="ln"> 2738</span>	<span class="cm">/*
</span><span class="ln"> 2739</span><span class="cm">	 * Allow resets if faults have been trapped before one scan
</span><span class="ln"> 2740</span><span class="cm">	 * has completed. This is most likely due to a new task that
</span><span class="ln"> 2741</span><span class="cm">	 * is pulled cross-node due to wakeups or load balancing.
</span><span class="ln"> 2742</span><span class="cm">	 */</span>
<span class="ln"> 2743</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_seq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2744</span>		<span class="cm">/*
</span><span class="ln"> 2745</span><span class="cm">		 * Avoid scan adjustments if moving to the preferred
</span><span class="ln"> 2746</span><span class="cm">		 * node or if the task was not previously running on
</span><span class="ln"> 2747</span><span class="cm">		 * the preferred node.
</span><span class="ln"> 2748</span><span class="cm">		 */</span>
<span class="ln"> 2749</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dst_nid</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">||</span>
<span class="ln"> 2750</span>		    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">src_nid</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">))</span>
<span class="ln"> 2751</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln"> 2752</span>	<span class="p">}</span>
<span class="ln"> 2753</span>
<span class="ln"> 2754</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_scan_period</span> <span class="o">=</span> <span class="n">task_scan_start</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 2755</span><span class="p">}</span>
<span class="ln"> 2756</span>
<span class="ln"> 2757</span><span class="cp">#else
</span><span class="ln"> 2758</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_tick_numa</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 2759</span><span class="p">{</span>
<span class="ln"> 2760</span><span class="p">}</span>
<span class="ln"> 2761</span>
<span class="ln"> 2762</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">account_numa_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 2763</span><span class="p">{</span>
<span class="ln"> 2764</span><span class="p">}</span>
<span class="ln"> 2765</span>
<span class="ln"> 2766</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">account_numa_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 2767</span><span class="p">{</span>
<span class="ln"> 2768</span><span class="p">}</span>
<span class="ln"> 2769</span>
<span class="ln"> 2770</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_scan_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_cpu</span><span class="p">)</span>
<span class="ln"> 2771</span><span class="p">{</span>
<span class="ln"> 2772</span><span class="p">}</span>
<span class="ln"> 2773</span>
<span class="ln"> 2774</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA_BALANCING */</span><span class="cp">
</span><span class="ln"> 2775</span><span class="cp"></span>
<span class="ln"> 2776</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 2777</span><span class="nf">account_entity_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 2778</span><span class="p">{</span>
<span class="ln"> 2779</span>	<span class="n">update_load_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="ln"> 2780</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln"> 2781</span>		<span class="n">update_load_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="ln"> 2782</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 2783</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2784</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 2785</span>
<span class="ln"> 2786</span>		<span class="n">account_numa_enqueue</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="ln"> 2787</span>		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">group_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">);</span>
<span class="ln"> 2788</span>	<span class="p">}</span>
<span class="ln"> 2789</span><span class="cp">#endif
</span><span class="ln"> 2790</span><span class="cp"></span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 2791</span><span class="p">}</span>
<span class="ln"> 2792</span>
<span class="ln"> 2793</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 2794</span><span class="nf">account_entity_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 2795</span><span class="p">{</span>
<span class="ln"> 2796</span>	<span class="n">update_load_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="ln"> 2797</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln"> 2798</span>		<span class="n">update_load_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">);</span>
<span class="ln"> 2799</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 2800</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 2801</span>		<span class="n">account_numa_dequeue</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">),</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="ln"> 2802</span>		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">group_node</span><span class="p">);</span>
<span class="ln"> 2803</span>	<span class="p">}</span>
<span class="ln"> 2804</span><span class="cp">#endif
</span><span class="ln"> 2805</span><span class="cp"></span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 2806</span><span class="p">}</span>
<span class="ln"> 2807</span>
<span class="ln"> 2808</span><span class="cm">/*
</span><span class="ln"> 2809</span><span class="cm"> * Signed add and clamp on underflow.
</span><span class="ln"> 2810</span><span class="cm"> *
</span><span class="ln"> 2811</span><span class="cm"> * Explicitly do a load-store to ensure the intermediate value never hits
</span><span class="ln"> 2812</span><span class="cm"> * memory. This allows lockless observations without ever seeing the negative
</span><span class="ln"> 2813</span><span class="cm"> * values.
</span><span class="ln"> 2814</span><span class="cm"> */</span>
<span class="ln"> 2815</span><span class="cp">#define add_positive(_ptr, _val) do {                           \
</span><span class="ln"> 2816</span><span class="cp">	typeof(_ptr) ptr = (_ptr);                              \
</span><span class="ln"> 2817</span><span class="cp">	typeof(_val) val = (_val);                              \
</span><span class="ln"> 2818</span><span class="cp">	typeof(*ptr) res, var = READ_ONCE(*ptr);                \
</span><span class="ln"> 2819</span><span class="cp">								\
</span><span class="ln"> 2820</span><span class="cp">	res = var + val;                                        \
</span><span class="ln"> 2821</span><span class="cp">								\
</span><span class="ln"> 2822</span><span class="cp">	if (val &lt; 0 &amp;&amp; res &gt; var)                               \
</span><span class="ln"> 2823</span><span class="cp">		res = 0;                                        \
</span><span class="ln"> 2824</span><span class="cp">								\
</span><span class="ln"> 2825</span><span class="cp">	WRITE_ONCE(*ptr, res);                                  \
</span><span class="ln"> 2826</span><span class="cp">} while (0)
</span><span class="ln"> 2827</span><span class="cp"></span>
<span class="ln"> 2828</span><span class="cm">/*
</span><span class="ln"> 2829</span><span class="cm"> * Unsigned subtract and clamp on underflow.
</span><span class="ln"> 2830</span><span class="cm"> *
</span><span class="ln"> 2831</span><span class="cm"> * Explicitly do a load-store to ensure the intermediate value never hits
</span><span class="ln"> 2832</span><span class="cm"> * memory. This allows lockless observations without ever seeing the negative
</span><span class="ln"> 2833</span><span class="cm"> * values.
</span><span class="ln"> 2834</span><span class="cm"> */</span>
<span class="ln"> 2835</span><span class="cp">#define sub_positive(_ptr, _val) do {				\
</span><span class="ln"> 2836</span><span class="cp">	typeof(_ptr) ptr = (_ptr);				\
</span><span class="ln"> 2837</span><span class="cp">	typeof(*ptr) val = (_val);				\
</span><span class="ln"> 2838</span><span class="cp">	typeof(*ptr) res, var = READ_ONCE(*ptr);		\
</span><span class="ln"> 2839</span><span class="cp">	res = var - val;					\
</span><span class="ln"> 2840</span><span class="cp">	if (res &gt; var)						\
</span><span class="ln"> 2841</span><span class="cp">		res = 0;					\
</span><span class="ln"> 2842</span><span class="cp">	WRITE_ONCE(*ptr, res);					\
</span><span class="ln"> 2843</span><span class="cp">} while (0)
</span><span class="ln"> 2844</span><span class="cp"></span>
<span class="ln"> 2845</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 2846</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2847</span><span class="nf">enqueue_runnable_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 2848</span><span class="p">{</span>
<span class="ln"> 2849</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runnable_weight</span> <span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">runnable_weight</span><span class="p">;</span>
<span class="ln"> 2850</span>
<span class="ln"> 2851</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span> <span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">;</span>
<span class="ln"> 2852</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span> <span class="o">+=</span> <span class="n">se_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">;</span>
<span class="ln"> 2853</span><span class="p">}</span>
<span class="ln"> 2854</span>
<span class="ln"> 2855</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2856</span><span class="nf">dequeue_runnable_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 2857</span><span class="p">{</span>
<span class="ln"> 2858</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runnable_weight</span> <span class="o">-=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">runnable_weight</span><span class="p">;</span>
<span class="ln"> 2859</span>
<span class="ln"> 2860</span>	<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">);</span>
<span class="ln"> 2861</span>	<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">,</span>
<span class="ln"> 2862</span>		     <span class="n">se_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">);</span>
<span class="ln"> 2863</span><span class="p">}</span>
<span class="ln"> 2864</span>
<span class="ln"> 2865</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2866</span><span class="nf">enqueue_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 2867</span><span class="p">{</span>
<span class="ln"> 2868</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 2869</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span> <span class="o">+=</span> <span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span>
<span class="ln"> 2870</span><span class="p">}</span>
<span class="ln"> 2871</span>
<span class="ln"> 2872</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2873</span><span class="nf">dequeue_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 2874</span><span class="p">{</span>
<span class="ln"> 2875</span>	<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">);</span>
<span class="ln"> 2876</span>	<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">);</span>
<span class="ln"> 2877</span><span class="p">}</span>
<span class="ln"> 2878</span><span class="cp">#else
</span><span class="ln"> 2879</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2880</span><span class="nf">enqueue_runnable_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 2881</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2882</span><span class="nf">dequeue_runnable_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 2883</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2884</span><span class="nf">enqueue_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 2885</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 2886</span><span class="nf">dequeue_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 2887</span><span class="cp">#endif
</span><span class="ln"> 2888</span><span class="cp"></span>
<span class="ln"> 2889</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">reweight_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span>
<span class="ln"> 2890</span>			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">runnable</span><span class="p">)</span>
<span class="ln"> 2891</span><span class="p">{</span>
<span class="ln"> 2892</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2893</span>		<span class="cm">/* commit outstanding execution time */</span>
<span class="ln"> 2894</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 2895</span>			<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 2896</span>		<span class="n">account_entity_dequeue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 2897</span>		<span class="n">dequeue_runnable_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 2898</span>	<span class="p">}</span>
<span class="ln"> 2899</span>	<span class="n">dequeue_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 2900</span>
<span class="ln"> 2901</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">runnable_weight</span> <span class="o">=</span> <span class="n">runnable</span><span class="p">;</span>
<span class="ln"> 2902</span>	<span class="n">update_load_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="ln"> 2903</span>
<span class="ln"> 2904</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 2905</span><span class="cp"></span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 2906</span>		<span class="n">u32</span> <span class="n">divider</span> <span class="o">=</span> <span class="n">LOAD_AVG_MAX</span> <span class="o">-</span> <span class="mi">1024</span> <span class="o">+</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">period_contrib</span><span class="p">;</span>
<span class="ln"> 2907</span>
<span class="ln"> 2908</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">divider</span><span class="p">);</span>
<span class="ln"> 2909</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span> <span class="o">=</span>
<span class="ln"> 2910</span>			<span class="n">div_u64</span><span class="p">(</span><span class="n">se_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">,</span> <span class="n">divider</span><span class="p">);</span>
<span class="ln"> 2911</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln"> 2912</span><span class="cp">#endif
</span><span class="ln"> 2913</span><span class="cp"></span>
<span class="ln"> 2914</span>	<span class="n">enqueue_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 2915</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2916</span>		<span class="n">account_entity_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 2917</span>		<span class="n">enqueue_runnable_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 2918</span>	<span class="p">}</span>
<span class="ln"> 2919</span><span class="p">}</span>
<span class="ln"> 2920</span>
<span class="ln"> 2921</span><span class="kt">void</span> <span class="nf">reweight_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="ln"> 2922</span><span class="p">{</span>
<span class="ln"> 2923</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 2924</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 2925</span>	<span class="k">struct</span> <span class="n">load_weight</span> <span class="o">*</span><span class="n">load</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">;</span>
<span class="ln"> 2926</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">sched_prio_to_weight</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>
<span class="ln"> 2927</span>
<span class="ln"> 2928</span>	<span class="n">reweight_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
<span class="ln"> 2929</span>	<span class="n">load</span><span class="o">-&gt;</span><span class="n">inv_weight</span> <span class="o">=</span> <span class="n">sched_prio_to_wmult</span><span class="p">[</span><span class="n">prio</span><span class="p">];</span>
<span class="ln"> 2930</span><span class="p">}</span>
<span class="ln"> 2931</span>
<span class="ln"> 2932</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 2933</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 2934</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 2935</span><span class="cm"> * All this does is approximate the hierarchical proportion which includes that
</span><span class="ln"> 2936</span><span class="cm"> * global sum we all love to hate.
</span><span class="ln"> 2937</span><span class="cm"> *
</span><span class="ln"> 2938</span><span class="cm"> * That is, the weight of a group entity, is the proportional share of the
</span><span class="ln"> 2939</span><span class="cm"> * group weight based on the group runqueue weights. That is:
</span><span class="ln"> 2940</span><span class="cm"> *
</span><span class="ln"> 2941</span><span class="cm"> *                     tg-&gt;weight * grq-&gt;load.weight
</span><span class="ln"> 2942</span><span class="cm"> *   ge-&gt;load.weight = -----------------------------               (1)
</span><span class="ln"> 2943</span><span class="cm"> *			  \Sum grq-&gt;load.weight
</span><span class="ln"> 2944</span><span class="cm"> *
</span><span class="ln"> 2945</span><span class="cm"> * Now, because computing that sum is prohibitively expensive to compute (been
</span><span class="ln"> 2946</span><span class="cm"> * there, done that) we approximate it with this average stuff. The average
</span><span class="ln"> 2947</span><span class="cm"> * moves slower and therefore the approximation is cheaper and more stable.
</span><span class="ln"> 2948</span><span class="cm"> *
</span><span class="ln"> 2949</span><span class="cm"> * So instead of the above, we substitute:
</span><span class="ln"> 2950</span><span class="cm"> *
</span><span class="ln"> 2951</span><span class="cm"> *   grq-&gt;load.weight -&gt; grq-&gt;avg.load_avg                         (2)
</span><span class="ln"> 2952</span><span class="cm"> *
</span><span class="ln"> 2953</span><span class="cm"> * which yields the following:
</span><span class="ln"> 2954</span><span class="cm"> *
</span><span class="ln"> 2955</span><span class="cm"> *                     tg-&gt;weight * grq-&gt;avg.load_avg
</span><span class="ln"> 2956</span><span class="cm"> *   ge-&gt;load.weight = ------------------------------              (3)
</span><span class="ln"> 2957</span><span class="cm"> *				tg-&gt;load_avg
</span><span class="ln"> 2958</span><span class="cm"> *
</span><span class="ln"> 2959</span><span class="cm"> * Where: tg-&gt;load_avg ~= \Sum grq-&gt;avg.load_avg
</span><span class="ln"> 2960</span><span class="cm"> *
</span><span class="ln"> 2961</span><span class="cm"> * That is shares_avg, and it is right (given the approximation (2)).
</span><span class="ln"> 2962</span><span class="cm"> *
</span><span class="ln"> 2963</span><span class="cm"> * The problem with it is that because the average is slow -- it was designed
</span><span class="ln"> 2964</span><span class="cm"> * to be exactly that of course -- this leads to transients in boundary
</span><span class="ln"> 2965</span><span class="cm"> * conditions. In specific, the case where the group was idle and we start the
</span><span class="ln"> 2966</span><span class="cm"> * one task. It takes time for our CPU&#39;s grq-&gt;avg.load_avg to build up,
</span><span class="ln"> 2967</span><span class="cm"> * yielding bad latency etc..
</span><span class="ln"> 2968</span><span class="cm"> *
</span><span class="ln"> 2969</span><span class="cm"> * Now, in that special case (1) reduces to:
</span><span class="ln"> 2970</span><span class="cm"> *
</span><span class="ln"> 2971</span><span class="cm"> *                     tg-&gt;weight * grq-&gt;load.weight
</span><span class="ln"> 2972</span><span class="cm"> *   ge-&gt;load.weight = ----------------------------- = tg-&gt;weight   (4)
</span><span class="ln"> 2973</span><span class="cm"> *			    grp-&gt;load.weight
</span><span class="ln"> 2974</span><span class="cm"> *
</span><span class="ln"> 2975</span><span class="cm"> * That is, the sum collapses because all other CPUs are idle; the UP scenario.
</span><span class="ln"> 2976</span><span class="cm"> *
</span><span class="ln"> 2977</span><span class="cm"> * So what we do is modify our approximation (3) to approach (4) in the (near)
</span><span class="ln"> 2978</span><span class="cm"> * UP case, like:
</span><span class="ln"> 2979</span><span class="cm"> *
</span><span class="ln"> 2980</span><span class="cm"> *   ge-&gt;load.weight =
</span><span class="ln"> 2981</span><span class="cm"> *
</span><span class="ln"> 2982</span><span class="cm"> *              tg-&gt;weight * grq-&gt;load.weight
</span><span class="ln"> 2983</span><span class="cm"> *     ---------------------------------------------------         (5)
</span><span class="ln"> 2984</span><span class="cm"> *     tg-&gt;load_avg - grq-&gt;avg.load_avg + grq-&gt;load.weight
</span><span class="ln"> 2985</span><span class="cm"> *
</span><span class="ln"> 2986</span><span class="cm"> * But because grq-&gt;load.weight can drop to 0, resulting in a divide by zero,
</span><span class="ln"> 2987</span><span class="cm"> * we need to use grq-&gt;avg.load_avg as its lower bound, which then gives:
</span><span class="ln"> 2988</span><span class="cm"> *
</span><span class="ln"> 2989</span><span class="cm"> *
</span><span class="ln"> 2990</span><span class="cm"> *                     tg-&gt;weight * grq-&gt;load.weight
</span><span class="ln"> 2991</span><span class="cm"> *   ge-&gt;load.weight = -----------------------------		   (6)
</span><span class="ln"> 2992</span><span class="cm"> *				tg_load_avg&#39;
</span><span class="ln"> 2993</span><span class="cm"> *
</span><span class="ln"> 2994</span><span class="cm"> * Where:
</span><span class="ln"> 2995</span><span class="cm"> *
</span><span class="ln"> 2996</span><span class="cm"> *   tg_load_avg&#39; = tg-&gt;load_avg - grq-&gt;avg.load_avg +
</span><span class="ln"> 2997</span><span class="cm"> *                  max(grq-&gt;load.weight, grq-&gt;avg.load_avg)
</span><span class="ln"> 2998</span><span class="cm"> *
</span><span class="ln"> 2999</span><span class="cm"> * And that is shares_weight and is icky. In the (near) UP case it approaches
</span><span class="ln"> 3000</span><span class="cm"> * (4) while in the normal case it approaches (3). It consistently
</span><span class="ln"> 3001</span><span class="cm"> * overestimates the ge-&gt;load.weight and therefore:
</span><span class="ln"> 3002</span><span class="cm"> *
</span><span class="ln"> 3003</span><span class="cm"> *   \Sum ge-&gt;load.weight &gt;= tg-&gt;weight
</span><span class="ln"> 3004</span><span class="cm"> *
</span><span class="ln"> 3005</span><span class="cm"> * hence icky!
</span><span class="ln"> 3006</span><span class="cm"> */</span>
<span class="ln"> 3007</span><span class="k">static</span> <span class="kt">long</span> <span class="nf">calc_group_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 3008</span><span class="p">{</span>
<span class="ln"> 3009</span>	<span class="kt">long</span> <span class="n">tg_weight</span><span class="p">,</span> <span class="n">tg_shares</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="n">shares</span><span class="p">;</span>
<span class="ln"> 3010</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">;</span>
<span class="ln"> 3011</span>
<span class="ln"> 3012</span>	<span class="n">tg_shares</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">);</span>
<span class="ln"> 3013</span>
<span class="ln"> 3014</span>	<span class="n">load</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">scale_load_down</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">),</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">);</span>
<span class="ln"> 3015</span>
<span class="ln"> 3016</span>	<span class="n">tg_weight</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">load_avg</span><span class="p">);</span>
<span class="ln"> 3017</span>
<span class="ln"> 3018</span>	<span class="cm">/* Ensure tg_weight &gt;= load */</span>
<span class="ln"> 3019</span>	<span class="n">tg_weight</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg_load_avg_contrib</span><span class="p">;</span>
<span class="ln"> 3020</span>	<span class="n">tg_weight</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 3021</span>
<span class="ln"> 3022</span>	<span class="n">shares</span> <span class="o">=</span> <span class="p">(</span><span class="n">tg_shares</span> <span class="o">*</span> <span class="n">load</span><span class="p">);</span>
<span class="ln"> 3023</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tg_weight</span><span class="p">)</span>
<span class="ln"> 3024</span>		<span class="n">shares</span> <span class="o">/=</span> <span class="n">tg_weight</span><span class="p">;</span>
<span class="ln"> 3025</span>
<span class="ln"> 3026</span>	<span class="cm">/*
</span><span class="ln"> 3027</span><span class="cm">	 * MIN_SHARES has to be unscaled here to support per-CPU partitioning
</span><span class="ln"> 3028</span><span class="cm">	 * of a group with small tg-&gt;shares value. It is a floor value which is
</span><span class="ln"> 3029</span><span class="cm">	 * assigned as a minimum load.weight to the sched_entity representing
</span><span class="ln"> 3030</span><span class="cm">	 * the group on a CPU.
</span><span class="ln"> 3031</span><span class="cm">	 *
</span><span class="ln"> 3032</span><span class="cm">	 * E.g. on 64-bit for a group with tg-&gt;shares of scale_load(15)=15*1024
</span><span class="ln"> 3033</span><span class="cm">	 * on an 8-core system with 8 tasks each runnable on one CPU shares has
</span><span class="ln"> 3034</span><span class="cm">	 * to be 15*1024*1/8=1920 instead of scale_load(MIN_SHARES)=2*1024. In
</span><span class="ln"> 3035</span><span class="cm">	 * case no task is runnable on a CPU MIN_SHARES=2 should be returned
</span><span class="ln"> 3036</span><span class="cm">	 * instead of 0.
</span><span class="ln"> 3037</span><span class="cm">	 */</span>
<span class="ln"> 3038</span>	<span class="k">return</span> <span class="n">clamp_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">MIN_SHARES</span><span class="p">,</span> <span class="n">tg_shares</span><span class="p">);</span>
<span class="ln"> 3039</span><span class="p">}</span>
<span class="ln"> 3040</span>
<span class="ln"> 3041</span><span class="cm">/*
</span><span class="ln"> 3042</span><span class="cm"> * This calculates the effective runnable weight for a group entity based on
</span><span class="ln"> 3043</span><span class="cm"> * the group entity weight calculated above.
</span><span class="ln"> 3044</span><span class="cm"> *
</span><span class="ln"> 3045</span><span class="cm"> * Because of the above approximation (2), our group entity weight is
</span><span class="ln"> 3046</span><span class="cm"> * an load_avg based ratio (3). This means that it includes blocked load and
</span><span class="ln"> 3047</span><span class="cm"> * does not represent the runnable weight.
</span><span class="ln"> 3048</span><span class="cm"> *
</span><span class="ln"> 3049</span><span class="cm"> * Approximate the group entity&#39;s runnable weight per ratio from the group
</span><span class="ln"> 3050</span><span class="cm"> * runqueue:
</span><span class="ln"> 3051</span><span class="cm"> *
</span><span class="ln"> 3052</span><span class="cm"> *					     grq-&gt;avg.runnable_load_avg
</span><span class="ln"> 3053</span><span class="cm"> *   ge-&gt;runnable_weight = ge-&gt;load.weight * -------------------------- (7)
</span><span class="ln"> 3054</span><span class="cm"> *						 grq-&gt;avg.load_avg
</span><span class="ln"> 3055</span><span class="cm"> *
</span><span class="ln"> 3056</span><span class="cm"> * However, analogous to above, since the avg numbers are slow, this leads to
</span><span class="ln"> 3057</span><span class="cm"> * transients in the from-idle case. Instead we use:
</span><span class="ln"> 3058</span><span class="cm"> *
</span><span class="ln"> 3059</span><span class="cm"> *   ge-&gt;runnable_weight = ge-&gt;load.weight *
</span><span class="ln"> 3060</span><span class="cm"> *
</span><span class="ln"> 3061</span><span class="cm"> *		max(grq-&gt;avg.runnable_load_avg, grq-&gt;runnable_weight)
</span><span class="ln"> 3062</span><span class="cm"> *		-----------------------------------------------------	(8)
</span><span class="ln"> 3063</span><span class="cm"> *		      max(grq-&gt;avg.load_avg, grq-&gt;load.weight)
</span><span class="ln"> 3064</span><span class="cm"> *
</span><span class="ln"> 3065</span><span class="cm"> * Where these max() serve both to use the &#39;instant&#39; values to fix the slow
</span><span class="ln"> 3066</span><span class="cm"> * from-idle and avoid the /0 on to-idle, similar to (6).
</span><span class="ln"> 3067</span><span class="cm"> */</span>
<span class="ln"> 3068</span><span class="k">static</span> <span class="kt">long</span> <span class="nf">calc_group_runnable</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">long</span> <span class="n">shares</span><span class="p">)</span>
<span class="ln"> 3069</span><span class="p">{</span>
<span class="ln"> 3070</span>	<span class="kt">long</span> <span class="n">runnable</span><span class="p">,</span> <span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3071</span>
<span class="ln"> 3072</span>	<span class="n">load_avg</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">,</span>
<span class="ln"> 3073</span>		       <span class="n">scale_load_down</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">));</span>
<span class="ln"> 3074</span>
<span class="ln"> 3075</span>	<span class="n">runnable</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">,</span>
<span class="ln"> 3076</span>		       <span class="n">scale_load_down</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runnable_weight</span><span class="p">));</span>
<span class="ln"> 3077</span>
<span class="ln"> 3078</span>	<span class="n">runnable</span> <span class="o">*=</span> <span class="n">shares</span><span class="p">;</span>
<span class="ln"> 3079</span>	<span class="k">if</span> <span class="p">(</span><span class="n">load_avg</span><span class="p">)</span>
<span class="ln"> 3080</span>		<span class="n">runnable</span> <span class="o">/=</span> <span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3081</span>
<span class="ln"> 3082</span>	<span class="k">return</span> <span class="n">clamp_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">runnable</span><span class="p">,</span> <span class="n">MIN_SHARES</span><span class="p">,</span> <span class="n">shares</span><span class="p">);</span>
<span class="ln"> 3083</span><span class="p">}</span>
<span class="ln"> 3084</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 3085</span><span class="cp"></span>
<span class="ln"> 3086</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3087</span>
<span class="ln"> 3088</span><span class="cm">/*
</span><span class="ln"> 3089</span><span class="cm"> * Recomputes the group entity based on the current state of its group
</span><span class="ln"> 3090</span><span class="cm"> * runqueue.
</span><span class="ln"> 3091</span><span class="cm"> */</span>
<span class="ln"> 3092</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3093</span><span class="p">{</span>
<span class="ln"> 3094</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">gcfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3095</span>	<span class="kt">long</span> <span class="n">shares</span><span class="p">,</span> <span class="n">runnable</span><span class="p">;</span>
<span class="ln"> 3096</span>
<span class="ln"> 3097</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcfs_rq</span><span class="p">)</span>
<span class="ln"> 3098</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3099</span>
<span class="ln"> 3100</span>	<span class="k">if</span> <span class="p">(</span><span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="p">))</span>
<span class="ln"> 3101</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3102</span>
<span class="ln"> 3103</span><span class="cp">#ifndef CONFIG_SMP
</span><span class="ln"> 3104</span><span class="cp"></span>	<span class="n">runnable</span> <span class="o">=</span> <span class="n">shares</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span><span class="p">);</span>
<span class="ln"> 3105</span>
<span class="ln"> 3106</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">==</span> <span class="n">shares</span><span class="p">))</span>
<span class="ln"> 3107</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3108</span><span class="cp">#else
</span><span class="ln"> 3109</span><span class="cp"></span>	<span class="n">shares</span>   <span class="o">=</span> <span class="n">calc_group_shares</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="p">);</span>
<span class="ln"> 3110</span>	<span class="n">runnable</span> <span class="o">=</span> <span class="n">calc_group_runnable</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="p">,</span> <span class="n">shares</span><span class="p">);</span>
<span class="ln"> 3111</span><span class="cp">#endif
</span><span class="ln"> 3112</span><span class="cp"></span>
<span class="ln"> 3113</span>	<span class="n">reweight_entity</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">,</span> <span class="n">shares</span><span class="p">,</span> <span class="n">runnable</span><span class="p">);</span>
<span class="ln"> 3114</span><span class="p">}</span>
<span class="ln"> 3115</span>
<span class="ln"> 3116</span><span class="cp">#else </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln"> 3117</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_cfs_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3118</span><span class="p">{</span>
<span class="ln"> 3119</span><span class="p">}</span>
<span class="ln"> 3120</span><span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln"> 3121</span><span class="cp"></span>
<span class="ln"> 3122</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cfs_rq_util_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 3123</span><span class="p">{</span>
<span class="ln"> 3124</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3125</span>
<span class="ln"> 3126</span>	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span> <span class="o">==</span> <span class="n">cfs_rq</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SCHED_CPUFREQ_MIGRATION</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 3127</span>		<span class="cm">/*
</span><span class="ln"> 3128</span><span class="cm">		 * There are a few boundary cases this might miss but it should
</span><span class="ln"> 3129</span><span class="cm">		 * get called often enough that that should (hopefully) not be
</span><span class="ln"> 3130</span><span class="cm">		 * a real problem.
</span><span class="ln"> 3131</span><span class="cm">		 *
</span><span class="ln"> 3132</span><span class="cm">		 * It will not get called when we go idle, because the idle
</span><span class="ln"> 3133</span><span class="cm">		 * thread is a different class (!fair), nor will the utilization
</span><span class="ln"> 3134</span><span class="cm">		 * number include things like RT tasks.
</span><span class="ln"> 3135</span><span class="cm">		 *
</span><span class="ln"> 3136</span><span class="cm">		 * As is, the util number is not freq-invariant (we&#39;d have to
</span><span class="ln"> 3137</span><span class="cm">		 * implement arch_scale_freq_capacity() for that).
</span><span class="ln"> 3138</span><span class="cm">		 *
</span><span class="ln"> 3139</span><span class="cm">		 * See cpu_util().
</span><span class="ln"> 3140</span><span class="cm">		 */</span>
<span class="ln"> 3141</span>		<span class="n">cpufreq_update_util</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 3142</span>	<span class="p">}</span>
<span class="ln"> 3143</span><span class="p">}</span>
<span class="ln"> 3144</span>
<span class="ln"> 3145</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 3146</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 3147</span><span class="cp"></span><span class="cm">/**
</span><span class="ln"> 3148</span><span class="cm"> * update_tg_load_avg - update the tg&#39;s load avg
</span><span class="ln"> 3149</span><span class="cm"> * @cfs_rq: the cfs_rq whose avg changed
</span><span class="ln"> 3150</span><span class="cm"> * @force: update regardless of how small the difference
</span><span class="ln"> 3151</span><span class="cm"> *
</span><span class="ln"> 3152</span><span class="cm"> * This function &#39;ensures&#39;: tg-&gt;load_avg := \Sum tg-&gt;cfs_rq[]-&gt;avg.load.
</span><span class="ln"> 3153</span><span class="cm"> * However, because tg-&gt;load_avg is a global value there are performance
</span><span class="ln"> 3154</span><span class="cm"> * considerations.
</span><span class="ln"> 3155</span><span class="cm"> *
</span><span class="ln"> 3156</span><span class="cm"> * In order to avoid having to look at the other cfs_rq&#39;s, we use a
</span><span class="ln"> 3157</span><span class="cm"> * differential update where we store the last value we propagated. This in
</span><span class="ln"> 3158</span><span class="cm"> * turn allows skipping updates if the differential is &#39;small&#39;.
</span><span class="ln"> 3159</span><span class="cm"> *
</span><span class="ln"> 3160</span><span class="cm"> * Updating tg&#39;s load_avg is necessary before update_cfs_share().
</span><span class="ln"> 3161</span><span class="cm"> */</span>
<span class="ln"> 3162</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_tg_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="ln"> 3163</span><span class="p">{</span>
<span class="ln"> 3164</span>	<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg_load_avg_contrib</span><span class="p">;</span>
<span class="ln"> 3165</span>
<span class="ln"> 3166</span>	<span class="cm">/*
</span><span class="ln"> 3167</span><span class="cm">	 * No need to update load_avg for root_task_group as it is not used.
</span><span class="ln"> 3168</span><span class="cm">	 */</span>
<span class="ln"> 3169</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root_task_group</span><span class="p">)</span>
<span class="ln"> 3170</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3171</span>
<span class="ln"> 3172</span>	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">||</span> <span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg_load_avg_contrib</span> <span class="o">/</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3173</span>		<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">load_avg</span><span class="p">);</span>
<span class="ln"> 3174</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg_load_avg_contrib</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3175</span>	<span class="p">}</span>
<span class="ln"> 3176</span><span class="p">}</span>
<span class="ln"> 3177</span>
<span class="ln"> 3178</span><span class="cm">/*
</span><span class="ln"> 3179</span><span class="cm"> * Called within set_task_rq() right before setting a task&#39;s CPU. The
</span><span class="ln"> 3180</span><span class="cm"> * caller only guarantees p-&gt;pi_lock is held; no other assumptions,
</span><span class="ln"> 3181</span><span class="cm"> * including the state of rq-&gt;lock, should be made.
</span><span class="ln"> 3182</span><span class="cm"> */</span>
<span class="ln"> 3183</span><span class="kt">void</span> <span class="nf">set_task_rq_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span>
<span class="ln"> 3184</span>		      <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
<span class="ln"> 3185</span><span class="p">{</span>
<span class="ln"> 3186</span>	<span class="n">u64</span> <span class="n">p_last_update_time</span><span class="p">;</span>
<span class="ln"> 3187</span>	<span class="n">u64</span> <span class="n">n_last_update_time</span><span class="p">;</span>
<span class="ln"> 3188</span>
<span class="ln"> 3189</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">ATTACH_AGE_LOAD</span><span class="p">))</span>
<span class="ln"> 3190</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3191</span>
<span class="ln"> 3192</span>	<span class="cm">/*
</span><span class="ln"> 3193</span><span class="cm">	 * We are supposed to update the task to &#34;current&#34; time, then its up to
</span><span class="ln"> 3194</span><span class="cm">	 * date and ready to go to new CPU/cfs_rq. But we have difficulty in
</span><span class="ln"> 3195</span><span class="cm">	 * getting what current time is, so simply throw away the out-of-date
</span><span class="ln"> 3196</span><span class="cm">	 * time. This will result in the wakee task is less decayed, but giving
</span><span class="ln"> 3197</span><span class="cm">	 * the wakee more load sounds not bad.
</span><span class="ln"> 3198</span><span class="cm">	 */</span>
<span class="ln"> 3199</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="p">))</span>
<span class="ln"> 3200</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3201</span>
<span class="ln"> 3202</span><span class="cp">#ifndef CONFIG_64BIT
</span><span class="ln"> 3203</span><span class="cp"></span>	<span class="p">{</span>
<span class="ln"> 3204</span>		<span class="n">u64</span> <span class="n">p_last_update_time_copy</span><span class="p">;</span>
<span class="ln"> 3205</span>		<span class="n">u64</span> <span class="n">n_last_update_time_copy</span><span class="p">;</span>
<span class="ln"> 3206</span>
<span class="ln"> 3207</span>		<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 3208</span>			<span class="n">p_last_update_time_copy</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">load_last_update_time_copy</span><span class="p">;</span>
<span class="ln"> 3209</span>			<span class="n">n_last_update_time_copy</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">load_last_update_time_copy</span><span class="p">;</span>
<span class="ln"> 3210</span>
<span class="ln"> 3211</span>			<span class="n">smp_rmb</span><span class="p">();</span>
<span class="ln"> 3212</span>
<span class="ln"> 3213</span>			<span class="n">p_last_update_time</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3214</span>			<span class="n">n_last_update_time</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3215</span>
<span class="ln"> 3216</span>		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p_last_update_time</span> <span class="o">!=</span> <span class="n">p_last_update_time_copy</span> <span class="o">||</span>
<span class="ln"> 3217</span>			 <span class="n">n_last_update_time</span> <span class="o">!=</span> <span class="n">n_last_update_time_copy</span><span class="p">);</span>
<span class="ln"> 3218</span>	<span class="p">}</span>
<span class="ln"> 3219</span><span class="cp">#else
</span><span class="ln"> 3220</span><span class="cp"></span>	<span class="n">p_last_update_time</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3221</span>	<span class="n">n_last_update_time</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3222</span><span class="cp">#endif
</span><span class="ln"> 3223</span><span class="cp"></span>	<span class="n">__update_load_avg_blocked_se</span><span class="p">(</span><span class="n">p_last_update_time</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">prev</span><span class="p">)),</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3224</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">=</span> <span class="n">n_last_update_time</span><span class="p">;</span>
<span class="ln"> 3225</span><span class="p">}</span>
<span class="ln"> 3226</span>
<span class="ln"> 3227</span>
<span class="ln"> 3228</span><span class="cm">/*
</span><span class="ln"> 3229</span><span class="cm"> * When on migration a sched_entity joins/leaves the PELT hierarchy, we need to
</span><span class="ln"> 3230</span><span class="cm"> * propagate its contribution. The key to this propagation is the invariant
</span><span class="ln"> 3231</span><span class="cm"> * that for each group:
</span><span class="ln"> 3232</span><span class="cm"> *
</span><span class="ln"> 3233</span><span class="cm"> *   ge-&gt;avg == grq-&gt;avg						(1)
</span><span class="ln"> 3234</span><span class="cm"> *
</span><span class="ln"> 3235</span><span class="cm"> * _IFF_ we look at the pure running and runnable sums. Because they
</span><span class="ln"> 3236</span><span class="cm"> * represent the very same entity, just at different points in the hierarchy.
</span><span class="ln"> 3237</span><span class="cm"> *
</span><span class="ln"> 3238</span><span class="cm"> * Per the above update_tg_cfs_util() is trivial and simply copies the running
</span><span class="ln"> 3239</span><span class="cm"> * sum over (but still wrong, because the group entity and group rq do not have
</span><span class="ln"> 3240</span><span class="cm"> * their PELT windows aligned).
</span><span class="ln"> 3241</span><span class="cm"> *
</span><span class="ln"> 3242</span><span class="cm"> * However, update_tg_cfs_runnable() is more complex. So we have:
</span><span class="ln"> 3243</span><span class="cm"> *
</span><span class="ln"> 3244</span><span class="cm"> *   ge-&gt;avg.load_avg = ge-&gt;load.weight * ge-&gt;avg.runnable_avg		(2)
</span><span class="ln"> 3245</span><span class="cm"> *
</span><span class="ln"> 3246</span><span class="cm"> * And since, like util, the runnable part should be directly transferable,
</span><span class="ln"> 3247</span><span class="cm"> * the following would _appear_ to be the straight forward approach:
</span><span class="ln"> 3248</span><span class="cm"> *
</span><span class="ln"> 3249</span><span class="cm"> *   grq-&gt;avg.load_avg = grq-&gt;load.weight * grq-&gt;avg.runnable_avg	(3)
</span><span class="ln"> 3250</span><span class="cm"> *
</span><span class="ln"> 3251</span><span class="cm"> * And per (1) we have:
</span><span class="ln"> 3252</span><span class="cm"> *
</span><span class="ln"> 3253</span><span class="cm"> *   ge-&gt;avg.runnable_avg == grq-&gt;avg.runnable_avg
</span><span class="ln"> 3254</span><span class="cm"> *
</span><span class="ln"> 3255</span><span class="cm"> * Which gives:
</span><span class="ln"> 3256</span><span class="cm"> *
</span><span class="ln"> 3257</span><span class="cm"> *                      ge-&gt;load.weight * grq-&gt;avg.load_avg
</span><span class="ln"> 3258</span><span class="cm"> *   ge-&gt;avg.load_avg = -----------------------------------		(4)
</span><span class="ln"> 3259</span><span class="cm"> *                               grq-&gt;load.weight
</span><span class="ln"> 3260</span><span class="cm"> *
</span><span class="ln"> 3261</span><span class="cm"> * Except that is wrong!
</span><span class="ln"> 3262</span><span class="cm"> *
</span><span class="ln"> 3263</span><span class="cm"> * Because while for entities historical weight is not important and we
</span><span class="ln"> 3264</span><span class="cm"> * really only care about our future and therefore can consider a pure
</span><span class="ln"> 3265</span><span class="cm"> * runnable sum, runqueues can NOT do this.
</span><span class="ln"> 3266</span><span class="cm"> *
</span><span class="ln"> 3267</span><span class="cm"> * We specifically want runqueues to have a load_avg that includes
</span><span class="ln"> 3268</span><span class="cm"> * historical weights. Those represent the blocked load, the load we expect
</span><span class="ln"> 3269</span><span class="cm"> * to (shortly) return to us. This only works by keeping the weights as
</span><span class="ln"> 3270</span><span class="cm"> * integral part of the sum. We therefore cannot decompose as per (3).
</span><span class="ln"> 3271</span><span class="cm"> *
</span><span class="ln"> 3272</span><span class="cm"> * Another reason this doesn&#39;t work is that runnable isn&#39;t a 0-sum entity.
</span><span class="ln"> 3273</span><span class="cm"> * Imagine a rq with 2 tasks that each are runnable 2/3 of the time. Then the
</span><span class="ln"> 3274</span><span class="cm"> * rq itself is runnable anywhere between 2/3 and 1 depending on how the
</span><span class="ln"> 3275</span><span class="cm"> * runnable section of these tasks overlap (or not). If they were to perfectly
</span><span class="ln"> 3276</span><span class="cm"> * align the rq as a whole would be runnable 2/3 of the time. If however we
</span><span class="ln"> 3277</span><span class="cm"> * always have at least 1 runnable task, the rq as a whole is always runnable.
</span><span class="ln"> 3278</span><span class="cm"> *
</span><span class="ln"> 3279</span><span class="cm"> * So we&#39;ll have to approximate.. :/
</span><span class="ln"> 3280</span><span class="cm"> *
</span><span class="ln"> 3281</span><span class="cm"> * Given the constraint:
</span><span class="ln"> 3282</span><span class="cm"> *
</span><span class="ln"> 3283</span><span class="cm"> *   ge-&gt;avg.running_sum &lt;= ge-&gt;avg.runnable_sum &lt;= LOAD_AVG_MAX
</span><span class="ln"> 3284</span><span class="cm"> *
</span><span class="ln"> 3285</span><span class="cm"> * We can construct a rule that adds runnable to a rq by assuming minimal
</span><span class="ln"> 3286</span><span class="cm"> * overlap.
</span><span class="ln"> 3287</span><span class="cm"> *
</span><span class="ln"> 3288</span><span class="cm"> * On removal, we&#39;ll assume each task is equally runnable; which yields:
</span><span class="ln"> 3289</span><span class="cm"> *
</span><span class="ln"> 3290</span><span class="cm"> *   grq-&gt;avg.runnable_sum = grq-&gt;avg.load_sum / grq-&gt;load.weight
</span><span class="ln"> 3291</span><span class="cm"> *
</span><span class="ln"> 3292</span><span class="cm"> * XXX: only do this for the part of runnable &gt; running ?
</span><span class="ln"> 3293</span><span class="cm"> *
</span><span class="ln"> 3294</span><span class="cm"> */</span>
<span class="ln"> 3295</span>
<span class="ln"> 3296</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 3297</span><span class="nf">update_tg_cfs_util</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">gcfs_rq</span><span class="p">)</span>
<span class="ln"> 3298</span><span class="p">{</span>
<span class="ln"> 3299</span>	<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">;</span>
<span class="ln"> 3300</span>
<span class="ln"> 3301</span>	<span class="cm">/* Nothing to update */</span>
<span class="ln"> 3302</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delta</span><span class="p">)</span>
<span class="ln"> 3303</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3304</span>
<span class="ln"> 3305</span>	<span class="cm">/*
</span><span class="ln"> 3306</span><span class="cm">	 * The relation between sum and avg is:
</span><span class="ln"> 3307</span><span class="cm">	 *
</span><span class="ln"> 3308</span><span class="cm">	 *   LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib
</span><span class="ln"> 3309</span><span class="cm">	 *
</span><span class="ln"> 3310</span><span class="cm">	 * however, the PELT windows are not aligned between grq and gse.
</span><span class="ln"> 3311</span><span class="cm">	 */</span>
<span class="ln"> 3312</span>
<span class="ln"> 3313</span>	<span class="cm">/* Set new sched_entity&#39;s utilization */</span>
<span class="ln"> 3314</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">=</span> <span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">;</span>
<span class="ln"> 3315</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">*</span> <span class="n">LOAD_AVG_MAX</span><span class="p">;</span>
<span class="ln"> 3316</span>
<span class="ln"> 3317</span>	<span class="cm">/* Update parent cfs_rq utilization */</span>
<span class="ln"> 3318</span>	<span class="n">add_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln"> 3319</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">*</span> <span class="n">LOAD_AVG_MAX</span><span class="p">;</span>
<span class="ln"> 3320</span><span class="p">}</span>
<span class="ln"> 3321</span>
<span class="ln"> 3322</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 3323</span><span class="nf">update_tg_cfs_runnable</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">gcfs_rq</span><span class="p">)</span>
<span class="ln"> 3324</span><span class="p">{</span>
<span class="ln"> 3325</span>	<span class="kt">long</span> <span class="n">delta_avg</span><span class="p">,</span> <span class="n">running_sum</span><span class="p">,</span> <span class="n">runnable_sum</span> <span class="o">=</span> <span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">prop_runnable_sum</span><span class="p">;</span>
<span class="ln"> 3326</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">runnable_load_avg</span><span class="p">,</span> <span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3327</span>	<span class="n">u64</span> <span class="n">runnable_load_sum</span><span class="p">,</span> <span class="n">load_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3328</span>	<span class="n">s64</span> <span class="n">delta_sum</span><span class="p">;</span>
<span class="ln"> 3329</span>
<span class="ln"> 3330</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">runnable_sum</span><span class="p">)</span>
<span class="ln"> 3331</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3332</span>
<span class="ln"> 3333</span>	<span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">prop_runnable_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3334</span>
<span class="ln"> 3335</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runnable_sum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3336</span>		<span class="cm">/*
</span><span class="ln"> 3337</span><span class="cm">		 * Add runnable; clip at LOAD_AVG_MAX. Reflects that until
</span><span class="ln"> 3338</span><span class="cm">		 * the CPU is saturated running == runnable.
</span><span class="ln"> 3339</span><span class="cm">		 */</span>
<span class="ln"> 3340</span>		<span class="n">runnable_sum</span> <span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span>
<span class="ln"> 3341</span>		<span class="n">runnable_sum</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">runnable_sum</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">LOAD_AVG_MAX</span><span class="p">);</span>
<span class="ln"> 3342</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 3343</span>		<span class="cm">/*
</span><span class="ln"> 3344</span><span class="cm">		 * Estimate the new unweighted runnable_sum of the gcfs_rq by
</span><span class="ln"> 3345</span><span class="cm">		 * assuming all tasks are equally runnable.
</span><span class="ln"> 3346</span><span class="cm">		 */</span>
<span class="ln"> 3347</span>		<span class="k">if</span> <span class="p">(</span><span class="n">scale_load_down</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 3348</span>			<span class="n">load_sum</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span>
<span class="ln"> 3349</span>				<span class="n">scale_load_down</span><span class="p">(</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">));</span>
<span class="ln"> 3350</span>		<span class="p">}</span>
<span class="ln"> 3351</span>
<span class="ln"> 3352</span>		<span class="cm">/* But make sure to not inflate se&#39;s runnable */</span>
<span class="ln"> 3353</span>		<span class="n">runnable_sum</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">load_sum</span><span class="p">);</span>
<span class="ln"> 3354</span>	<span class="p">}</span>
<span class="ln"> 3355</span>
<span class="ln"> 3356</span>	<span class="cm">/*
</span><span class="ln"> 3357</span><span class="cm">	 * runnable_sum can&#39;t be lower than running_sum
</span><span class="ln"> 3358</span><span class="cm">	 * As running sum is scale with CPU capacity wehreas the runnable sum
</span><span class="ln"> 3359</span><span class="cm">	 * is not we rescale running_sum 1st
</span><span class="ln"> 3360</span><span class="cm">	 */</span>
<span class="ln"> 3361</span>	<span class="n">running_sum</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span> <span class="o">/</span>
<span class="ln"> 3362</span>		<span class="n">arch_scale_cpu_capacity</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)));</span>
<span class="ln"> 3363</span>	<span class="n">runnable_sum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">runnable_sum</span><span class="p">,</span> <span class="n">running_sum</span><span class="p">);</span>
<span class="ln"> 3364</span>
<span class="ln"> 3365</span>	<span class="n">load_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">runnable_sum</span><span class="p">;</span>
<span class="ln"> 3366</span>	<span class="n">load_avg</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">(</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">LOAD_AVG_MAX</span><span class="p">);</span>
<span class="ln"> 3367</span>
<span class="ln"> 3368</span>	<span class="n">delta_sum</span> <span class="o">=</span> <span class="n">load_sum</span> <span class="o">-</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span>
<span class="ln"> 3369</span>	<span class="n">delta_avg</span> <span class="o">=</span> <span class="n">load_avg</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3370</span>
<span class="ln"> 3371</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span> <span class="o">=</span> <span class="n">runnable_sum</span><span class="p">;</span>
<span class="ln"> 3372</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">=</span> <span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3373</span>	<span class="n">add_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">,</span> <span class="n">delta_avg</span><span class="p">);</span>
<span class="ln"> 3374</span>	<span class="n">add_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">delta_sum</span><span class="p">);</span>
<span class="ln"> 3375</span>
<span class="ln"> 3376</span>	<span class="n">runnable_load_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">se_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">runnable_sum</span><span class="p">;</span>
<span class="ln"> 3377</span>	<span class="n">runnable_load_avg</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">(</span><span class="n">runnable_load_sum</span><span class="p">,</span> <span class="n">LOAD_AVG_MAX</span><span class="p">);</span>
<span class="ln"> 3378</span>	<span class="n">delta_sum</span> <span class="o">=</span> <span class="n">runnable_load_sum</span> <span class="o">-</span> <span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">;</span>
<span class="ln"> 3379</span>	<span class="n">delta_avg</span> <span class="o">=</span> <span class="n">runnable_load_avg</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">;</span>
<span class="ln"> 3380</span>
<span class="ln"> 3381</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span> <span class="o">=</span> <span class="n">runnable_sum</span><span class="p">;</span>
<span class="ln"> 3382</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span> <span class="o">=</span> <span class="n">runnable_load_avg</span><span class="p">;</span>
<span class="ln"> 3383</span>
<span class="ln"> 3384</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3385</span>		<span class="n">add_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">,</span> <span class="n">delta_avg</span><span class="p">);</span>
<span class="ln"> 3386</span>		<span class="n">add_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">,</span> <span class="n">delta_sum</span><span class="p">);</span>
<span class="ln"> 3387</span>	<span class="p">}</span>
<span class="ln"> 3388</span><span class="p">}</span>
<span class="ln"> 3389</span>
<span class="ln"> 3390</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_tg_cfs_propagate</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">long</span> <span class="n">runnable_sum</span><span class="p">)</span>
<span class="ln"> 3391</span><span class="p">{</span>
<span class="ln"> 3392</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">propagate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 3393</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">prop_runnable_sum</span> <span class="o">+=</span> <span class="n">runnable_sum</span><span class="p">;</span>
<span class="ln"> 3394</span><span class="p">}</span>
<span class="ln"> 3395</span>
<span class="ln"> 3396</span><span class="cm">/* Update task and its cfs_rq load average */</span>
<span class="ln"> 3397</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">propagate_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3398</span><span class="p">{</span>
<span class="ln"> 3399</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">gcfs_rq</span><span class="p">;</span>
<span class="ln"> 3400</span>
<span class="ln"> 3401</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln"> 3402</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3403</span>
<span class="ln"> 3404</span>	<span class="n">gcfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3405</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">propagate</span><span class="p">)</span>
<span class="ln"> 3406</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3407</span>
<span class="ln"> 3408</span>	<span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">propagate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3409</span>
<span class="ln"> 3410</span>	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3411</span>
<span class="ln"> 3412</span>	<span class="n">add_tg_cfs_propagate</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">prop_runnable_sum</span><span class="p">);</span>
<span class="ln"> 3413</span>
<span class="ln"> 3414</span>	<span class="n">update_tg_cfs_util</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">gcfs_rq</span><span class="p">);</span>
<span class="ln"> 3415</span>	<span class="n">update_tg_cfs_runnable</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">gcfs_rq</span><span class="p">);</span>
<span class="ln"> 3416</span>
<span class="ln"> 3417</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 3418</span><span class="p">}</span>
<span class="ln"> 3419</span>
<span class="ln"> 3420</span><span class="cm">/*
</span><span class="ln"> 3421</span><span class="cm"> * Check if we need to update the load and the utilization of a blocked
</span><span class="ln"> 3422</span><span class="cm"> * group_entity:
</span><span class="ln"> 3423</span><span class="cm"> */</span>
<span class="ln"> 3424</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">skip_blocked_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3425</span><span class="p">{</span>
<span class="ln"> 3426</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">gcfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3427</span>
<span class="ln"> 3428</span>	<span class="cm">/*
</span><span class="ln"> 3429</span><span class="cm">	 * If sched_entity still have not zero load or utilization, we have to
</span><span class="ln"> 3430</span><span class="cm">	 * decay it:
</span><span class="ln"> 3431</span><span class="cm">	 */</span>
<span class="ln"> 3432</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">||</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">)</span>
<span class="ln"> 3433</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 3434</span>
<span class="ln"> 3435</span>	<span class="cm">/*
</span><span class="ln"> 3436</span><span class="cm">	 * If there is a pending propagation, we have to update the load and
</span><span class="ln"> 3437</span><span class="cm">	 * the utilization of the sched_entity:
</span><span class="ln"> 3438</span><span class="cm">	 */</span>
<span class="ln"> 3439</span>	<span class="k">if</span> <span class="p">(</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">propagate</span><span class="p">)</span>
<span class="ln"> 3440</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 3441</span>
<span class="ln"> 3442</span>	<span class="cm">/*
</span><span class="ln"> 3443</span><span class="cm">	 * Otherwise, the load and the utilization of the sched_entity is
</span><span class="ln"> 3444</span><span class="cm">	 * already zero and there is no pending propagation, so it will be a
</span><span class="ln"> 3445</span><span class="cm">	 * waste of time to try to decay it:
</span><span class="ln"> 3446</span><span class="cm">	 */</span>
<span class="ln"> 3447</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 3448</span><span class="p">}</span>
<span class="ln"> 3449</span>
<span class="ln"> 3450</span><span class="cp">#else </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln"> 3451</span><span class="cp"></span>
<span class="ln"> 3452</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_tg_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3453</span>
<span class="ln"> 3454</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">propagate_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3455</span><span class="p">{</span>
<span class="ln"> 3456</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3457</span><span class="p">}</span>
<span class="ln"> 3458</span>
<span class="ln"> 3459</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_tg_cfs_propagate</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="kt">long</span> <span class="n">runnable_sum</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3460</span>
<span class="ln"> 3461</span><span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln"> 3462</span><span class="cp"></span>
<span class="ln"> 3463</span><span class="cm">/**
</span><span class="ln"> 3464</span><span class="cm"> * update_cfs_rq_load_avg - update the cfs_rq&#39;s load/util averages
</span><span class="ln"> 3465</span><span class="cm"> * @now: current time, as per cfs_rq_clock_task()
</span><span class="ln"> 3466</span><span class="cm"> * @cfs_rq: cfs_rq to update
</span><span class="ln"> 3467</span><span class="cm"> *
</span><span class="ln"> 3468</span><span class="cm"> * The cfs_rq avg is the direct sum of all its entities (blocked and runnable)
</span><span class="ln"> 3469</span><span class="cm"> * avg. The immediate corollary is that all (fair) tasks must be attached, see
</span><span class="ln"> 3470</span><span class="cm"> * post_init_entity_util_avg().
</span><span class="ln"> 3471</span><span class="cm"> *
</span><span class="ln"> 3472</span><span class="cm"> * cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.
</span><span class="ln"> 3473</span><span class="cm"> *
</span><span class="ln"> 3474</span><span class="cm"> * Returns true if the load decayed or we removed load.
</span><span class="ln"> 3475</span><span class="cm"> *
</span><span class="ln"> 3476</span><span class="cm"> * Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should
</span><span class="ln"> 3477</span><span class="cm"> * call update_tg_load_avg() when this function returns true.
</span><span class="ln"> 3478</span><span class="cm"> */</span>
<span class="ln"> 3479</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="ln"> 3480</span><span class="nf">update_cfs_rq_load_avg</span><span class="p">(</span><span class="n">u64</span> <span class="n">now</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 3481</span><span class="p">{</span>
<span class="ln"> 3482</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">removed_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">removed_util</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">removed_runnable_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3483</span>	<span class="k">struct</span> <span class="n">sched_avg</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">;</span>
<span class="ln"> 3484</span>	<span class="kt">int</span> <span class="n">decayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3485</span>
<span class="ln"> 3486</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3487</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">r</span><span class="p">;</span>
<span class="ln"> 3488</span>		<span class="n">u32</span> <span class="n">divider</span> <span class="o">=</span> <span class="n">LOAD_AVG_MAX</span> <span class="o">-</span> <span class="mi">1024</span> <span class="o">+</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">period_contrib</span><span class="p">;</span>
<span class="ln"> 3489</span>
<span class="ln"> 3490</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 3491</span>		<span class="n">swap</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">util_avg</span><span class="p">,</span> <span class="n">removed_util</span><span class="p">);</span>
<span class="ln"> 3492</span>		<span class="n">swap</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">load_avg</span><span class="p">,</span> <span class="n">removed_load</span><span class="p">);</span>
<span class="ln"> 3493</span>		<span class="n">swap</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">runnable_sum</span><span class="p">,</span> <span class="n">removed_runnable_sum</span><span class="p">);</span>
<span class="ln"> 3494</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3495</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 3496</span>
<span class="ln"> 3497</span>		<span class="n">r</span> <span class="o">=</span> <span class="n">removed_load</span><span class="p">;</span>
<span class="ln"> 3498</span>		<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">load_avg</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="ln"> 3499</span>		<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">divider</span><span class="p">);</span>
<span class="ln"> 3500</span>
<span class="ln"> 3501</span>		<span class="n">r</span> <span class="o">=</span> <span class="n">removed_util</span><span class="p">;</span>
<span class="ln"> 3502</span>		<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_avg</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="ln"> 3503</span>		<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_sum</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">divider</span><span class="p">);</span>
<span class="ln"> 3504</span>
<span class="ln"> 3505</span>		<span class="n">add_tg_cfs_propagate</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">removed_runnable_sum</span><span class="p">);</span>
<span class="ln"> 3506</span>
<span class="ln"> 3507</span>		<span class="n">decayed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 3508</span>	<span class="p">}</span>
<span class="ln"> 3509</span>
<span class="ln"> 3510</span>	<span class="n">decayed</span> <span class="o">|=</span> <span class="n">__update_load_avg_cfs_rq</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)),</span> <span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3511</span>
<span class="ln"> 3512</span><span class="cp">#ifndef CONFIG_64BIT
</span><span class="ln"> 3513</span><span class="cp"></span>	<span class="n">smp_wmb</span><span class="p">();</span>
<span class="ln"> 3514</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_last_update_time_copy</span> <span class="o">=</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3515</span><span class="cp">#endif
</span><span class="ln"> 3516</span><span class="cp"></span>
<span class="ln"> 3517</span>	<span class="k">if</span> <span class="p">(</span><span class="n">decayed</span><span class="p">)</span>
<span class="ln"> 3518</span>		<span class="n">cfs_rq_util_change</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3519</span>
<span class="ln"> 3520</span>	<span class="k">return</span> <span class="n">decayed</span><span class="p">;</span>
<span class="ln"> 3521</span><span class="p">}</span>
<span class="ln"> 3522</span>
<span class="ln"> 3523</span><span class="cm">/**
</span><span class="ln"> 3524</span><span class="cm"> * attach_entity_load_avg - attach this entity to its cfs_rq load avg
</span><span class="ln"> 3525</span><span class="cm"> * @cfs_rq: cfs_rq to attach to
</span><span class="ln"> 3526</span><span class="cm"> * @se: sched_entity to attach
</span><span class="ln"> 3527</span><span class="cm"> * @flags: migration hints
</span><span class="ln"> 3528</span><span class="cm"> *
</span><span class="ln"> 3529</span><span class="cm"> * Must call update_cfs_rq_load_avg() before this, since we rely on
</span><span class="ln"> 3530</span><span class="cm"> * cfs_rq-&gt;avg.last_update_time being current.
</span><span class="ln"> 3531</span><span class="cm"> */</span>
<span class="ln"> 3532</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 3533</span><span class="p">{</span>
<span class="ln"> 3534</span>	<span class="n">u32</span> <span class="n">divider</span> <span class="o">=</span> <span class="n">LOAD_AVG_MAX</span> <span class="o">-</span> <span class="mi">1024</span> <span class="o">+</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">period_contrib</span><span class="p">;</span>
<span class="ln"> 3535</span>
<span class="ln"> 3536</span>	<span class="cm">/*
</span><span class="ln"> 3537</span><span class="cm">	 * When we attach the @se to the @cfs_rq, we must align the decay
</span><span class="ln"> 3538</span><span class="cm">	 * window because without that, really weird and wonderful things can
</span><span class="ln"> 3539</span><span class="cm">	 * happen.
</span><span class="ln"> 3540</span><span class="cm">	 *
</span><span class="ln"> 3541</span><span class="cm">	 * XXX illustrate
</span><span class="ln"> 3542</span><span class="cm">	 */</span>
<span class="ln"> 3543</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3544</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">period_contrib</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">period_contrib</span><span class="p">;</span>
<span class="ln"> 3545</span>
<span class="ln"> 3546</span>	<span class="cm">/*
</span><span class="ln"> 3547</span><span class="cm">	 * Hell(o) Nasty stuff.. we need to recompute _sum based on the new
</span><span class="ln"> 3548</span><span class="cm">	 * period_contrib. This isn&#39;t strictly correct, but since we&#39;re
</span><span class="ln"> 3549</span><span class="cm">	 * entirely outside of the PELT hierarchy, nobody cares if we truncate
</span><span class="ln"> 3550</span><span class="cm">	 * _sum a little.
</span><span class="ln"> 3551</span><span class="cm">	 */</span>
<span class="ln"> 3552</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">*</span> <span class="n">divider</span><span class="p">;</span>
<span class="ln"> 3553</span>
<span class="ln"> 3554</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span> <span class="o">=</span> <span class="n">divider</span><span class="p">;</span>
<span class="ln"> 3555</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 3556</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span> <span class="o">=</span>
<span class="ln"> 3557</span>			<span class="n">div_u64</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span> <span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="ln"> 3558</span>	<span class="p">}</span>
<span class="ln"> 3559</span>
<span class="ln"> 3560</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span>
<span class="ln"> 3561</span>
<span class="ln"> 3562</span>	<span class="n">enqueue_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3563</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span> <span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">;</span>
<span class="ln"> 3564</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span> <span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="p">;</span>
<span class="ln"> 3565</span>
<span class="ln"> 3566</span>	<span class="n">add_tg_cfs_propagate</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">);</span>
<span class="ln"> 3567</span>
<span class="ln"> 3568</span>	<span class="n">cfs_rq_util_change</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 3569</span><span class="p">}</span>
<span class="ln"> 3570</span>
<span class="ln"> 3571</span><span class="cm">/**
</span><span class="ln"> 3572</span><span class="cm"> * detach_entity_load_avg - detach this entity from its cfs_rq load avg
</span><span class="ln"> 3573</span><span class="cm"> * @cfs_rq: cfs_rq to detach from
</span><span class="ln"> 3574</span><span class="cm"> * @se: sched_entity to detach
</span><span class="ln"> 3575</span><span class="cm"> *
</span><span class="ln"> 3576</span><span class="cm"> * Must call update_cfs_rq_load_avg() before this, since we rely on
</span><span class="ln"> 3577</span><span class="cm"> * cfs_rq-&gt;avg.last_update_time being current.
</span><span class="ln"> 3578</span><span class="cm"> */</span>
<span class="ln"> 3579</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3580</span><span class="p">{</span>
<span class="ln"> 3581</span>	<span class="n">dequeue_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3582</span>	<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">);</span>
<span class="ln"> 3583</span>	<span class="n">sub_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="p">);</span>
<span class="ln"> 3584</span>
<span class="ln"> 3585</span>	<span class="n">add_tg_cfs_propagate</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">-</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">);</span>
<span class="ln"> 3586</span>
<span class="ln"> 3587</span>	<span class="n">cfs_rq_util_change</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3588</span><span class="p">}</span>
<span class="ln"> 3589</span>
<span class="ln"> 3590</span><span class="cm">/*
</span><span class="ln"> 3591</span><span class="cm"> * Optional action to be done while updating the load average
</span><span class="ln"> 3592</span><span class="cm"> */</span>
<span class="ln"> 3593</span><span class="cp">#define UPDATE_TG	0x1
</span><span class="ln"> 3594</span><span class="cp">#define SKIP_AGE_LOAD	0x2
</span><span class="ln"> 3595</span><span class="cp">#define DO_ATTACH	0x4
</span><span class="ln"> 3596</span><span class="cp"></span>
<span class="ln"> 3597</span><span class="cm">/* Update task and its cfs_rq load average */</span>
<span class="ln"> 3598</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 3599</span><span class="p">{</span>
<span class="ln"> 3600</span>	<span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">cfs_rq_clock_task</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3601</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3602</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 3603</span>	<span class="kt">int</span> <span class="n">decayed</span><span class="p">;</span>
<span class="ln"> 3604</span>
<span class="ln"> 3605</span>	<span class="cm">/*
</span><span class="ln"> 3606</span><span class="cm">	 * Track task load average for carrying it to new CPU after migrated, and
</span><span class="ln"> 3607</span><span class="cm">	 * track group sched_entity load average for task_h_load calc in migration
</span><span class="ln"> 3608</span><span class="cm">	 */</span>
<span class="ln"> 3609</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SKIP_AGE_LOAD</span><span class="p">))</span>
<span class="ln"> 3610</span>		<span class="n">__update_load_avg_se</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3611</span>
<span class="ln"> 3612</span>	<span class="n">decayed</span>  <span class="o">=</span> <span class="n">update_cfs_rq_load_avg</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3613</span>	<span class="n">decayed</span> <span class="o">|=</span> <span class="n">propagate_entity_load_avg</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3614</span>
<span class="ln"> 3615</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DO_ATTACH</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 3616</span>
<span class="ln"> 3617</span>		<span class="cm">/*
</span><span class="ln"> 3618</span><span class="cm">		 * DO_ATTACH means we&#39;re here from enqueue_entity().
</span><span class="ln"> 3619</span><span class="cm">		 * !last_update_time means we&#39;ve passed through
</span><span class="ln"> 3620</span><span class="cm">		 * migrate_task_rq_fair() indicating we migrated.
</span><span class="ln"> 3621</span><span class="cm">		 *
</span><span class="ln"> 3622</span><span class="cm">		 * IOW we&#39;re enqueueing a task on a new CPU.
</span><span class="ln"> 3623</span><span class="cm">		 */</span>
<span class="ln"> 3624</span>		<span class="n">attach_entity_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">SCHED_CPUFREQ_MIGRATION</span><span class="p">);</span>
<span class="ln"> 3625</span>		<span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3626</span>
<span class="ln"> 3627</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">decayed</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UPDATE_TG</span><span class="p">))</span>
<span class="ln"> 3628</span>		<span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3629</span><span class="p">}</span>
<span class="ln"> 3630</span>
<span class="ln"> 3631</span><span class="cp">#ifndef CONFIG_64BIT
</span><span class="ln"> 3632</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cfs_rq_last_update_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 3633</span><span class="p">{</span>
<span class="ln"> 3634</span>	<span class="n">u64</span> <span class="n">last_update_time_copy</span><span class="p">;</span>
<span class="ln"> 3635</span>	<span class="n">u64</span> <span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3636</span>
<span class="ln"> 3637</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 3638</span>		<span class="n">last_update_time_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load_last_update_time_copy</span><span class="p">;</span>
<span class="ln"> 3639</span>		<span class="n">smp_rmb</span><span class="p">();</span>
<span class="ln"> 3640</span>		<span class="n">last_update_time</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3641</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">last_update_time</span> <span class="o">!=</span> <span class="n">last_update_time_copy</span><span class="p">);</span>
<span class="ln"> 3642</span>
<span class="ln"> 3643</span>	<span class="k">return</span> <span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3644</span><span class="p">}</span>
<span class="ln"> 3645</span><span class="cp">#else
</span><span class="ln"> 3646</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cfs_rq_last_update_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 3647</span><span class="p">{</span>
<span class="ln"> 3648</span>	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3649</span><span class="p">}</span>
<span class="ln"> 3650</span><span class="cp">#endif
</span><span class="ln"> 3651</span><span class="cp"></span>
<span class="ln"> 3652</span><span class="cm">/*
</span><span class="ln"> 3653</span><span class="cm"> * Synchronize entity load avg of dequeued entity without locking
</span><span class="ln"> 3654</span><span class="cm"> * the previous rq.
</span><span class="ln"> 3655</span><span class="cm"> */</span>
<span class="ln"> 3656</span><span class="kt">void</span> <span class="nf">sync_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3657</span><span class="p">{</span>
<span class="ln"> 3658</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3659</span>	<span class="n">u64</span> <span class="n">last_update_time</span><span class="p">;</span>
<span class="ln"> 3660</span>
<span class="ln"> 3661</span>	<span class="n">last_update_time</span> <span class="o">=</span> <span class="n">cfs_rq_last_update_time</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3662</span>	<span class="n">__update_load_avg_blocked_se</span><span class="p">(</span><span class="n">last_update_time</span><span class="p">,</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)),</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3663</span><span class="p">}</span>
<span class="ln"> 3664</span>
<span class="ln"> 3665</span><span class="cm">/*
</span><span class="ln"> 3666</span><span class="cm"> * Task first catches up with cfs_rq, and then subtract
</span><span class="ln"> 3667</span><span class="cm"> * itself from the cfs_rq (task must be off the queue now).
</span><span class="ln"> 3668</span><span class="cm"> */</span>
<span class="ln"> 3669</span><span class="kt">void</span> <span class="nf">remove_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3670</span><span class="p">{</span>
<span class="ln"> 3671</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3672</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln"> 3673</span>
<span class="ln"> 3674</span>	<span class="cm">/*
</span><span class="ln"> 3675</span><span class="cm">	 * tasks cannot exit without having gone through wake_up_new_task() -&gt;
</span><span class="ln"> 3676</span><span class="cm">	 * post_init_entity_util_avg() which will have added things to the
</span><span class="ln"> 3677</span><span class="cm">	 * cfs_rq, so we can remove unconditionally.
</span><span class="ln"> 3678</span><span class="cm">	 *
</span><span class="ln"> 3679</span><span class="cm">	 * Similarly for groups, they will have passed through
</span><span class="ln"> 3680</span><span class="cm">	 * post_init_entity_util_avg() before unregister_sched_fair_group()
</span><span class="ln"> 3681</span><span class="cm">	 * calls this.
</span><span class="ln"> 3682</span><span class="cm">	 */</span>
<span class="ln"> 3683</span>
<span class="ln"> 3684</span>	<span class="n">sync_entity_load_avg</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3685</span>
<span class="ln"> 3686</span>	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 3687</span>	<span class="o">++</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">nr</span><span class="p">;</span>
<span class="ln"> 3688</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">util_avg</span>	<span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">;</span>
<span class="ln"> 3689</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">load_avg</span>	<span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3690</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">runnable_sum</span>	<span class="o">+=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span> <span class="cm">/* == runnable_sum */</span>
<span class="ln"> 3691</span>	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 3692</span><span class="p">}</span>
<span class="ln"> 3693</span>
<span class="ln"> 3694</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cfs_rq_runnable_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 3695</span><span class="p">{</span>
<span class="ln"> 3696</span>	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_avg</span><span class="p">;</span>
<span class="ln"> 3697</span><span class="p">}</span>
<span class="ln"> 3698</span>
<span class="ln"> 3699</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cfs_rq_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 3700</span><span class="p">{</span>
<span class="ln"> 3701</span>	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 3702</span><span class="p">}</span>
<span class="ln"> 3703</span>
<span class="ln"> 3704</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">idle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 3705</span>
<span class="ln"> 3706</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_util</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 3707</span><span class="p">{</span>
<span class="ln"> 3708</span>	<span class="k">return</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">);</span>
<span class="ln"> 3709</span><span class="p">}</span>
<span class="ln"> 3710</span>
<span class="ln"> 3711</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_task_util_est</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 3712</span><span class="p">{</span>
<span class="ln"> 3713</span>	<span class="k">struct</span> <span class="n">util_est</span> <span class="n">ue</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">);</span>
<span class="ln"> 3714</span>
<span class="ln"> 3715</span>	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">ue</span><span class="p">.</span><span class="n">ewma</span><span class="p">,</span> <span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span><span class="p">);</span>
<span class="ln"> 3716</span><span class="p">}</span>
<span class="ln"> 3717</span>
<span class="ln"> 3718</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_util_est</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 3719</span><span class="p">{</span>
<span class="ln"> 3720</span>	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">task_util</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">_task_util_est</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 3721</span><span class="p">}</span>
<span class="ln"> 3722</span>
<span class="ln"> 3723</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">util_est_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span>
<span class="ln"> 3724</span>				    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 3725</span><span class="p">{</span>
<span class="ln"> 3726</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">enqueued</span><span class="p">;</span>
<span class="ln"> 3727</span>
<span class="ln"> 3728</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">UTIL_EST</span><span class="p">))</span>
<span class="ln"> 3729</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3730</span>
<span class="ln"> 3731</span>	<span class="cm">/* Update root cfs_rq&#39;s estimated utilization */</span>
<span class="ln"> 3732</span>	<span class="n">enqueued</span>  <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="p">;</span>
<span class="ln"> 3733</span>	<span class="n">enqueued</span> <span class="o">+=</span> <span class="p">(</span><span class="n">_task_util_est</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">UTIL_AVG_UNCHANGED</span><span class="p">);</span>
<span class="ln"> 3734</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="p">,</span> <span class="n">enqueued</span><span class="p">);</span>
<span class="ln"> 3735</span><span class="p">}</span>
<span class="ln"> 3736</span>
<span class="ln"> 3737</span><span class="cm">/*
</span><span class="ln"> 3738</span><span class="cm"> * Check if a (signed) value is within a specified (unsigned) margin,
</span><span class="ln"> 3739</span><span class="cm"> * based on the observation that:
</span><span class="ln"> 3740</span><span class="cm"> *
</span><span class="ln"> 3741</span><span class="cm"> *     abs(x) &lt; y := (unsigned)(x + y - 1) &lt; (2 * y - 1)
</span><span class="ln"> 3742</span><span class="cm"> *
</span><span class="ln"> 3743</span><span class="cm"> * NOTE: this only works when value + maring &lt; INT_MAX.
</span><span class="ln"> 3744</span><span class="cm"> */</span>
<span class="ln"> 3745</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">within_margin</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">margin</span><span class="p">)</span>
<span class="ln"> 3746</span><span class="p">{</span>
<span class="ln"> 3747</span>	<span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">value</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="ln"> 3748</span><span class="p">}</span>
<span class="ln"> 3749</span>
<span class="ln"> 3750</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 3751</span><span class="nf">util_est_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">task_sleep</span><span class="p">)</span>
<span class="ln"> 3752</span><span class="p">{</span>
<span class="ln"> 3753</span>	<span class="kt">long</span> <span class="n">last_ewma_diff</span><span class="p">;</span>
<span class="ln"> 3754</span>	<span class="k">struct</span> <span class="n">util_est</span> <span class="n">ue</span><span class="p">;</span>
<span class="ln"> 3755</span>
<span class="ln"> 3756</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">UTIL_EST</span><span class="p">))</span>
<span class="ln"> 3757</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3758</span>
<span class="ln"> 3759</span>	<span class="cm">/* Update root cfs_rq&#39;s estimated utilization */</span>
<span class="ln"> 3760</span>	<span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span>  <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="p">;</span>
<span class="ln"> 3761</span>	<span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span><span class="p">,</span>
<span class="ln"> 3762</span>			     <span class="p">(</span><span class="n">_task_util_est</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">UTIL_AVG_UNCHANGED</span><span class="p">));</span>
<span class="ln"> 3763</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="p">,</span> <span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span><span class="p">);</span>
<span class="ln"> 3764</span>
<span class="ln"> 3765</span>	<span class="cm">/*
</span><span class="ln"> 3766</span><span class="cm">	 * Skip update of task&#39;s estimated utilization when the task has not
</span><span class="ln"> 3767</span><span class="cm">	 * yet completed an activation, e.g. being migrated.
</span><span class="ln"> 3768</span><span class="cm">	 */</span>
<span class="ln"> 3769</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_sleep</span><span class="p">)</span>
<span class="ln"> 3770</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3771</span>
<span class="ln"> 3772</span>	<span class="cm">/*
</span><span class="ln"> 3773</span><span class="cm">	 * If the PELT values haven&#39;t changed since enqueue time,
</span><span class="ln"> 3774</span><span class="cm">	 * skip the util_est update.
</span><span class="ln"> 3775</span><span class="cm">	 */</span>
<span class="ln"> 3776</span>	<span class="n">ue</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">;</span>
<span class="ln"> 3777</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span> <span class="o">&amp;</span> <span class="n">UTIL_AVG_UNCHANGED</span><span class="p">)</span>
<span class="ln"> 3778</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3779</span>
<span class="ln"> 3780</span>	<span class="cm">/*
</span><span class="ln"> 3781</span><span class="cm">	 * Skip update of task&#39;s estimated utilization when its EWMA is
</span><span class="ln"> 3782</span><span class="cm">	 * already ~1% close to its last activation value.
</span><span class="ln"> 3783</span><span class="cm">	 */</span>
<span class="ln"> 3784</span>	<span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_util</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">UTIL_AVG_UNCHANGED</span><span class="p">);</span>
<span class="ln"> 3785</span>	<span class="n">last_ewma_diff</span> <span class="o">=</span> <span class="n">ue</span><span class="p">.</span><span class="n">enqueued</span> <span class="o">-</span> <span class="n">ue</span><span class="p">.</span><span class="n">ewma</span><span class="p">;</span>
<span class="ln"> 3786</span>	<span class="k">if</span> <span class="p">(</span><span class="n">within_margin</span><span class="p">(</span><span class="n">last_ewma_diff</span><span class="p">,</span> <span class="p">(</span><span class="n">SCHED_CAPACITY_SCALE</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)))</span>
<span class="ln"> 3787</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3788</span>
<span class="ln"> 3789</span>	<span class="cm">/*
</span><span class="ln"> 3790</span><span class="cm">	 * Update Task&#39;s estimated utilization
</span><span class="ln"> 3791</span><span class="cm">	 *
</span><span class="ln"> 3792</span><span class="cm">	 * When *p completes an activation we can consolidate another sample
</span><span class="ln"> 3793</span><span class="cm">	 * of the task size. This is done by storing the current PELT value
</span><span class="ln"> 3794</span><span class="cm">	 * as ue.enqueued and by using this value to update the Exponential
</span><span class="ln"> 3795</span><span class="cm">	 * Weighted Moving Average (EWMA):
</span><span class="ln"> 3796</span><span class="cm">	 *
</span><span class="ln"> 3797</span><span class="cm">	 *  ewma(t) = w *  task_util(p) + (1-w) * ewma(t-1)
</span><span class="ln"> 3798</span><span class="cm">	 *          = w *  task_util(p) +         ewma(t-1)  - w * ewma(t-1)
</span><span class="ln"> 3799</span><span class="cm">	 *          = w * (task_util(p) -         ewma(t-1)) +     ewma(t-1)
</span><span class="ln"> 3800</span><span class="cm">	 *          = w * (      last_ewma_diff            ) +     ewma(t-1)
</span><span class="ln"> 3801</span><span class="cm">	 *          = w * (last_ewma_diff  +  ewma(t-1) / w)
</span><span class="ln"> 3802</span><span class="cm">	 *
</span><span class="ln"> 3803</span><span class="cm">	 * Where &#39;w&#39; is the weight of new samples, which is configured to be
</span><span class="ln"> 3804</span><span class="cm">	 * 0.25, thus making w=1/4 ( &gt;&gt;= UTIL_EST_WEIGHT_SHIFT)
</span><span class="ln"> 3805</span><span class="cm">	 */</span>
<span class="ln"> 3806</span>	<span class="n">ue</span><span class="p">.</span><span class="n">ewma</span> <span class="o">&lt;&lt;=</span> <span class="n">UTIL_EST_WEIGHT_SHIFT</span><span class="p">;</span>
<span class="ln"> 3807</span>	<span class="n">ue</span><span class="p">.</span><span class="n">ewma</span>  <span class="o">+=</span> <span class="n">last_ewma_diff</span><span class="p">;</span>
<span class="ln"> 3808</span>	<span class="n">ue</span><span class="p">.</span><span class="n">ewma</span> <span class="o">&gt;&gt;=</span> <span class="n">UTIL_EST_WEIGHT_SHIFT</span><span class="p">;</span>
<span class="ln"> 3809</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">,</span> <span class="n">ue</span><span class="p">);</span>
<span class="ln"> 3810</span><span class="p">}</span>
<span class="ln"> 3811</span>
<span class="ln"> 3812</span><span class="cp">#else </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 3813</span><span class="cp"></span>
<span class="ln"> 3814</span><span class="cp">#define UPDATE_TG	0x0
</span><span class="ln"> 3815</span><span class="cp">#define SKIP_AGE_LOAD	0x0
</span><span class="ln"> 3816</span><span class="cp">#define DO_ATTACH	0x0
</span><span class="ln"> 3817</span><span class="cp"></span>
<span class="ln"> 3818</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">not_used1</span><span class="p">)</span>
<span class="ln"> 3819</span><span class="p">{</span>
<span class="ln"> 3820</span>	<span class="n">cfs_rq_util_change</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3821</span><span class="p">}</span>
<span class="ln"> 3822</span>
<span class="ln"> 3823</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3824</span>
<span class="ln"> 3825</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 3826</span><span class="nf">attach_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3827</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 3828</span><span class="nf">detach_entity_load_avg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3829</span>
<span class="ln"> 3830</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">idle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln"> 3831</span><span class="p">{</span>
<span class="ln"> 3832</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 3833</span><span class="p">}</span>
<span class="ln"> 3834</span>
<span class="ln"> 3835</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 3836</span><span class="nf">util_est_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3837</span>
<span class="ln"> 3838</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 3839</span><span class="nf">util_est_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 3840</span>		 <span class="kt">bool</span> <span class="n">task_sleep</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 3841</span>
<span class="ln"> 3842</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 3843</span><span class="cp"></span>
<span class="ln"> 3844</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">check_spread</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3845</span><span class="p">{</span>
<span class="ln"> 3846</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln"> 3847</span><span class="cp"></span>	<span class="n">s64</span> <span class="n">d</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 3848</span>
<span class="ln"> 3849</span>	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 3850</span>		<span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span><span class="p">;</span>
<span class="ln"> 3851</span>
<span class="ln"> 3852</span>	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">sysctl_sched_latency</span><span class="p">)</span>
<span class="ln"> 3853</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_spread_over</span><span class="p">);</span>
<span class="ln"> 3854</span><span class="cp">#endif
</span><span class="ln"> 3855</span><span class="cp"></span><span class="p">}</span>
<span class="ln"> 3856</span>
<span class="ln"> 3857</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 3858</span><span class="nf">place_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">initial</span><span class="p">)</span>
<span class="ln"> 3859</span><span class="p">{</span>
<span class="ln"> 3860</span>	<span class="n">u64</span> <span class="n">vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 3861</span>
<span class="ln"> 3862</span>	<span class="cm">/*
</span><span class="ln"> 3863</span><span class="cm">	 * The &#39;current&#39; period is already promised to the current tasks,
</span><span class="ln"> 3864</span><span class="cm">	 * however the extra weight of the new task will slow them down a
</span><span class="ln"> 3865</span><span class="cm">	 * little, place the new task so that it fits in the slot that
</span><span class="ln"> 3866</span><span class="cm">	 * stays open at the end.
</span><span class="ln"> 3867</span><span class="cm">	 */</span>
<span class="ln"> 3868</span>	<span class="k">if</span> <span class="p">(</span><span class="n">initial</span> <span class="o">&amp;&amp;</span> <span class="n">sched_feat</span><span class="p">(</span><span class="n">START_DEBIT</span><span class="p">))</span>
<span class="ln"> 3869</span>		<span class="n">vruntime</span> <span class="o">+=</span> <span class="n">sched_vslice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3870</span>
<span class="ln"> 3871</span>	<span class="cm">/* sleeps up to a single latency don&#39;t count. */</span>
<span class="ln"> 3872</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initial</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3873</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span> <span class="o">=</span> <span class="n">sysctl_sched_latency</span><span class="p">;</span>
<span class="ln"> 3874</span>
<span class="ln"> 3875</span>		<span class="cm">/*
</span><span class="ln"> 3876</span><span class="cm">		 * Halve their sleep time&#39;s effect, to allow
</span><span class="ln"> 3877</span><span class="cm">		 * for a gentler effect of sleepers:
</span><span class="ln"> 3878</span><span class="cm">		 */</span>
<span class="ln"> 3879</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">GENTLE_FAIR_SLEEPERS</span><span class="p">))</span>
<span class="ln"> 3880</span>			<span class="n">thresh</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 3881</span>
<span class="ln"> 3882</span>		<span class="n">vruntime</span> <span class="o">-=</span> <span class="n">thresh</span><span class="p">;</span>
<span class="ln"> 3883</span>	<span class="p">}</span>
<span class="ln"> 3884</span>
<span class="ln"> 3885</span>	<span class="cm">/* ensure we never gain time by being placed backwards. */</span>
<span class="ln"> 3886</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">=</span> <span class="n">max_vruntime</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">,</span> <span class="n">vruntime</span><span class="p">);</span>
<span class="ln"> 3887</span><span class="p">}</span>
<span class="ln"> 3888</span>
<span class="ln"> 3889</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">check_enqueue_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3890</span>
<span class="ln"> 3891</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_schedstat_required</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 3892</span><span class="p">{</span>
<span class="ln"> 3893</span><span class="cp">#ifdef CONFIG_SCHEDSTATS
</span><span class="ln"> 3894</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">schedstat_enabled</span><span class="p">())</span>
<span class="ln"> 3895</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 3896</span>
<span class="ln"> 3897</span>	<span class="cm">/* Force schedstat enabled if a dependent tracepoint is active */</span>
<span class="ln"> 3898</span>	<span class="k">if</span> <span class="p">(</span><span class="n">trace_sched_stat_wait_enabled</span><span class="p">()</span>    <span class="o">||</span>
<span class="ln"> 3899</span>			<span class="n">trace_sched_stat_sleep_enabled</span><span class="p">()</span>   <span class="o">||</span>
<span class="ln"> 3900</span>			<span class="n">trace_sched_stat_iowait_enabled</span><span class="p">()</span>  <span class="o">||</span>
<span class="ln"> 3901</span>			<span class="n">trace_sched_stat_blocked_enabled</span><span class="p">()</span> <span class="o">||</span>
<span class="ln"> 3902</span>			<span class="n">trace_sched_stat_runtime_enabled</span><span class="p">())</span>  <span class="p">{</span>
<span class="ln"> 3903</span>		<span class="n">printk_deferred_once</span><span class="p">(</span><span class="s">&#34;Scheduler tracepoints stat_sleep, stat_iowait, &#34;</span>
<span class="ln"> 3904</span>			     <span class="s">&#34;stat_blocked and stat_runtime require the &#34;</span>
<span class="ln"> 3905</span>			     <span class="s">&#34;kernel parameter schedstats=enable or &#34;</span>
<span class="ln"> 3906</span>			     <span class="s">&#34;kernel.sched_schedstats=1</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln"> 3907</span>	<span class="p">}</span>
<span class="ln"> 3908</span><span class="cp">#endif
</span><span class="ln"> 3909</span><span class="cp"></span><span class="p">}</span>
<span class="ln"> 3910</span>
<span class="ln"> 3911</span>
<span class="ln"> 3912</span><span class="cm">/*
</span><span class="ln"> 3913</span><span class="cm"> * MIGRATION
</span><span class="ln"> 3914</span><span class="cm"> *
</span><span class="ln"> 3915</span><span class="cm"> *	dequeue
</span><span class="ln"> 3916</span><span class="cm"> *	  update_curr()
</span><span class="ln"> 3917</span><span class="cm"> *	    update_min_vruntime()
</span><span class="ln"> 3918</span><span class="cm"> *	  vruntime -= min_vruntime
</span><span class="ln"> 3919</span><span class="cm"> *
</span><span class="ln"> 3920</span><span class="cm"> *	enqueue
</span><span class="ln"> 3921</span><span class="cm"> *	  update_curr()
</span><span class="ln"> 3922</span><span class="cm"> *	    update_min_vruntime()
</span><span class="ln"> 3923</span><span class="cm"> *	  vruntime += min_vruntime
</span><span class="ln"> 3924</span><span class="cm"> *
</span><span class="ln"> 3925</span><span class="cm"> * this way the vruntime transition between RQs is done when both
</span><span class="ln"> 3926</span><span class="cm"> * min_vruntime are up-to-date.
</span><span class="ln"> 3927</span><span class="cm"> *
</span><span class="ln"> 3928</span><span class="cm"> * WAKEUP (remote)
</span><span class="ln"> 3929</span><span class="cm"> *
</span><span class="ln"> 3930</span><span class="cm"> *	-&gt;migrate_task_rq_fair() (p-&gt;state == TASK_WAKING)
</span><span class="ln"> 3931</span><span class="cm"> *	  vruntime -= min_vruntime
</span><span class="ln"> 3932</span><span class="cm"> *
</span><span class="ln"> 3933</span><span class="cm"> *	enqueue
</span><span class="ln"> 3934</span><span class="cm"> *	  update_curr()
</span><span class="ln"> 3935</span><span class="cm"> *	    update_min_vruntime()
</span><span class="ln"> 3936</span><span class="cm"> *	  vruntime += min_vruntime
</span><span class="ln"> 3937</span><span class="cm"> *
</span><span class="ln"> 3938</span><span class="cm"> * this way we don&#39;t have the most up-to-date min_vruntime on the originating
</span><span class="ln"> 3939</span><span class="cm"> * CPU and an up-to-date min_vruntime on the destination CPU.
</span><span class="ln"> 3940</span><span class="cm"> */</span>
<span class="ln"> 3941</span>
<span class="ln"> 3942</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 3943</span><span class="nf">enqueue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 3944</span><span class="p">{</span>
<span class="ln"> 3945</span>	<span class="kt">bool</span> <span class="n">renorm</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_MIGRATED</span><span class="p">);</span>
<span class="ln"> 3946</span>	<span class="kt">bool</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">se</span><span class="p">;</span>
<span class="ln"> 3947</span>
<span class="ln"> 3948</span>	<span class="cm">/*
</span><span class="ln"> 3949</span><span class="cm">	 * If we&#39;re the current task, we must renormalise before calling
</span><span class="ln"> 3950</span><span class="cm">	 * update_curr().
</span><span class="ln"> 3951</span><span class="cm">	 */</span>
<span class="ln"> 3952</span>	<span class="k">if</span> <span class="p">(</span><span class="n">renorm</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="p">)</span>
<span class="ln"> 3953</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 3954</span>
<span class="ln"> 3955</span>	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3956</span>
<span class="ln"> 3957</span>	<span class="cm">/*
</span><span class="ln"> 3958</span><span class="cm">	 * Otherwise, renormalise after, such that we&#39;re placed at the current
</span><span class="ln"> 3959</span><span class="cm">	 * moment in time, instead of some random moment in the past. Being
</span><span class="ln"> 3960</span><span class="cm">	 * placed in the past could significantly boost this task to the
</span><span class="ln"> 3961</span><span class="cm">	 * fairness detriment of existing tasks.
</span><span class="ln"> 3962</span><span class="cm">	 */</span>
<span class="ln"> 3963</span>	<span class="k">if</span> <span class="p">(</span><span class="n">renorm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 3964</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 3965</span>
<span class="ln"> 3966</span>	<span class="cm">/*
</span><span class="ln"> 3967</span><span class="cm">	 * When enqueuing a sched_entity, we must:
</span><span class="ln"> 3968</span><span class="cm">	 *   - Update loads to have both entity and cfs_rq synced with now.
</span><span class="ln"> 3969</span><span class="cm">	 *   - Add its load to cfs_rq-&gt;runnable_avg
</span><span class="ln"> 3970</span><span class="cm">	 *   - For group_entity, update its weight to reflect the new share of
</span><span class="ln"> 3971</span><span class="cm">	 *     its group cfs_rq
</span><span class="ln"> 3972</span><span class="cm">	 *   - Add its new weight to cfs_rq-&gt;load.weight
</span><span class="ln"> 3973</span><span class="cm">	 */</span>
<span class="ln"> 3974</span>	<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span> <span class="o">|</span> <span class="n">DO_ATTACH</span><span class="p">);</span>
<span class="ln"> 3975</span>	<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3976</span>	<span class="n">enqueue_runnable_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3977</span>	<span class="n">account_entity_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3978</span>
<span class="ln"> 3979</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span>
<span class="ln"> 3980</span>		<span class="n">place_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 3981</span>
<span class="ln"> 3982</span>	<span class="n">check_schedstat_required</span><span class="p">();</span>
<span class="ln"> 3983</span>	<span class="n">update_stats_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 3984</span>	<span class="n">check_spread</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3985</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 3986</span>		<span class="n">__enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 3987</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 3988</span>
<span class="ln"> 3989</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3990</span>		<span class="n">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3991</span>		<span class="n">check_enqueue_throttle</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 3992</span>	<span class="p">}</span>
<span class="ln"> 3993</span><span class="p">}</span>
<span class="ln"> 3994</span>
<span class="ln"> 3995</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_buddies_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 3996</span><span class="p">{</span>
<span class="ln"> 3997</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 3998</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 3999</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">!=</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 4000</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4001</span>
<span class="ln"> 4002</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 4003</span>	<span class="p">}</span>
<span class="ln"> 4004</span><span class="p">}</span>
<span class="ln"> 4005</span>
<span class="ln"> 4006</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_buddies_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 4007</span><span class="p">{</span>
<span class="ln"> 4008</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4009</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4010</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 4011</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4012</span>
<span class="ln"> 4013</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 4014</span>	<span class="p">}</span>
<span class="ln"> 4015</span><span class="p">}</span>
<span class="ln"> 4016</span>
<span class="ln"> 4017</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__clear_buddies_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 4018</span><span class="p">{</span>
<span class="ln"> 4019</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4020</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4021</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">!=</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 4022</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4023</span>
<span class="ln"> 4024</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 4025</span>	<span class="p">}</span>
<span class="ln"> 4026</span><span class="p">}</span>
<span class="ln"> 4027</span>
<span class="ln"> 4028</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_buddies</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 4029</span><span class="p">{</span>
<span class="ln"> 4030</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 4031</span>		<span class="n">__clear_buddies_last</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4032</span>
<span class="ln"> 4033</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 4034</span>		<span class="n">__clear_buddies_next</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4035</span>
<span class="ln"> 4036</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span>
<span class="ln"> 4037</span>		<span class="n">__clear_buddies_skip</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4038</span><span class="p">}</span>
<span class="ln"> 4039</span>
<span class="ln"> 4040</span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4041</span>
<span class="ln"> 4042</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 4043</span><span class="nf">dequeue_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 4044</span><span class="p">{</span>
<span class="ln"> 4045</span>	<span class="cm">/*
</span><span class="ln"> 4046</span><span class="cm">	 * Update run-time statistics of the &#39;current&#39;.
</span><span class="ln"> 4047</span><span class="cm">	 */</span>
<span class="ln"> 4048</span>	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4049</span>
<span class="ln"> 4050</span>	<span class="cm">/*
</span><span class="ln"> 4051</span><span class="cm">	 * When dequeuing a sched_entity, we must:
</span><span class="ln"> 4052</span><span class="cm">	 *   - Update loads to have both entity and cfs_rq synced with now.
</span><span class="ln"> 4053</span><span class="cm">	 *   - Substract its load from the cfs_rq-&gt;runnable_avg.
</span><span class="ln"> 4054</span><span class="cm">	 *   - Substract its previous weight from cfs_rq-&gt;load.weight.
</span><span class="ln"> 4055</span><span class="cm">	 *   - For group entity, update its weight to reflect the new share
</span><span class="ln"> 4056</span><span class="cm">	 *     of its group cfs_rq.
</span><span class="ln"> 4057</span><span class="cm">	 */</span>
<span class="ln"> 4058</span>	<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln"> 4059</span>	<span class="n">dequeue_runnable_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4060</span>
<span class="ln"> 4061</span>	<span class="n">update_stats_dequeue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 4062</span>
<span class="ln"> 4063</span>	<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4064</span>
<span class="ln"> 4065</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">!=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 4066</span>		<span class="n">__dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4067</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4068</span>	<span class="n">account_entity_dequeue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4069</span>
<span class="ln"> 4070</span>	<span class="cm">/*
</span><span class="ln"> 4071</span><span class="cm">	 * Normalize after update_curr(); which will also have moved
</span><span class="ln"> 4072</span><span class="cm">	 * min_vruntime if @se is the one holding it back. But before doing
</span><span class="ln"> 4073</span><span class="cm">	 * update_min_vruntime() again, which will discount @se&#39;s position and
</span><span class="ln"> 4074</span><span class="cm">	 * can move min_vruntime forward still more.
</span><span class="ln"> 4075</span><span class="cm">	 */</span>
<span class="ln"> 4076</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">))</span>
<span class="ln"> 4077</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 4078</span>
<span class="ln"> 4079</span>	<span class="cm">/* return excess runtime on last dequeue */</span>
<span class="ln"> 4080</span>	<span class="n">return_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4081</span>
<span class="ln"> 4082</span>	<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4083</span>
<span class="ln"> 4084</span>	<span class="cm">/*
</span><span class="ln"> 4085</span><span class="cm">	 * Now advance min_vruntime if @se was the entity holding it back,
</span><span class="ln"> 4086</span><span class="cm">	 * except when: DEQUEUE_SAVE &amp;&amp; !DEQUEUE_MOVE, in this case we&#39;ll be
</span><span class="ln"> 4087</span><span class="cm">	 * put back on, and if we advance min_vruntime, we&#39;ll be placed back
</span><span class="ln"> 4088</span><span class="cm">	 * further than we started -- ie. we&#39;ll be penalized.
</span><span class="ln"> 4089</span><span class="cm">	 */</span>
<span class="ln"> 4090</span>	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEQUEUE_SAVE</span> <span class="o">|</span> <span class="n">DEQUEUE_MOVE</span><span class="p">))</span> <span class="o">!=</span> <span class="n">DEQUEUE_SAVE</span><span class="p">)</span>
<span class="ln"> 4091</span>		<span class="n">update_min_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4092</span><span class="p">}</span>
<span class="ln"> 4093</span>
<span class="ln"> 4094</span><span class="cm">/*
</span><span class="ln"> 4095</span><span class="cm"> * Preempt the current task with a newly woken task if needed:
</span><span class="ln"> 4096</span><span class="cm"> */</span>
<span class="ln"> 4097</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 4098</span><span class="nf">check_preempt_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 4099</span><span class="p">{</span>
<span class="ln"> 4100</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ideal_runtime</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">;</span>
<span class="ln"> 4101</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 4102</span>	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 4103</span>
<span class="ln"> 4104</span>	<span class="n">ideal_runtime</span> <span class="o">=</span> <span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln"> 4105</span>	<span class="n">delta_exec</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 4106</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta_exec</span> <span class="o">&gt;</span> <span class="n">ideal_runtime</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4107</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln"> 4108</span>		<span class="cm">/*
</span><span class="ln"> 4109</span><span class="cm">		 * The current task ran long enough, ensure it doesn&#39;t get
</span><span class="ln"> 4110</span><span class="cm">		 * re-elected due to buddy favours.
</span><span class="ln"> 4111</span><span class="cm">		 */</span>
<span class="ln"> 4112</span>		<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln"> 4113</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4114</span>	<span class="p">}</span>
<span class="ln"> 4115</span>
<span class="ln"> 4116</span>	<span class="cm">/*
</span><span class="ln"> 4117</span><span class="cm">	 * Ensure that a task that missed wakeup preemption by a
</span><span class="ln"> 4118</span><span class="cm">	 * narrow margin doesn&#39;t have to wait for a full slice.
</span><span class="ln"> 4119</span><span class="cm">	 * This also mitigates buddy induced latencies under load.
</span><span class="ln"> 4120</span><span class="cm">	 */</span>
<span class="ln"> 4121</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta_exec</span> <span class="o">&lt;</span> <span class="n">sysctl_sched_min_granularity</span><span class="p">)</span>
<span class="ln"> 4122</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4123</span>
<span class="ln"> 4124</span>	<span class="n">se</span> <span class="o">=</span> <span class="n">__pick_first_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4125</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
<span class="ln"> 4126</span>
<span class="ln"> 4127</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 4128</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4129</span>
<span class="ln"> 4130</span>	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">ideal_runtime</span><span class="p">)</span>
<span class="ln"> 4131</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln"> 4132</span><span class="p">}</span>
<span class="ln"> 4133</span>
<span class="ln"> 4134</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 4135</span><span class="nf">set_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 4136</span><span class="p">{</span>
<span class="ln"> 4137</span>	<span class="cm">/* &#39;current&#39; is not kept within the tree. */</span>
<span class="ln"> 4138</span>	<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4139</span>		<span class="cm">/*
</span><span class="ln"> 4140</span><span class="cm">		 * Any task has to be enqueued before it get to execute on
</span><span class="ln"> 4141</span><span class="cm">		 * a CPU. So account for the time it spent waiting on the
</span><span class="ln"> 4142</span><span class="cm">		 * runqueue.
</span><span class="ln"> 4143</span><span class="cm">		 */</span>
<span class="ln"> 4144</span>		<span class="n">update_stats_wait_end</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4145</span>		<span class="n">__dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4146</span>		<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln"> 4147</span>	<span class="p">}</span>
<span class="ln"> 4148</span>
<span class="ln"> 4149</span>	<span class="n">update_stats_curr_start</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4150</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="ln"> 4151</span>
<span class="ln"> 4152</span>	<span class="cm">/*
</span><span class="ln"> 4153</span><span class="cm">	 * Track our maximum slice length, if the CPU&#39;s load is at
</span><span class="ln"> 4154</span><span class="cm">	 * least twice that of our own weight (i.e. dont track it
</span><span class="ln"> 4155</span><span class="cm">	 * when there are only lesser-weight tasks around):
</span><span class="ln"> 4156</span><span class="cm">	 */</span>
<span class="ln"> 4157</span>	<span class="k">if</span> <span class="p">(</span><span class="n">schedstat_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4158</span>		<span class="n">schedstat_set</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">slice_max</span><span class="p">,</span>
<span class="ln"> 4159</span>			<span class="n">max</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">schedstat_val</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">statistics</span><span class="p">.</span><span class="n">slice_max</span><span class="p">),</span>
<span class="ln"> 4160</span>			    <span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span><span class="p">));</span>
<span class="ln"> 4161</span>	<span class="p">}</span>
<span class="ln"> 4162</span>
<span class="ln"> 4163</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 4164</span><span class="p">}</span>
<span class="ln"> 4165</span>
<span class="ln"> 4166</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln"> 4167</span><span class="nf">wakeup_preempt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4168</span>
<span class="ln"> 4169</span><span class="cm">/*
</span><span class="ln"> 4170</span><span class="cm"> * Pick the next process, keeping these things in mind, in this order:
</span><span class="ln"> 4171</span><span class="cm"> * 1) keep things fair between processes/task groups
</span><span class="ln"> 4172</span><span class="cm"> * 2) pick the &#34;next&#34; process, since someone really wants that to run
</span><span class="ln"> 4173</span><span class="cm"> * 3) pick the &#34;last&#34; process, for cache locality
</span><span class="ln"> 4174</span><span class="cm"> * 4) do not run the &#34;skip&#34; process, if something else is available
</span><span class="ln"> 4175</span><span class="cm"> */</span>
<span class="ln"> 4176</span><span class="k">static</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span>
<span class="ln"> 4177</span><span class="nf">pick_next_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 4178</span><span class="p">{</span>
<span class="ln"> 4179</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">__pick_first_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4180</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 4181</span>
<span class="ln"> 4182</span>	<span class="cm">/*
</span><span class="ln"> 4183</span><span class="cm">	 * If curr is set we have to see if its left of the leftmost entity
</span><span class="ln"> 4184</span><span class="cm">	 * still in the tree, provided there was anything in the tree at all.
</span><span class="ln"> 4185</span><span class="cm">	 */</span>
<span class="ln"> 4186</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span> <span class="o">||</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">entity_before</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">left</span><span class="p">)))</span>
<span class="ln"> 4187</span>		<span class="n">left</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
<span class="ln"> 4188</span>
<span class="ln"> 4189</span>	<span class="n">se</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="cm">/* ideally we run the leftmost entity */</span>
<span class="ln"> 4190</span>
<span class="ln"> 4191</span>	<span class="cm">/*
</span><span class="ln"> 4192</span><span class="cm">	 * Avoid running the skip buddy, if running something else can
</span><span class="ln"> 4193</span><span class="cm">	 * be done without getting too unfair.
</span><span class="ln"> 4194</span><span class="cm">	 */</span>
<span class="ln"> 4195</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">==</span> <span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4196</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">second</span><span class="p">;</span>
<span class="ln"> 4197</span>
<span class="ln"> 4198</span>		<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">==</span> <span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4199</span>			<span class="n">second</span> <span class="o">=</span> <span class="n">__pick_first_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4200</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 4201</span>			<span class="n">second</span> <span class="o">=</span> <span class="n">__pick_next_entity</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4202</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">second</span> <span class="o">||</span> <span class="p">(</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">entity_before</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">second</span><span class="p">)))</span>
<span class="ln"> 4203</span>				<span class="n">second</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
<span class="ln"> 4204</span>		<span class="p">}</span>
<span class="ln"> 4205</span>
<span class="ln"> 4206</span>		<span class="k">if</span> <span class="p">(</span><span class="n">second</span> <span class="o">&amp;&amp;</span> <span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 4207</span>			<span class="n">se</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
<span class="ln"> 4208</span>	<span class="p">}</span>
<span class="ln"> 4209</span>
<span class="ln"> 4210</span>	<span class="cm">/*
</span><span class="ln"> 4211</span><span class="cm">	 * Prefer last buddy, try to return the CPU to a preempted task.
</span><span class="ln"> 4212</span><span class="cm">	 */</span>
<span class="ln"> 4213</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 4214</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
<span class="ln"> 4215</span>
<span class="ln"> 4216</span>	<span class="cm">/*
</span><span class="ln"> 4217</span><span class="cm">	 * Someone really wants this to run. If it&#39;s not unfair, run it.
</span><span class="ln"> 4218</span><span class="cm">	 */</span>
<span class="ln"> 4219</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 4220</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="ln"> 4221</span>
<span class="ln"> 4222</span>	<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 4223</span>
<span class="ln"> 4224</span>	<span class="k">return</span> <span class="n">se</span><span class="p">;</span>
<span class="ln"> 4225</span><span class="p">}</span>
<span class="ln"> 4226</span>
<span class="ln"> 4227</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">check_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4228</span>
<span class="ln"> 4229</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln"> 4230</span><span class="p">{</span>
<span class="ln"> 4231</span>	<span class="cm">/*
</span><span class="ln"> 4232</span><span class="cm">	 * If still on the runqueue then deactivate_task()
</span><span class="ln"> 4233</span><span class="cm">	 * was not called and update_curr() has to be done:
</span><span class="ln"> 4234</span><span class="cm">	 */</span>
<span class="ln"> 4235</span>	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln"> 4236</span>		<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4237</span>
<span class="ln"> 4238</span>	<span class="cm">/* throttle cfs_rqs exceeding runtime */</span>
<span class="ln"> 4239</span>	<span class="n">check_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4240</span>
<span class="ln"> 4241</span>	<span class="n">check_spread</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="ln"> 4242</span>
<span class="ln"> 4243</span>	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4244</span>		<span class="n">update_stats_wait_start</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="ln"> 4245</span>		<span class="cm">/* Put &#39;current&#39; back into the tree. */</span>
<span class="ln"> 4246</span>		<span class="n">__enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="ln"> 4247</span>		<span class="cm">/* in !on_rq case, update occurred at dequeue */</span>
<span class="ln"> 4248</span>		<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 4249</span>	<span class="p">}</span>
<span class="ln"> 4250</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 4251</span><span class="p">}</span>
<span class="ln"> 4252</span>
<span class="ln"> 4253</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 4254</span><span class="nf">entity_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="ln"> 4255</span><span class="p">{</span>
<span class="ln"> 4256</span>	<span class="cm">/*
</span><span class="ln"> 4257</span><span class="cm">	 * Update run-time statistics of the &#39;current&#39;.
</span><span class="ln"> 4258</span><span class="cm">	 */</span>
<span class="ln"> 4259</span>	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4260</span>
<span class="ln"> 4261</span>	<span class="cm">/*
</span><span class="ln"> 4262</span><span class="cm">	 * Ensure that runnable average is periodically updated.
</span><span class="ln"> 4263</span><span class="cm">	 */</span>
<span class="ln"> 4264</span>	<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln"> 4265</span>	<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 4266</span>
<span class="ln"> 4267</span><span class="cp">#ifdef CONFIG_SCHED_HRTICK
</span><span class="ln"> 4268</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln"> 4269</span><span class="cm">	 * queued ticks are scheduled to match the slice, so don&#39;t bother
</span><span class="ln"> 4270</span><span class="cm">	 * validating it and just reschedule.
</span><span class="ln"> 4271</span><span class="cm">	 */</span>
<span class="ln"> 4272</span>	<span class="k">if</span> <span class="p">(</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4273</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln"> 4274</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4275</span>	<span class="p">}</span>
<span class="ln"> 4276</span>	<span class="cm">/*
</span><span class="ln"> 4277</span><span class="cm">	 * don&#39;t let the period tick interfere with the hrtick preemption
</span><span class="ln"> 4278</span><span class="cm">	 */</span>
<span class="ln"> 4279</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">DOUBLE_TICK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 4280</span>			<span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hrtick_timer</span><span class="p">))</span>
<span class="ln"> 4281</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4282</span><span class="cp">#endif
</span><span class="ln"> 4283</span><span class="cp"></span>
<span class="ln"> 4284</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 4285</span>		<span class="n">check_preempt_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln"> 4286</span><span class="p">}</span>
<span class="ln"> 4287</span>
<span class="ln"> 4288</span>
<span class="ln"> 4289</span><span class="cm">/**************************************************
</span><span class="ln"> 4290</span><span class="cm"> * CFS bandwidth control machinery
</span><span class="ln"> 4291</span><span class="cm"> */</span>
<span class="ln"> 4292</span>
<span class="ln"> 4293</span><span class="cp">#ifdef CONFIG_CFS_BANDWIDTH
</span><span class="ln"> 4294</span><span class="cp"></span>
<span class="ln"> 4295</span><span class="cp">#ifdef CONFIG_JUMP_LABEL
</span><span class="ln"> 4296</span><span class="cp"></span><span class="k">static</span> <span class="k">struct</span> <span class="n">static_key</span> <span class="n">__cfs_bandwidth_used</span><span class="p">;</span>
<span class="ln"> 4297</span>
<span class="ln"> 4298</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">cfs_bandwidth_used</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 4299</span><span class="p">{</span>
<span class="ln"> 4300</span>	<span class="k">return</span> <span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfs_bandwidth_used</span><span class="p">);</span>
<span class="ln"> 4301</span><span class="p">}</span>
<span class="ln"> 4302</span>
<span class="ln"> 4303</span><span class="kt">void</span> <span class="nf">cfs_bandwidth_usage_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 4304</span><span class="p">{</span>
<span class="ln"> 4305</span>	<span class="n">static_key_slow_inc_cpuslocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfs_bandwidth_used</span><span class="p">);</span>
<span class="ln"> 4306</span><span class="p">}</span>
<span class="ln"> 4307</span>
<span class="ln"> 4308</span><span class="kt">void</span> <span class="nf">cfs_bandwidth_usage_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 4309</span><span class="p">{</span>
<span class="ln"> 4310</span>	<span class="n">static_key_slow_dec_cpuslocked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__cfs_bandwidth_used</span><span class="p">);</span>
<span class="ln"> 4311</span><span class="p">}</span>
<span class="ln"> 4312</span><span class="cp">#else </span><span class="cm">/* CONFIG_JUMP_LABEL */</span><span class="cp">
</span><span class="ln"> 4313</span><span class="cp"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">cfs_bandwidth_used</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 4314</span><span class="p">{</span>
<span class="ln"> 4315</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 4316</span><span class="p">}</span>
<span class="ln"> 4317</span>
<span class="ln"> 4318</span><span class="kt">void</span> <span class="nf">cfs_bandwidth_usage_inc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 4319</span><span class="kt">void</span> <span class="nf">cfs_bandwidth_usage_dec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 4320</span><span class="cp">#endif </span><span class="cm">/* CONFIG_JUMP_LABEL */</span><span class="cp">
</span><span class="ln"> 4321</span><span class="cp"></span>
<span class="ln"> 4322</span><span class="cm">/*
</span><span class="ln"> 4323</span><span class="cm"> * default period for cfs group bandwidth.
</span><span class="ln"> 4324</span><span class="cm"> * default: 0.1s, units: nanoseconds
</span><span class="ln"> 4325</span><span class="cm"> */</span>
<span class="ln"> 4326</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">default_cfs_period</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 4327</span><span class="p">{</span>
<span class="ln"> 4328</span>	<span class="k">return</span> <span class="mi">100000000ULL</span><span class="p">;</span>
<span class="ln"> 4329</span><span class="p">}</span>
<span class="ln"> 4330</span>
<span class="ln"> 4331</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">sched_cfs_bandwidth_slice</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 4332</span><span class="p">{</span>
<span class="ln"> 4333</span>	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">sysctl_sched_cfs_bandwidth_slice</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
<span class="ln"> 4334</span><span class="p">}</span>
<span class="ln"> 4335</span>
<span class="ln"> 4336</span><span class="cm">/*
</span><span class="ln"> 4337</span><span class="cm"> * Replenish runtime according to assigned quota. We use sched_clock_cpu
</span><span class="ln"> 4338</span><span class="cm"> * directly instead of rq-&gt;clock to avoid adding additional synchronization
</span><span class="ln"> 4339</span><span class="cm"> * around rq-&gt;lock.
</span><span class="ln"> 4340</span><span class="cm"> *
</span><span class="ln"> 4341</span><span class="cm"> * requires cfs_b-&gt;lock
</span><span class="ln"> 4342</span><span class="cm"> */</span>
<span class="ln"> 4343</span><span class="kt">void</span> <span class="nf">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="ln"> 4344</span><span class="p">{</span>
<span class="ln"> 4345</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
<span class="ln"> 4346</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">;</span>
<span class="ln"> 4347</span><span class="p">}</span>
<span class="ln"> 4348</span>
<span class="ln"> 4349</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="nf">tg_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln"> 4350</span><span class="p">{</span>
<span class="ln"> 4351</span>	<span class="k">return</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln"> 4352</span><span class="p">}</span>
<span class="ln"> 4353</span>
<span class="ln"> 4354</span><span class="cm">/* rq-&gt;task_clock normalized against any time this cfs_rq has spent throttled */</span>
<span class="ln"> 4355</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cfs_rq_clock_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4356</span><span class="p">{</span>
<span class="ln"> 4357</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">))</span>
<span class="ln"> 4358</span>		<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task_time</span><span class="p">;</span>
<span class="ln"> 4359</span>
<span class="ln"> 4360</span>	<span class="k">return</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task_time</span><span class="p">;</span>
<span class="ln"> 4361</span><span class="p">}</span>
<span class="ln"> 4362</span>
<span class="ln"> 4363</span><span class="cm">/* returns 0 on failure to allocate runtime */</span>
<span class="ln"> 4364</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">assign_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4365</span><span class="p">{</span>
<span class="ln"> 4366</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">;</span>
<span class="ln"> 4367</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">);</span>
<span class="ln"> 4368</span>	<span class="n">u64</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_amount</span><span class="p">;</span>
<span class="ln"> 4369</span>
<span class="ln"> 4370</span>	<span class="cm">/* note: this is a positive sum as runtime_remaining &lt;= 0 */</span>
<span class="ln"> 4371</span>	<span class="n">min_amount</span> <span class="o">=</span> <span class="n">sched_cfs_bandwidth_slice</span><span class="p">()</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span><span class="p">;</span>
<span class="ln"> 4372</span>
<span class="ln"> 4373</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4374</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
<span class="ln"> 4375</span>		<span class="n">amount</span> <span class="o">=</span> <span class="n">min_amount</span><span class="p">;</span>
<span class="ln"> 4376</span>	<span class="k">else</span> <span class="p">{</span>
<span class="ln"> 4377</span>		<span class="n">start_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln"> 4378</span>
<span class="ln"> 4379</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4380</span>			<span class="n">amount</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">min_amount</span><span class="p">);</span>
<span class="ln"> 4381</span>			<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
<span class="ln"> 4382</span>			<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4383</span>		<span class="p">}</span>
<span class="ln"> 4384</span>	<span class="p">}</span>
<span class="ln"> 4385</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4386</span>
<span class="ln"> 4387</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
<span class="ln"> 4388</span>
<span class="ln"> 4389</span>	<span class="k">return</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4390</span><span class="p">}</span>
<span class="ln"> 4391</span>
<span class="ln"> 4392</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delta_exec</span><span class="p">)</span>
<span class="ln"> 4393</span><span class="p">{</span>
<span class="ln"> 4394</span>	<span class="cm">/* dock delta_exec before expiring quota (as it could span periods) */</span>
<span class="ln"> 4395</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">-=</span> <span class="n">delta_exec</span><span class="p">;</span>
<span class="ln"> 4396</span>
<span class="ln"> 4397</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
<span class="ln"> 4398</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4399</span>
<span class="ln"> 4400</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span><span class="p">)</span>
<span class="ln"> 4401</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4402</span>	<span class="cm">/*
</span><span class="ln"> 4403</span><span class="cm">	 * if we&#39;re unable to extend our runtime we resched so that the active
</span><span class="ln"> 4404</span><span class="cm">	 * hierarchy can be throttled
</span><span class="ln"> 4405</span><span class="cm">	 */</span>
<span class="ln"> 4406</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">assign_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">))</span>
<span class="ln"> 4407</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln"> 4408</span><span class="p">}</span>
<span class="ln"> 4409</span>
<span class="ln"> 4410</span><span class="k">static</span> <span class="n">__always_inline</span>
<span class="ln"> 4411</span><span class="kt">void</span> <span class="nf">account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delta_exec</span><span class="p">)</span>
<span class="ln"> 4412</span><span class="p">{</span>
<span class="ln"> 4413</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span><span class="p">)</span>
<span class="ln"> 4414</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4415</span>
<span class="ln"> 4416</span>	<span class="n">__account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">delta_exec</span><span class="p">);</span>
<span class="ln"> 4417</span><span class="p">}</span>
<span class="ln"> 4418</span>
<span class="ln"> 4419</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfs_rq_throttled</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4420</span><span class="p">{</span>
<span class="ln"> 4421</span>	<span class="k">return</span> <span class="n">cfs_bandwidth_used</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span><span class="p">;</span>
<span class="ln"> 4422</span><span class="p">}</span>
<span class="ln"> 4423</span>
<span class="ln"> 4424</span><span class="cm">/* check whether cfs_rq, or any parent, is throttled */</span>
<span class="ln"> 4425</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4426</span><span class="p">{</span>
<span class="ln"> 4427</span>	<span class="k">return</span> <span class="n">cfs_bandwidth_used</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">;</span>
<span class="ln"> 4428</span><span class="p">}</span>
<span class="ln"> 4429</span>
<span class="ln"> 4430</span><span class="cm">/*
</span><span class="ln"> 4431</span><span class="cm"> * Ensure that neither of the group entities corresponding to src_cpu or
</span><span class="ln"> 4432</span><span class="cm"> * dest_cpu are members of a throttled hierarchy when performing group
</span><span class="ln"> 4433</span><span class="cm"> * load-balance operations.
</span><span class="ln"> 4434</span><span class="cm"> */</span>
<span class="ln"> 4435</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_lb_pair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
<span class="ln"> 4436</span>				    <span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">)</span>
<span class="ln"> 4437</span><span class="p">{</span>
<span class="ln"> 4438</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">src_cfs_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">dest_cfs_rq</span><span class="p">;</span>
<span class="ln"> 4439</span>
<span class="ln"> 4440</span>	<span class="n">src_cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">src_cpu</span><span class="p">];</span>
<span class="ln"> 4441</span>	<span class="n">dest_cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">dest_cpu</span><span class="p">];</span>
<span class="ln"> 4442</span>
<span class="ln"> 4443</span>	<span class="k">return</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">src_cfs_rq</span><span class="p">)</span> <span class="o">||</span>
<span class="ln"> 4444</span>	       <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">dest_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4445</span><span class="p">}</span>
<span class="ln"> 4446</span>
<span class="ln"> 4447</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_unthrottle_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln"> 4448</span><span class="p">{</span>
<span class="ln"> 4449</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="ln"> 4450</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>
<span class="ln"> 4451</span>
<span class="ln"> 4452</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 4453</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4454</span>		<span class="cm">/* adjust cfs_rq_clock_task() */</span>
<span class="ln"> 4455</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task_time</span> <span class="o">+=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span>
<span class="ln"> 4456</span>					     <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task</span><span class="p">;</span>
<span class="ln"> 4457</span>
<span class="ln"> 4458</span>		<span class="cm">/* Add cfs_rq with already running entity in the list */</span>
<span class="ln"> 4459</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 4460</span>			<span class="n">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4461</span>	<span class="p">}</span>
<span class="ln"> 4462</span>
<span class="ln"> 4463</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4464</span><span class="p">}</span>
<span class="ln"> 4465</span>
<span class="ln"> 4466</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">tg_throttle_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln"> 4467</span><span class="p">{</span>
<span class="ln"> 4468</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="ln"> 4469</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>
<span class="ln"> 4470</span>
<span class="ln"> 4471</span>	<span class="cm">/* group is entering throttled state, stop time */</span>
<span class="ln"> 4472</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4473</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4474</span>		<span class="n">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4475</span>	<span class="p">}</span>
<span class="ln"> 4476</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 4477</span>
<span class="ln"> 4478</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4479</span><span class="p">}</span>
<span class="ln"> 4480</span>
<span class="ln"> 4481</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">throttle_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4482</span><span class="p">{</span>
<span class="ln"> 4483</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4484</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
<span class="ln"> 4485</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 4486</span>	<span class="kt">long</span> <span class="n">task_delta</span><span class="p">,</span> <span class="n">dequeue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4487</span>	<span class="kt">bool</span> <span class="n">empty</span><span class="p">;</span>
<span class="ln"> 4488</span>
<span class="ln"> 4489</span>	<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))];</span>
<span class="ln"> 4490</span>
<span class="ln"> 4491</span>	<span class="cm">/* freeze hierarchy runnable averages while throttled */</span>
<span class="ln"> 4492</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 4493</span>	<span class="n">walk_tg_tree_from</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">,</span> <span class="n">tg_throttle_down</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4494</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 4495</span>
<span class="ln"> 4496</span>	<span class="n">task_delta</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="p">;</span>
<span class="ln"> 4497</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4498</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">qcfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4499</span>		<span class="cm">/* throttled entity or throttle-on-deactivate */</span>
<span class="ln"> 4500</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln"> 4501</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4502</span>
<span class="ln"> 4503</span>		<span class="k">if</span> <span class="p">(</span><span class="n">dequeue</span><span class="p">)</span>
<span class="ln"> 4504</span>			<span class="n">dequeue_entity</span><span class="p">(</span><span class="n">qcfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">);</span>
<span class="ln"> 4505</span>		<span class="n">qcfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span> <span class="o">-=</span> <span class="n">task_delta</span><span class="p">;</span>
<span class="ln"> 4506</span>
<span class="ln"> 4507</span>		<span class="k">if</span> <span class="p">(</span><span class="n">qcfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
<span class="ln"> 4508</span>			<span class="n">dequeue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4509</span>	<span class="p">}</span>
<span class="ln"> 4510</span>
<span class="ln"> 4511</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 4512</span>		<span class="n">sub_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">task_delta</span><span class="p">);</span>
<span class="ln"> 4513</span>
<span class="ln"> 4514</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4515</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4516</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4517</span>	<span class="n">empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4518</span>
<span class="ln"> 4519</span>	<span class="cm">/*
</span><span class="ln"> 4520</span><span class="cm">	 * Add to the _head_ of the list, so that an already-started
</span><span class="ln"> 4521</span><span class="cm">	 * distribute_cfs_runtime will not see us. If disribute_cfs_runtime is
</span><span class="ln"> 4522</span><span class="cm">	 * not running add to the tail so that later runqueues don&#39;t get starved.
</span><span class="ln"> 4523</span><span class="cm">	 */</span>
<span class="ln"> 4524</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span><span class="p">)</span>
<span class="ln"> 4525</span>		<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4526</span>	<span class="k">else</span>
<span class="ln"> 4527</span>		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4528</span>
<span class="ln"> 4529</span>	<span class="cm">/*
</span><span class="ln"> 4530</span><span class="cm">	 * If we&#39;re the first throttled task, make sure the bandwidth
</span><span class="ln"> 4531</span><span class="cm">	 * timer is running.
</span><span class="ln"> 4532</span><span class="cm">	 */</span>
<span class="ln"> 4533</span>	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
<span class="ln"> 4534</span>		<span class="n">start_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln"> 4535</span>
<span class="ln"> 4536</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4537</span><span class="p">}</span>
<span class="ln"> 4538</span>
<span class="ln"> 4539</span><span class="kt">void</span> <span class="nf">unthrottle_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4540</span><span class="p">{</span>
<span class="ln"> 4541</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4542</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
<span class="ln"> 4543</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 4544</span>	<span class="kt">int</span> <span class="n">enqueue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4545</span>	<span class="kt">long</span> <span class="n">task_delta</span><span class="p">;</span>
<span class="ln"> 4546</span>
<span class="ln"> 4547</span>	<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>
<span class="ln"> 4548</span>
<span class="ln"> 4549</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4550</span>
<span class="ln"> 4551</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4552</span>
<span class="ln"> 4553</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4554</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_time</span> <span class="o">+=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">-</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock</span><span class="p">;</span>
<span class="ln"> 4555</span>	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">);</span>
<span class="ln"> 4556</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4557</span>
<span class="ln"> 4558</span>	<span class="cm">/* update hierarchical throttle state */</span>
<span class="ln"> 4559</span>	<span class="n">walk_tg_tree_from</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">,</span> <span class="n">tg_nop</span><span class="p">,</span> <span class="n">tg_unthrottle_up</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4560</span>
<span class="ln"> 4561</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
<span class="ln"> 4562</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4563</span>
<span class="ln"> 4564</span>	<span class="n">task_delta</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="p">;</span>
<span class="ln"> 4565</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4566</span>		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln"> 4567</span>			<span class="n">enqueue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4568</span>
<span class="ln"> 4569</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 4570</span>		<span class="k">if</span> <span class="p">(</span><span class="n">enqueue</span><span class="p">)</span>
<span class="ln"> 4571</span>			<span class="n">enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">);</span>
<span class="ln"> 4572</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span> <span class="o">+=</span> <span class="n">task_delta</span><span class="p">;</span>
<span class="ln"> 4573</span>
<span class="ln"> 4574</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 4575</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4576</span>	<span class="p">}</span>
<span class="ln"> 4577</span>
<span class="ln"> 4578</span>	<span class="n">assert_list_leaf_cfs_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4579</span>
<span class="ln"> 4580</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 4581</span>		<span class="n">add_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">task_delta</span><span class="p">);</span>
<span class="ln"> 4582</span>
<span class="ln"> 4583</span>	<span class="cm">/* Determine whether we need to wake up potentially idle CPU: */</span>
<span class="ln"> 4584</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">&amp;&amp;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">nr_running</span><span class="p">)</span>
<span class="ln"> 4585</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 4586</span><span class="p">}</span>
<span class="ln"> 4587</span>
<span class="ln"> 4588</span><span class="k">static</span> <span class="n">u64</span> <span class="nf">distribute_cfs_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">u64</span> <span class="n">remaining</span><span class="p">)</span>
<span class="ln"> 4589</span><span class="p">{</span>
<span class="ln"> 4590</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 4591</span>	<span class="n">u64</span> <span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 4592</span>	<span class="n">u64</span> <span class="n">starting_runtime</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
<span class="ln"> 4593</span>
<span class="ln"> 4594</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 4595</span>	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">,</span>
<span class="ln"> 4596</span>				<span class="n">throttled_list</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4597</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4598</span>		<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 4599</span>
<span class="ln"> 4600</span>		<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 4601</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 4602</span>			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
<span class="ln"> 4603</span>
<span class="ln"> 4604</span>		<span class="cm">/* By the above check, this should never be true */</span>
<span class="ln"> 4605</span>		<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 4606</span>
<span class="ln"> 4607</span>		<span class="n">runtime</span> <span class="o">=</span> <span class="o">-</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4608</span>		<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span>
<span class="ln"> 4609</span>			<span class="n">runtime</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
<span class="ln"> 4610</span>		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 4611</span>
<span class="ln"> 4612</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">+=</span> <span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 4613</span>
<span class="ln"> 4614</span>		<span class="cm">/* we check whether we&#39;re throttled above */</span>
<span class="ln"> 4615</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 4616</span>			<span class="n">unthrottle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4617</span>
<span class="ln"> 4618</span><span class="nl">next</span><span class="p">:</span>
<span class="ln"> 4619</span>		<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 4620</span>
<span class="ln"> 4621</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remaining</span><span class="p">)</span>
<span class="ln"> 4622</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4623</span>	<span class="p">}</span>
<span class="ln"> 4624</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 4625</span>
<span class="ln"> 4626</span>	<span class="k">return</span> <span class="n">starting_runtime</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">;</span>
<span class="ln"> 4627</span><span class="p">}</span>
<span class="ln"> 4628</span>
<span class="ln"> 4629</span><span class="cm">/*
</span><span class="ln"> 4630</span><span class="cm"> * Responsible for refilling a task_group&#39;s bandwidth and unthrottling its
</span><span class="ln"> 4631</span><span class="cm"> * cfs_rqs as appropriate. If there has been no activity within the last
</span><span class="ln"> 4632</span><span class="cm"> * period the timer is deactivated until scheduling resumes; cfs_b-&gt;idle is
</span><span class="ln"> 4633</span><span class="cm"> * used to track this state.
</span><span class="ln"> 4634</span><span class="cm"> */</span>
<span class="ln"> 4635</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_sched_cfs_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">overrun</span><span class="p">)</span>
<span class="ln"> 4636</span><span class="p">{</span>
<span class="ln"> 4637</span>	<span class="n">u64</span> <span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 4638</span>	<span class="kt">int</span> <span class="n">throttled</span><span class="p">;</span>
<span class="ln"> 4639</span>
<span class="ln"> 4640</span>	<span class="cm">/* no need to continue the timer with no bandwidth constraint */</span>
<span class="ln"> 4641</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">==</span> <span class="n">RUNTIME_INF</span><span class="p">)</span>
<span class="ln"> 4642</span>		<span class="k">goto</span> <span class="n">out_deactivate</span><span class="p">;</span>
<span class="ln"> 4643</span>
<span class="ln"> 4644</span>	<span class="n">throttled</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4645</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_periods</span> <span class="o">+=</span> <span class="n">overrun</span><span class="p">;</span>
<span class="ln"> 4646</span>
<span class="ln"> 4647</span>	<span class="cm">/*
</span><span class="ln"> 4648</span><span class="cm">	 * idle depends on !throttled (for the case of a large deficit), and if
</span><span class="ln"> 4649</span><span class="cm">	 * we&#39;re going inactive then everything else can be deferred
</span><span class="ln"> 4650</span><span class="cm">	 */</span>
<span class="ln"> 4651</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">throttled</span><span class="p">)</span>
<span class="ln"> 4652</span>		<span class="k">goto</span> <span class="n">out_deactivate</span><span class="p">;</span>
<span class="ln"> 4653</span>
<span class="ln"> 4654</span>	<span class="n">__refill_cfs_bandwidth_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln"> 4655</span>
<span class="ln"> 4656</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">throttled</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4657</span>		<span class="cm">/* mark as potentially idle for the upcoming period */</span>
<span class="ln"> 4658</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4659</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4660</span>	<span class="p">}</span>
<span class="ln"> 4661</span>
<span class="ln"> 4662</span>	<span class="cm">/* account preceding periods in which throttling occurred */</span>
<span class="ln"> 4663</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">nr_throttled</span> <span class="o">+=</span> <span class="n">overrun</span><span class="p">;</span>
<span class="ln"> 4664</span>
<span class="ln"> 4665</span>	<span class="cm">/*
</span><span class="ln"> 4666</span><span class="cm">	 * This check is repeated as we are holding onto the new bandwidth while
</span><span class="ln"> 4667</span><span class="cm">	 * we unthrottle. This can potentially race with an unthrottled group
</span><span class="ln"> 4668</span><span class="cm">	 * trying to acquire new bandwidth from the global pool. This can result
</span><span class="ln"> 4669</span><span class="cm">	 * in us over-using our runtime if it is all used during this loop, but
</span><span class="ln"> 4670</span><span class="cm">	 * only by limited amounts in that extreme case.
</span><span class="ln"> 4671</span><span class="cm">	 */</span>
<span class="ln"> 4672</span>	<span class="k">while</span> <span class="p">(</span><span class="n">throttled</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4673</span>		<span class="n">runtime</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 4674</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4675</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4676</span>		<span class="cm">/* we can&#39;t nest cfs_b-&gt;lock while distributing bandwidth */</span>
<span class="ln"> 4677</span>		<span class="n">runtime</span> <span class="o">=</span> <span class="n">distribute_cfs_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">runtime</span><span class="p">);</span>
<span class="ln"> 4678</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4679</span>
<span class="ln"> 4680</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4681</span>		<span class="n">throttled</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4682</span>
<span class="ln"> 4683</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">);</span>
<span class="ln"> 4684</span>	<span class="p">}</span>
<span class="ln"> 4685</span>
<span class="ln"> 4686</span>	<span class="cm">/*
</span><span class="ln"> 4687</span><span class="cm">	 * While we are ensured activity in the period following an
</span><span class="ln"> 4688</span><span class="cm">	 * unthrottle, this also covers the case in which the new bandwidth is
</span><span class="ln"> 4689</span><span class="cm">	 * insufficient to cover the existing bandwidth deficit.  (Forcing the
</span><span class="ln"> 4690</span><span class="cm">	 * timer to remain active while there are any throttled entities.)
</span><span class="ln"> 4691</span><span class="cm">	 */</span>
<span class="ln"> 4692</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4693</span>
<span class="ln"> 4694</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4695</span>
<span class="ln"> 4696</span><span class="nl">out_deactivate</span><span class="p">:</span>
<span class="ln"> 4697</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4698</span><span class="p">}</span>
<span class="ln"> 4699</span>
<span class="ln"> 4700</span><span class="cm">/* a cfs_rq won&#39;t donate quota below this amount */</span>
<span class="ln"> 4701</span><span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">min_cfs_rq_runtime</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="ln"> 4702</span><span class="cm">/* minimum remaining period time to redistribute slack quota */</span>
<span class="ln"> 4703</span><span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">min_bandwidth_expiration</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="ln"> 4704</span><span class="cm">/* how long we wait to gather additional slack before distributing */</span>
<span class="ln"> 4705</span><span class="k">static</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">cfs_bandwidth_slack_period</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">NSEC_PER_MSEC</span><span class="p">;</span>
<span class="ln"> 4706</span>
<span class="ln"> 4707</span><span class="cm">/*
</span><span class="ln"> 4708</span><span class="cm"> * Are we near the end of the current quota period?
</span><span class="ln"> 4709</span><span class="cm"> *
</span><span class="ln"> 4710</span><span class="cm"> * Requires cfs_b-&gt;lock for hrtimer_expires_remaining to be safe against the
</span><span class="ln"> 4711</span><span class="cm"> * hrtimer base being cleared by hrtimer_start. In the case of
</span><span class="ln"> 4712</span><span class="cm"> * migrate_hrtimers, base is never cleared, so we are fine.
</span><span class="ln"> 4713</span><span class="cm"> */</span>
<span class="ln"> 4714</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">runtime_refresh_within</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_expire</span><span class="p">)</span>
<span class="ln"> 4715</span><span class="p">{</span>
<span class="ln"> 4716</span>	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">refresh_timer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">;</span>
<span class="ln"> 4717</span>	<span class="n">u64</span> <span class="n">remaining</span><span class="p">;</span>
<span class="ln"> 4718</span>
<span class="ln"> 4719</span>	<span class="cm">/* if the call-back is running a quota refresh is already occurring */</span>
<span class="ln"> 4720</span>	<span class="k">if</span> <span class="p">(</span><span class="n">hrtimer_callback_running</span><span class="p">(</span><span class="n">refresh_timer</span><span class="p">))</span>
<span class="ln"> 4721</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4722</span>
<span class="ln"> 4723</span>	<span class="cm">/* is a quota refresh about to occur? */</span>
<span class="ln"> 4724</span>	<span class="n">remaining</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">hrtimer_expires_remaining</span><span class="p">(</span><span class="n">refresh_timer</span><span class="p">));</span>
<span class="ln"> 4725</span>	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&lt;</span> <span class="n">min_expire</span><span class="p">)</span>
<span class="ln"> 4726</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4727</span>
<span class="ln"> 4728</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4729</span><span class="p">}</span>
<span class="ln"> 4730</span>
<span class="ln"> 4731</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">start_cfs_slack_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="ln"> 4732</span><span class="p">{</span>
<span class="ln"> 4733</span>	<span class="n">u64</span> <span class="n">min_left</span> <span class="o">=</span> <span class="n">cfs_bandwidth_slack_period</span> <span class="o">+</span> <span class="n">min_bandwidth_expiration</span><span class="p">;</span>
<span class="ln"> 4734</span>
<span class="ln"> 4735</span>	<span class="cm">/* if there&#39;s a quota refresh soon don&#39;t bother with slack */</span>
<span class="ln"> 4736</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_refresh_within</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">min_left</span><span class="p">))</span>
<span class="ln"> 4737</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4738</span>
<span class="ln"> 4739</span>	<span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">,</span>
<span class="ln"> 4740</span>			<span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">cfs_bandwidth_slack_period</span><span class="p">),</span>
<span class="ln"> 4741</span>			<span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="ln"> 4742</span><span class="p">}</span>
<span class="ln"> 4743</span>
<span class="ln"> 4744</span><span class="cm">/* we know any runtime found here is valid as update_curr() precedes return */</span>
<span class="ln"> 4745</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4746</span><span class="p">{</span>
<span class="ln"> 4747</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="p">);</span>
<span class="ln"> 4748</span>	<span class="n">s64</span> <span class="n">slack_runtime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">-</span> <span class="n">min_cfs_rq_runtime</span><span class="p">;</span>
<span class="ln"> 4749</span>
<span class="ln"> 4750</span>	<span class="k">if</span> <span class="p">(</span><span class="n">slack_runtime</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 4751</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4752</span>
<span class="ln"> 4753</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4754</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4755</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">+=</span> <span class="n">slack_runtime</span><span class="p">;</span>
<span class="ln"> 4756</span>
<span class="ln"> 4757</span>		<span class="cm">/* we are under rq-&gt;lock, defer unthrottling using a timer */</span>
<span class="ln"> 4758</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">sched_cfs_bandwidth_slice</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 4759</span>		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">))</span>
<span class="ln"> 4760</span>			<span class="n">start_cfs_slack_bandwidth</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln"> 4761</span>	<span class="p">}</span>
<span class="ln"> 4762</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4763</span>
<span class="ln"> 4764</span>	<span class="cm">/* even if it&#39;s not valid for return we don&#39;t want to try again */</span>
<span class="ln"> 4765</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">-=</span> <span class="n">slack_runtime</span><span class="p">;</span>
<span class="ln"> 4766</span><span class="p">}</span>
<span class="ln"> 4767</span>
<span class="ln"> 4768</span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4769</span><span class="p">{</span>
<span class="ln"> 4770</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
<span class="ln"> 4771</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4772</span>
<span class="ln"> 4773</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
<span class="ln"> 4774</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4775</span>
<span class="ln"> 4776</span>	<span class="n">__return_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4777</span><span class="p">}</span>
<span class="ln"> 4778</span>
<span class="ln"> 4779</span><span class="cm">/*
</span><span class="ln"> 4780</span><span class="cm"> * This is done with a timer (instead of inline with bandwidth return) since
</span><span class="ln"> 4781</span><span class="cm"> * it&#39;s necessary to juggle rq-&gt;locks to unthrottle their respective cfs_rqs.
</span><span class="ln"> 4782</span><span class="cm"> */</span>
<span class="ln"> 4783</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">do_sched_cfs_slack_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="ln"> 4784</span><span class="p">{</span>
<span class="ln"> 4785</span>	<span class="n">u64</span> <span class="n">runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">sched_cfs_bandwidth_slice</span><span class="p">();</span>
<span class="ln"> 4786</span>
<span class="ln"> 4787</span>	<span class="cm">/* confirm we&#39;re still not at a refresh boundary */</span>
<span class="ln"> 4788</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4789</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4790</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4791</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4792</span>	<span class="p">}</span>
<span class="ln"> 4793</span>
<span class="ln"> 4794</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime_refresh_within</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">min_bandwidth_expiration</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 4795</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4796</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4797</span>	<span class="p">}</span>
<span class="ln"> 4798</span>
<span class="ln"> 4799</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span> <span class="o">&amp;&amp;</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">&gt;</span> <span class="n">slice</span><span class="p">)</span>
<span class="ln"> 4800</span>		<span class="n">runtime</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">;</span>
<span class="ln"> 4801</span>
<span class="ln"> 4802</span>	<span class="k">if</span> <span class="p">(</span><span class="n">runtime</span><span class="p">)</span>
<span class="ln"> 4803</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4804</span>
<span class="ln"> 4805</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4806</span>
<span class="ln"> 4807</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">runtime</span><span class="p">)</span>
<span class="ln"> 4808</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4809</span>
<span class="ln"> 4810</span>	<span class="n">runtime</span> <span class="o">=</span> <span class="n">distribute_cfs_runtime</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">runtime</span><span class="p">);</span>
<span class="ln"> 4811</span>
<span class="ln"> 4812</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4813</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span><span class="p">);</span>
<span class="ln"> 4814</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4815</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4816</span><span class="p">}</span>
<span class="ln"> 4817</span>
<span class="ln"> 4818</span><span class="cm">/*
</span><span class="ln"> 4819</span><span class="cm"> * When a group wakes up we want to make sure that its quota is not already
</span><span class="ln"> 4820</span><span class="cm"> * expired/exceeded, otherwise it may be allowed to steal additional ticks of
</span><span class="ln"> 4821</span><span class="cm"> * runtime as update_curr() throttling can not not trigger until it&#39;s on-rq.
</span><span class="ln"> 4822</span><span class="cm"> */</span>
<span class="ln"> 4823</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">check_enqueue_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4824</span><span class="p">{</span>
<span class="ln"> 4825</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
<span class="ln"> 4826</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4827</span>
<span class="ln"> 4828</span>	<span class="cm">/* an active group must be handled by the update_curr()-&gt;put() path */</span>
<span class="ln"> 4829</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">)</span>
<span class="ln"> 4830</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4831</span>
<span class="ln"> 4832</span>	<span class="cm">/* ensure the group is not already throttled */</span>
<span class="ln"> 4833</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 4834</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4835</span>
<span class="ln"> 4836</span>	<span class="cm">/* update runtime allocation */</span>
<span class="ln"> 4837</span>	<span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 4838</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 4839</span>		<span class="n">throttle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4840</span><span class="p">}</span>
<span class="ln"> 4841</span>
<span class="ln"> 4842</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 4843</span><span class="p">{</span>
<span class="ln"> 4844</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">pcfs_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 4845</span>
<span class="ln"> 4846</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
<span class="ln"> 4847</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4848</span>
<span class="ln"> 4849</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
<span class="ln"> 4850</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4851</span>
<span class="ln"> 4852</span>	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
<span class="ln"> 4853</span>	<span class="n">pcfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
<span class="ln"> 4854</span>
<span class="ln"> 4855</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span> <span class="o">=</span> <span class="n">pcfs_rq</span><span class="o">-&gt;</span><span class="n">throttle_count</span><span class="p">;</span>
<span class="ln"> 4856</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_clock_task</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 4857</span><span class="p">}</span>
<span class="ln"> 4858</span>
<span class="ln"> 4859</span><span class="cm">/* conditionally throttle active cfs_rq&#39;s from put_prev_entity() */</span>
<span class="ln"> 4860</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">check_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4861</span><span class="p">{</span>
<span class="ln"> 4862</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span>
<span class="ln"> 4863</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 4864</span>
<span class="ln"> 4865</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">||</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
<span class="ln"> 4866</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 4867</span>
<span class="ln"> 4868</span>	<span class="cm">/*
</span><span class="ln"> 4869</span><span class="cm">	 * it&#39;s possible for a throttled entity to be forced into a running
</span><span class="ln"> 4870</span><span class="cm">	 * state (e.g. set_curr_task), in this case we&#39;re finished.
</span><span class="ln"> 4871</span><span class="cm">	 */</span>
<span class="ln"> 4872</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 4873</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 4874</span>
<span class="ln"> 4875</span>	<span class="n">throttle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 4876</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 4877</span><span class="p">}</span>
<span class="ln"> 4878</span>
<span class="ln"> 4879</span><span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">sched_cfs_slack_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="ln"> 4880</span><span class="p">{</span>
<span class="ln"> 4881</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span>
<span class="ln"> 4882</span>		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span><span class="p">,</span> <span class="n">slack_timer</span><span class="p">);</span>
<span class="ln"> 4883</span>
<span class="ln"> 4884</span>	<span class="n">do_sched_cfs_slack_timer</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">);</span>
<span class="ln"> 4885</span>
<span class="ln"> 4886</span>	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="ln"> 4887</span><span class="p">}</span>
<span class="ln"> 4888</span>
<span class="ln"> 4889</span><span class="k">extern</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">max_cfs_quota_period</span><span class="p">;</span>
<span class="ln"> 4890</span>
<span class="ln"> 4891</span><span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">sched_cfs_period_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="ln"> 4892</span><span class="p">{</span>
<span class="ln"> 4893</span>	<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span>
<span class="ln"> 4894</span>		<span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span><span class="p">,</span> <span class="n">period_timer</span><span class="p">);</span>
<span class="ln"> 4895</span>	<span class="kt">int</span> <span class="n">overrun</span><span class="p">;</span>
<span class="ln"> 4896</span>	<span class="kt">int</span> <span class="n">idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4897</span>	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4898</span>
<span class="ln"> 4899</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4900</span>	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="ln"> 4901</span>		<span class="n">overrun</span> <span class="o">=</span> <span class="n">hrtimer_forward_now</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
<span class="ln"> 4902</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overrun</span><span class="p">)</span>
<span class="ln"> 4903</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 4904</span>
<span class="ln"> 4905</span>		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4906</span>			<span class="n">u64</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
<span class="ln"> 4907</span>
<span class="ln"> 4908</span>			<span class="cm">/*
</span><span class="ln"> 4909</span><span class="cm">			 * Grow period by a factor of 2 to avoid losing precision.
</span><span class="ln"> 4910</span><span class="cm">			 * Precision loss in the quota/period ratio can cause __cfs_schedulable
</span><span class="ln"> 4911</span><span class="cm">			 * to fail.
</span><span class="ln"> 4912</span><span class="cm">			 */</span>
<span class="ln"> 4913</span>			<span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 4914</span>			<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">&lt;</span> <span class="n">max_cfs_quota_period</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 4915</span>				<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
<span class="ln"> 4916</span>				<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 4917</span>
<span class="ln"> 4918</span>				<span class="n">pr_warn_ratelimited</span><span class="p">(</span>
<span class="ln"> 4919</span>	<span class="s">&#34;cfs_period_timer[cpu%d]: period too short, scaling up (new cfs_period_us = %lld, cfs_quota_us = %lld)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln"> 4920</span>					<span class="n">smp_processor_id</span><span class="p">(),</span>
<span class="ln"> 4921</span>					<span class="n">div_u64</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">),</span>
<span class="ln"> 4922</span>					<span class="n">div_u64</span><span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">));</span>
<span class="ln"> 4923</span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 4924</span>				<span class="n">pr_warn_ratelimited</span><span class="p">(</span>
<span class="ln"> 4925</span>	<span class="s">&#34;cfs_period_timer[cpu%d]: period too short, but cannot scale up without losing precision (cfs_period_us = %lld, cfs_quota_us = %lld)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="ln"> 4926</span>					<span class="n">smp_processor_id</span><span class="p">(),</span>
<span class="ln"> 4927</span>					<span class="n">div_u64</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">),</span>
<span class="ln"> 4928</span>					<span class="n">div_u64</span><span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span><span class="p">,</span> <span class="n">NSEC_PER_USEC</span><span class="p">));</span>
<span class="ln"> 4929</span>			<span class="p">}</span>
<span class="ln"> 4930</span>
<span class="ln"> 4931</span>			<span class="cm">/* reset count so we don&#39;t come right back in here */</span>
<span class="ln"> 4932</span>			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4933</span>		<span class="p">}</span>
<span class="ln"> 4934</span>
<span class="ln"> 4935</span>		<span class="n">idle</span> <span class="o">=</span> <span class="n">do_sched_cfs_period_timer</span><span class="p">(</span><span class="n">cfs_b</span><span class="p">,</span> <span class="n">overrun</span><span class="p">);</span>
<span class="ln"> 4936</span>	<span class="p">}</span>
<span class="ln"> 4937</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span>
<span class="ln"> 4938</span>		<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4939</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4940</span>
<span class="ln"> 4941</span>	<span class="k">return</span> <span class="n">idle</span> <span class="o">?</span> <span class="nl">HRTIMER_NORESTART</span> <span class="p">:</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
<span class="ln"> 4942</span><span class="p">}</span>
<span class="ln"> 4943</span>
<span class="ln"> 4944</span><span class="kt">void</span> <span class="nf">init_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="ln"> 4945</span><span class="p">{</span>
<span class="ln"> 4946</span>	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4947</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">runtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4948</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln"> 4949</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">ns_to_ktime</span><span class="p">(</span><span class="n">default_cfs_period</span><span class="p">());</span>
<span class="ln"> 4950</span>
<span class="ln"> 4951</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">);</span>
<span class="ln"> 4952</span>	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">);</span>
<span class="ln"> 4953</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sched_cfs_period_timer</span><span class="p">;</span>
<span class="ln"> 4954</span>	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="ln"> 4955</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sched_cfs_slack_timer</span><span class="p">;</span>
<span class="ln"> 4956</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">distribute_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4957</span><span class="p">}</span>
<span class="ln"> 4958</span>
<span class="ln"> 4959</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 4960</span><span class="p">{</span>
<span class="ln"> 4961</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4962</span>	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">throttled_list</span><span class="p">);</span>
<span class="ln"> 4963</span><span class="p">}</span>
<span class="ln"> 4964</span>
<span class="ln"> 4965</span><span class="kt">void</span> <span class="nf">start_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="ln"> 4966</span><span class="p">{</span>
<span class="ln"> 4967</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 4968</span>
<span class="ln"> 4969</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_active</span><span class="p">)</span>
<span class="ln"> 4970</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4971</span>
<span class="ln"> 4972</span>	<span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 4973</span>	<span class="n">hrtimer_forward_now</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">);</span>
<span class="ln"> 4974</span>	<span class="n">hrtimer_start_expires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS_PINNED</span><span class="p">);</span>
<span class="ln"> 4975</span><span class="p">}</span>
<span class="ln"> 4976</span>
<span class="ln"> 4977</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span>
<span class="ln"> 4978</span><span class="p">{</span>
<span class="ln"> 4979</span>	<span class="cm">/* init_cfs_bandwidth() was not called */</span>
<span class="ln"> 4980</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">throttled_cfs_rq</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
<span class="ln"> 4981</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 4982</span>
<span class="ln"> 4983</span>	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">period_timer</span><span class="p">);</span>
<span class="ln"> 4984</span>	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">slack_timer</span><span class="p">);</span>
<span class="ln"> 4985</span><span class="p">}</span>
<span class="ln"> 4986</span>
<span class="ln"> 4987</span><span class="cm">/*
</span><span class="ln"> 4988</span><span class="cm"> * Both these CPU hotplug callbacks race against unregister_fair_sched_group()
</span><span class="ln"> 4989</span><span class="cm"> *
</span><span class="ln"> 4990</span><span class="cm"> * The race is harmless, since modifying bandwidth settings of unhooked group
</span><span class="ln"> 4991</span><span class="cm"> * bits doesn&#39;t do much.
</span><span class="ln"> 4992</span><span class="cm"> */</span>
<span class="ln"> 4993</span>
<span class="ln"> 4994</span><span class="cm">/* cpu online calback */</span>
<span class="ln"> 4995</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__maybe_unused</span> <span class="nf">update_runtime_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 4996</span><span class="p">{</span>
<span class="ln"> 4997</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="ln"> 4998</span>
<span class="ln"> 4999</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 5000</span>
<span class="ln"> 5001</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 5002</span>	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5003</span>		<span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_bandwidth</span><span class="p">;</span>
<span class="ln"> 5004</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>
<span class="ln"> 5005</span>
<span class="ln"> 5006</span>		<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 5007</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">=</span> <span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">quota</span> <span class="o">!=</span> <span class="n">RUNTIME_INF</span><span class="p">;</span>
<span class="ln"> 5008</span>		<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 5009</span>	<span class="p">}</span>
<span class="ln"> 5010</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 5011</span><span class="p">}</span>
<span class="ln"> 5012</span>
<span class="ln"> 5013</span><span class="cm">/* cpu offline callback */</span>
<span class="ln"> 5014</span><span class="k">static</span> <span class="kt">void</span> <span class="n">__maybe_unused</span> <span class="nf">unthrottle_offline_cfs_rqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 5015</span><span class="p">{</span>
<span class="ln"> 5016</span>	<span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="ln"> 5017</span>
<span class="ln"> 5018</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 5019</span>
<span class="ln"> 5020</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 5021</span>	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_groups</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5022</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>
<span class="ln"> 5023</span>
<span class="ln"> 5024</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span><span class="p">)</span>
<span class="ln"> 5025</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 5026</span>
<span class="ln"> 5027</span>		<span class="cm">/*
</span><span class="ln"> 5028</span><span class="cm">		 * clock_task is not advancing so we just need to make sure
</span><span class="ln"> 5029</span><span class="cm">		 * there&#39;s some valid quota amount
</span><span class="ln"> 5030</span><span class="cm">		 */</span>
<span class="ln"> 5031</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_remaining</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5032</span>		<span class="cm">/*
</span><span class="ln"> 5033</span><span class="cm">		 * Offline rq is schedulable till CPU is completely disabled
</span><span class="ln"> 5034</span><span class="cm">		 * in take_cpu_down(), so we prevent new cfs throttling here.
</span><span class="ln"> 5035</span><span class="cm">		 */</span>
<span class="ln"> 5036</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">runtime_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5037</span>
<span class="ln"> 5038</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5039</span>			<span class="n">unthrottle_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 5040</span>	<span class="p">}</span>
<span class="ln"> 5041</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 5042</span><span class="p">}</span>
<span class="ln"> 5043</span>
<span class="ln"> 5044</span><span class="cp">#else </span><span class="cm">/* CONFIG_CFS_BANDWIDTH */</span><span class="cp">
</span><span class="ln"> 5045</span><span class="cp"></span>
<span class="ln"> 5046</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">cfs_bandwidth_used</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 5047</span><span class="p">{</span>
<span class="ln"> 5048</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 5049</span><span class="p">}</span>
<span class="ln"> 5050</span>
<span class="ln"> 5051</span><span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">cfs_rq_clock_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 5052</span><span class="p">{</span>
<span class="ln"> 5053</span>	<span class="k">return</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span>
<span class="ln"> 5054</span><span class="p">}</span>
<span class="ln"> 5055</span>
<span class="ln"> 5056</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">account_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">delta_exec</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5057</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">check_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
<span class="ln"> 5058</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">check_enqueue_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5059</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sync_throttle</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5060</span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">return_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5061</span>
<span class="ln"> 5062</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cfs_rq_throttled</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 5063</span><span class="p">{</span>
<span class="ln"> 5064</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5065</span><span class="p">}</span>
<span class="ln"> 5066</span>
<span class="ln"> 5067</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_hierarchy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 5068</span><span class="p">{</span>
<span class="ln"> 5069</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5070</span><span class="p">}</span>
<span class="ln"> 5071</span>
<span class="ln"> 5072</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">throttled_lb_pair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span>
<span class="ln"> 5073</span>				    <span class="kt">int</span> <span class="n">src_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dest_cpu</span><span class="p">)</span>
<span class="ln"> 5074</span><span class="p">{</span>
<span class="ln"> 5075</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5076</span><span class="p">}</span>
<span class="ln"> 5077</span>
<span class="ln"> 5078</span><span class="kt">void</span> <span class="nf">init_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5079</span>
<span class="ln"> 5080</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 5081</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">init_cfs_rq_runtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5082</span><span class="cp">#endif
</span><span class="ln"> 5083</span><span class="cp"></span>
<span class="ln"> 5084</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="nf">tg_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln"> 5085</span><span class="p">{</span>
<span class="ln"> 5086</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5087</span><span class="p">}</span>
<span class="ln"> 5088</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">destroy_cfs_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_bandwidth</span> <span class="o">*</span><span class="n">cfs_b</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5089</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_runtime_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5090</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unthrottle_offline_cfs_rqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span> <span class="p">{}</span>
<span class="ln"> 5091</span>
<span class="ln"> 5092</span><span class="cp">#endif </span><span class="cm">/* CONFIG_CFS_BANDWIDTH */</span><span class="cp">
</span><span class="ln"> 5093</span><span class="cp"></span>
<span class="ln"> 5094</span><span class="cm">/**************************************************
</span><span class="ln"> 5095</span><span class="cm"> * CFS operations on tasks:
</span><span class="ln"> 5096</span><span class="cm"> */</span>
<span class="ln"> 5097</span>
<span class="ln"> 5098</span><span class="cp">#ifdef CONFIG_SCHED_HRTICK
</span><span class="ln"> 5099</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_start_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 5100</span><span class="p">{</span>
<span class="ln"> 5101</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 5102</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5103</span>
<span class="ln"> 5104</span>	<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5105</span>
<span class="ln"> 5106</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5107</span>		<span class="n">u64</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 5108</span>		<span class="n">u64</span> <span class="n">ran</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">prev_sum_exec_runtime</span><span class="p">;</span>
<span class="ln"> 5109</span>		<span class="n">s64</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">slice</span> <span class="o">-</span> <span class="n">ran</span><span class="p">;</span>
<span class="ln"> 5110</span>
<span class="ln"> 5111</span>		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5112</span>			<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
<span class="ln"> 5113</span>				<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5114</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln"> 5115</span>		<span class="p">}</span>
<span class="ln"> 5116</span>		<span class="n">hrtick_start</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="ln"> 5117</span>	<span class="p">}</span>
<span class="ln"> 5118</span><span class="p">}</span>
<span class="ln"> 5119</span>
<span class="ln"> 5120</span><span class="cm">/*
</span><span class="ln"> 5121</span><span class="cm"> * called from enqueue/dequeue and updates the hrtick when the
</span><span class="ln"> 5122</span><span class="cm"> * current task is from our class and nr_running is low enough
</span><span class="ln"> 5123</span><span class="cm"> * to matter.
</span><span class="ln"> 5124</span><span class="cm"> */</span>
<span class="ln"> 5125</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">hrtick_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 5126</span><span class="p">{</span>
<span class="ln"> 5127</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 5128</span>
<span class="ln"> 5129</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrtick_enabled</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">||</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span>
<span class="ln"> 5130</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 5131</span>
<span class="ln"> 5132</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&lt;</span> <span class="n">sched_nr_latency</span><span class="p">)</span>
<span class="ln"> 5133</span>		<span class="n">hrtick_start_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln"> 5134</span><span class="p">}</span>
<span class="ln"> 5135</span><span class="cp">#else </span><span class="cm">/* !CONFIG_SCHED_HRTICK */</span><span class="cp">
</span><span class="ln"> 5136</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 5137</span><span class="nf">hrtick_start_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 5138</span><span class="p">{</span>
<span class="ln"> 5139</span><span class="p">}</span>
<span class="ln"> 5140</span>
<span class="ln"> 5141</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hrtick_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 5142</span><span class="p">{</span>
<span class="ln"> 5143</span><span class="p">}</span>
<span class="ln"> 5144</span><span class="cp">#endif
</span><span class="ln"> 5145</span><span class="cp"></span>
<span class="ln"> 5146</span><span class="cm">/*
</span><span class="ln"> 5147</span><span class="cm"> * The enqueue_task method is called before nr_running is
</span><span class="ln"> 5148</span><span class="cm"> * increased. Here we update the fair scheduling stats and
</span><span class="ln"> 5149</span><span class="cm"> * then put the task into the rbtree:
</span><span class="ln"> 5150</span><span class="cm"> */</span>
<span class="ln"> 5151</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 5152</span><span class="nf">enqueue_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 5153</span><span class="p">{</span>
<span class="ln"> 5154</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 5155</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 5156</span>
<span class="ln"> 5157</span>	<span class="cm">/*
</span><span class="ln"> 5158</span><span class="cm">	 * The code below (indirectly) updates schedutil which looks at
</span><span class="ln"> 5159</span><span class="cm">	 * the cfs_rq utilization to select a frequency.
</span><span class="ln"> 5160</span><span class="cm">	 * Let&#39;s add the task&#39;s estimated utilization to the cfs_rq&#39;s
</span><span class="ln"> 5161</span><span class="cm">	 * estimated utilization, before we update schedutil.
</span><span class="ln"> 5162</span><span class="cm">	 */</span>
<span class="ln"> 5163</span>	<span class="n">util_est_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 5164</span>
<span class="ln"> 5165</span>	<span class="cm">/*
</span><span class="ln"> 5166</span><span class="cm">	 * If in_iowait is set, the code below may not trigger any cpufreq
</span><span class="ln"> 5167</span><span class="cm">	 * utilization updates, so do it here explicitly with the IOWAIT flag
</span><span class="ln"> 5168</span><span class="cm">	 * passed.
</span><span class="ln"> 5169</span><span class="cm">	 */</span>
<span class="ln"> 5170</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span>
<span class="ln"> 5171</span>		<span class="n">cpufreq_update_util</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">SCHED_CPUFREQ_IOWAIT</span><span class="p">);</span>
<span class="ln"> 5172</span>
<span class="ln"> 5173</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5174</span>		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln"> 5175</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5176</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5177</span>		<span class="n">enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 5178</span>
<span class="ln"> 5179</span>		<span class="cm">/*
</span><span class="ln"> 5180</span><span class="cm">		 * end evaluation on encountering a throttled cfs_rq
</span><span class="ln"> 5181</span><span class="cm">		 *
</span><span class="ln"> 5182</span><span class="cm">		 * note: in the case of encountering a throttled cfs_rq we will
</span><span class="ln"> 5183</span><span class="cm">		 * post the final h_nr_running increment below.
</span><span class="ln"> 5184</span><span class="cm">		 */</span>
<span class="ln"> 5185</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5186</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5187</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 5188</span>
<span class="ln"> 5189</span>		<span class="n">flags</span> <span class="o">=</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">;</span>
<span class="ln"> 5190</span>	<span class="p">}</span>
<span class="ln"> 5191</span>
<span class="ln"> 5192</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5193</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5194</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 5195</span>
<span class="ln"> 5196</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5197</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5198</span>
<span class="ln"> 5199</span>		<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln"> 5200</span>		<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5201</span>	<span class="p">}</span>
<span class="ln"> 5202</span>
<span class="ln"> 5203</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 5204</span>		<span class="n">add_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 5205</span>
<span class="ln"> 5206</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_bandwidth_used</span><span class="p">())</span> <span class="p">{</span>
<span class="ln"> 5207</span>		<span class="cm">/*
</span><span class="ln"> 5208</span><span class="cm">		 * When bandwidth control is enabled; the cfs_rq_throttled()
</span><span class="ln"> 5209</span><span class="cm">		 * breaks in the above iteration can result in incomplete
</span><span class="ln"> 5210</span><span class="cm">		 * leaf list maintenance, resulting in triggering the assertion
</span><span class="ln"> 5211</span><span class="cm">		 * below.
</span><span class="ln"> 5212</span><span class="cm">		 */</span>
<span class="ln"> 5213</span>		<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5214</span>			<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5215</span>
<span class="ln"> 5216</span>			<span class="k">if</span> <span class="p">(</span><span class="n">list_add_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5217</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5218</span>		<span class="p">}</span>
<span class="ln"> 5219</span>	<span class="p">}</span>
<span class="ln"> 5220</span>
<span class="ln"> 5221</span>	<span class="n">assert_list_leaf_cfs_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5222</span>
<span class="ln"> 5223</span>	<span class="n">hrtick_update</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5224</span><span class="p">}</span>
<span class="ln"> 5225</span>
<span class="ln"> 5226</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_next_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5227</span>
<span class="ln"> 5228</span><span class="cm">/*
</span><span class="ln"> 5229</span><span class="cm"> * The dequeue_task method is called before nr_running is
</span><span class="ln"> 5230</span><span class="cm"> * decreased. We remove the task from the rbtree and
</span><span class="ln"> 5231</span><span class="cm"> * update the fair scheduling stats:
</span><span class="ln"> 5232</span><span class="cm"> */</span>
<span class="ln"> 5233</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">dequeue_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 5234</span><span class="p">{</span>
<span class="ln"> 5235</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 5236</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 5237</span>	<span class="kt">int</span> <span class="n">task_sleep</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">;</span>
<span class="ln"> 5238</span>
<span class="ln"> 5239</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5240</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5241</span>		<span class="n">dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 5242</span>
<span class="ln"> 5243</span>		<span class="cm">/*
</span><span class="ln"> 5244</span><span class="cm">		 * end evaluation on encountering a throttled cfs_rq
</span><span class="ln"> 5245</span><span class="cm">		 *
</span><span class="ln"> 5246</span><span class="cm">		 * note: in the case of encountering a throttled cfs_rq we will
</span><span class="ln"> 5247</span><span class="cm">		 * post the final h_nr_running decrement below.
</span><span class="ln"> 5248</span><span class="cm">		*/</span>
<span class="ln"> 5249</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5250</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5251</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 5252</span>
<span class="ln"> 5253</span>		<span class="cm">/* Don&#39;t dequeue parent if it has other entities besides us */</span>
<span class="ln"> 5254</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5255</span>			<span class="cm">/* Avoid re-evaluating load for this entity: */</span>
<span class="ln"> 5256</span>			<span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5257</span>			<span class="cm">/*
</span><span class="ln"> 5258</span><span class="cm">			 * Bias pick_next to pick a task from this cfs_rq, as
</span><span class="ln"> 5259</span><span class="cm">			 * p is sleeping when it is within its sched_slice.
</span><span class="ln"> 5260</span><span class="cm">			 */</span>
<span class="ln"> 5261</span>			<span class="k">if</span> <span class="p">(</span><span class="n">task_sleep</span> <span class="o">&amp;&amp;</span> <span class="n">se</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5262</span>				<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5263</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5264</span>		<span class="p">}</span>
<span class="ln"> 5265</span>		<span class="n">flags</span> <span class="o">|=</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">;</span>
<span class="ln"> 5266</span>	<span class="p">}</span>
<span class="ln"> 5267</span>
<span class="ln"> 5268</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5269</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5270</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="o">--</span><span class="p">;</span>
<span class="ln"> 5271</span>
<span class="ln"> 5272</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 5273</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 5274</span>
<span class="ln"> 5275</span>		<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln"> 5276</span>		<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5277</span>	<span class="p">}</span>
<span class="ln"> 5278</span>
<span class="ln"> 5279</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 5280</span>		<span class="n">sub_nr_running</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 5281</span>
<span class="ln"> 5282</span>	<span class="n">util_est_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">task_sleep</span><span class="p">);</span>
<span class="ln"> 5283</span>	<span class="n">hrtick_update</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5284</span><span class="p">}</span>
<span class="ln"> 5285</span>
<span class="ln"> 5286</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 5287</span><span class="cp"></span>
<span class="ln"> 5288</span><span class="cm">/* Working cpumask for: load_balance, load_balance_newidle. */</span>
<span class="ln"> 5289</span><span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">load_balance_mask</span><span class="p">);</span>
<span class="ln"> 5290</span><span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="n">cpumask_var_t</span><span class="p">,</span> <span class="n">select_idle_mask</span><span class="p">);</span>
<span class="ln"> 5291</span>
<span class="ln"> 5292</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 5293</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 5294</span><span class="cm"> * per rq &#39;load&#39; arrray crap; XXX kill this.
</span><span class="ln"> 5295</span><span class="cm"> */</span>
<span class="ln"> 5296</span>
<span class="ln"> 5297</span><span class="cm">/*
</span><span class="ln"> 5298</span><span class="cm"> * The exact cpuload calculated at every tick would be:
</span><span class="ln"> 5299</span><span class="cm"> *
</span><span class="ln"> 5300</span><span class="cm"> *   load&#39; = (1 - 1/2^i) * load + (1/2^i) * cur_load
</span><span class="ln"> 5301</span><span class="cm"> *
</span><span class="ln"> 5302</span><span class="cm"> * If a CPU misses updates for n ticks (as it was idle) and update gets
</span><span class="ln"> 5303</span><span class="cm"> * called on the n+1-th tick when CPU may be busy, then we have:
</span><span class="ln"> 5304</span><span class="cm"> *
</span><span class="ln"> 5305</span><span class="cm"> *   load_n   = (1 - 1/2^i)^n * load_0
</span><span class="ln"> 5306</span><span class="cm"> *   load_n+1 = (1 - 1/2^i)   * load_n + (1/2^i) * cur_load
</span><span class="ln"> 5307</span><span class="cm"> *
</span><span class="ln"> 5308</span><span class="cm"> * decay_load_missed() below does efficient calculation of
</span><span class="ln"> 5309</span><span class="cm"> *
</span><span class="ln"> 5310</span><span class="cm"> *   load&#39; = (1 - 1/2^i)^n * load
</span><span class="ln"> 5311</span><span class="cm"> *
</span><span class="ln"> 5312</span><span class="cm"> * Because x^(n+m) := x^n * x^m we can decompose any x^n in power-of-2 factors.
</span><span class="ln"> 5313</span><span class="cm"> * This allows us to precompute the above in said factors, thereby allowing the
</span><span class="ln"> 5314</span><span class="cm"> * reduction of an arbitrary n in O(log_2 n) steps. (See also
</span><span class="ln"> 5315</span><span class="cm"> * fixed_power_int())
</span><span class="ln"> 5316</span><span class="cm"> *
</span><span class="ln"> 5317</span><span class="cm"> * The calculation is approximated on a 128 point scale.
</span><span class="ln"> 5318</span><span class="cm"> */</span>
<span class="ln"> 5319</span><span class="cp">#define DEGRADE_SHIFT		7
</span><span class="ln"> 5320</span><span class="cp"></span>
<span class="ln"> 5321</span><span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">degrade_zero_ticks</span><span class="p">[</span><span class="n">CPU_LOAD_IDX_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
<span class="ln"> 5322</span><span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">degrade_factor</span><span class="p">[</span><span class="n">CPU_LOAD_IDX_MAX</span><span class="p">][</span><span class="n">DEGRADE_SHIFT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 5323</span>	<span class="p">{</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="ln"> 5324</span>	<span class="p">{</span>  <span class="mi">64</span><span class="p">,</span>  <span class="mi">32</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="ln"> 5325</span>	<span class="p">{</span>  <span class="mi">96</span><span class="p">,</span>  <span class="mi">72</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="ln"> 5326</span>	<span class="p">{</span> <span class="mi">112</span><span class="p">,</span>  <span class="mi">98</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
<span class="ln"> 5327</span>	<span class="p">{</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="ln"> 5328</span><span class="p">};</span>
<span class="ln"> 5329</span>
<span class="ln"> 5330</span><span class="cm">/*
</span><span class="ln"> 5331</span><span class="cm"> * Update cpu_load for any missed ticks, due to tickless idle. The backlog
</span><span class="ln"> 5332</span><span class="cm"> * would be when CPU is idle and so we just decay the old load without
</span><span class="ln"> 5333</span><span class="cm"> * adding any new load.
</span><span class="ln"> 5334</span><span class="cm"> */</span>
<span class="ln"> 5335</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="ln"> 5336</span><span class="nf">decay_load_missed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">missed_updates</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="ln"> 5337</span><span class="p">{</span>
<span class="ln"> 5338</span>	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5339</span>
<span class="ln"> 5340</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">missed_updates</span><span class="p">)</span>
<span class="ln"> 5341</span>		<span class="k">return</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 5342</span>
<span class="ln"> 5343</span>	<span class="k">if</span> <span class="p">(</span><span class="n">missed_updates</span> <span class="o">&gt;=</span> <span class="n">degrade_zero_ticks</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="ln"> 5344</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5345</span>
<span class="ln"> 5346</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 5347</span>		<span class="k">return</span> <span class="n">load</span> <span class="o">&gt;&gt;</span> <span class="n">missed_updates</span><span class="p">;</span>
<span class="ln"> 5348</span>
<span class="ln"> 5349</span>	<span class="k">while</span> <span class="p">(</span><span class="n">missed_updates</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5350</span>		<span class="k">if</span> <span class="p">(</span><span class="n">missed_updates</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
<span class="ln"> 5351</span>			<span class="n">load</span> <span class="o">=</span> <span class="p">(</span><span class="n">load</span> <span class="o">*</span> <span class="n">degrade_factor</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">DEGRADE_SHIFT</span><span class="p">;</span>
<span class="ln"> 5352</span>
<span class="ln"> 5353</span>		<span class="n">missed_updates</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5354</span>		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 5355</span>	<span class="p">}</span>
<span class="ln"> 5356</span>	<span class="k">return</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 5357</span><span class="p">}</span>
<span class="ln"> 5358</span>
<span class="ln"> 5359</span><span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
<span class="ln"> 5360</span>	<span class="n">cpumask_var_t</span> <span class="n">idle_cpus_mask</span><span class="p">;</span>
<span class="ln"> 5361</span>	<span class="n">atomic_t</span> <span class="n">nr_cpus</span><span class="p">;</span>
<span class="ln"> 5362</span>	<span class="kt">int</span> <span class="n">has_blocked</span><span class="p">;</span>		<span class="cm">/* Idle CPUS has blocked load */</span>
<span class="ln"> 5363</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span><span class="p">;</span>     <span class="cm">/* in jiffy units */</span>
<span class="ln"> 5364</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_blocked</span><span class="p">;</span>	<span class="cm">/* Next update of blocked load in jiffies */</span>
<span class="ln"> 5365</span><span class="p">}</span> <span class="n">nohz</span> <span class="n">____cacheline_aligned</span><span class="p">;</span>
<span class="ln"> 5366</span>
<span class="ln"> 5367</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 5368</span><span class="cp"></span>
<span class="ln"> 5369</span><span class="cm">/**
</span><span class="ln"> 5370</span><span class="cm"> * __cpu_load_update - update the rq-&gt;cpu_load[] statistics
</span><span class="ln"> 5371</span><span class="cm"> * @this_rq: The rq to update statistics for
</span><span class="ln"> 5372</span><span class="cm"> * @this_load: The current load
</span><span class="ln"> 5373</span><span class="cm"> * @pending_updates: The number of missed updates
</span><span class="ln"> 5374</span><span class="cm"> *
</span><span class="ln"> 5375</span><span class="cm"> * Update rq-&gt;cpu_load[] statistics. This function is usually called every
</span><span class="ln"> 5376</span><span class="cm"> * scheduler tick (TICK_NSEC).
</span><span class="ln"> 5377</span><span class="cm"> *
</span><span class="ln"> 5378</span><span class="cm"> * This function computes a decaying average:
</span><span class="ln"> 5379</span><span class="cm"> *
</span><span class="ln"> 5380</span><span class="cm"> *   load[i]&#39; = (1 - 1/2^i) * load[i] + (1/2^i) * load
</span><span class="ln"> 5381</span><span class="cm"> *
</span><span class="ln"> 5382</span><span class="cm"> * Because of NOHZ it might not get called on every tick which gives need for
</span><span class="ln"> 5383</span><span class="cm"> * the @pending_updates argument.
</span><span class="ln"> 5384</span><span class="cm"> *
</span><span class="ln"> 5385</span><span class="cm"> *   load[i]_n = (1 - 1/2^i) * load[i]_n-1 + (1/2^i) * load_n-1
</span><span class="ln"> 5386</span><span class="cm"> *             = A * load[i]_n-1 + B ; A := (1 - 1/2^i), B := (1/2^i) * load
</span><span class="ln"> 5387</span><span class="cm"> *             = A * (A * load[i]_n-2 + B) + B
</span><span class="ln"> 5388</span><span class="cm"> *             = A * (A * (A * load[i]_n-3 + B) + B) + B
</span><span class="ln"> 5389</span><span class="cm"> *             = A^3 * load[i]_n-3 + (A^2 + A + 1) * B
</span><span class="ln"> 5390</span><span class="cm"> *             = A^n * load[i]_0 + (A^(n-1) + A^(n-2) + ... + 1) * B
</span><span class="ln"> 5391</span><span class="cm"> *             = A^n * load[i]_0 + ((1 - A^n) / (1 - A)) * B
</span><span class="ln"> 5392</span><span class="cm"> *             = (1 - 1/2^i)^n * (load[i]_0 - load) + load
</span><span class="ln"> 5393</span><span class="cm"> *
</span><span class="ln"> 5394</span><span class="cm"> * In the above we&#39;ve assumed load_n := load, which is true for NOHZ_FULL as
</span><span class="ln"> 5395</span><span class="cm"> * any change in load would have resulted in the tick being turned back on.
</span><span class="ln"> 5396</span><span class="cm"> *
</span><span class="ln"> 5397</span><span class="cm"> * For regular NOHZ, this reduces to:
</span><span class="ln"> 5398</span><span class="cm"> *
</span><span class="ln"> 5399</span><span class="cm"> *   load[i]_n = (1 - 1/2^i)^n * load[i]_0
</span><span class="ln"> 5400</span><span class="cm"> *
</span><span class="ln"> 5401</span><span class="cm"> * see decay_load_misses(). For NOHZ_FULL we get to subtract and add the extra
</span><span class="ln"> 5402</span><span class="cm"> * term.
</span><span class="ln"> 5403</span><span class="cm"> */</span>
<span class="ln"> 5404</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_load_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_load</span><span class="p">,</span>
<span class="ln"> 5405</span>			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_updates</span><span class="p">)</span>
<span class="ln"> 5406</span><span class="p">{</span>
<span class="ln"> 5407</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__maybe_unused</span> <span class="n">tickless_load</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="ln"> 5408</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span><span class="p">;</span>
<span class="ln"> 5409</span>
<span class="ln"> 5410</span>	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_load_updates</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 5411</span>
<span class="ln"> 5412</span>	<span class="cm">/* Update our load: */</span>
<span class="ln"> 5413</span>	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_load</span><span class="p">;</span> <span class="cm">/* Fasttrack for idx 0 */</span>
<span class="ln"> 5414</span>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CPU_LOAD_IDX_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">scale</span> <span class="o">+=</span> <span class="n">scale</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5415</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_load</span><span class="p">,</span> <span class="n">new_load</span><span class="p">;</span>
<span class="ln"> 5416</span>
<span class="ln"> 5417</span>		<span class="cm">/* scale is effectively 1 &lt;&lt; i now, and &gt;&gt; i divides by scale */</span>
<span class="ln"> 5418</span>
<span class="ln"> 5419</span>		<span class="n">old_load</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 5420</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 5421</span><span class="cp"></span>		<span class="n">old_load</span> <span class="o">=</span> <span class="n">decay_load_missed</span><span class="p">(</span><span class="n">old_load</span><span class="p">,</span> <span class="n">pending_updates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="ln"> 5422</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tickless_load</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5423</span>			<span class="n">old_load</span> <span class="o">-=</span> <span class="n">decay_load_missed</span><span class="p">(</span><span class="n">tickless_load</span><span class="p">,</span> <span class="n">pending_updates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="ln"> 5424</span>			<span class="cm">/*
</span><span class="ln"> 5425</span><span class="cm">			 * old_load can never be a negative value because a
</span><span class="ln"> 5426</span><span class="cm">			 * decayed tickless_load cannot be greater than the
</span><span class="ln"> 5427</span><span class="cm">			 * original tickless_load.
</span><span class="ln"> 5428</span><span class="cm">			 */</span>
<span class="ln"> 5429</span>			<span class="n">old_load</span> <span class="o">+=</span> <span class="n">tickless_load</span><span class="p">;</span>
<span class="ln"> 5430</span>		<span class="p">}</span>
<span class="ln"> 5431</span><span class="cp">#endif
</span><span class="ln"> 5432</span><span class="cp"></span>		<span class="n">new_load</span> <span class="o">=</span> <span class="n">this_load</span><span class="p">;</span>
<span class="ln"> 5433</span>		<span class="cm">/*
</span><span class="ln"> 5434</span><span class="cm">		 * Round up the averaging division if load is increasing. This
</span><span class="ln"> 5435</span><span class="cm">		 * prevents us from getting stuck on 9 if the load is 10, for
</span><span class="ln"> 5436</span><span class="cm">		 * example.
</span><span class="ln"> 5437</span><span class="cm">		 */</span>
<span class="ln"> 5438</span>		<span class="k">if</span> <span class="p">(</span><span class="n">new_load</span> <span class="o">&gt;</span> <span class="n">old_load</span><span class="p">)</span>
<span class="ln"> 5439</span>			<span class="n">new_load</span> <span class="o">+=</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5440</span>
<span class="ln"> 5441</span>		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_load</span> <span class="o">*</span> <span class="p">(</span><span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_load</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 5442</span>	<span class="p">}</span>
<span class="ln"> 5443</span><span class="p">}</span>
<span class="ln"> 5444</span>
<span class="ln"> 5445</span><span class="cm">/* Used instead of source_load when we know the type == 0 */</span>
<span class="ln"> 5446</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">weighted_cpuload</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 5447</span><span class="p">{</span>
<span class="ln"> 5448</span>	<span class="k">return</span> <span class="n">cfs_rq_runnable_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">);</span>
<span class="ln"> 5449</span><span class="p">}</span>
<span class="ln"> 5450</span>
<span class="ln"> 5451</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 5452</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 5453</span><span class="cm"> * There is no sane way to deal with nohz on smp when using jiffies because the
</span><span class="ln"> 5454</span><span class="cm"> * CPU doing the jiffies update might drift wrt the CPU doing the jiffy reading
</span><span class="ln"> 5455</span><span class="cm"> * causing off-by-one errors in observed deltas; {0,2} instead of {1,1}.
</span><span class="ln"> 5456</span><span class="cm"> *
</span><span class="ln"> 5457</span><span class="cm"> * Therefore we need to avoid the delta approach from the regular tick when
</span><span class="ln"> 5458</span><span class="cm"> * possible since that would seriously skew the load calculation. This is why we
</span><span class="ln"> 5459</span><span class="cm"> * use cpu_load_update_periodic() for CPUs out of nohz. However we&#39;ll rely on
</span><span class="ln"> 5460</span><span class="cm"> * jiffies deltas for updates happening while in nohz mode (idle ticks, idle
</span><span class="ln"> 5461</span><span class="cm"> * loop exit, nohz_idle_balance, nohz full exit...)
</span><span class="ln"> 5462</span><span class="cm"> *
</span><span class="ln"> 5463</span><span class="cm"> * This means we might still be one tick off for nohz periods.
</span><span class="ln"> 5464</span><span class="cm"> */</span>
<span class="ln"> 5465</span>
<span class="ln"> 5466</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_load_update_nohz</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span>
<span class="ln"> 5467</span>				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_jiffies</span><span class="p">,</span>
<span class="ln"> 5468</span>				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">)</span>
<span class="ln"> 5469</span><span class="p">{</span>
<span class="ln"> 5470</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_updates</span><span class="p">;</span>
<span class="ln"> 5471</span>
<span class="ln"> 5472</span>	<span class="n">pending_updates</span> <span class="o">=</span> <span class="n">curr_jiffies</span> <span class="o">-</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span><span class="p">;</span>
<span class="ln"> 5473</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pending_updates</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5474</span>		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">curr_jiffies</span><span class="p">;</span>
<span class="ln"> 5475</span>		<span class="cm">/*
</span><span class="ln"> 5476</span><span class="cm">		 * In the regular NOHZ case, we were idle, this means load 0.
</span><span class="ln"> 5477</span><span class="cm">		 * In the NOHZ_FULL case, we were non-idle, we should consider
</span><span class="ln"> 5478</span><span class="cm">		 * its weighted load.
</span><span class="ln"> 5479</span><span class="cm">		 */</span>
<span class="ln"> 5480</span>		<span class="n">cpu_load_update</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="n">pending_updates</span><span class="p">);</span>
<span class="ln"> 5481</span>	<span class="p">}</span>
<span class="ln"> 5482</span><span class="p">}</span>
<span class="ln"> 5483</span>
<span class="ln"> 5484</span><span class="cm">/*
</span><span class="ln"> 5485</span><span class="cm"> * Called from nohz_idle_balance() to update the load ratings before doing the
</span><span class="ln"> 5486</span><span class="cm"> * idle balance.
</span><span class="ln"> 5487</span><span class="cm"> */</span>
<span class="ln"> 5488</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_load_update_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="ln"> 5489</span><span class="p">{</span>
<span class="ln"> 5490</span>	<span class="cm">/*
</span><span class="ln"> 5491</span><span class="cm">	 * bail if there&#39;s load or we&#39;re actually up-to-date.
</span><span class="ln"> 5492</span><span class="cm">	 */</span>
<span class="ln"> 5493</span>	<span class="k">if</span> <span class="p">(</span><span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">this_rq</span><span class="p">))</span>
<span class="ln"> 5494</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 5495</span>
<span class="ln"> 5496</span>	<span class="n">cpu_load_update_nohz</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 5497</span><span class="p">}</span>
<span class="ln"> 5498</span>
<span class="ln"> 5499</span><span class="cm">/*
</span><span class="ln"> 5500</span><span class="cm"> * Record CPU load on nohz entry so we know the tickless load to account
</span><span class="ln"> 5501</span><span class="cm"> * on nohz exit. cpu_load[0] happens then to be updated more frequently
</span><span class="ln"> 5502</span><span class="cm"> * than other cpu_load[idx] but it should be fine as cpu_load readers
</span><span class="ln"> 5503</span><span class="cm"> * shouldn&#39;t rely into synchronized cpu_load[*] updates.
</span><span class="ln"> 5504</span><span class="cm"> */</span>
<span class="ln"> 5505</span><span class="kt">void</span> <span class="nf">cpu_load_update_nohz_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 5506</span><span class="p">{</span>
<span class="ln"> 5507</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln"> 5508</span>
<span class="ln"> 5509</span>	<span class="cm">/*
</span><span class="ln"> 5510</span><span class="cm">	 * This is all lockless but should be fine. If weighted_cpuload changes
</span><span class="ln"> 5511</span><span class="cm">	 * concurrently we&#39;ll exit nohz. And cpu_load write can race with
</span><span class="ln"> 5512</span><span class="cm">	 * cpu_load_update_idle() but both updater would be writing the same.
</span><span class="ln"> 5513</span><span class="cm">	 */</span>
<span class="ln"> 5514</span>	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="ln"> 5515</span><span class="p">}</span>
<span class="ln"> 5516</span>
<span class="ln"> 5517</span><span class="cm">/*
</span><span class="ln"> 5518</span><span class="cm"> * Account the tickless load in the end of a nohz frame.
</span><span class="ln"> 5519</span><span class="cm"> */</span>
<span class="ln"> 5520</span><span class="kt">void</span> <span class="nf">cpu_load_update_nohz_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 5521</span><span class="p">{</span>
<span class="ln"> 5522</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_jiffies</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
<span class="ln"> 5523</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln"> 5524</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 5525</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 5526</span>
<span class="ln"> 5527</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr_jiffies</span> <span class="o">==</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span><span class="p">)</span>
<span class="ln"> 5528</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 5529</span>
<span class="ln"> 5530</span>	<span class="n">load</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="ln"> 5531</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 5532</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="ln"> 5533</span>	<span class="n">cpu_load_update_nohz</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">curr_jiffies</span><span class="p">,</span> <span class="n">load</span><span class="p">);</span>
<span class="ln"> 5534</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 5535</span><span class="p">}</span>
<span class="ln"> 5536</span><span class="cp">#else </span><span class="cm">/* !CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 5537</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cpu_load_update_nohz</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span>
<span class="ln"> 5538</span>					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_jiffies</span><span class="p">,</span>
<span class="ln"> 5539</span>					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 5540</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 5541</span><span class="cp"></span>
<span class="ln"> 5542</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">cpu_load_update_periodic</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">)</span>
<span class="ln"> 5543</span><span class="p">{</span>
<span class="ln"> 5544</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 5545</span><span class="cp"></span>	<span class="cm">/* See the mess around cpu_load_update_nohz(). */</span>
<span class="ln"> 5546</span>	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">last_load_update_tick</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
<span class="ln"> 5547</span><span class="cp">#endif
</span><span class="ln"> 5548</span><span class="cp"></span>	<span class="n">cpu_load_update</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">load</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 5549</span><span class="p">}</span>
<span class="ln"> 5550</span>
<span class="ln"> 5551</span><span class="cm">/*
</span><span class="ln"> 5552</span><span class="cm"> * Called from scheduler_tick()
</span><span class="ln"> 5553</span><span class="cm"> */</span>
<span class="ln"> 5554</span><span class="kt">void</span> <span class="nf">cpu_load_update_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="ln"> 5555</span><span class="p">{</span>
<span class="ln"> 5556</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="ln"> 5557</span>
<span class="ln"> 5558</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tick_nohz_tick_stopped</span><span class="p">())</span>
<span class="ln"> 5559</span>		<span class="n">cpu_load_update_nohz</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">jiffies</span><span class="p">),</span> <span class="n">load</span><span class="p">);</span>
<span class="ln"> 5560</span>	<span class="k">else</span>
<span class="ln"> 5561</span>		<span class="n">cpu_load_update_periodic</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">load</span><span class="p">);</span>
<span class="ln"> 5562</span><span class="p">}</span>
<span class="ln"> 5563</span>
<span class="ln"> 5564</span><span class="cm">/*
</span><span class="ln"> 5565</span><span class="cm"> * Return a low guess at the load of a migration-source CPU weighted
</span><span class="ln"> 5566</span><span class="cm"> * according to the scheduling class and &#34;nice&#34; value.
</span><span class="ln"> 5567</span><span class="cm"> *
</span><span class="ln"> 5568</span><span class="cm"> * We want to under-estimate the load of migration sources, to
</span><span class="ln"> 5569</span><span class="cm"> * balance conservatively.
</span><span class="ln"> 5570</span><span class="cm"> */</span>
<span class="ln"> 5571</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">source_load</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="ln"> 5572</span><span class="p">{</span>
<span class="ln"> 5573</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 5574</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5575</span>
<span class="ln"> 5576</span>	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LB_BIAS</span><span class="p">))</span>
<span class="ln"> 5577</span>		<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="ln"> 5578</span>
<span class="ln"> 5579</span>	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">type</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">total</span><span class="p">);</span>
<span class="ln"> 5580</span><span class="p">}</span>
<span class="ln"> 5581</span>
<span class="ln"> 5582</span><span class="cm">/*
</span><span class="ln"> 5583</span><span class="cm"> * Return a high guess at the load of a migration-target CPU weighted
</span><span class="ln"> 5584</span><span class="cm"> * according to the scheduling class and &#34;nice&#34; value.
</span><span class="ln"> 5585</span><span class="cm"> */</span>
<span class="ln"> 5586</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">target_load</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="ln"> 5587</span><span class="p">{</span>
<span class="ln"> 5588</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 5589</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5590</span>
<span class="ln"> 5591</span>	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LB_BIAS</span><span class="p">))</span>
<span class="ln"> 5592</span>		<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="ln"> 5593</span>
<span class="ln"> 5594</span>	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_load</span><span class="p">[</span><span class="n">type</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">total</span><span class="p">);</span>
<span class="ln"> 5595</span><span class="p">}</span>
<span class="ln"> 5596</span>
<span class="ln"> 5597</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">capacity_of</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 5598</span><span class="p">{</span>
<span class="ln"> 5599</span>	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu_capacity</span><span class="p">;</span>
<span class="ln"> 5600</span><span class="p">}</span>
<span class="ln"> 5601</span>
<span class="ln"> 5602</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">capacity_orig_of</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 5603</span><span class="p">{</span>
<span class="ln"> 5604</span>	<span class="k">return</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu_capacity_orig</span><span class="p">;</span>
<span class="ln"> 5605</span><span class="p">}</span>
<span class="ln"> 5606</span>
<span class="ln"> 5607</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cpu_avg_load_per_task</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 5608</span><span class="p">{</span>
<span class="ln"> 5609</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 5610</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">);</span>
<span class="ln"> 5611</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_avg</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5612</span>
<span class="ln"> 5613</span>	<span class="k">if</span> <span class="p">(</span><span class="n">nr_running</span><span class="p">)</span>
<span class="ln"> 5614</span>		<span class="k">return</span> <span class="n">load_avg</span> <span class="o">/</span> <span class="n">nr_running</span><span class="p">;</span>
<span class="ln"> 5615</span>
<span class="ln"> 5616</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5617</span><span class="p">}</span>
<span class="ln"> 5618</span>
<span class="ln"> 5619</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">record_wakee</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 5620</span><span class="p">{</span>
<span class="ln"> 5621</span>	<span class="cm">/*
</span><span class="ln"> 5622</span><span class="cm">	 * Only decay a single time; tasks that have less then 1 wakeup per
</span><span class="ln"> 5623</span><span class="cm">	 * jiffy will not have built up many flips.
</span><span class="ln"> 5624</span><span class="cm">	 */</span>
<span class="ln"> 5625</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">wakee_flip_decay_ts</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 5626</span>		<span class="n">current</span><span class="o">-&gt;</span><span class="n">wakee_flips</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5627</span>		<span class="n">current</span><span class="o">-&gt;</span><span class="n">wakee_flip_decay_ts</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 5628</span>	<span class="p">}</span>
<span class="ln"> 5629</span>
<span class="ln"> 5630</span>	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">last_wakee</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5631</span>		<span class="n">current</span><span class="o">-&gt;</span><span class="n">last_wakee</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="ln"> 5632</span>		<span class="n">current</span><span class="o">-&gt;</span><span class="n">wakee_flips</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 5633</span>	<span class="p">}</span>
<span class="ln"> 5634</span><span class="p">}</span>
<span class="ln"> 5635</span>
<span class="ln"> 5636</span><span class="cm">/*
</span><span class="ln"> 5637</span><span class="cm"> * Detect M:N waker/wakee relationships via a switching-frequency heuristic.
</span><span class="ln"> 5638</span><span class="cm"> *
</span><span class="ln"> 5639</span><span class="cm"> * A waker of many should wake a different task than the one last awakened
</span><span class="ln"> 5640</span><span class="cm"> * at a frequency roughly N times higher than one of its wakees.
</span><span class="ln"> 5641</span><span class="cm"> *
</span><span class="ln"> 5642</span><span class="cm"> * In order to determine whether we should let the load spread vs consolidating
</span><span class="ln"> 5643</span><span class="cm"> * to shared cache, we look for a minimum &#39;flip&#39; frequency of llc_size in one
</span><span class="ln"> 5644</span><span class="cm"> * partner, and a factor of lls_size higher frequency in the other.
</span><span class="ln"> 5645</span><span class="cm"> *
</span><span class="ln"> 5646</span><span class="cm"> * With both conditions met, we can be relatively sure that the relationship is
</span><span class="ln"> 5647</span><span class="cm"> * non-monogamous, with partner count exceeding socket size.
</span><span class="ln"> 5648</span><span class="cm"> *
</span><span class="ln"> 5649</span><span class="cm"> * Waker/wakee being client/server, worker/dispatcher, interrupt source or
</span><span class="ln"> 5650</span><span class="cm"> * whatever is irrelevant, spread criteria is apparent partner count exceeds
</span><span class="ln"> 5651</span><span class="cm"> * socket size.
</span><span class="ln"> 5652</span><span class="cm"> */</span>
<span class="ln"> 5653</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">wake_wide</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 5654</span><span class="p">{</span>
<span class="ln"> 5655</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">master</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">wakee_flips</span><span class="p">;</span>
<span class="ln"> 5656</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">wakee_flips</span><span class="p">;</span>
<span class="ln"> 5657</span>	<span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">sd_llc_size</span><span class="p">);</span>
<span class="ln"> 5658</span>
<span class="ln"> 5659</span>	<span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">&lt;</span> <span class="n">slave</span><span class="p">)</span>
<span class="ln"> 5660</span>		<span class="n">swap</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
<span class="ln"> 5661</span>	<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">&lt;</span> <span class="n">factor</span> <span class="o">||</span> <span class="n">master</span> <span class="o">&lt;</span> <span class="n">slave</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span>
<span class="ln"> 5662</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5663</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5664</span><span class="p">}</span>
<span class="ln"> 5665</span>
<span class="ln"> 5666</span><span class="cm">/*
</span><span class="ln"> 5667</span><span class="cm"> * The purpose of wake_affine() is to quickly determine on which CPU we can run
</span><span class="ln"> 5668</span><span class="cm"> * soonest. For the purpose of speed we only consider the waking and previous
</span><span class="ln"> 5669</span><span class="cm"> * CPU.
</span><span class="ln"> 5670</span><span class="cm"> *
</span><span class="ln"> 5671</span><span class="cm"> * wake_affine_idle() - only considers &#39;now&#39;, it check if the waking CPU is
</span><span class="ln"> 5672</span><span class="cm"> *			cache-affine and is (or	will be) idle.
</span><span class="ln"> 5673</span><span class="cm"> *
</span><span class="ln"> 5674</span><span class="cm"> * wake_affine_weight() - considers the weight to reflect the average
</span><span class="ln"> 5675</span><span class="cm"> *			  scheduling latency of the CPUs. This seems to work
</span><span class="ln"> 5676</span><span class="cm"> *			  for the overloaded case.
</span><span class="ln"> 5677</span><span class="cm"> */</span>
<span class="ln"> 5678</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln"> 5679</span><span class="nf">wake_affine_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="ln"> 5680</span><span class="p">{</span>
<span class="ln"> 5681</span>	<span class="cm">/*
</span><span class="ln"> 5682</span><span class="cm">	 * If this_cpu is idle, it implies the wakeup is from interrupt
</span><span class="ln"> 5683</span><span class="cm">	 * context. Only allow the move if cache is shared. Otherwise an
</span><span class="ln"> 5684</span><span class="cm">	 * interrupt intensive workload could force all tasks onto one
</span><span class="ln"> 5685</span><span class="cm">	 * node depending on the IO topology or IRQ affinity settings.
</span><span class="ln"> 5686</span><span class="cm">	 *
</span><span class="ln"> 5687</span><span class="cm">	 * If the prev_cpu is idle and cache affine then avoid a migration.
</span><span class="ln"> 5688</span><span class="cm">	 * There is no guarantee that the cache hot data from an interrupt
</span><span class="ln"> 5689</span><span class="cm">	 * is more important than cache hot data on the prev_cpu and from
</span><span class="ln"> 5690</span><span class="cm">	 * a cpufreq perspective, it&#39;s better to have higher utilisation
</span><span class="ln"> 5691</span><span class="cm">	 * on one CPU.
</span><span class="ln"> 5692</span><span class="cm">	 */</span>
<span class="ln"> 5693</span>	<span class="k">if</span> <span class="p">(</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cpus_share_cache</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">))</span>
<span class="ln"> 5694</span>		<span class="k">return</span> <span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">)</span> <span class="o">?</span> <span class="nl">prev_cpu</span> <span class="p">:</span> <span class="n">this_cpu</span><span class="p">;</span>
<span class="ln"> 5695</span>
<span class="ln"> 5696</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 5697</span>		<span class="k">return</span> <span class="n">this_cpu</span><span class="p">;</span>
<span class="ln"> 5698</span>
<span class="ln"> 5699</span>	<span class="k">return</span> <span class="n">nr_cpumask_bits</span><span class="p">;</span>
<span class="ln"> 5700</span><span class="p">}</span>
<span class="ln"> 5701</span>
<span class="ln"> 5702</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln"> 5703</span><span class="nf">wake_affine_weight</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 5704</span>		   <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="ln"> 5705</span><span class="p">{</span>
<span class="ln"> 5706</span>	<span class="n">s64</span> <span class="n">this_eff_load</span><span class="p">,</span> <span class="n">prev_eff_load</span><span class="p">;</span>
<span class="ln"> 5707</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_load</span><span class="p">;</span>
<span class="ln"> 5708</span>
<span class="ln"> 5709</span>	<span class="n">this_eff_load</span> <span class="o">=</span> <span class="n">target_load</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">wake_idx</span><span class="p">);</span>
<span class="ln"> 5710</span>
<span class="ln"> 5711</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5712</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_load</span> <span class="o">=</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln"> 5713</span>
<span class="ln"> 5714</span>		<span class="k">if</span> <span class="p">(</span><span class="n">current_load</span> <span class="o">&gt;</span> <span class="n">this_eff_load</span><span class="p">)</span>
<span class="ln"> 5715</span>			<span class="k">return</span> <span class="n">this_cpu</span><span class="p">;</span>
<span class="ln"> 5716</span>
<span class="ln"> 5717</span>		<span class="n">this_eff_load</span> <span class="o">-=</span> <span class="n">current_load</span><span class="p">;</span>
<span class="ln"> 5718</span>	<span class="p">}</span>
<span class="ln"> 5719</span>
<span class="ln"> 5720</span>	<span class="n">task_load</span> <span class="o">=</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 5721</span>
<span class="ln"> 5722</span>	<span class="n">this_eff_load</span> <span class="o">+=</span> <span class="n">task_load</span><span class="p">;</span>
<span class="ln"> 5723</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">WA_BIAS</span><span class="p">))</span>
<span class="ln"> 5724</span>		<span class="n">this_eff_load</span> <span class="o">*=</span> <span class="mi">100</span><span class="p">;</span>
<span class="ln"> 5725</span>	<span class="n">this_eff_load</span> <span class="o">*=</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">);</span>
<span class="ln"> 5726</span>
<span class="ln"> 5727</span>	<span class="n">prev_eff_load</span> <span class="o">=</span> <span class="n">source_load</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">wake_idx</span><span class="p">);</span>
<span class="ln"> 5728</span>	<span class="n">prev_eff_load</span> <span class="o">-=</span> <span class="n">task_load</span><span class="p">;</span>
<span class="ln"> 5729</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">WA_BIAS</span><span class="p">))</span>
<span class="ln"> 5730</span>		<span class="n">prev_eff_load</span> <span class="o">*=</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 5731</span>	<span class="n">prev_eff_load</span> <span class="o">*=</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
<span class="ln"> 5732</span>
<span class="ln"> 5733</span>	<span class="cm">/*
</span><span class="ln"> 5734</span><span class="cm">	 * If sync, adjust the weight of prev_eff_load such that if
</span><span class="ln"> 5735</span><span class="cm">	 * prev_eff == this_eff that select_idle_sibling() will consider
</span><span class="ln"> 5736</span><span class="cm">	 * stacking the wakee on top of the waker if no other CPU is
</span><span class="ln"> 5737</span><span class="cm">	 * idle.
</span><span class="ln"> 5738</span><span class="cm">	 */</span>
<span class="ln"> 5739</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
<span class="ln"> 5740</span>		<span class="n">prev_eff_load</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5741</span>
<span class="ln"> 5742</span>	<span class="k">return</span> <span class="n">this_eff_load</span> <span class="o">&lt;</span> <span class="n">prev_eff_load</span> <span class="o">?</span> <span class="nl">this_cpu</span> <span class="p">:</span> <span class="n">nr_cpumask_bits</span><span class="p">;</span>
<span class="ln"> 5743</span><span class="p">}</span>
<span class="ln"> 5744</span>
<span class="ln"> 5745</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">wake_affine</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 5746</span>		       <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="ln"> 5747</span><span class="p">{</span>
<span class="ln"> 5748</span>	<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">nr_cpumask_bits</span><span class="p">;</span>
<span class="ln"> 5749</span>
<span class="ln"> 5750</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">WA_IDLE</span><span class="p">))</span>
<span class="ln"> 5751</span>		<span class="n">target</span> <span class="o">=</span> <span class="n">wake_affine_idle</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
<span class="ln"> 5752</span>
<span class="ln"> 5753</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">WA_WEIGHT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">==</span> <span class="n">nr_cpumask_bits</span><span class="p">)</span>
<span class="ln"> 5754</span>		<span class="n">target</span> <span class="o">=</span> <span class="n">wake_affine_weight</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
<span class="ln"> 5755</span>
<span class="ln"> 5756</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_affine_attempts</span><span class="p">);</span>
<span class="ln"> 5757</span>	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">nr_cpumask_bits</span><span class="p">)</span>
<span class="ln"> 5758</span>		<span class="k">return</span> <span class="n">prev_cpu</span><span class="p">;</span>
<span class="ln"> 5759</span>
<span class="ln"> 5760</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">ttwu_move_affine</span><span class="p">);</span>
<span class="ln"> 5761</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_wakeups_affine</span><span class="p">);</span>
<span class="ln"> 5762</span>	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="ln"> 5763</span><span class="p">}</span>
<span class="ln"> 5764</span>
<span class="ln"> 5765</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cpu_util_without</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 5766</span>
<span class="ln"> 5767</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">capacity_spare_without</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 5768</span><span class="p">{</span>
<span class="ln"> 5769</span>	<span class="k">return</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">-</span> <span class="n">cpu_util_without</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 5770</span><span class="p">}</span>
<span class="ln"> 5771</span>
<span class="ln"> 5772</span><span class="cm">/*
</span><span class="ln"> 5773</span><span class="cm"> * find_idlest_group finds and returns the least busy CPU group within the
</span><span class="ln"> 5774</span><span class="cm"> * domain.
</span><span class="ln"> 5775</span><span class="cm"> *
</span><span class="ln"> 5776</span><span class="cm"> * Assumes p is allowed on at least one CPU in sd.
</span><span class="ln"> 5777</span><span class="cm"> */</span>
<span class="ln"> 5778</span><span class="k">static</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span>
<span class="ln"> 5779</span><span class="nf">find_idlest_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 5780</span>		  <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">)</span>
<span class="ln"> 5781</span><span class="p">{</span>
<span class="ln"> 5782</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">idlest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">group</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
<span class="ln"> 5783</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">most_spare_sg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5784</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_runnable_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
<span class="ln"> 5785</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_runnable_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
<span class="ln"> 5786</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_avg_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">,</span> <span class="n">this_avg_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
<span class="ln"> 5787</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">most_spare</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">this_spare</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5788</span>	<span class="kt">int</span> <span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">forkexec_idx</span><span class="p">;</span>
<span class="ln"> 5789</span>	<span class="kt">int</span> <span class="n">imbalance_scale</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="ln"> 5790</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">imbalance</span> <span class="o">=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">NICE_0_LOAD</span><span class="p">)</span> <span class="o">*</span>
<span class="ln"> 5791</span>				<span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="o">-</span><span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
<span class="ln"> 5792</span>
<span class="ln"> 5793</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">)</span>
<span class="ln"> 5794</span>		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">wake_idx</span><span class="p">;</span>
<span class="ln"> 5795</span>
<span class="ln"> 5796</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 5797</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="n">avg_load</span><span class="p">,</span> <span class="n">runnable_load</span><span class="p">;</span>
<span class="ln"> 5798</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">spare_cap</span><span class="p">,</span> <span class="n">max_spare_cap</span><span class="p">;</span>
<span class="ln"> 5799</span>		<span class="kt">int</span> <span class="n">local_group</span><span class="p">;</span>
<span class="ln"> 5800</span>		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 5801</span>
<span class="ln"> 5802</span>		<span class="cm">/* Skip over this group if it has no CPUs allowed */</span>
<span class="ln"> 5803</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">),</span>
<span class="ln"> 5804</span>					<span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 5805</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 5806</span>
<span class="ln"> 5807</span>		<span class="n">local_group</span> <span class="o">=</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span>
<span class="ln"> 5808</span>					       <span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">));</span>
<span class="ln"> 5809</span>
<span class="ln"> 5810</span>		<span class="cm">/*
</span><span class="ln"> 5811</span><span class="cm">		 * Tally up the load of all CPUs in the group and find
</span><span class="ln"> 5812</span><span class="cm">		 * the group containing the CPU with most spare capacity.
</span><span class="ln"> 5813</span><span class="cm">		 */</span>
<span class="ln"> 5814</span>		<span class="n">avg_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5815</span>		<span class="n">runnable_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5816</span>		<span class="n">max_spare_cap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5817</span>
<span class="ln"> 5818</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 5819</span>			<span class="cm">/* Bias balancing toward CPUs of our domain */</span>
<span class="ln"> 5820</span>			<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span>
<span class="ln"> 5821</span>				<span class="n">load</span> <span class="o">=</span> <span class="n">source_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
<span class="ln"> 5822</span>			<span class="k">else</span>
<span class="ln"> 5823</span>				<span class="n">load</span> <span class="o">=</span> <span class="n">target_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
<span class="ln"> 5824</span>
<span class="ln"> 5825</span>			<span class="n">runnable_load</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 5826</span>
<span class="ln"> 5827</span>			<span class="n">avg_load</span> <span class="o">+=</span> <span class="n">cfs_rq_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">);</span>
<span class="ln"> 5828</span>
<span class="ln"> 5829</span>			<span class="n">spare_cap</span> <span class="o">=</span> <span class="n">capacity_spare_without</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 5830</span>
<span class="ln"> 5831</span>			<span class="k">if</span> <span class="p">(</span><span class="n">spare_cap</span> <span class="o">&gt;</span> <span class="n">max_spare_cap</span><span class="p">)</span>
<span class="ln"> 5832</span>				<span class="n">max_spare_cap</span> <span class="o">=</span> <span class="n">spare_cap</span><span class="p">;</span>
<span class="ln"> 5833</span>		<span class="p">}</span>
<span class="ln"> 5834</span>
<span class="ln"> 5835</span>		<span class="cm">/* Adjust by relative CPU capacity of the group */</span>
<span class="ln"> 5836</span>		<span class="n">avg_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">avg_load</span> <span class="o">*</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">)</span> <span class="o">/</span>
<span class="ln"> 5837</span>					<span class="n">group</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 5838</span>		<span class="n">runnable_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">runnable_load</span> <span class="o">*</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">)</span> <span class="o">/</span>
<span class="ln"> 5839</span>					<span class="n">group</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 5840</span>
<span class="ln"> 5841</span>		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5842</span>			<span class="n">this_runnable_load</span> <span class="o">=</span> <span class="n">runnable_load</span><span class="p">;</span>
<span class="ln"> 5843</span>			<span class="n">this_avg_load</span> <span class="o">=</span> <span class="n">avg_load</span><span class="p">;</span>
<span class="ln"> 5844</span>			<span class="n">this_spare</span> <span class="o">=</span> <span class="n">max_spare_cap</span><span class="p">;</span>
<span class="ln"> 5845</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 5846</span>			<span class="k">if</span> <span class="p">(</span><span class="n">min_runnable_load</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">runnable_load</span> <span class="o">+</span> <span class="n">imbalance</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 5847</span>				<span class="cm">/*
</span><span class="ln"> 5848</span><span class="cm">				 * The runnable load is significantly smaller
</span><span class="ln"> 5849</span><span class="cm">				 * so we can pick this new CPU:
</span><span class="ln"> 5850</span><span class="cm">				 */</span>
<span class="ln"> 5851</span>				<span class="n">min_runnable_load</span> <span class="o">=</span> <span class="n">runnable_load</span><span class="p">;</span>
<span class="ln"> 5852</span>				<span class="n">min_avg_load</span> <span class="o">=</span> <span class="n">avg_load</span><span class="p">;</span>
<span class="ln"> 5853</span>				<span class="n">idlest</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
<span class="ln"> 5854</span>			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">runnable_load</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">min_runnable_load</span> <span class="o">+</span> <span class="n">imbalance</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 5855</span>				   <span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">min_avg_load</span> <span class="o">&gt;</span> <span class="n">imbalance_scale</span><span class="o">*</span><span class="n">avg_load</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 5856</span>				<span class="cm">/*
</span><span class="ln"> 5857</span><span class="cm">				 * The runnable loads are close so take the
</span><span class="ln"> 5858</span><span class="cm">				 * blocked load into account through avg_load:
</span><span class="ln"> 5859</span><span class="cm">				 */</span>
<span class="ln"> 5860</span>				<span class="n">min_avg_load</span> <span class="o">=</span> <span class="n">avg_load</span><span class="p">;</span>
<span class="ln"> 5861</span>				<span class="n">idlest</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
<span class="ln"> 5862</span>			<span class="p">}</span>
<span class="ln"> 5863</span>
<span class="ln"> 5864</span>			<span class="k">if</span> <span class="p">(</span><span class="n">most_spare</span> <span class="o">&lt;</span> <span class="n">max_spare_cap</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5865</span>				<span class="n">most_spare</span> <span class="o">=</span> <span class="n">max_spare_cap</span><span class="p">;</span>
<span class="ln"> 5866</span>				<span class="n">most_spare_sg</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
<span class="ln"> 5867</span>			<span class="p">}</span>
<span class="ln"> 5868</span>		<span class="p">}</span>
<span class="ln"> 5869</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">group</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
<span class="ln"> 5870</span>
<span class="ln"> 5871</span>	<span class="cm">/*
</span><span class="ln"> 5872</span><span class="cm">	 * The cross-over point between using spare capacity or least load
</span><span class="ln"> 5873</span><span class="cm">	 * is too conservative for high utilization tasks on partially
</span><span class="ln"> 5874</span><span class="cm">	 * utilized systems if we require spare_capacity &gt; task_util(p),
</span><span class="ln"> 5875</span><span class="cm">	 * so we allow for some task stuffing by using
</span><span class="ln"> 5876</span><span class="cm">	 * spare_capacity &gt; task_util(p)/2.
</span><span class="ln"> 5877</span><span class="cm">	 *
</span><span class="ln"> 5878</span><span class="cm">	 * Spare capacity can&#39;t be used for fork because the utilization has
</span><span class="ln"> 5879</span><span class="cm">	 * not been set yet, we must first select a rq to compute the initial
</span><span class="ln"> 5880</span><span class="cm">	 * utilization.
</span><span class="ln"> 5881</span><span class="cm">	 */</span>
<span class="ln"> 5882</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_FORK</span><span class="p">)</span>
<span class="ln"> 5883</span>		<span class="k">goto</span> <span class="n">skip_spare</span><span class="p">;</span>
<span class="ln"> 5884</span>
<span class="ln"> 5885</span>	<span class="k">if</span> <span class="p">(</span><span class="n">this_spare</span> <span class="o">&gt;</span> <span class="n">task_util</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 5886</span>	    <span class="n">imbalance_scale</span><span class="o">*</span><span class="n">this_spare</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="o">*</span><span class="n">most_spare</span><span class="p">)</span>
<span class="ln"> 5887</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5888</span>
<span class="ln"> 5889</span>	<span class="k">if</span> <span class="p">(</span><span class="n">most_spare</span> <span class="o">&gt;</span> <span class="n">task_util</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="ln"> 5890</span>		<span class="k">return</span> <span class="n">most_spare_sg</span><span class="p">;</span>
<span class="ln"> 5891</span>
<span class="ln"> 5892</span><span class="nl">skip_spare</span><span class="p">:</span>
<span class="ln"> 5893</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idlest</span><span class="p">)</span>
<span class="ln"> 5894</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5895</span>
<span class="ln"> 5896</span>	<span class="cm">/*
</span><span class="ln"> 5897</span><span class="cm">	 * When comparing groups across NUMA domains, it&#39;s possible for the
</span><span class="ln"> 5898</span><span class="cm">	 * local domain to be very lightly loaded relative to the remote
</span><span class="ln"> 5899</span><span class="cm">	 * domains but &#34;imbalance&#34; skews the comparison making remote CPUs
</span><span class="ln"> 5900</span><span class="cm">	 * look much more favourable. When considering cross-domain, add
</span><span class="ln"> 5901</span><span class="cm">	 * imbalance to the runnable load on the remote node and consider
</span><span class="ln"> 5902</span><span class="cm">	 * staying local.
</span><span class="ln"> 5903</span><span class="cm">	 */</span>
<span class="ln"> 5904</span>	<span class="k">if</span> <span class="p">((</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_NUMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 5905</span>	    <span class="n">min_runnable_load</span> <span class="o">+</span> <span class="n">imbalance</span> <span class="o">&gt;=</span> <span class="n">this_runnable_load</span><span class="p">)</span>
<span class="ln"> 5906</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5907</span>
<span class="ln"> 5908</span>	<span class="k">if</span> <span class="p">(</span><span class="n">min_runnable_load</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">this_runnable_load</span> <span class="o">+</span> <span class="n">imbalance</span><span class="p">))</span>
<span class="ln"> 5909</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5910</span>
<span class="ln"> 5911</span>	<span class="k">if</span> <span class="p">((</span><span class="n">this_runnable_load</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">min_runnable_load</span> <span class="o">+</span> <span class="n">imbalance</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 5912</span>	     <span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">this_avg_load</span> <span class="o">&lt;</span> <span class="n">imbalance_scale</span><span class="o">*</span><span class="n">min_avg_load</span><span class="p">))</span>
<span class="ln"> 5913</span>		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 5914</span>
<span class="ln"> 5915</span>	<span class="k">return</span> <span class="n">idlest</span><span class="p">;</span>
<span class="ln"> 5916</span><span class="p">}</span>
<span class="ln"> 5917</span>
<span class="ln"> 5918</span><span class="cm">/*
</span><span class="ln"> 5919</span><span class="cm"> * find_idlest_group_cpu - find the idlest CPU among the CPUs in the group.
</span><span class="ln"> 5920</span><span class="cm"> */</span>
<span class="ln"> 5921</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln"> 5922</span><span class="nf">find_idlest_group_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">this_cpu</span><span class="p">)</span>
<span class="ln"> 5923</span><span class="p">{</span>
<span class="ln"> 5924</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">,</span> <span class="n">min_load</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
<span class="ln"> 5925</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_exit_latency</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
<span class="ln"> 5926</span>	<span class="n">u64</span> <span class="n">latest_idle_timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 5927</span>	<span class="kt">int</span> <span class="n">least_loaded_cpu</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="p">;</span>
<span class="ln"> 5928</span>	<span class="kt">int</span> <span class="n">shallowest_idle_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 5929</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 5930</span>
<span class="ln"> 5931</span>	<span class="cm">/* Check if we have any choice: */</span>
<span class="ln"> 5932</span>	<span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">group_weight</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 5933</span>		<span class="k">return</span> <span class="n">cpumask_first</span><span class="p">(</span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">));</span>
<span class="ln"> 5934</span>
<span class="ln"> 5935</span>	<span class="cm">/* Traverse only the allowed CPUs */</span>
<span class="ln"> 5936</span>	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5937</span>		<span class="k">if</span> <span class="p">(</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 5938</span>			<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln"> 5939</span>			<span class="k">struct</span> <span class="n">cpuidle_state</span> <span class="o">*</span><span class="n">idle</span> <span class="o">=</span> <span class="n">idle_get_state</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 5940</span>			<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">&amp;&amp;</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="n">exit_latency</span> <span class="o">&lt;</span> <span class="n">min_exit_latency</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5941</span>				<span class="cm">/*
</span><span class="ln"> 5942</span><span class="cm">				 * We give priority to a CPU whose idle state
</span><span class="ln"> 5943</span><span class="cm">				 * has the smallest exit latency irrespective
</span><span class="ln"> 5944</span><span class="cm">				 * of any idle timestamp.
</span><span class="ln"> 5945</span><span class="cm">				 */</span>
<span class="ln"> 5946</span>				<span class="n">min_exit_latency</span> <span class="o">=</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="n">exit_latency</span><span class="p">;</span>
<span class="ln"> 5947</span>				<span class="n">latest_idle_timestamp</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="p">;</span>
<span class="ln"> 5948</span>				<span class="n">shallowest_idle_cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 5949</span>			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">idle</span> <span class="o">||</span> <span class="n">idle</span><span class="o">-&gt;</span><span class="n">exit_latency</span> <span class="o">==</span> <span class="n">min_exit_latency</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 5950</span>				   <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">&gt;</span> <span class="n">latest_idle_timestamp</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5951</span>				<span class="cm">/*
</span><span class="ln"> 5952</span><span class="cm">				 * If equal or no active idle state, then
</span><span class="ln"> 5953</span><span class="cm">				 * the most recently idled CPU might have
</span><span class="ln"> 5954</span><span class="cm">				 * a warmer cache.
</span><span class="ln"> 5955</span><span class="cm">				 */</span>
<span class="ln"> 5956</span>				<span class="n">latest_idle_timestamp</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span><span class="p">;</span>
<span class="ln"> 5957</span>				<span class="n">shallowest_idle_cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 5958</span>			<span class="p">}</span>
<span class="ln"> 5959</span>		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shallowest_idle_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5960</span>			<span class="n">load</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="ln"> 5961</span>			<span class="k">if</span> <span class="p">(</span><span class="n">load</span> <span class="o">&lt;</span> <span class="n">min_load</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5962</span>				<span class="n">min_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 5963</span>				<span class="n">least_loaded_cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 5964</span>			<span class="p">}</span>
<span class="ln"> 5965</span>		<span class="p">}</span>
<span class="ln"> 5966</span>	<span class="p">}</span>
<span class="ln"> 5967</span>
<span class="ln"> 5968</span>	<span class="k">return</span> <span class="n">shallowest_idle_cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="nl">shallowest_idle_cpu</span> <span class="p">:</span> <span class="n">least_loaded_cpu</span><span class="p">;</span>
<span class="ln"> 5969</span><span class="p">}</span>
<span class="ln"> 5970</span>
<span class="ln"> 5971</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_idlest_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 5972</span>				  <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">)</span>
<span class="ln"> 5973</span><span class="p">{</span>
<span class="ln"> 5974</span>	<span class="kt">int</span> <span class="n">new_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 5975</span>
<span class="ln"> 5976</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_intersects</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 5977</span>		<span class="k">return</span> <span class="n">prev_cpu</span><span class="p">;</span>
<span class="ln"> 5978</span>
<span class="ln"> 5979</span>	<span class="cm">/*
</span><span class="ln"> 5980</span><span class="cm">	 * We need task&#39;s util for capacity_spare_without, sync it up to
</span><span class="ln"> 5981</span><span class="cm">	 * prev_cpu&#39;s last_update_time.
</span><span class="ln"> 5982</span><span class="cm">	 */</span>
<span class="ln"> 5983</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_FORK</span><span class="p">))</span>
<span class="ln"> 5984</span>		<span class="n">sync_entity_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 5985</span>
<span class="ln"> 5986</span>	<span class="k">while</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5987</span>		<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
<span class="ln"> 5988</span>		<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
<span class="ln"> 5989</span>		<span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
<span class="ln"> 5990</span>
<span class="ln"> 5991</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">sd_flag</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 5992</span>			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
<span class="ln"> 5993</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 5994</span>		<span class="p">}</span>
<span class="ln"> 5995</span>
<span class="ln"> 5996</span>		<span class="n">group</span> <span class="o">=</span> <span class="n">find_idlest_group</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sd_flag</span><span class="p">);</span>
<span class="ln"> 5997</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 5998</span>			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
<span class="ln"> 5999</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 6000</span>		<span class="p">}</span>
<span class="ln"> 6001</span>
<span class="ln"> 6002</span>		<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">find_idlest_group_cpu</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 6003</span>		<span class="k">if</span> <span class="p">(</span><span class="n">new_cpu</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6004</span>			<span class="cm">/* Now try balancing at a lower domain level of &#39;cpu&#39;: */</span>
<span class="ln"> 6005</span>			<span class="n">sd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
<span class="ln"> 6006</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 6007</span>		<span class="p">}</span>
<span class="ln"> 6008</span>
<span class="ln"> 6009</span>		<span class="cm">/* Now try balancing at a lower domain level of &#39;new_cpu&#39;: */</span>
<span class="ln"> 6010</span>		<span class="n">cpu</span> <span class="o">=</span> <span class="n">new_cpu</span><span class="p">;</span>
<span class="ln"> 6011</span>		<span class="n">weight</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="p">;</span>
<span class="ln"> 6012</span>		<span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 6013</span>		<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6014</span>			<span class="k">if</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="p">)</span>
<span class="ln"> 6015</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln"> 6016</span>			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">sd_flag</span><span class="p">)</span>
<span class="ln"> 6017</span>				<span class="n">sd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="ln"> 6018</span>		<span class="p">}</span>
<span class="ln"> 6019</span>	<span class="p">}</span>
<span class="ln"> 6020</span>
<span class="ln"> 6021</span>	<span class="k">return</span> <span class="n">new_cpu</span><span class="p">;</span>
<span class="ln"> 6022</span><span class="p">}</span>
<span class="ln"> 6023</span>
<span class="ln"> 6024</span><span class="cp">#ifdef CONFIG_SCHED_SMT
</span><span class="ln"> 6025</span><span class="cp"></span><span class="n">DEFINE_STATIC_KEY_FALSE</span><span class="p">(</span><span class="n">sched_smt_present</span><span class="p">);</span>
<span class="ln"> 6026</span><span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sched_smt_present</span><span class="p">);</span>
<span class="ln"> 6027</span>
<span class="ln"> 6028</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_idle_cores</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="ln"> 6029</span><span class="p">{</span>
<span class="ln"> 6030</span>	<span class="k">struct</span> <span class="n">sched_domain_shared</span> <span class="o">*</span><span class="n">sds</span><span class="p">;</span>
<span class="ln"> 6031</span>
<span class="ln"> 6032</span>	<span class="n">sds</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_shared</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 6033</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 6034</span>		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">has_idle_cores</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="ln"> 6035</span><span class="p">}</span>
<span class="ln"> 6036</span>
<span class="ln"> 6037</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">test_idle_cores</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">def</span><span class="p">)</span>
<span class="ln"> 6038</span><span class="p">{</span>
<span class="ln"> 6039</span>	<span class="k">struct</span> <span class="n">sched_domain_shared</span> <span class="o">*</span><span class="n">sds</span><span class="p">;</span>
<span class="ln"> 6040</span>
<span class="ln"> 6041</span>	<span class="n">sds</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_shared</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 6042</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 6043</span>		<span class="k">return</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">has_idle_cores</span><span class="p">);</span>
<span class="ln"> 6044</span>
<span class="ln"> 6045</span>	<span class="k">return</span> <span class="n">def</span><span class="p">;</span>
<span class="ln"> 6046</span><span class="p">}</span>
<span class="ln"> 6047</span>
<span class="ln"> 6048</span><span class="cm">/*
</span><span class="ln"> 6049</span><span class="cm"> * Scans the local SMT mask to see if the entire core is idle, and records this
</span><span class="ln"> 6050</span><span class="cm"> * information in sd_llc_shared-&gt;has_idle_cores.
</span><span class="ln"> 6051</span><span class="cm"> *
</span><span class="ln"> 6052</span><span class="cm"> * Since SMT siblings share all cache levels, inspecting this limited remote
</span><span class="ln"> 6053</span><span class="cm"> * state should be fairly cheap.
</span><span class="ln"> 6054</span><span class="cm"> */</span>
<span class="ln"> 6055</span><span class="kt">void</span> <span class="nf">__update_idle_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 6056</span><span class="p">{</span>
<span class="ln"> 6057</span>	<span class="kt">int</span> <span class="n">core</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 6058</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 6059</span>
<span class="ln"> 6060</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 6061</span>	<span class="k">if</span> <span class="p">(</span><span class="n">test_idle_cores</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
<span class="ln"> 6062</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 6063</span>
<span class="ln"> 6064</span>	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_smt_mask</span><span class="p">(</span><span class="n">core</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6065</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">core</span><span class="p">)</span>
<span class="ln"> 6066</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 6067</span>
<span class="ln"> 6068</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 6069</span>			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 6070</span>	<span class="p">}</span>
<span class="ln"> 6071</span>
<span class="ln"> 6072</span>	<span class="n">set_idle_cores</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 6073</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln"> 6074</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 6075</span><span class="p">}</span>
<span class="ln"> 6076</span>
<span class="ln"> 6077</span><span class="cm">/*
</span><span class="ln"> 6078</span><span class="cm"> * Scan the entire LLC domain for idle cores; this dynamically switches off if
</span><span class="ln"> 6079</span><span class="cm"> * there are no idle cores left in the system; tracked through
</span><span class="ln"> 6080</span><span class="cm"> * sd_llc-&gt;shared-&gt;has_idle_cores and enabled through update_idle_core() above.
</span><span class="ln"> 6081</span><span class="cm"> */</span>
<span class="ln"> 6082</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_idle_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="ln"> 6083</span><span class="p">{</span>
<span class="ln"> 6084</span>	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span> <span class="o">=</span> <span class="n">this_cpu_cpumask_var_ptr</span><span class="p">(</span><span class="n">select_idle_mask</span><span class="p">);</span>
<span class="ln"> 6085</span>	<span class="kt">int</span> <span class="n">core</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 6086</span>
<span class="ln"> 6087</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_smt_present</span><span class="p">))</span>
<span class="ln"> 6088</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6089</span>
<span class="ln"> 6090</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_idle_cores</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
<span class="ln"> 6091</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6092</span>
<span class="ln"> 6093</span>	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln"> 6094</span>
<span class="ln"> 6095</span>	<span class="n">for_each_cpu_wrap</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="n">cpus</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6096</span>		<span class="kt">bool</span> <span class="n">idle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 6097</span>
<span class="ln"> 6098</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_smt_mask</span><span class="p">(</span><span class="n">core</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6099</span>			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpus</span><span class="p">);</span>
<span class="ln"> 6100</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 6101</span>				<span class="n">idle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 6102</span>		<span class="p">}</span>
<span class="ln"> 6103</span>
<span class="ln"> 6104</span>		<span class="k">if</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span>
<span class="ln"> 6105</span>			<span class="k">return</span> <span class="n">core</span><span class="p">;</span>
<span class="ln"> 6106</span>	<span class="p">}</span>
<span class="ln"> 6107</span>
<span class="ln"> 6108</span>	<span class="cm">/*
</span><span class="ln"> 6109</span><span class="cm">	 * Failed to find an idle core; stop looking for one.
</span><span class="ln"> 6110</span><span class="cm">	 */</span>
<span class="ln"> 6111</span>	<span class="n">set_idle_cores</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 6112</span>
<span class="ln"> 6113</span>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6114</span><span class="p">}</span>
<span class="ln"> 6115</span>
<span class="ln"> 6116</span><span class="cm">/*
</span><span class="ln"> 6117</span><span class="cm"> * Scan the local SMT mask for idle CPUs.
</span><span class="ln"> 6118</span><span class="cm"> */</span>
<span class="ln"> 6119</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_idle_smt</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="ln"> 6120</span><span class="p">{</span>
<span class="ln"> 6121</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 6122</span>
<span class="ln"> 6123</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_smt_present</span><span class="p">))</span>
<span class="ln"> 6124</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6125</span>
<span class="ln"> 6126</span>	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu_smt_mask</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6127</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 6128</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 6129</span>		<span class="k">if</span> <span class="p">(</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 6130</span>			<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 6131</span>	<span class="p">}</span>
<span class="ln"> 6132</span>
<span class="ln"> 6133</span>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6134</span><span class="p">}</span>
<span class="ln"> 6135</span>
<span class="ln"> 6136</span><span class="cp">#else </span><span class="cm">/* CONFIG_SCHED_SMT */</span><span class="cp">
</span><span class="ln"> 6137</span><span class="cp"></span>
<span class="ln"> 6138</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">select_idle_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="ln"> 6139</span><span class="p">{</span>
<span class="ln"> 6140</span>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6141</span><span class="p">}</span>
<span class="ln"> 6142</span>
<span class="ln"> 6143</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">select_idle_smt</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="ln"> 6144</span><span class="p">{</span>
<span class="ln"> 6145</span>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6146</span><span class="p">}</span>
<span class="ln"> 6147</span>
<span class="ln"> 6148</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_SMT */</span><span class="cp">
</span><span class="ln"> 6149</span><span class="cp"></span>
<span class="ln"> 6150</span><span class="cm">/*
</span><span class="ln"> 6151</span><span class="cm"> * Scan the LLC domain for idle CPUs; this is dynamically regulated by
</span><span class="ln"> 6152</span><span class="cm"> * comparing the average scan cost (tracked in sd-&gt;avg_scan_cost) against the
</span><span class="ln"> 6153</span><span class="cm"> * average idle time for this rq (as found in rq-&gt;avg_idle).
</span><span class="ln"> 6154</span><span class="cm"> */</span>
<span class="ln"> 6155</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_idle_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="ln"> 6156</span><span class="p">{</span>
<span class="ln"> 6157</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">this_sd</span><span class="p">;</span>
<span class="ln"> 6158</span>	<span class="n">u64</span> <span class="n">avg_cost</span><span class="p">,</span> <span class="n">avg_idle</span><span class="p">;</span>
<span class="ln"> 6159</span>	<span class="n">u64</span> <span class="n">time</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span>
<span class="ln"> 6160</span>	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 6161</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
<span class="ln"> 6162</span>
<span class="ln"> 6163</span>	<span class="n">this_sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="o">*</span><span class="n">this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd_llc</span><span class="p">));</span>
<span class="ln"> 6164</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_sd</span><span class="p">)</span>
<span class="ln"> 6165</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6166</span>
<span class="ln"> 6167</span>	<span class="cm">/*
</span><span class="ln"> 6168</span><span class="cm">	 * Due to large variance we need a large fuzz factor; hackbench in
</span><span class="ln"> 6169</span><span class="cm">	 * particularly is sensitive here.
</span><span class="ln"> 6170</span><span class="cm">	 */</span>
<span class="ln"> 6171</span>	<span class="n">avg_idle</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>
<span class="ln"> 6172</span>	<span class="n">avg_cost</span> <span class="o">=</span> <span class="n">this_sd</span><span class="o">-&gt;</span><span class="n">avg_scan_cost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6173</span>
<span class="ln"> 6174</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">SIS_AVG_CPU</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">avg_idle</span> <span class="o">&lt;</span> <span class="n">avg_cost</span><span class="p">)</span>
<span class="ln"> 6175</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6176</span>
<span class="ln"> 6177</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">SIS_PROP</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6178</span>		<span class="n">u64</span> <span class="n">span_avg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span> <span class="o">*</span> <span class="n">avg_idle</span><span class="p">;</span>
<span class="ln"> 6179</span>		<span class="k">if</span> <span class="p">(</span><span class="n">span_avg</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">*</span><span class="n">avg_cost</span><span class="p">)</span>
<span class="ln"> 6180</span>			<span class="n">nr</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">span_avg</span><span class="p">,</span> <span class="n">avg_cost</span><span class="p">);</span>
<span class="ln"> 6181</span>		<span class="k">else</span>
<span class="ln"> 6182</span>			<span class="n">nr</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="ln"> 6183</span>	<span class="p">}</span>
<span class="ln"> 6184</span>
<span class="ln"> 6185</span>	<span class="n">time</span> <span class="o">=</span> <span class="n">local_clock</span><span class="p">();</span>
<span class="ln"> 6186</span>
<span class="ln"> 6187</span>	<span class="n">for_each_cpu_wrap</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6188</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">nr</span><span class="p">)</span>
<span class="ln"> 6189</span>			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6190</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span>
<span class="ln"> 6191</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 6192</span>		<span class="k">if</span> <span class="p">(</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 6193</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 6194</span>	<span class="p">}</span>
<span class="ln"> 6195</span>
<span class="ln"> 6196</span>	<span class="n">time</span> <span class="o">=</span> <span class="n">local_clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">time</span><span class="p">;</span>
<span class="ln"> 6197</span>	<span class="n">cost</span> <span class="o">=</span> <span class="n">this_sd</span><span class="o">-&gt;</span><span class="n">avg_scan_cost</span><span class="p">;</span>
<span class="ln"> 6198</span>	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64</span><span class="p">)(</span><span class="n">time</span> <span class="o">-</span> <span class="n">cost</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
<span class="ln"> 6199</span>	<span class="n">this_sd</span><span class="o">-&gt;</span><span class="n">avg_scan_cost</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 6200</span>
<span class="ln"> 6201</span>	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 6202</span><span class="p">}</span>
<span class="ln"> 6203</span>
<span class="ln"> 6204</span><span class="cm">/*
</span><span class="ln"> 6205</span><span class="cm"> * Try and locate an idle core/thread in the LLC cache domain.
</span><span class="ln"> 6206</span><span class="cm"> */</span>
<span class="ln"> 6207</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">select_idle_sibling</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="ln"> 6208</span><span class="p">{</span>
<span class="ln"> 6209</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 6210</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">recent_used_cpu</span><span class="p">;</span>
<span class="ln"> 6211</span>
<span class="ln"> 6212</span>	<span class="k">if</span> <span class="p">(</span><span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
<span class="ln"> 6213</span>		<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="ln"> 6214</span>
<span class="ln"> 6215</span>	<span class="cm">/*
</span><span class="ln"> 6216</span><span class="cm">	 * If the previous CPU is cache affine and idle, don&#39;t be stupid:
</span><span class="ln"> 6217</span><span class="cm">	 */</span>
<span class="ln"> 6218</span>	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">cpus_share_cache</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
<span class="ln"> 6219</span>		<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
<span class="ln"> 6220</span>
<span class="ln"> 6221</span>	<span class="cm">/* Check a recently used CPU as a potential idle candidate: */</span>
<span class="ln"> 6222</span>	<span class="n">recent_used_cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">recent_used_cpu</span><span class="p">;</span>
<span class="ln"> 6223</span>	<span class="k">if</span> <span class="p">(</span><span class="n">recent_used_cpu</span> <span class="o">!=</span> <span class="n">prev</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 6224</span>	    <span class="n">recent_used_cpu</span> <span class="o">!=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 6225</span>	    <span class="n">cpus_share_cache</span><span class="p">(</span><span class="n">recent_used_cpu</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 6226</span>	    <span class="n">available_idle_cpu</span><span class="p">(</span><span class="n">recent_used_cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 6227</span>	    <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">recent_used_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6228</span>		<span class="cm">/*
</span><span class="ln"> 6229</span><span class="cm">		 * Replace recent_used_cpu with prev as it is a potential
</span><span class="ln"> 6230</span><span class="cm">		 * candidate for the next wake:
</span><span class="ln"> 6231</span><span class="cm">		 */</span>
<span class="ln"> 6232</span>		<span class="n">p</span><span class="o">-&gt;</span><span class="n">recent_used_cpu</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
<span class="ln"> 6233</span>		<span class="k">return</span> <span class="n">recent_used_cpu</span><span class="p">;</span>
<span class="ln"> 6234</span>	<span class="p">}</span>
<span class="ln"> 6235</span>
<span class="ln"> 6236</span>	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc</span><span class="p">,</span> <span class="n">target</span><span class="p">));</span>
<span class="ln"> 6237</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span>
<span class="ln"> 6238</span>		<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="ln"> 6239</span>
<span class="ln"> 6240</span>	<span class="n">i</span> <span class="o">=</span> <span class="n">select_idle_core</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="ln"> 6241</span>	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpumask_bits</span><span class="p">)</span>
<span class="ln"> 6242</span>		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 6243</span>
<span class="ln"> 6244</span>	<span class="n">i</span> <span class="o">=</span> <span class="n">select_idle_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="ln"> 6245</span>	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpumask_bits</span><span class="p">)</span>
<span class="ln"> 6246</span>		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 6247</span>
<span class="ln"> 6248</span>	<span class="n">i</span> <span class="o">=</span> <span class="n">select_idle_smt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="ln"> 6249</span>	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_cpumask_bits</span><span class="p">)</span>
<span class="ln"> 6250</span>		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 6251</span>
<span class="ln"> 6252</span>	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="ln"> 6253</span><span class="p">}</span>
<span class="ln"> 6254</span>
<span class="ln"> 6255</span><span class="cm">/**
</span><span class="ln"> 6256</span><span class="cm"> * Amount of capacity of a CPU that is (estimated to be) used by CFS tasks
</span><span class="ln"> 6257</span><span class="cm"> * @cpu: the CPU to get the utilization of
</span><span class="ln"> 6258</span><span class="cm"> *
</span><span class="ln"> 6259</span><span class="cm"> * The unit of the return value must be the one of capacity so we can compare
</span><span class="ln"> 6260</span><span class="cm"> * the utilization with the capacity of the CPU that is available for CFS task
</span><span class="ln"> 6261</span><span class="cm"> * (ie cpu_capacity).
</span><span class="ln"> 6262</span><span class="cm"> *
</span><span class="ln"> 6263</span><span class="cm"> * cfs_rq.avg.util_avg is the sum of running time of runnable tasks plus the
</span><span class="ln"> 6264</span><span class="cm"> * recent utilization of currently non-runnable tasks on a CPU. It represents
</span><span class="ln"> 6265</span><span class="cm"> * the amount of utilization of a CPU in the range [0..capacity_orig] where
</span><span class="ln"> 6266</span><span class="cm"> * capacity_orig is the cpu_capacity available at the highest frequency
</span><span class="ln"> 6267</span><span class="cm"> * (arch_scale_freq_capacity()).
</span><span class="ln"> 6268</span><span class="cm"> * The utilization of a CPU converges towards a sum equal to or less than the
</span><span class="ln"> 6269</span><span class="cm"> * current capacity (capacity_curr &lt;= capacity_orig) of the CPU because it is
</span><span class="ln"> 6270</span><span class="cm"> * the running time on this CPU scaled by capacity_curr.
</span><span class="ln"> 6271</span><span class="cm"> *
</span><span class="ln"> 6272</span><span class="cm"> * The estimated utilization of a CPU is defined to be the maximum between its
</span><span class="ln"> 6273</span><span class="cm"> * cfs_rq.avg.util_avg and the sum of the estimated utilization of the tasks
</span><span class="ln"> 6274</span><span class="cm"> * currently RUNNABLE on that CPU.
</span><span class="ln"> 6275</span><span class="cm"> * This allows to properly represent the expected utilization of a CPU which
</span><span class="ln"> 6276</span><span class="cm"> * has just got a big task running since a long sleep period. At the same time
</span><span class="ln"> 6277</span><span class="cm"> * however it preserves the benefits of the &#34;blocked utilization&#34; in
</span><span class="ln"> 6278</span><span class="cm"> * describing the potential for other tasks waking up on the same CPU.
</span><span class="ln"> 6279</span><span class="cm"> *
</span><span class="ln"> 6280</span><span class="cm"> * Nevertheless, cfs_rq.avg.util_avg can be higher than capacity_curr or even
</span><span class="ln"> 6281</span><span class="cm"> * higher than capacity_orig because of unfortunate rounding in
</span><span class="ln"> 6282</span><span class="cm"> * cfs.avg.util_avg or just after migrating tasks and new task wakeups until
</span><span class="ln"> 6283</span><span class="cm"> * the average stabilizes with the new running time. We need to check that the
</span><span class="ln"> 6284</span><span class="cm"> * utilization stays within the range of [0..capacity_orig] and cap it if
</span><span class="ln"> 6285</span><span class="cm"> * necessary. Without utilization capping, a group could be seen as overloaded
</span><span class="ln"> 6286</span><span class="cm"> * (CPU0 utilization at 121% + CPU1 utilization at 80%) whereas CPU1 has 20% of
</span><span class="ln"> 6287</span><span class="cm"> * available capacity. We allow utilization to overshoot capacity_curr (but not
</span><span class="ln"> 6288</span><span class="cm"> * capacity_orig) as it useful for predicting the capacity required after task
</span><span class="ln"> 6289</span><span class="cm"> * migrations (scheduler-driven DVFS).
</span><span class="ln"> 6290</span><span class="cm"> *
</span><span class="ln"> 6291</span><span class="cm"> * Return: the (estimated) utilization for the specified CPU
</span><span class="ln"> 6292</span><span class="cm"> */</span>
<span class="ln"> 6293</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cpu_util</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 6294</span><span class="p">{</span>
<span class="ln"> 6295</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 6296</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">util</span><span class="p">;</span>
<span class="ln"> 6297</span>
<span class="ln"> 6298</span>	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln"> 6299</span>	<span class="n">util</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">);</span>
<span class="ln"> 6300</span>
<span class="ln"> 6301</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">UTIL_EST</span><span class="p">))</span>
<span class="ln"> 6302</span>		<span class="n">util</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">util</span><span class="p">,</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="p">));</span>
<span class="ln"> 6303</span>
<span class="ln"> 6304</span>	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">capacity_orig_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 6305</span><span class="p">}</span>
<span class="ln"> 6306</span>
<span class="ln"> 6307</span><span class="cm">/*
</span><span class="ln"> 6308</span><span class="cm"> * cpu_util_without: compute cpu utilization without any contributions from *p
</span><span class="ln"> 6309</span><span class="cm"> * @cpu: the CPU which utilization is requested
</span><span class="ln"> 6310</span><span class="cm"> * @p: the task which utilization should be discounted
</span><span class="ln"> 6311</span><span class="cm"> *
</span><span class="ln"> 6312</span><span class="cm"> * The utilization of a CPU is defined by the utilization of tasks currently
</span><span class="ln"> 6313</span><span class="cm"> * enqueued on that CPU as well as tasks which are currently sleeping after an
</span><span class="ln"> 6314</span><span class="cm"> * execution on that CPU.
</span><span class="ln"> 6315</span><span class="cm"> *
</span><span class="ln"> 6316</span><span class="cm"> * This method returns the utilization of the specified CPU by discounting the
</span><span class="ln"> 6317</span><span class="cm"> * utilization of the specified task, whenever the task is currently
</span><span class="ln"> 6318</span><span class="cm"> * contributing to the CPU utilization.
</span><span class="ln"> 6319</span><span class="cm"> */</span>
<span class="ln"> 6320</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">cpu_util_without</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 6321</span><span class="p">{</span>
<span class="ln"> 6322</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 6323</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">util</span><span class="p">;</span>
<span class="ln"> 6324</span>
<span class="ln"> 6325</span>	<span class="cm">/* Task has no contribution or is new */</span>
<span class="ln"> 6326</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">))</span>
<span class="ln"> 6327</span>		<span class="k">return</span> <span class="n">cpu_util</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 6328</span>
<span class="ln"> 6329</span>	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln"> 6330</span>	<span class="n">util</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">);</span>
<span class="ln"> 6331</span>
<span class="ln"> 6332</span>	<span class="cm">/* Discount task&#39;s util from CPU&#39;s util */</span>
<span class="ln"> 6333</span>	<span class="n">util</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">task_util</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln"> 6334</span>
<span class="ln"> 6335</span>	<span class="cm">/*
</span><span class="ln"> 6336</span><span class="cm">	 * Covered cases:
</span><span class="ln"> 6337</span><span class="cm">	 *
</span><span class="ln"> 6338</span><span class="cm">	 * a) if *p is the only task sleeping on this CPU, then:
</span><span class="ln"> 6339</span><span class="cm">	 *      cpu_util (== task_util) &gt; util_est (== 0)
</span><span class="ln"> 6340</span><span class="cm">	 *    and thus we return:
</span><span class="ln"> 6341</span><span class="cm">	 *      cpu_util_without = (cpu_util - task_util) = 0
</span><span class="ln"> 6342</span><span class="cm">	 *
</span><span class="ln"> 6343</span><span class="cm">	 * b) if other tasks are SLEEPING on this CPU, which is now exiting
</span><span class="ln"> 6344</span><span class="cm">	 *    IDLE, then:
</span><span class="ln"> 6345</span><span class="cm">	 *      cpu_util &gt;= task_util
</span><span class="ln"> 6346</span><span class="cm">	 *      cpu_util &gt; util_est (== 0)
</span><span class="ln"> 6347</span><span class="cm">	 *    and thus we discount *p&#39;s blocked utilization to return:
</span><span class="ln"> 6348</span><span class="cm">	 *      cpu_util_without = (cpu_util - task_util) &gt;= 0
</span><span class="ln"> 6349</span><span class="cm">	 *
</span><span class="ln"> 6350</span><span class="cm">	 * c) if other tasks are RUNNABLE on that CPU and
</span><span class="ln"> 6351</span><span class="cm">	 *      util_est &gt; cpu_util
</span><span class="ln"> 6352</span><span class="cm">	 *    then we use util_est since it returns a more restrictive
</span><span class="ln"> 6353</span><span class="cm">	 *    estimation of the spare capacity on that CPU, by just
</span><span class="ln"> 6354</span><span class="cm">	 *    considering the expected utilization of tasks already
</span><span class="ln"> 6355</span><span class="cm">	 *    runnable on that CPU.
</span><span class="ln"> 6356</span><span class="cm">	 *
</span><span class="ln"> 6357</span><span class="cm">	 * Cases a) and b) are covered by the above code, while case c) is
</span><span class="ln"> 6358</span><span class="cm">	 * covered by the following code when estimated utilization is
</span><span class="ln"> 6359</span><span class="cm">	 * enabled.
</span><span class="ln"> 6360</span><span class="cm">	 */</span>
<span class="ln"> 6361</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">UTIL_EST</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6362</span>		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">estimated</span> <span class="o">=</span>
<span class="ln"> 6363</span>			<span class="n">READ_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="p">);</span>
<span class="ln"> 6364</span>
<span class="ln"> 6365</span>		<span class="cm">/*
</span><span class="ln"> 6366</span><span class="cm">		 * Despite the following checks we still have a small window
</span><span class="ln"> 6367</span><span class="cm">		 * for a possible race, when an execl&#39;s select_task_rq_fair()
</span><span class="ln"> 6368</span><span class="cm">		 * races with LB&#39;s detach_task():
</span><span class="ln"> 6369</span><span class="cm">		 *
</span><span class="ln"> 6370</span><span class="cm">		 *   detach_task()
</span><span class="ln"> 6371</span><span class="cm">		 *     p-&gt;on_rq = TASK_ON_RQ_MIGRATING;
</span><span class="ln"> 6372</span><span class="cm">		 *     ---------------------------------- A
</span><span class="ln"> 6373</span><span class="cm">		 *     deactivate_task()                   \
</span><span class="ln"> 6374</span><span class="cm">		 *       dequeue_task()                     + RaceTime
</span><span class="ln"> 6375</span><span class="cm">		 *         util_est_dequeue()              /
</span><span class="ln"> 6376</span><span class="cm">		 *     ---------------------------------- B
</span><span class="ln"> 6377</span><span class="cm">		 *
</span><span class="ln"> 6378</span><span class="cm">		 * The additional check on &#34;current == p&#34; it&#39;s required to
</span><span class="ln"> 6379</span><span class="cm">		 * properly fix the execl regression and it helps in further
</span><span class="ln"> 6380</span><span class="cm">		 * reducing the chances for the above race.
</span><span class="ln"> 6381</span><span class="cm">		 */</span>
<span class="ln"> 6382</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">current</span> <span class="o">==</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6383</span>			<span class="n">estimated</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">estimated</span><span class="p">,</span>
<span class="ln"> 6384</span>					   <span class="p">(</span><span class="n">_task_util_est</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">UTIL_AVG_UNCHANGED</span><span class="p">));</span>
<span class="ln"> 6385</span>		<span class="p">}</span>
<span class="ln"> 6386</span>		<span class="n">util</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">util</span><span class="p">,</span> <span class="n">estimated</span><span class="p">);</span>
<span class="ln"> 6387</span>	<span class="p">}</span>
<span class="ln"> 6388</span>
<span class="ln"> 6389</span>	<span class="cm">/*
</span><span class="ln"> 6390</span><span class="cm">	 * Utilization (estimated) can exceed the CPU capacity, thus let&#39;s
</span><span class="ln"> 6391</span><span class="cm">	 * clamp to the maximum CPU capacity to ensure consistency with
</span><span class="ln"> 6392</span><span class="cm">	 * the cpu_util call.
</span><span class="ln"> 6393</span><span class="cm">	 */</span>
<span class="ln"> 6394</span>	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">capacity_orig_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 6395</span><span class="p">}</span>
<span class="ln"> 6396</span>
<span class="ln"> 6397</span><span class="cm">/*
</span><span class="ln"> 6398</span><span class="cm"> * Disable WAKE_AFFINE in the case where task @p doesn&#39;t fit in the
</span><span class="ln"> 6399</span><span class="cm"> * capacity of either the waking CPU @cpu or the previous CPU @prev_cpu.
</span><span class="ln"> 6400</span><span class="cm"> *
</span><span class="ln"> 6401</span><span class="cm"> * In that case WAKE_AFFINE doesn&#39;t make sense and we&#39;ll let
</span><span class="ln"> 6402</span><span class="cm"> * BALANCE_WAKE sort things out.
</span><span class="ln"> 6403</span><span class="cm"> */</span>
<span class="ln"> 6404</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">wake_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">)</span>
<span class="ln"> 6405</span><span class="p">{</span>
<span class="ln"> 6406</span>	<span class="kt">long</span> <span class="n">min_cap</span><span class="p">,</span> <span class="n">max_cap</span><span class="p">;</span>
<span class="ln"> 6407</span>
<span class="ln"> 6408</span>	<span class="n">min_cap</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">capacity_orig_of</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">),</span> <span class="n">capacity_orig_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 6409</span>	<span class="n">max_cap</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">max_cpu_capacity</span><span class="p">;</span>
<span class="ln"> 6410</span>
<span class="ln"> 6411</span>	<span class="cm">/* Minimum capacity is close to max, no need to abort wake_affine */</span>
<span class="ln"> 6412</span>	<span class="k">if</span> <span class="p">(</span><span class="n">max_cap</span> <span class="o">-</span> <span class="n">min_cap</span> <span class="o">&lt;</span> <span class="n">max_cap</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="ln"> 6413</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6414</span>
<span class="ln"> 6415</span>	<span class="cm">/* Bring task utilization in sync with prev_cpu */</span>
<span class="ln"> 6416</span>	<span class="n">sync_entity_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6417</span>
<span class="ln"> 6418</span>	<span class="k">return</span> <span class="n">min_cap</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&lt;</span> <span class="n">task_util</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity_margin</span><span class="p">;</span>
<span class="ln"> 6419</span><span class="p">}</span>
<span class="ln"> 6420</span>
<span class="ln"> 6421</span><span class="cm">/*
</span><span class="ln"> 6422</span><span class="cm"> * select_task_rq_fair: Select target runqueue for the waking task in domains
</span><span class="ln"> 6423</span><span class="cm"> * that have the &#39;sd_flag&#39; flag set. In practice, this is SD_BALANCE_WAKE,
</span><span class="ln"> 6424</span><span class="cm"> * SD_BALANCE_FORK, or SD_BALANCE_EXEC.
</span><span class="ln"> 6425</span><span class="cm"> *
</span><span class="ln"> 6426</span><span class="cm"> * Balances load by selecting the idlest CPU in the idlest group, or under
</span><span class="ln"> 6427</span><span class="cm"> * certain conditions an idle sibling CPU if the domain has SD_WAKE_AFFINE set.
</span><span class="ln"> 6428</span><span class="cm"> *
</span><span class="ln"> 6429</span><span class="cm"> * Returns the target CPU number.
</span><span class="ln"> 6430</span><span class="cm"> *
</span><span class="ln"> 6431</span><span class="cm"> * preempt must be disabled.
</span><span class="ln"> 6432</span><span class="cm"> */</span>
<span class="ln"> 6433</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln"> 6434</span><span class="nf">select_task_rq_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln"> 6435</span><span class="p">{</span>
<span class="ln"> 6436</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 6437</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="ln"> 6438</span>	<span class="kt">int</span> <span class="n">new_cpu</span> <span class="o">=</span> <span class="n">prev_cpu</span><span class="p">;</span>
<span class="ln"> 6439</span>	<span class="kt">int</span> <span class="n">want_affine</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6440</span>	<span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_SYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">);</span>
<span class="ln"> 6441</span>
<span class="ln"> 6442</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6443</span>		<span class="n">record_wakee</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 6444</span>		<span class="n">want_affine</span> <span class="o">=</span> <span class="o">!</span><span class="n">wake_wide</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wake_cap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">)</span>
<span class="ln"> 6445</span>			      <span class="o">&amp;&amp;</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">);</span>
<span class="ln"> 6446</span>	<span class="p">}</span>
<span class="ln"> 6447</span>
<span class="ln"> 6448</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 6449</span>	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6450</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span>
<span class="ln"> 6451</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 6452</span>
<span class="ln"> 6453</span>		<span class="cm">/*
</span><span class="ln"> 6454</span><span class="cm">		 * If both &#39;cpu&#39; and &#39;prev_cpu&#39; are part of this domain,
</span><span class="ln"> 6455</span><span class="cm">		 * cpu is a valid SD_WAKE_AFFINE target.
</span><span class="ln"> 6456</span><span class="cm">		 */</span>
<span class="ln"> 6457</span>		<span class="k">if</span> <span class="p">(</span><span class="n">want_affine</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_WAKE_AFFINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 6458</span>		    <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">tmp</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 6459</span>			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">prev_cpu</span><span class="p">)</span>
<span class="ln"> 6460</span>				<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">wake_affine</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
<span class="ln"> 6461</span>
<span class="ln"> 6462</span>			<span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Prefer wake_affine over balance flags */</span>
<span class="ln"> 6463</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 6464</span>		<span class="p">}</span>
<span class="ln"> 6465</span>
<span class="ln"> 6466</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">sd_flag</span><span class="p">)</span>
<span class="ln"> 6467</span>			<span class="n">sd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="ln"> 6468</span>		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want_affine</span><span class="p">)</span>
<span class="ln"> 6469</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 6470</span>	<span class="p">}</span>
<span class="ln"> 6471</span>
<span class="ln"> 6472</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6473</span>		<span class="cm">/* Slow path */</span>
<span class="ln"> 6474</span>		<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">find_idlest_cpu</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="n">sd_flag</span><span class="p">);</span>
<span class="ln"> 6475</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_WAKE</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* XXX always ? */</span>
<span class="ln"> 6476</span>		<span class="cm">/* Fast path */</span>
<span class="ln"> 6477</span>
<span class="ln"> 6478</span>		<span class="n">new_cpu</span> <span class="o">=</span> <span class="n">select_idle_sibling</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prev_cpu</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln"> 6479</span>
<span class="ln"> 6480</span>		<span class="k">if</span> <span class="p">(</span><span class="n">want_affine</span><span class="p">)</span>
<span class="ln"> 6481</span>			<span class="n">current</span><span class="o">-&gt;</span><span class="n">recent_used_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 6482</span>	<span class="p">}</span>
<span class="ln"> 6483</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 6484</span>
<span class="ln"> 6485</span>	<span class="k">return</span> <span class="n">new_cpu</span><span class="p">;</span>
<span class="ln"> 6486</span><span class="p">}</span>
<span class="ln"> 6487</span>
<span class="ln"> 6488</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_entity_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6489</span>
<span class="ln"> 6490</span><span class="cm">/*
</span><span class="ln"> 6491</span><span class="cm"> * Called immediately before a task is migrated to a new CPU; task_cpu(p) and
</span><span class="ln"> 6492</span><span class="cm"> * cfs_rq_of(p) references at time of call are still valid and identify the
</span><span class="ln"> 6493</span><span class="cm"> * previous CPU. The caller guarantees p-&gt;pi_lock or task_rq(p)-&gt;lock is held.
</span><span class="ln"> 6494</span><span class="cm"> */</span>
<span class="ln"> 6495</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">migrate_task_rq_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_cpu</span><span class="p">)</span>
<span class="ln"> 6496</span><span class="p">{</span>
<span class="ln"> 6497</span>	<span class="cm">/*
</span><span class="ln"> 6498</span><span class="cm">	 * As blocked tasks retain absolute vruntime the migration needs to
</span><span class="ln"> 6499</span><span class="cm">	 * deal with this by subtracting the old and adding the new
</span><span class="ln"> 6500</span><span class="cm">	 * min_vruntime -- the latter is done by enqueue_entity() when placing
</span><span class="ln"> 6501</span><span class="cm">	 * the task on the new runqueue.
</span><span class="ln"> 6502</span><span class="cm">	 */</span>
<span class="ln"> 6503</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_WAKING</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6504</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6505</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6506</span>		<span class="n">u64</span> <span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 6507</span>
<span class="ln"> 6508</span><span class="cp">#ifndef CONFIG_64BIT
</span><span class="ln"> 6509</span><span class="cp"></span>		<span class="n">u64</span> <span class="n">min_vruntime_copy</span><span class="p">;</span>
<span class="ln"> 6510</span>
<span class="ln"> 6511</span>		<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 6512</span>			<span class="n">min_vruntime_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime_copy</span><span class="p">;</span>
<span class="ln"> 6513</span>			<span class="n">smp_rmb</span><span class="p">();</span>
<span class="ln"> 6514</span>			<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 6515</span>		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">min_vruntime</span> <span class="o">!=</span> <span class="n">min_vruntime_copy</span><span class="p">);</span>
<span class="ln"> 6516</span><span class="cp">#else
</span><span class="ln"> 6517</span><span class="cp"></span>		<span class="n">min_vruntime</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 6518</span><span class="cp">#endif
</span><span class="ln"> 6519</span><span class="cp"></span>
<span class="ln"> 6520</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 6521</span>	<span class="p">}</span>
<span class="ln"> 6522</span>
<span class="ln"> 6523</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">==</span> <span class="n">TASK_ON_RQ_MIGRATING</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6524</span>		<span class="cm">/*
</span><span class="ln"> 6525</span><span class="cm">		 * In case of TASK_ON_RQ_MIGRATING we in fact hold the &#39;old&#39;
</span><span class="ln"> 6526</span><span class="cm">		 * rq-&gt;lock and can modify state directly.
</span><span class="ln"> 6527</span><span class="cm">		 */</span>
<span class="ln"> 6528</span>		<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 6529</span>		<span class="n">detach_entity_cfs_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6530</span>
<span class="ln"> 6531</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 6532</span>		<span class="cm">/*
</span><span class="ln"> 6533</span><span class="cm">		 * We are supposed to update the task to &#34;current&#34; time, then
</span><span class="ln"> 6534</span><span class="cm">		 * its up to date and ready to go to new CPU/cfs_rq. But we
</span><span class="ln"> 6535</span><span class="cm">		 * have difficulty in getting what current time is, so simply
</span><span class="ln"> 6536</span><span class="cm">		 * throw away the out-of-date time. This will result in the
</span><span class="ln"> 6537</span><span class="cm">		 * wakee task is less decayed, but giving the wakee more load
</span><span class="ln"> 6538</span><span class="cm">		 * sounds not bad.
</span><span class="ln"> 6539</span><span class="cm">		 */</span>
<span class="ln"> 6540</span>		<span class="n">remove_entity_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6541</span>	<span class="p">}</span>
<span class="ln"> 6542</span>
<span class="ln"> 6543</span>	<span class="cm">/* Tell new CPU we are migrated */</span>
<span class="ln"> 6544</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6545</span>
<span class="ln"> 6546</span>	<span class="cm">/* We have migrated, no longer consider this task hot */</span>
<span class="ln"> 6547</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6548</span>
<span class="ln"> 6549</span>	<span class="n">update_scan_period</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">new_cpu</span><span class="p">);</span>
<span class="ln"> 6550</span><span class="p">}</span>
<span class="ln"> 6551</span>
<span class="ln"> 6552</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_dead_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 6553</span><span class="p">{</span>
<span class="ln"> 6554</span>	<span class="n">remove_entity_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6555</span><span class="p">}</span>
<span class="ln"> 6556</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 6557</span><span class="cp"></span>
<span class="ln"> 6558</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">wakeup_gran</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 6559</span><span class="p">{</span>
<span class="ln"> 6560</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gran</span> <span class="o">=</span> <span class="n">sysctl_sched_wakeup_granularity</span><span class="p">;</span>
<span class="ln"> 6561</span>
<span class="ln"> 6562</span>	<span class="cm">/*
</span><span class="ln"> 6563</span><span class="cm">	 * Since its curr running now, convert the gran from real-time
</span><span class="ln"> 6564</span><span class="cm">	 * to virtual-time in his units.
</span><span class="ln"> 6565</span><span class="cm">	 *
</span><span class="ln"> 6566</span><span class="cm">	 * By using &#39;se&#39; instead of &#39;curr&#39; we penalize light tasks, so
</span><span class="ln"> 6567</span><span class="cm">	 * they get preempted easier. That is, if &#39;se&#39; &lt; &#39;curr&#39; then
</span><span class="ln"> 6568</span><span class="cm">	 * the resulting gran will be larger, therefore penalizing the
</span><span class="ln"> 6569</span><span class="cm">	 * lighter, if otoh &#39;se&#39; &gt; &#39;curr&#39; then the resulting gran will
</span><span class="ln"> 6570</span><span class="cm">	 * be smaller, again penalizing the lighter task.
</span><span class="ln"> 6571</span><span class="cm">	 *
</span><span class="ln"> 6572</span><span class="cm">	 * This is especially important for buddies when the leftmost
</span><span class="ln"> 6573</span><span class="cm">	 * task is higher priority than the buddy.
</span><span class="ln"> 6574</span><span class="cm">	 */</span>
<span class="ln"> 6575</span>	<span class="k">return</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">gran</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 6576</span><span class="p">}</span>
<span class="ln"> 6577</span>
<span class="ln"> 6578</span><span class="cm">/*
</span><span class="ln"> 6579</span><span class="cm"> * Should &#39;se&#39; preempt &#39;curr&#39;.
</span><span class="ln"> 6580</span><span class="cm"> *
</span><span class="ln"> 6581</span><span class="cm"> *             |s1
</span><span class="ln"> 6582</span><span class="cm"> *        |s2
</span><span class="ln"> 6583</span><span class="cm"> *   |s3
</span><span class="ln"> 6584</span><span class="cm"> *         g
</span><span class="ln"> 6585</span><span class="cm"> *      |&lt;---&gt;|c
</span><span class="ln"> 6586</span><span class="cm"> *
</span><span class="ln"> 6587</span><span class="cm"> *  w(c, s1) = -1
</span><span class="ln"> 6588</span><span class="cm"> *  w(c, s2) =  0
</span><span class="ln"> 6589</span><span class="cm"> *  w(c, s3) =  1
</span><span class="ln"> 6590</span><span class="cm"> *
</span><span class="ln"> 6591</span><span class="cm"> */</span>
<span class="ln"> 6592</span><span class="k">static</span> <span class="kt">int</span>
<span class="ln"> 6593</span><span class="nf">wakeup_preempt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 6594</span><span class="p">{</span>
<span class="ln"> 6595</span>	<span class="n">s64</span> <span class="n">gran</span><span class="p">,</span> <span class="n">vdiff</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
<span class="ln"> 6596</span>
<span class="ln"> 6597</span>	<span class="k">if</span> <span class="p">(</span><span class="n">vdiff</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 6598</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6599</span>
<span class="ln"> 6600</span>	<span class="n">gran</span> <span class="o">=</span> <span class="n">wakeup_gran</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6601</span>	<span class="k">if</span> <span class="p">(</span><span class="n">vdiff</span> <span class="o">&gt;</span> <span class="n">gran</span><span class="p">)</span>
<span class="ln"> 6602</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6603</span>
<span class="ln"> 6604</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6605</span><span class="p">}</span>
<span class="ln"> 6606</span>
<span class="ln"> 6607</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_last_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 6608</span><span class="p">{</span>
<span class="ln"> 6609</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
<span class="ln"> 6610</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6611</span>
<span class="ln"> 6612</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6613</span>		<span class="k">if</span> <span class="p">(</span><span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">))</span>
<span class="ln"> 6614</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6615</span>		<span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="ln"> 6616</span>	<span class="p">}</span>
<span class="ln"> 6617</span><span class="p">}</span>
<span class="ln"> 6618</span>
<span class="ln"> 6619</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_next_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 6620</span><span class="p">{</span>
<span class="ln"> 6621</span>	<span class="k">if</span> <span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
<span class="ln"> 6622</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6623</span>
<span class="ln"> 6624</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6625</span>		<span class="k">if</span> <span class="p">(</span><span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">))</span>
<span class="ln"> 6626</span>			<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6627</span>		<span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="ln"> 6628</span>	<span class="p">}</span>
<span class="ln"> 6629</span><span class="p">}</span>
<span class="ln"> 6630</span>
<span class="ln"> 6631</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_skip_buddy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 6632</span><span class="p">{</span>
<span class="ln"> 6633</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 6634</span>		<span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="ln"> 6635</span><span class="p">}</span>
<span class="ln"> 6636</span>
<span class="ln"> 6637</span><span class="cm">/*
</span><span class="ln"> 6638</span><span class="cm"> * Preempt the current task with a newly woken task if needed:
</span><span class="ln"> 6639</span><span class="cm"> */</span>
<span class="ln"> 6640</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">check_preempt_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="ln"> 6641</span><span class="p">{</span>
<span class="ln"> 6642</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 6643</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">,</span> <span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6644</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 6645</span>	<span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;=</span> <span class="n">sched_nr_latency</span><span class="p">;</span>
<span class="ln"> 6646</span>	<span class="kt">int</span> <span class="n">next_buddy_marked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 6647</span>
<span class="ln"> 6648</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">se</span> <span class="o">==</span> <span class="n">pse</span><span class="p">))</span>
<span class="ln"> 6649</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6650</span>
<span class="ln"> 6651</span>	<span class="cm">/*
</span><span class="ln"> 6652</span><span class="cm">	 * This is possible from callers such as attach_tasks(), in which we
</span><span class="ln"> 6653</span><span class="cm">	 * unconditionally check_prempt_curr() after an enqueue (which may have
</span><span class="ln"> 6654</span><span class="cm">	 * lead to a throttle).  This both saves work and prevents false
</span><span class="ln"> 6655</span><span class="cm">	 * next-buddy nomination below.
</span><span class="ln"> 6656</span><span class="cm">	 */</span>
<span class="ln"> 6657</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">pse</span><span class="p">))))</span>
<span class="ln"> 6658</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6659</span>
<span class="ln"> 6660</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">NEXT_BUDDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scale</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="n">WF_FORK</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 6661</span>		<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6662</span>		<span class="n">next_buddy_marked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6663</span>	<span class="p">}</span>
<span class="ln"> 6664</span>
<span class="ln"> 6665</span>	<span class="cm">/*
</span><span class="ln"> 6666</span><span class="cm">	 * We can come here with TIF_NEED_RESCHED already set from new task
</span><span class="ln"> 6667</span><span class="cm">	 * wake up path.
</span><span class="ln"> 6668</span><span class="cm">	 *
</span><span class="ln"> 6669</span><span class="cm">	 * Note: this also catches the edge-case of curr being in a throttled
</span><span class="ln"> 6670</span><span class="cm">	 * group (e.g. via set_curr_task), since update_curr() (in the
</span><span class="ln"> 6671</span><span class="cm">	 * enqueue of curr) will have resulted in resched being set.  This
</span><span class="ln"> 6672</span><span class="cm">	 * prevents us from potentially nominating it as a false LAST_BUDDY
</span><span class="ln"> 6673</span><span class="cm">	 * below.
</span><span class="ln"> 6674</span><span class="cm">	 */</span>
<span class="ln"> 6675</span>	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>
<span class="ln"> 6676</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6677</span>
<span class="ln"> 6678</span>	<span class="cm">/* Idle tasks are by definition preempted by non-idle tasks. */</span>
<span class="ln"> 6679</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 6680</span>	    <span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
<span class="ln"> 6681</span>		<span class="k">goto</span> <span class="n">preempt</span><span class="p">;</span>
<span class="ln"> 6682</span>
<span class="ln"> 6683</span>	<span class="cm">/*
</span><span class="ln"> 6684</span><span class="cm">	 * Batch and idle tasks do not preempt non-idle tasks (their preemption
</span><span class="ln"> 6685</span><span class="cm">	 * is driven by the tick):
</span><span class="ln"> 6686</span><span class="cm">	 */</span>
<span class="ln"> 6687</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_NORMAL</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">WAKEUP_PREEMPTION</span><span class="p">))</span>
<span class="ln"> 6688</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6689</span>
<span class="ln"> 6690</span>	<span class="n">find_matching_se</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6691</span>	<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="ln"> 6692</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6693</span>	<span class="k">if</span> <span class="p">(</span><span class="n">wakeup_preempt_entity</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">pse</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6694</span>		<span class="cm">/*
</span><span class="ln"> 6695</span><span class="cm">		 * Bias pick_next to pick the sched entity that is
</span><span class="ln"> 6696</span><span class="cm">		 * triggering this preemption.
</span><span class="ln"> 6697</span><span class="cm">		 */</span>
<span class="ln"> 6698</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_buddy_marked</span><span class="p">)</span>
<span class="ln"> 6699</span>			<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6700</span>		<span class="k">goto</span> <span class="n">preempt</span><span class="p">;</span>
<span class="ln"> 6701</span>	<span class="p">}</span>
<span class="ln"> 6702</span>
<span class="ln"> 6703</span>	<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6704</span>
<span class="ln"> 6705</span><span class="nl">preempt</span><span class="p">:</span>
<span class="ln"> 6706</span>	<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 6707</span>	<span class="cm">/*
</span><span class="ln"> 6708</span><span class="cm">	 * Only set the backward buddy when the current task is still
</span><span class="ln"> 6709</span><span class="cm">	 * on the rq. This can happen when a wakeup gets interleaved
</span><span class="ln"> 6710</span><span class="cm">	 * with schedule on the -&gt;pre_schedule() or idle_balance()
</span><span class="ln"> 6711</span><span class="cm">	 * point, either of which can * drop the rq lock.
</span><span class="ln"> 6712</span><span class="cm">	 *
</span><span class="ln"> 6713</span><span class="cm">	 * Also, during early boot the idle thread is in the fair class,
</span><span class="ln"> 6714</span><span class="cm">	 * for obvious reasons its a bad idea to schedule back to it.
</span><span class="ln"> 6715</span><span class="cm">	 */</span>
<span class="ln"> 6716</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">||</span> <span class="n">curr</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">))</span>
<span class="ln"> 6717</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6718</span>
<span class="ln"> 6719</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LAST_BUDDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">scale</span> <span class="o">&amp;&amp;</span> <span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln"> 6720</span>		<span class="n">set_last_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6721</span><span class="p">}</span>
<span class="ln"> 6722</span>
<span class="ln"> 6723</span><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="ln"> 6724</span><span class="nf">pick_next_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln"> 6725</span><span class="p">{</span>
<span class="ln"> 6726</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln"> 6727</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6728</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln"> 6729</span>	<span class="kt">int</span> <span class="n">new_tasks</span><span class="p">;</span>
<span class="ln"> 6730</span>
<span class="ln"> 6731</span><span class="nl">again</span><span class="p">:</span>
<span class="ln"> 6732</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
<span class="ln"> 6733</span>		<span class="k">goto</span> <span class="n">idle</span><span class="p">;</span>
<span class="ln"> 6734</span>
<span class="ln"> 6735</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 6736</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span>
<span class="ln"> 6737</span>		<span class="k">goto</span> <span class="n">simple</span><span class="p">;</span>
<span class="ln"> 6738</span>
<span class="ln"> 6739</span>	<span class="cm">/*
</span><span class="ln"> 6740</span><span class="cm">	 * Because of the set_next_buddy() in dequeue_task_fair() it is rather
</span><span class="ln"> 6741</span><span class="cm">	 * likely that a next task is from the same cgroup as the current.
</span><span class="ln"> 6742</span><span class="cm">	 *
</span><span class="ln"> 6743</span><span class="cm">	 * Therefore attempt to avoid putting and setting the entire cgroup
</span><span class="ln"> 6744</span><span class="cm">	 * hierarchy, only change the part that actually changes.
</span><span class="ln"> 6745</span><span class="cm">	 */</span>
<span class="ln"> 6746</span>
<span class="ln"> 6747</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 6748</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 6749</span>
<span class="ln"> 6750</span>		<span class="cm">/*
</span><span class="ln"> 6751</span><span class="cm">		 * Since we got here without doing put_prev_entity() we also
</span><span class="ln"> 6752</span><span class="cm">		 * have to consider cfs_rq-&gt;curr. If it is still a runnable
</span><span class="ln"> 6753</span><span class="cm">		 * entity, update_curr() will update its vruntime, otherwise
</span><span class="ln"> 6754</span><span class="cm">		 * forget we&#39;ve ever seen it.
</span><span class="ln"> 6755</span><span class="cm">		 */</span>
<span class="ln"> 6756</span>		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6757</span>			<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln"> 6758</span>				<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 6759</span>			<span class="k">else</span>
<span class="ln"> 6760</span>				<span class="n">curr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 6761</span>
<span class="ln"> 6762</span>			<span class="cm">/*
</span><span class="ln"> 6763</span><span class="cm">			 * This call to check_cfs_rq_runtime() will do the
</span><span class="ln"> 6764</span><span class="cm">			 * throttle and dequeue its entity in the parent(s).
</span><span class="ln"> 6765</span><span class="cm">			 * Therefore the nr_running test will indeed
</span><span class="ln"> 6766</span><span class="cm">			 * be correct.
</span><span class="ln"> 6767</span><span class="cm">			 */</span>
<span class="ln"> 6768</span>			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">check_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 6769</span>				<span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln"> 6770</span>
<span class="ln"> 6771</span>				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">)</span>
<span class="ln"> 6772</span>					<span class="k">goto</span> <span class="n">idle</span><span class="p">;</span>
<span class="ln"> 6773</span>
<span class="ln"> 6774</span>				<span class="k">goto</span> <span class="n">simple</span><span class="p">;</span>
<span class="ln"> 6775</span>			<span class="p">}</span>
<span class="ln"> 6776</span>		<span class="p">}</span>
<span class="ln"> 6777</span>
<span class="ln"> 6778</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">pick_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln"> 6779</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6780</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 6781</span>
<span class="ln"> 6782</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6783</span>
<span class="ln"> 6784</span>	<span class="cm">/*
</span><span class="ln"> 6785</span><span class="cm">	 * Since we haven&#39;t yet done put_prev_entity and if the selected task
</span><span class="ln"> 6786</span><span class="cm">	 * is a different task than we started out with, try and touch the
</span><span class="ln"> 6787</span><span class="cm">	 * least amount of cfs_rqs.
</span><span class="ln"> 6788</span><span class="cm">	 */</span>
<span class="ln"> 6789</span>	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6790</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">pse</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6791</span>
<span class="ln"> 6792</span>		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">is_same_group</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">pse</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 6793</span>			<span class="kt">int</span> <span class="n">se_depth</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
<span class="ln"> 6794</span>			<span class="kt">int</span> <span class="n">pse_depth</span> <span class="o">=</span> <span class="n">pse</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
<span class="ln"> 6795</span>
<span class="ln"> 6796</span>			<span class="k">if</span> <span class="p">(</span><span class="n">se_depth</span> <span class="o">&lt;=</span> <span class="n">pse_depth</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6797</span>				<span class="n">put_prev_entity</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">pse</span><span class="p">),</span> <span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6798</span>				<span class="n">pse</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6799</span>			<span class="p">}</span>
<span class="ln"> 6800</span>			<span class="k">if</span> <span class="p">(</span><span class="n">se_depth</span> <span class="o">&gt;=</span> <span class="n">pse_depth</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6801</span>				<span class="n">set_next_entity</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 6802</span>				<span class="n">se</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6803</span>			<span class="p">}</span>
<span class="ln"> 6804</span>		<span class="p">}</span>
<span class="ln"> 6805</span>
<span class="ln"> 6806</span>		<span class="n">put_prev_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">pse</span><span class="p">);</span>
<span class="ln"> 6807</span>		<span class="n">set_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 6808</span>	<span class="p">}</span>
<span class="ln"> 6809</span>
<span class="ln"> 6810</span>	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="ln"> 6811</span><span class="nl">simple</span><span class="p">:</span>
<span class="ln"> 6812</span><span class="cp">#endif
</span><span class="ln"> 6813</span><span class="cp"></span>
<span class="ln"> 6814</span>	<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
<span class="ln"> 6815</span>
<span class="ln"> 6816</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 6817</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">pick_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 6818</span>		<span class="n">set_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 6819</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6820</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 6821</span>
<span class="ln"> 6822</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">task_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6823</span>
<span class="ln"> 6824</span><span class="nl">done</span><span class="p">:</span> <span class="n">__maybe_unused</span><span class="p">;</span>
<span class="ln"> 6825</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 6826</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln"> 6827</span><span class="cm">	 * Move the next running task to the front of
</span><span class="ln"> 6828</span><span class="cm">	 * the list, so our cfs_tasks list becomes MRU
</span><span class="ln"> 6829</span><span class="cm">	 * one.
</span><span class="ln"> 6830</span><span class="cm">	 */</span>
<span class="ln"> 6831</span>	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">);</span>
<span class="ln"> 6832</span><span class="cp">#endif
</span><span class="ln"> 6833</span><span class="cp"></span>
<span class="ln"> 6834</span>	<span class="k">if</span> <span class="p">(</span><span class="n">hrtick_enabled</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
<span class="ln"> 6835</span>		<span class="n">hrtick_start_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 6836</span>
<span class="ln"> 6837</span>	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="ln"> 6838</span>
<span class="ln"> 6839</span><span class="nl">idle</span><span class="p">:</span>
<span class="ln"> 6840</span>	<span class="n">new_tasks</span> <span class="o">=</span> <span class="n">idle_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln"> 6841</span>
<span class="ln"> 6842</span>	<span class="cm">/*
</span><span class="ln"> 6843</span><span class="cm">	 * Because idle_balance() releases (and re-acquires) rq-&gt;lock, it is
</span><span class="ln"> 6844</span><span class="cm">	 * possible for any higher priority task to appear. In that case we
</span><span class="ln"> 6845</span><span class="cm">	 * must re-start the pick_next_entity() loop.
</span><span class="ln"> 6846</span><span class="cm">	 */</span>
<span class="ln"> 6847</span>	<span class="k">if</span> <span class="p">(</span><span class="n">new_tasks</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 6848</span>		<span class="k">return</span> <span class="n">RETRY_TASK</span><span class="p">;</span>
<span class="ln"> 6849</span>
<span class="ln"> 6850</span>	<span class="k">if</span> <span class="p">(</span><span class="n">new_tasks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 6851</span>		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="ln"> 6852</span>
<span class="ln"> 6853</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 6854</span><span class="p">}</span>
<span class="ln"> 6855</span>
<span class="ln"> 6856</span><span class="cm">/*
</span><span class="ln"> 6857</span><span class="cm"> * Account for a descheduled task:
</span><span class="ln"> 6858</span><span class="cm"> */</span>
<span class="ln"> 6859</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">put_prev_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="ln"> 6860</span><span class="p">{</span>
<span class="ln"> 6861</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6862</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 6863</span>
<span class="ln"> 6864</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6865</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6866</span>		<span class="n">put_prev_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 6867</span>	<span class="p">}</span>
<span class="ln"> 6868</span><span class="p">}</span>
<span class="ln"> 6869</span>
<span class="ln"> 6870</span><span class="cm">/*
</span><span class="ln"> 6871</span><span class="cm"> * sched_yield() is very simple
</span><span class="ln"> 6872</span><span class="cm"> *
</span><span class="ln"> 6873</span><span class="cm"> * The magic of dealing with the -&gt;skip buddy is in pick_next_entity.
</span><span class="ln"> 6874</span><span class="cm"> */</span>
<span class="ln"> 6875</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">yield_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 6876</span><span class="p">{</span>
<span class="ln"> 6877</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 6878</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
<span class="ln"> 6879</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6880</span>
<span class="ln"> 6881</span>	<span class="cm">/*
</span><span class="ln"> 6882</span><span class="cm">	 * Are we the only task in the tree?
</span><span class="ln"> 6883</span><span class="cm">	 */</span>
<span class="ln"> 6884</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
<span class="ln"> 6885</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 6886</span>
<span class="ln"> 6887</span>	<span class="n">clear_buddies</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 6888</span>
<span class="ln"> 6889</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_BATCH</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6890</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 6891</span>		<span class="cm">/*
</span><span class="ln"> 6892</span><span class="cm">		 * Update run-time statistics of the &#39;current&#39;.
</span><span class="ln"> 6893</span><span class="cm">		 */</span>
<span class="ln"> 6894</span>		<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 6895</span>		<span class="cm">/*
</span><span class="ln"> 6896</span><span class="cm">		 * Tell update_rq_clock() that we&#39;ve just updated,
</span><span class="ln"> 6897</span><span class="cm">		 * so we don&#39;t do microscopic update in schedule()
</span><span class="ln"> 6898</span><span class="cm">		 * and double the fastpath cost.
</span><span class="ln"> 6899</span><span class="cm">		 */</span>
<span class="ln"> 6900</span>		<span class="n">rq_clock_skip_update</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 6901</span>	<span class="p">}</span>
<span class="ln"> 6902</span>
<span class="ln"> 6903</span>	<span class="n">set_skip_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6904</span><span class="p">}</span>
<span class="ln"> 6905</span>
<span class="ln"> 6906</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">yield_to_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="ln"> 6907</span><span class="p">{</span>
<span class="ln"> 6908</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 6909</span>
<span class="ln"> 6910</span>	<span class="cm">/* throttled hierarchies are not runnable */</span>
<span class="ln"> 6911</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">||</span> <span class="n">throttled_hierarchy</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">)))</span>
<span class="ln"> 6912</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 6913</span>
<span class="ln"> 6914</span>	<span class="cm">/* Tell the scheduler that we&#39;d really like pse to run next. */</span>
<span class="ln"> 6915</span>	<span class="n">set_next_buddy</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 6916</span>
<span class="ln"> 6917</span>	<span class="n">yield_task_fair</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 6918</span>
<span class="ln"> 6919</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 6920</span><span class="p">}</span>
<span class="ln"> 6921</span>
<span class="ln"> 6922</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln"> 6923</span><span class="cp"></span><span class="cm">/**************************************************
</span><span class="ln"> 6924</span><span class="cm"> * Fair scheduling class load-balancing methods.
</span><span class="ln"> 6925</span><span class="cm"> *
</span><span class="ln"> 6926</span><span class="cm"> * BASICS
</span><span class="ln"> 6927</span><span class="cm"> *
</span><span class="ln"> 6928</span><span class="cm"> * The purpose of load-balancing is to achieve the same basic fairness the
</span><span class="ln"> 6929</span><span class="cm"> * per-CPU scheduler provides, namely provide a proportional amount of compute
</span><span class="ln"> 6930</span><span class="cm"> * time to each task. This is expressed in the following equation:
</span><span class="ln"> 6931</span><span class="cm"> *
</span><span class="ln"> 6932</span><span class="cm"> *   W_i,n/P_i == W_j,n/P_j for all i,j                               (1)
</span><span class="ln"> 6933</span><span class="cm"> *
</span><span class="ln"> 6934</span><span class="cm"> * Where W_i,n is the n-th weight average for CPU i. The instantaneous weight
</span><span class="ln"> 6935</span><span class="cm"> * W_i,0 is defined as:
</span><span class="ln"> 6936</span><span class="cm"> *
</span><span class="ln"> 6937</span><span class="cm"> *   W_i,0 = \Sum_j w_i,j                                             (2)
</span><span class="ln"> 6938</span><span class="cm"> *
</span><span class="ln"> 6939</span><span class="cm"> * Where w_i,j is the weight of the j-th runnable task on CPU i. This weight
</span><span class="ln"> 6940</span><span class="cm"> * is derived from the nice value as per sched_prio_to_weight[].
</span><span class="ln"> 6941</span><span class="cm"> *
</span><span class="ln"> 6942</span><span class="cm"> * The weight average is an exponential decay average of the instantaneous
</span><span class="ln"> 6943</span><span class="cm"> * weight:
</span><span class="ln"> 6944</span><span class="cm"> *
</span><span class="ln"> 6945</span><span class="cm"> *   W&#39;_i,n = (2^n - 1) / 2^n * W_i,n + 1 / 2^n * W_i,0               (3)
</span><span class="ln"> 6946</span><span class="cm"> *
</span><span class="ln"> 6947</span><span class="cm"> * C_i is the compute capacity of CPU i, typically it is the
</span><span class="ln"> 6948</span><span class="cm"> * fraction of &#39;recent&#39; time available for SCHED_OTHER task execution. But it
</span><span class="ln"> 6949</span><span class="cm"> * can also include other factors [XXX].
</span><span class="ln"> 6950</span><span class="cm"> *
</span><span class="ln"> 6951</span><span class="cm"> * To achieve this balance we define a measure of imbalance which follows
</span><span class="ln"> 6952</span><span class="cm"> * directly from (1):
</span><span class="ln"> 6953</span><span class="cm"> *
</span><span class="ln"> 6954</span><span class="cm"> *   imb_i,j = max{ avg(W/C), W_i/C_i } - min{ avg(W/C), W_j/C_j }    (4)
</span><span class="ln"> 6955</span><span class="cm"> *
</span><span class="ln"> 6956</span><span class="cm"> * We them move tasks around to minimize the imbalance. In the continuous
</span><span class="ln"> 6957</span><span class="cm"> * function space it is obvious this converges, in the discrete case we get
</span><span class="ln"> 6958</span><span class="cm"> * a few fun cases generally called infeasible weight scenarios.
</span><span class="ln"> 6959</span><span class="cm"> *
</span><span class="ln"> 6960</span><span class="cm"> * [XXX expand on:
</span><span class="ln"> 6961</span><span class="cm"> *     - infeasible weights;
</span><span class="ln"> 6962</span><span class="cm"> *     - local vs global optima in the discrete case. ]
</span><span class="ln"> 6963</span><span class="cm"> *
</span><span class="ln"> 6964</span><span class="cm"> *
</span><span class="ln"> 6965</span><span class="cm"> * SCHED DOMAINS
</span><span class="ln"> 6966</span><span class="cm"> *
</span><span class="ln"> 6967</span><span class="cm"> * In order to solve the imbalance equation (4), and avoid the obvious O(n^2)
</span><span class="ln"> 6968</span><span class="cm"> * for all i,j solution, we create a tree of CPUs that follows the hardware
</span><span class="ln"> 6969</span><span class="cm"> * topology where each level pairs two lower groups (or better). This results
</span><span class="ln"> 6970</span><span class="cm"> * in O(log n) layers. Furthermore we reduce the number of CPUs going up the
</span><span class="ln"> 6971</span><span class="cm"> * tree to only the first of the previous level and we decrease the frequency
</span><span class="ln"> 6972</span><span class="cm"> * of load-balance at each level inv. proportional to the number of CPUs in
</span><span class="ln"> 6973</span><span class="cm"> * the groups.
</span><span class="ln"> 6974</span><span class="cm"> *
</span><span class="ln"> 6975</span><span class="cm"> * This yields:
</span><span class="ln"> 6976</span><span class="cm"> *
</span><span class="ln"> 6977</span><span class="cm"> *     log_2 n     1     n
</span><span class="ln"> 6978</span><span class="cm"> *   \Sum       { --- * --- * 2^i } = O(n)                            (5)
</span><span class="ln"> 6979</span><span class="cm"> *     i = 0      2^i   2^i
</span><span class="ln"> 6980</span><span class="cm"> *                               `- size of each group
</span><span class="ln"> 6981</span><span class="cm"> *         |         |     `- number of CPUs doing load-balance
</span><span class="ln"> 6982</span><span class="cm"> *         |         `- freq
</span><span class="ln"> 6983</span><span class="cm"> *         `- sum over all levels
</span><span class="ln"> 6984</span><span class="cm"> *
</span><span class="ln"> 6985</span><span class="cm"> * Coupled with a limit on how many tasks we can migrate every balance pass,
</span><span class="ln"> 6986</span><span class="cm"> * this makes (5) the runtime complexity of the balancer.
</span><span class="ln"> 6987</span><span class="cm"> *
</span><span class="ln"> 6988</span><span class="cm"> * An important property here is that each CPU is still (indirectly) connected
</span><span class="ln"> 6989</span><span class="cm"> * to every other CPU in at most O(log n) steps:
</span><span class="ln"> 6990</span><span class="cm"> *
</span><span class="ln"> 6991</span><span class="cm"> * The adjacency matrix of the resulting graph is given by:
</span><span class="ln"> 6992</span><span class="cm"> *
</span><span class="ln"> 6993</span><span class="cm"> *             log_2 n
</span><span class="ln"> 6994</span><span class="cm"> *   A_i,j = \Union     (i % 2^k == 0) &amp;&amp; i / 2^(k+1) == j / 2^(k+1)  (6)
</span><span class="ln"> 6995</span><span class="cm"> *             k = 0
</span><span class="ln"> 6996</span><span class="cm"> *
</span><span class="ln"> 6997</span><span class="cm"> * And you&#39;ll find that:
</span><span class="ln"> 6998</span><span class="cm"> *
</span><span class="ln"> 6999</span><span class="cm"> *   A^(log_2 n)_i,j != 0  for all i,j                                (7)
</span><span class="ln"> 7000</span><span class="cm"> *
</span><span class="ln"> 7001</span><span class="cm"> * Showing there&#39;s indeed a path between every CPU in at most O(log n) steps.
</span><span class="ln"> 7002</span><span class="cm"> * The task movement gives a factor of O(m), giving a convergence complexity
</span><span class="ln"> 7003</span><span class="cm"> * of:
</span><span class="ln"> 7004</span><span class="cm"> *
</span><span class="ln"> 7005</span><span class="cm"> *   O(nm log n),  n := nr_cpus, m := nr_tasks                        (8)
</span><span class="ln"> 7006</span><span class="cm"> *
</span><span class="ln"> 7007</span><span class="cm"> *
</span><span class="ln"> 7008</span><span class="cm"> * WORK CONSERVING
</span><span class="ln"> 7009</span><span class="cm"> *
</span><span class="ln"> 7010</span><span class="cm"> * In order to avoid CPUs going idle while there&#39;s still work to do, new idle
</span><span class="ln"> 7011</span><span class="cm"> * balancing is more aggressive and has the newly idle CPU iterate up the domain
</span><span class="ln"> 7012</span><span class="cm"> * tree itself instead of relying on other CPUs to bring it work.
</span><span class="ln"> 7013</span><span class="cm"> *
</span><span class="ln"> 7014</span><span class="cm"> * This adds some complexity to both (5) and (8) but it reduces the total idle
</span><span class="ln"> 7015</span><span class="cm"> * time.
</span><span class="ln"> 7016</span><span class="cm"> *
</span><span class="ln"> 7017</span><span class="cm"> * [XXX more?]
</span><span class="ln"> 7018</span><span class="cm"> *
</span><span class="ln"> 7019</span><span class="cm"> *
</span><span class="ln"> 7020</span><span class="cm"> * CGROUPS
</span><span class="ln"> 7021</span><span class="cm"> *
</span><span class="ln"> 7022</span><span class="cm"> * Cgroups make a horror show out of (2), instead of a simple sum we get:
</span><span class="ln"> 7023</span><span class="cm"> *
</span><span class="ln"> 7024</span><span class="cm"> *                                s_k,i
</span><span class="ln"> 7025</span><span class="cm"> *   W_i,0 = \Sum_j \Prod_k w_k * -----                               (9)
</span><span class="ln"> 7026</span><span class="cm"> *                                 S_k
</span><span class="ln"> 7027</span><span class="cm"> *
</span><span class="ln"> 7028</span><span class="cm"> * Where
</span><span class="ln"> 7029</span><span class="cm"> *
</span><span class="ln"> 7030</span><span class="cm"> *   s_k,i = \Sum_j w_i,j,k  and  S_k = \Sum_i s_k,i                 (10)
</span><span class="ln"> 7031</span><span class="cm"> *
</span><span class="ln"> 7032</span><span class="cm"> * w_i,j,k is the weight of the j-th runnable task in the k-th cgroup on CPU i.
</span><span class="ln"> 7033</span><span class="cm"> *
</span><span class="ln"> 7034</span><span class="cm"> * The big problem is S_k, its a global sum needed to compute a local (W_i)
</span><span class="ln"> 7035</span><span class="cm"> * property.
</span><span class="ln"> 7036</span><span class="cm"> *
</span><span class="ln"> 7037</span><span class="cm"> * [XXX write more on how we solve this.. _after_ merging pjt&#39;s patches that
</span><span class="ln"> 7038</span><span class="cm"> *      rewrite all of this once again.]
</span><span class="ln"> 7039</span><span class="cm"> */</span>
<span class="ln"> 7040</span>
<span class="ln"> 7041</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__read_mostly</span> <span class="n">max_load_balance_interval</span> <span class="o">=</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
<span class="ln"> 7042</span>
<span class="ln"> 7043</span><span class="k">enum</span> <span class="n">fbq_type</span> <span class="p">{</span> <span class="n">regular</span><span class="p">,</span> <span class="n">remote</span><span class="p">,</span> <span class="n">all</span> <span class="p">};</span>
<span class="ln"> 7044</span>
<span class="ln"> 7045</span><span class="cp">#define LBF_ALL_PINNED	0x01
</span><span class="ln"> 7046</span><span class="cp">#define LBF_NEED_BREAK	0x02
</span><span class="ln"> 7047</span><span class="cp">#define LBF_DST_PINNED  0x04
</span><span class="ln"> 7048</span><span class="cp">#define LBF_SOME_PINNED	0x08
</span><span class="ln"> 7049</span><span class="cp">#define LBF_NOHZ_STATS	0x10
</span><span class="ln"> 7050</span><span class="cp">#define LBF_NOHZ_AGAIN	0x20
</span><span class="ln"> 7051</span><span class="cp"></span>
<span class="ln"> 7052</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="p">{</span>
<span class="ln"> 7053</span>	<span class="k">struct</span> <span class="n">sched_domain</span>	<span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 7054</span>
<span class="ln"> 7055</span>	<span class="k">struct</span> <span class="n">rq</span>		<span class="o">*</span><span class="n">src_rq</span><span class="p">;</span>
<span class="ln"> 7056</span>	<span class="kt">int</span>			<span class="n">src_cpu</span><span class="p">;</span>
<span class="ln"> 7057</span>
<span class="ln"> 7058</span>	<span class="kt">int</span>			<span class="n">dst_cpu</span><span class="p">;</span>
<span class="ln"> 7059</span>	<span class="k">struct</span> <span class="n">rq</span>		<span class="o">*</span><span class="n">dst_rq</span><span class="p">;</span>
<span class="ln"> 7060</span>
<span class="ln"> 7061</span>	<span class="k">struct</span> <span class="n">cpumask</span>		<span class="o">*</span><span class="n">dst_grpmask</span><span class="p">;</span>
<span class="ln"> 7062</span>	<span class="kt">int</span>			<span class="n">new_dst_cpu</span><span class="p">;</span>
<span class="ln"> 7063</span>	<span class="k">enum</span> <span class="n">cpu_idle_type</span>	<span class="n">idle</span><span class="p">;</span>
<span class="ln"> 7064</span>	<span class="kt">long</span>			<span class="n">imbalance</span><span class="p">;</span>
<span class="ln"> 7065</span>	<span class="cm">/* The set of CPUs under consideration for load-balancing */</span>
<span class="ln"> 7066</span>	<span class="k">struct</span> <span class="n">cpumask</span>		<span class="o">*</span><span class="n">cpus</span><span class="p">;</span>
<span class="ln"> 7067</span>
<span class="ln"> 7068</span>	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>
<span class="ln"> 7069</span>
<span class="ln"> 7070</span>	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">loop</span><span class="p">;</span>
<span class="ln"> 7071</span>	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">loop_break</span><span class="p">;</span>
<span class="ln"> 7072</span>	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">loop_max</span><span class="p">;</span>
<span class="ln"> 7073</span>
<span class="ln"> 7074</span>	<span class="k">enum</span> <span class="n">fbq_type</span>		<span class="n">fbq_type</span><span class="p">;</span>
<span class="ln"> 7075</span>	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">tasks</span><span class="p">;</span>
<span class="ln"> 7076</span><span class="p">};</span>
<span class="ln"> 7077</span>
<span class="ln"> 7078</span><span class="cm">/*
</span><span class="ln"> 7079</span><span class="cm"> * Is this task likely cache-hot:
</span><span class="ln"> 7080</span><span class="cm"> */</span>
<span class="ln"> 7081</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">task_hot</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7082</span><span class="p">{</span>
<span class="ln"> 7083</span>	<span class="n">s64</span> <span class="n">delta</span><span class="p">;</span>
<span class="ln"> 7084</span>
<span class="ln"> 7085</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 7086</span>
<span class="ln"> 7087</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span>
<span class="ln"> 7088</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7089</span>
<span class="ln"> 7090</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">==</span> <span class="n">SCHED_IDLE</span><span class="p">))</span>
<span class="ln"> 7091</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7092</span>
<span class="ln"> 7093</span>	<span class="cm">/*
</span><span class="ln"> 7094</span><span class="cm">	 * Buddy candidates are cache hot:
</span><span class="ln"> 7095</span><span class="cm">	 */</span>
<span class="ln"> 7096</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">CACHE_HOT_BUDDY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 7097</span>			<span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span> <span class="o">==</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">||</span>
<span class="ln"> 7098</span>			 <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span> <span class="o">==</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">))</span>
<span class="ln"> 7099</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7100</span>
<span class="ln"> 7101</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_migration_cost</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="ln"> 7102</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7103</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_migration_cost</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 7104</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7105</span>
<span class="ln"> 7106</span>	<span class="n">delta</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="p">;</span>
<span class="ln"> 7107</span>
<span class="ln"> 7108</span>	<span class="k">return</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span><span class="n">sysctl_sched_migration_cost</span><span class="p">;</span>
<span class="ln"> 7109</span><span class="p">}</span>
<span class="ln"> 7110</span>
<span class="ln"> 7111</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln"> 7112</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 7113</span><span class="cm"> * Returns 1, if task migration degrades locality
</span><span class="ln"> 7114</span><span class="cm"> * Returns 0, if task migration improves locality i.e migration preferred.
</span><span class="ln"> 7115</span><span class="cm"> * Returns -1, if task migration is not affected by locality.
</span><span class="ln"> 7116</span><span class="cm"> */</span>
<span class="ln"> 7117</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">migrate_degrades_locality</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7118</span><span class="p">{</span>
<span class="ln"> 7119</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">numa_group</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln"> 7120</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src_weight</span><span class="p">,</span> <span class="n">dst_weight</span><span class="p">;</span>
<span class="ln"> 7121</span>	<span class="kt">int</span> <span class="n">src_nid</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">;</span>
<span class="ln"> 7122</span>
<span class="ln"> 7123</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">static_branch_likely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">))</span>
<span class="ln"> 7124</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7125</span>
<span class="ln"> 7126</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_NUMA</span><span class="p">))</span>
<span class="ln"> 7127</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7128</span>
<span class="ln"> 7129</span>	<span class="n">src_nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">);</span>
<span class="ln"> 7130</span>	<span class="n">dst_nid</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 7131</span>
<span class="ln"> 7132</span>	<span class="k">if</span> <span class="p">(</span><span class="n">src_nid</span> <span class="o">==</span> <span class="n">dst_nid</span><span class="p">)</span>
<span class="ln"> 7133</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7134</span>
<span class="ln"> 7135</span>	<span class="cm">/* Migrating away from the preferred node is always bad. */</span>
<span class="ln"> 7136</span>	<span class="k">if</span> <span class="p">(</span><span class="n">src_nid</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7137</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span><span class="p">)</span>
<span class="ln"> 7138</span>			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7139</span>		<span class="k">else</span>
<span class="ln"> 7140</span>			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7141</span>	<span class="p">}</span>
<span class="ln"> 7142</span>
<span class="ln"> 7143</span>	<span class="cm">/* Encourage migration to the preferred node. */</span>
<span class="ln"> 7144</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dst_nid</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_preferred_nid</span><span class="p">)</span>
<span class="ln"> 7145</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7146</span>
<span class="ln"> 7147</span>	<span class="cm">/* Leaving a core idle is often worse than degrading locality. */</span>
<span class="ln"> 7148</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_IDLE</span><span class="p">)</span>
<span class="ln"> 7149</span>		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7150</span>
<span class="ln"> 7151</span>	<span class="n">dist</span> <span class="o">=</span> <span class="n">node_distance</span><span class="p">(</span><span class="n">src_nid</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">);</span>
<span class="ln"> 7152</span>	<span class="k">if</span> <span class="p">(</span><span class="n">numa_group</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7153</span>		<span class="n">src_weight</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 7154</span>		<span class="n">dst_weight</span> <span class="o">=</span> <span class="n">group_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 7155</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 7156</span>		<span class="n">src_weight</span> <span class="o">=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">src_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 7157</span>		<span class="n">dst_weight</span> <span class="o">=</span> <span class="n">task_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dst_nid</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
<span class="ln"> 7158</span>	<span class="p">}</span>
<span class="ln"> 7159</span>
<span class="ln"> 7160</span>	<span class="k">return</span> <span class="n">dst_weight</span> <span class="o">&lt;</span> <span class="n">src_weight</span><span class="p">;</span>
<span class="ln"> 7161</span><span class="p">}</span>
<span class="ln"> 7162</span>
<span class="ln"> 7163</span><span class="cp">#else
</span><span class="ln"> 7164</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">migrate_degrades_locality</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 7165</span>					     <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7166</span><span class="p">{</span>
<span class="ln"> 7167</span>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7168</span><span class="p">}</span>
<span class="ln"> 7169</span><span class="cp">#endif
</span><span class="ln"> 7170</span><span class="cp"></span>
<span class="ln"> 7171</span><span class="cm">/*
</span><span class="ln"> 7172</span><span class="cm"> * can_migrate_task - may task p from runqueue rq be migrated to this_cpu?
</span><span class="ln"> 7173</span><span class="cm"> */</span>
<span class="ln"> 7174</span><span class="k">static</span>
<span class="ln"> 7175</span><span class="kt">int</span> <span class="nf">can_migrate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7176</span><span class="p">{</span>
<span class="ln"> 7177</span>	<span class="kt">int</span> <span class="n">tsk_cache_hot</span><span class="p">;</span>
<span class="ln"> 7178</span>
<span class="ln"> 7179</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 7180</span>
<span class="ln"> 7181</span>	<span class="cm">/*
</span><span class="ln"> 7182</span><span class="cm">	 * We do not migrate tasks that are:
</span><span class="ln"> 7183</span><span class="cm">	 * 1) throttled_lb_pair, or
</span><span class="ln"> 7184</span><span class="cm">	 * 2) cannot be migrated to this CPU due to cpus_allowed, or
</span><span class="ln"> 7185</span><span class="cm">	 * 3) running (obviously), or
</span><span class="ln"> 7186</span><span class="cm">	 * 4) are cache-hot on their current CPU.
</span><span class="ln"> 7187</span><span class="cm">	 */</span>
<span class="ln"> 7188</span>	<span class="k">if</span> <span class="p">(</span><span class="n">throttled_lb_pair</span><span class="p">(</span><span class="n">task_group</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">))</span>
<span class="ln"> 7189</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7190</span>
<span class="ln"> 7191</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7192</span>		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 7193</span>
<span class="ln"> 7194</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_failed_migrations_affine</span><span class="p">);</span>
<span class="ln"> 7195</span>
<span class="ln"> 7196</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_SOME_PINNED</span><span class="p">;</span>
<span class="ln"> 7197</span>
<span class="ln"> 7198</span>		<span class="cm">/*
</span><span class="ln"> 7199</span><span class="cm">		 * Remember if this task can be migrated to any other CPU in
</span><span class="ln"> 7200</span><span class="cm">		 * our sched_group. We may want to revisit it if we couldn&#39;t
</span><span class="ln"> 7201</span><span class="cm">		 * meet load balance goals by pulling other tasks on src_cpu.
</span><span class="ln"> 7202</span><span class="cm">		 *
</span><span class="ln"> 7203</span><span class="cm">		 * Avoid computing new_dst_cpu for NEWLY_IDLE or if we have
</span><span class="ln"> 7204</span><span class="cm">		 * already computed one in current iteration.
</span><span class="ln"> 7205</span><span class="cm">		 */</span>
<span class="ln"> 7206</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span> <span class="o">||</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_DST_PINNED</span><span class="p">))</span>
<span class="ln"> 7207</span>			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7208</span>
<span class="ln"> 7209</span>		<span class="cm">/* Prevent to re-select dst_cpu via env&#39;s CPUs: */</span>
<span class="ln"> 7210</span>		<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_grpmask</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7211</span>			<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7212</span>				<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_DST_PINNED</span><span class="p">;</span>
<span class="ln"> 7213</span>				<span class="n">env</span><span class="o">-&gt;</span><span class="n">new_dst_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 7214</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7215</span>			<span class="p">}</span>
<span class="ln"> 7216</span>		<span class="p">}</span>
<span class="ln"> 7217</span>
<span class="ln"> 7218</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7219</span>	<span class="p">}</span>
<span class="ln"> 7220</span>
<span class="ln"> 7221</span>	<span class="cm">/* Record that we found atleast one task that could run on dst_cpu */</span>
<span class="ln"> 7222</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LBF_ALL_PINNED</span><span class="p">;</span>
<span class="ln"> 7223</span>
<span class="ln"> 7224</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_running</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7225</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_failed_migrations_running</span><span class="p">);</span>
<span class="ln"> 7226</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7227</span>	<span class="p">}</span>
<span class="ln"> 7228</span>
<span class="ln"> 7229</span>	<span class="cm">/*
</span><span class="ln"> 7230</span><span class="cm">	 * Aggressive migration if:
</span><span class="ln"> 7231</span><span class="cm">	 * 1) destination numa is preferred
</span><span class="ln"> 7232</span><span class="cm">	 * 2) task is cache cold, or
</span><span class="ln"> 7233</span><span class="cm">	 * 3) too many balance attempts have failed.
</span><span class="ln"> 7234</span><span class="cm">	 */</span>
<span class="ln"> 7235</span>	<span class="n">tsk_cache_hot</span> <span class="o">=</span> <span class="n">migrate_degrades_locality</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
<span class="ln"> 7236</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tsk_cache_hot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="ln"> 7237</span>		<span class="n">tsk_cache_hot</span> <span class="o">=</span> <span class="n">task_hot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
<span class="ln"> 7238</span>
<span class="ln"> 7239</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tsk_cache_hot</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span>
<span class="ln"> 7240</span>	    <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7241</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tsk_cache_hot</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7242</span>			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_hot_gained</span><span class="p">[</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 7243</span>			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_forced_migrations</span><span class="p">);</span>
<span class="ln"> 7244</span>		<span class="p">}</span>
<span class="ln"> 7245</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7246</span>	<span class="p">}</span>
<span class="ln"> 7247</span>
<span class="ln"> 7248</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">statistics</span><span class="p">.</span><span class="n">nr_failed_migrations_hot</span><span class="p">);</span>
<span class="ln"> 7249</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7250</span><span class="p">}</span>
<span class="ln"> 7251</span>
<span class="ln"> 7252</span><span class="cm">/*
</span><span class="ln"> 7253</span><span class="cm"> * detach_task() -- detach the task for the migration specified in env
</span><span class="ln"> 7254</span><span class="cm"> */</span>
<span class="ln"> 7255</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7256</span><span class="p">{</span>
<span class="ln"> 7257</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 7258</span>
<span class="ln"> 7259</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_MIGRATING</span><span class="p">;</span>
<span class="ln"> 7260</span>	<span class="n">deactivate_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln"> 7261</span>	<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 7262</span><span class="p">}</span>
<span class="ln"> 7263</span>
<span class="ln"> 7264</span><span class="cm">/*
</span><span class="ln"> 7265</span><span class="cm"> * detach_one_task() -- tries to dequeue exactly one task from env-&gt;src_rq, as
</span><span class="ln"> 7266</span><span class="cm"> * part of active balancing operations within &#34;domain&#34;.
</span><span class="ln"> 7267</span><span class="cm"> *
</span><span class="ln"> 7268</span><span class="cm"> * Returns a task if successful and NULL otherwise.
</span><span class="ln"> 7269</span><span class="cm"> */</span>
<span class="ln"> 7270</span><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">detach_one_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7271</span><span class="p">{</span>
<span class="ln"> 7272</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln"> 7273</span>
<span class="ln"> 7274</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 7275</span>
<span class="ln"> 7276</span>	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span>
<span class="ln"> 7277</span>			<span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7278</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_migrate_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
<span class="ln"> 7279</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 7280</span>
<span class="ln"> 7281</span>		<span class="n">detach_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
<span class="ln"> 7282</span>
<span class="ln"> 7283</span>		<span class="cm">/*
</span><span class="ln"> 7284</span><span class="cm">		 * Right now, this is only the second place where
</span><span class="ln"> 7285</span><span class="cm">		 * lb_gained[env-&gt;idle] is updated (other is detach_tasks)
</span><span class="ln"> 7286</span><span class="cm">		 * so we can safely collect stats here rather than
</span><span class="ln"> 7287</span><span class="cm">		 * inside detach_tasks().
</span><span class="ln"> 7288</span><span class="cm">		 */</span>
<span class="ln"> 7289</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_gained</span><span class="p">[</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 7290</span>		<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="ln"> 7291</span>	<span class="p">}</span>
<span class="ln"> 7292</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 7293</span><span class="p">}</span>
<span class="ln"> 7294</span>
<span class="ln"> 7295</span><span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sched_nr_migrate_break</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="ln"> 7296</span>
<span class="ln"> 7297</span><span class="cm">/*
</span><span class="ln"> 7298</span><span class="cm"> * detach_tasks() -- tries to detach up to imbalance weighted load from
</span><span class="ln"> 7299</span><span class="cm"> * busiest_rq, as part of a balancing operation within domain &#34;sd&#34;.
</span><span class="ln"> 7300</span><span class="cm"> *
</span><span class="ln"> 7301</span><span class="cm"> * Returns number of detached tasks if successful and 0 otherwise.
</span><span class="ln"> 7302</span><span class="cm"> */</span>
<span class="ln"> 7303</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">detach_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7304</span><span class="p">{</span>
<span class="ln"> 7305</span>	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tasks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">cfs_tasks</span><span class="p">;</span>
<span class="ln"> 7306</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln"> 7307</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 7308</span>	<span class="kt">int</span> <span class="n">detached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7309</span>
<span class="ln"> 7310</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 7311</span>
<span class="ln"> 7312</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 7313</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7314</span>
<span class="ln"> 7315</span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7316</span>		<span class="cm">/*
</span><span class="ln"> 7317</span><span class="cm">		 * We don&#39;t want to steal all, otherwise we may be treated likewise,
</span><span class="ln"> 7318</span><span class="cm">		 * which could at worst lead to a livelock crash.
</span><span class="ln"> 7319</span><span class="cm">		 */</span>
<span class="ln"> 7320</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NOT_IDLE</span> <span class="o">&amp;&amp;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 7321</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7322</span>
<span class="ln"> 7323</span>		<span class="n">p</span> <span class="o">=</span> <span class="n">list_last_entry</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">);</span>
<span class="ln"> 7324</span>
<span class="ln"> 7325</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 7326</span>		<span class="cm">/* We&#39;ve more or less seen every task there is, call it quits */</span>
<span class="ln"> 7327</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">loop</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">loop_max</span><span class="p">)</span>
<span class="ln"> 7328</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7329</span>
<span class="ln"> 7330</span>		<span class="cm">/* take a breather every nr_migrate tasks */</span>
<span class="ln"> 7331</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">loop</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">loop_break</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7332</span>			<span class="n">env</span><span class="o">-&gt;</span><span class="n">loop_break</span> <span class="o">+=</span> <span class="n">sched_nr_migrate_break</span><span class="p">;</span>
<span class="ln"> 7333</span>			<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_NEED_BREAK</span><span class="p">;</span>
<span class="ln"> 7334</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7335</span>		<span class="p">}</span>
<span class="ln"> 7336</span>
<span class="ln"> 7337</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_migrate_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
<span class="ln"> 7338</span>			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
<span class="ln"> 7339</span>
<span class="ln"> 7340</span>		<span class="cm">/*
</span><span class="ln"> 7341</span><span class="cm">		 * Depending of the number of CPUs and tasks and the
</span><span class="ln"> 7342</span><span class="cm">		 * cgroup hierarchy, task_h_load() can return a null
</span><span class="ln"> 7343</span><span class="cm">		 * value. Make sure that env-&gt;imbalance decreases
</span><span class="ln"> 7344</span><span class="cm">		 * otherwise detach_tasks() will stop only after
</span><span class="ln"> 7345</span><span class="cm">		 * detaching up to loop_max tasks.
</span><span class="ln"> 7346</span><span class="cm">		 */</span>
<span class="ln"> 7347</span>		<span class="n">load</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">task_h_load</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 7348</span>
<span class="ln"> 7349</span>
<span class="ln"> 7350</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">LB_MIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">load</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span><span class="p">)</span>
<span class="ln"> 7351</span>			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
<span class="ln"> 7352</span>
<span class="ln"> 7353</span>		<span class="k">if</span> <span class="p">((</span><span class="n">load</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span><span class="p">)</span>
<span class="ln"> 7354</span>			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
<span class="ln"> 7355</span>
<span class="ln"> 7356</span>		<span class="n">detach_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
<span class="ln"> 7357</span>		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
<span class="ln"> 7358</span>
<span class="ln"> 7359</span>		<span class="n">detached</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 7360</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">-=</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 7361</span>
<span class="ln"> 7362</span><span class="cp">#ifdef CONFIG_PREEMPT
</span><span class="ln"> 7363</span><span class="cp"></span>		<span class="cm">/*
</span><span class="ln"> 7364</span><span class="cm">		 * NEWIDLE balancing is a source of latency, so preemptible
</span><span class="ln"> 7365</span><span class="cm">		 * kernels will stop after the first task is detached to minimize
</span><span class="ln"> 7366</span><span class="cm">		 * the critical section.
</span><span class="ln"> 7367</span><span class="cm">		 */</span>
<span class="ln"> 7368</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span>
<span class="ln"> 7369</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7370</span><span class="cp">#endif
</span><span class="ln"> 7371</span><span class="cp"></span>
<span class="ln"> 7372</span>		<span class="cm">/*
</span><span class="ln"> 7373</span><span class="cm">		 * We only want to steal up to the prescribed amount of
</span><span class="ln"> 7374</span><span class="cm">		 * weighted load.
</span><span class="ln"> 7375</span><span class="cm">		 */</span>
<span class="ln"> 7376</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 7377</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7378</span>
<span class="ln"> 7379</span>		<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 7380</span><span class="nl">next</span><span class="p">:</span>
<span class="ln"> 7381</span>		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">,</span> <span class="n">tasks</span><span class="p">);</span>
<span class="ln"> 7382</span>	<span class="p">}</span>
<span class="ln"> 7383</span>
<span class="ln"> 7384</span>	<span class="cm">/*
</span><span class="ln"> 7385</span><span class="cm">	 * Right now, this is one of only two places we collect this stat
</span><span class="ln"> 7386</span><span class="cm">	 * so we can safely collect detach_one_task() stats here rather
</span><span class="ln"> 7387</span><span class="cm">	 * than inside detach_one_task().
</span><span class="ln"> 7388</span><span class="cm">	 */</span>
<span class="ln"> 7389</span>	<span class="n">schedstat_add</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_gained</span><span class="p">[</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">],</span> <span class="n">detached</span><span class="p">);</span>
<span class="ln"> 7390</span>
<span class="ln"> 7391</span>	<span class="k">return</span> <span class="n">detached</span><span class="p">;</span>
<span class="ln"> 7392</span><span class="p">}</span>
<span class="ln"> 7393</span>
<span class="ln"> 7394</span><span class="cm">/*
</span><span class="ln"> 7395</span><span class="cm"> * attach_task() -- attach the task detached by detach_task() to its new rq.
</span><span class="ln"> 7396</span><span class="cm"> */</span>
<span class="ln"> 7397</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 7398</span><span class="p">{</span>
<span class="ln"> 7399</span>	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 7400</span>
<span class="ln"> 7401</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rq</span><span class="p">);</span>
<span class="ln"> 7402</span>	<span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
<span class="ln"> 7403</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="ln"> 7404</span>	<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 7405</span><span class="p">}</span>
<span class="ln"> 7406</span>
<span class="ln"> 7407</span><span class="cm">/*
</span><span class="ln"> 7408</span><span class="cm"> * attach_one_task() -- attaches the task returned from detach_one_task() to
</span><span class="ln"> 7409</span><span class="cm"> * its new rq.
</span><span class="ln"> 7410</span><span class="cm"> */</span>
<span class="ln"> 7411</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_one_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 7412</span><span class="p">{</span>
<span class="ln"> 7413</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 7414</span>
<span class="ln"> 7415</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7416</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 7417</span>	<span class="n">attach_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 7418</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7419</span><span class="p">}</span>
<span class="ln"> 7420</span>
<span class="ln"> 7421</span><span class="cm">/*
</span><span class="ln"> 7422</span><span class="cm"> * attach_tasks() -- attaches all tasks detached by detach_tasks() to their
</span><span class="ln"> 7423</span><span class="cm"> * new rq.
</span><span class="ln"> 7424</span><span class="cm"> */</span>
<span class="ln"> 7425</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 7426</span><span class="p">{</span>
<span class="ln"> 7427</span>	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tasks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">;</span>
<span class="ln"> 7428</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="ln"> 7429</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 7430</span>
<span class="ln"> 7431</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7432</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="p">);</span>
<span class="ln"> 7433</span>
<span class="ln"> 7434</span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7435</span>		<span class="n">p</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span><span class="p">,</span> <span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">);</span>
<span class="ln"> 7436</span>		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">group_node</span><span class="p">);</span>
<span class="ln"> 7437</span>
<span class="ln"> 7438</span>		<span class="n">attach_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 7439</span>	<span class="p">}</span>
<span class="ln"> 7440</span>
<span class="ln"> 7441</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7442</span><span class="p">}</span>
<span class="ln"> 7443</span>
<span class="ln"> 7444</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">cfs_rq_has_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 7445</span><span class="p">{</span>
<span class="ln"> 7446</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">)</span>
<span class="ln"> 7447</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7448</span>
<span class="ln"> 7449</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">)</span>
<span class="ln"> 7450</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7451</span>
<span class="ln"> 7452</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7453</span><span class="p">}</span>
<span class="ln"> 7454</span>
<span class="ln"> 7455</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">others_have_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 7456</span><span class="p">{</span>
<span class="ln"> 7457</span>	<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_rt</span><span class="p">.</span><span class="n">util_avg</span><span class="p">))</span>
<span class="ln"> 7458</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7459</span>
<span class="ln"> 7460</span>	<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_dl</span><span class="p">.</span><span class="n">util_avg</span><span class="p">))</span>
<span class="ln"> 7461</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7462</span>
<span class="ln"> 7463</span><span class="cp">#ifdef CONFIG_HAVE_SCHED_AVG_IRQ
</span><span class="ln"> 7464</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_irq</span><span class="p">.</span><span class="n">util_avg</span><span class="p">))</span>
<span class="ln"> 7465</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7466</span><span class="cp">#endif
</span><span class="ln"> 7467</span><span class="cp"></span>
<span class="ln"> 7468</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7469</span><span class="p">}</span>
<span class="ln"> 7470</span>
<span class="ln"> 7471</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 7472</span><span class="cp"></span>
<span class="ln"> 7473</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">cfs_rq_is_decayed</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 7474</span><span class="p">{</span>
<span class="ln"> 7475</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
<span class="ln"> 7476</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7477</span>
<span class="ln"> 7478</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">)</span>
<span class="ln"> 7479</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7480</span>
<span class="ln"> 7481</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="p">)</span>
<span class="ln"> 7482</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7483</span>
<span class="ln"> 7484</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_load_sum</span><span class="p">)</span>
<span class="ln"> 7485</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7486</span>
<span class="ln"> 7487</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7488</span><span class="p">}</span>
<span class="ln"> 7489</span>
<span class="ln"> 7490</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_blocked_averages</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 7491</span><span class="p">{</span>
<span class="ln"> 7492</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7493</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
<span class="ln"> 7494</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">curr_class</span><span class="p">;</span>
<span class="ln"> 7495</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 7496</span>	<span class="kt">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7497</span>
<span class="ln"> 7498</span>	<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7499</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 7500</span>
<span class="ln"> 7501</span>	<span class="cm">/*
</span><span class="ln"> 7502</span><span class="cm">	 * Iterates the task_group tree in a bottom up fashion, see
</span><span class="ln"> 7503</span><span class="cm">	 * list_add_leaf_cfs_rq() for details.
</span><span class="ln"> 7504</span><span class="cm">	 */</span>
<span class="ln"> 7505</span>	<span class="n">for_each_leaf_cfs_rq_safe</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7506</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 7507</span>
<span class="ln"> 7508</span>		<span class="k">if</span> <span class="p">(</span><span class="n">update_cfs_rq_load_avg</span><span class="p">(</span><span class="n">cfs_rq_clock_task</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">),</span> <span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 7509</span>			<span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 7510</span>
<span class="ln"> 7511</span>		<span class="cm">/* Propagate pending load changes to the parent, if any: */</span>
<span class="ln"> 7512</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
<span class="ln"> 7513</span>		<span class="k">if</span> <span class="p">(</span><span class="n">se</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_blocked_update</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="ln"> 7514</span>			<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 7515</span>
<span class="ln"> 7516</span>		<span class="cm">/*
</span><span class="ln"> 7517</span><span class="cm">		 * There can be a lot of idle CPU cgroups.  Don&#39;t let fully
</span><span class="ln"> 7518</span><span class="cm">		 * decayed cfs_rqs linger on the list.
</span><span class="ln"> 7519</span><span class="cm">		 */</span>
<span class="ln"> 7520</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_is_decayed</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 7521</span>			<span class="n">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 7522</span>
<span class="ln"> 7523</span>		<span class="cm">/* Don&#39;t need periodic decay once load/util_avg are null */</span>
<span class="ln"> 7524</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_has_blocked</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 7525</span>			<span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7526</span>	<span class="p">}</span>
<span class="ln"> 7527</span>
<span class="ln"> 7528</span>	<span class="n">curr_class</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
<span class="ln"> 7529</span>	<span class="n">update_rt_rq_load_avg</span><span class="p">(</span><span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="p">,</span> <span class="n">curr_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">);</span>
<span class="ln"> 7530</span>	<span class="n">update_dl_rq_load_avg</span><span class="p">(</span><span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="p">,</span> <span class="n">curr_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dl_sched_class</span><span class="p">);</span>
<span class="ln"> 7531</span>	<span class="n">update_irq_load_avg</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 7532</span>	<span class="cm">/* Don&#39;t need periodic decay once load/util_avg are null */</span>
<span class="ln"> 7533</span>	<span class="k">if</span> <span class="p">(</span><span class="n">others_have_blocked</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
<span class="ln"> 7534</span>		<span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7535</span>
<span class="ln"> 7536</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 7537</span><span class="cp"></span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_blocked_load_update_tick</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 7538</span>	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
<span class="ln"> 7539</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">has_blocked_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7540</span><span class="cp">#endif
</span><span class="ln"> 7541</span><span class="cp"></span>	<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7542</span><span class="p">}</span>
<span class="ln"> 7543</span>
<span class="ln"> 7544</span><span class="cm">/*
</span><span class="ln"> 7545</span><span class="cm"> * Compute the hierarchical load factor for cfs_rq and all its ascendants.
</span><span class="ln"> 7546</span><span class="cm"> * This needs to be done in a top-down fashion because the load of a child
</span><span class="ln"> 7547</span><span class="cm"> * group is a fraction of its parents load.
</span><span class="ln"> 7548</span><span class="cm"> */</span>
<span class="ln"> 7549</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cfs_rq_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln"> 7550</span><span class="p">{</span>
<span class="ln"> 7551</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 7552</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">)];</span>
<span class="ln"> 7553</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 7554</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 7555</span>
<span class="ln"> 7556</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last_h_load_update</span> <span class="o">==</span> <span class="n">now</span><span class="p">)</span>
<span class="ln"> 7557</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 7558</span>
<span class="ln"> 7559</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load_next</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 7560</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7561</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 7562</span>		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load_next</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 7563</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last_h_load_update</span> <span class="o">==</span> <span class="n">now</span><span class="p">)</span>
<span class="ln"> 7564</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7565</span>	<span class="p">}</span>
<span class="ln"> 7566</span>
<span class="ln"> 7567</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7568</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load</span> <span class="o">=</span> <span class="n">cfs_rq_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 7569</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last_h_load_update</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="ln"> 7570</span>	<span class="p">}</span>
<span class="ln"> 7571</span>
<span class="ln"> 7572</span>	<span class="k">while</span> <span class="p">((</span><span class="n">se</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load_next</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7573</span>		<span class="n">load</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load</span><span class="p">;</span>
<span class="ln"> 7574</span>		<span class="n">load</span> <span class="o">=</span> <span class="n">div64_ul</span><span class="p">(</span><span class="n">load</span> <span class="o">*</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">,</span>
<span class="ln"> 7575</span>			<span class="n">cfs_rq_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 7576</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 7577</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load</span> <span class="o">=</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 7578</span>		<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">last_h_load_update</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="ln"> 7579</span>	<span class="p">}</span>
<span class="ln"> 7580</span><span class="p">}</span>
<span class="ln"> 7581</span>
<span class="ln"> 7582</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 7583</span><span class="p">{</span>
<span class="ln"> 7584</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 7585</span>
<span class="ln"> 7586</span>	<span class="n">update_cfs_rq_h_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 7587</span>	<span class="k">return</span> <span class="n">div64_ul</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span> <span class="o">*</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_load</span><span class="p">,</span>
<span class="ln"> 7588</span>			<span class="n">cfs_rq_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 7589</span><span class="p">}</span>
<span class="ln"> 7590</span><span class="cp">#else
</span><span class="ln"> 7591</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_blocked_averages</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 7592</span><span class="p">{</span>
<span class="ln"> 7593</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7594</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln"> 7595</span>	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">curr_class</span><span class="p">;</span>
<span class="ln"> 7596</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 7597</span>
<span class="ln"> 7598</span>	<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7599</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 7600</span>	<span class="n">update_cfs_rq_load_avg</span><span class="p">(</span><span class="n">cfs_rq_clock_task</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">),</span> <span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 7601</span>
<span class="ln"> 7602</span>	<span class="n">curr_class</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">;</span>
<span class="ln"> 7603</span>	<span class="n">update_rt_rq_load_avg</span><span class="p">(</span><span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="p">,</span> <span class="n">curr_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">);</span>
<span class="ln"> 7604</span>	<span class="n">update_dl_rq_load_avg</span><span class="p">(</span><span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="p">,</span> <span class="n">curr_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dl_sched_class</span><span class="p">);</span>
<span class="ln"> 7605</span>	<span class="n">update_irq_load_avg</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 7606</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 7607</span><span class="cp"></span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_blocked_load_update_tick</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 7608</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq_has_blocked</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">others_have_blocked</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
<span class="ln"> 7609</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">has_blocked_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7610</span><span class="cp">#endif
</span><span class="ln"> 7611</span><span class="cp"></span>	<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 7612</span><span class="p">}</span>
<span class="ln"> 7613</span>
<span class="ln"> 7614</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">task_h_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 7615</span><span class="p">{</span>
<span class="ln"> 7616</span>	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="ln"> 7617</span><span class="p">}</span>
<span class="ln"> 7618</span><span class="cp">#endif
</span><span class="ln"> 7619</span><span class="cp"></span>
<span class="ln"> 7620</span><span class="cm">/********** Helpers for find_busiest_group ************************/</span>
<span class="ln"> 7621</span>
<span class="ln"> 7622</span><span class="k">enum</span> <span class="n">group_type</span> <span class="p">{</span>
<span class="ln"> 7623</span>	<span class="n">group_other</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="ln"> 7624</span>	<span class="n">group_imbalanced</span><span class="p">,</span>
<span class="ln"> 7625</span>	<span class="n">group_overloaded</span><span class="p">,</span>
<span class="ln"> 7626</span><span class="p">};</span>
<span class="ln"> 7627</span>
<span class="ln"> 7628</span><span class="cm">/*
</span><span class="ln"> 7629</span><span class="cm"> * sg_lb_stats - stats of a sched_group required for load_balancing
</span><span class="ln"> 7630</span><span class="cm"> */</span>
<span class="ln"> 7631</span><span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="p">{</span>
<span class="ln"> 7632</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_load</span><span class="p">;</span> <span class="cm">/*Avg load across the CPUs of the group */</span>
<span class="ln"> 7633</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_load</span><span class="p">;</span> <span class="cm">/* Total load over the CPUs of the group */</span>
<span class="ln"> 7634</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum_weighted_load</span><span class="p">;</span> <span class="cm">/* Weighted load of group&#39;s tasks */</span>
<span class="ln"> 7635</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_per_task</span><span class="p">;</span>
<span class="ln"> 7636</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 7637</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">group_util</span><span class="p">;</span> <span class="cm">/* Total utilization of the group */</span>
<span class="ln"> 7638</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sum_nr_running</span><span class="p">;</span> <span class="cm">/* Nr tasks running in the group */</span>
<span class="ln"> 7639</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idle_cpus</span><span class="p">;</span>
<span class="ln"> 7640</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">group_weight</span><span class="p">;</span>
<span class="ln"> 7641</span>	<span class="k">enum</span> <span class="n">group_type</span> <span class="n">group_type</span><span class="p">;</span>
<span class="ln"> 7642</span>	<span class="kt">int</span> <span class="n">group_no_capacity</span><span class="p">;</span>
<span class="ln"> 7643</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln"> 7644</span><span class="cp"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_numa_running</span><span class="p">;</span>
<span class="ln"> 7645</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_preferred_running</span><span class="p">;</span>
<span class="ln"> 7646</span><span class="cp">#endif
</span><span class="ln"> 7647</span><span class="cp"></span><span class="p">};</span>
<span class="ln"> 7648</span>
<span class="ln"> 7649</span><span class="cm">/*
</span><span class="ln"> 7650</span><span class="cm"> * sd_lb_stats - Structure to store the statistics of a sched_domain
</span><span class="ln"> 7651</span><span class="cm"> *		 during load balancing.
</span><span class="ln"> 7652</span><span class="cm"> */</span>
<span class="ln"> 7653</span><span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="p">{</span>
<span class="ln"> 7654</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span>	<span class="cm">/* Busiest group in this sd */</span>
<span class="ln"> 7655</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>	<span class="cm">/* Local group in this sd */</span>
<span class="ln"> 7656</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_running</span><span class="p">;</span>
<span class="ln"> 7657</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_load</span><span class="p">;</span>	<span class="cm">/* Total load of all groups in sd */</span>
<span class="ln"> 7658</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_capacity</span><span class="p">;</span>	<span class="cm">/* Total capacity of all groups in sd */</span>
<span class="ln"> 7659</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg_load</span><span class="p">;</span>	<span class="cm">/* Average load across all groups in sd */</span>
<span class="ln"> 7660</span>
<span class="ln"> 7661</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="n">busiest_stat</span><span class="p">;</span><span class="cm">/* Statistics of the busiest group */</span>
<span class="ln"> 7662</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="n">local_stat</span><span class="p">;</span>	<span class="cm">/* Statistics of the local group */</span>
<span class="ln"> 7663</span><span class="p">};</span>
<span class="ln"> 7664</span>
<span class="ln"> 7665</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_sd_lb_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 7666</span><span class="p">{</span>
<span class="ln"> 7667</span>	<span class="cm">/*
</span><span class="ln"> 7668</span><span class="cm">	 * Skimp on the clearing to avoid duplicate work. We can avoid clearing
</span><span class="ln"> 7669</span><span class="cm">	 * local_stat because update_sg_lb_stats() does a full clear/assignment.
</span><span class="ln"> 7670</span><span class="cm">	 * We must however clear busiest_stat::avg_load because
</span><span class="ln"> 7671</span><span class="cm">	 * update_sd_pick_busiest() reads this before assignment.
</span><span class="ln"> 7672</span><span class="cm">	 */</span>
<span class="ln"> 7673</span>	<span class="o">*</span><span class="n">sds</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sd_lb_stats</span><span class="p">){</span>
<span class="ln"> 7674</span>		<span class="p">.</span><span class="n">busiest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="ln"> 7675</span>		<span class="p">.</span><span class="n">local</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="ln"> 7676</span>		<span class="p">.</span><span class="n">total_running</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span>
<span class="ln"> 7677</span>		<span class="p">.</span><span class="n">total_load</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span>
<span class="ln"> 7678</span>		<span class="p">.</span><span class="n">total_capacity</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span>
<span class="ln"> 7679</span>		<span class="p">.</span><span class="n">busiest_stat</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 7680</span>			<span class="p">.</span><span class="n">avg_load</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">,</span>
<span class="ln"> 7681</span>			<span class="p">.</span><span class="n">sum_nr_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="ln"> 7682</span>			<span class="p">.</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">group_other</span><span class="p">,</span>
<span class="ln"> 7683</span>		<span class="p">},</span>
<span class="ln"> 7684</span>	<span class="p">};</span>
<span class="ln"> 7685</span><span class="p">}</span>
<span class="ln"> 7686</span>
<span class="ln"> 7687</span><span class="cm">/**
</span><span class="ln"> 7688</span><span class="cm"> * get_sd_load_idx - Obtain the load index for a given sched domain.
</span><span class="ln"> 7689</span><span class="cm"> * @sd: The sched_domain whose load_idx is to be obtained.
</span><span class="ln"> 7690</span><span class="cm"> * @idle: The idle status of the CPU for whose sd load_idx is obtained.
</span><span class="ln"> 7691</span><span class="cm"> *
</span><span class="ln"> 7692</span><span class="cm"> * Return: The load index.
</span><span class="ln"> 7693</span><span class="cm"> */</span>
<span class="ln"> 7694</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_sd_load_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
<span class="ln"> 7695</span>					<span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="ln"> 7696</span><span class="p">{</span>
<span class="ln"> 7697</span>	<span class="kt">int</span> <span class="n">load_idx</span><span class="p">;</span>
<span class="ln"> 7698</span>
<span class="ln"> 7699</span>	<span class="k">switch</span> <span class="p">(</span><span class="n">idle</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7700</span>	<span class="k">case</span> <span class="nl">CPU_NOT_IDLE</span><span class="p">:</span>
<span class="ln"> 7701</span>		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">busy_idx</span><span class="p">;</span>
<span class="ln"> 7702</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7703</span>
<span class="ln"> 7704</span>	<span class="k">case</span> <span class="nl">CPU_NEWLY_IDLE</span><span class="p">:</span>
<span class="ln"> 7705</span>		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">newidle_idx</span><span class="p">;</span>
<span class="ln"> 7706</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7707</span>	<span class="k">default</span><span class="o">:</span>
<span class="ln"> 7708</span>		<span class="n">load_idx</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">idle_idx</span><span class="p">;</span>
<span class="ln"> 7709</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln"> 7710</span>	<span class="p">}</span>
<span class="ln"> 7711</span>
<span class="ln"> 7712</span>	<span class="k">return</span> <span class="n">load_idx</span><span class="p">;</span>
<span class="ln"> 7713</span><span class="p">}</span>
<span class="ln"> 7714</span>
<span class="ln"> 7715</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">scale_rt_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 7716</span><span class="p">{</span>
<span class="ln"> 7717</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7718</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arch_scale_cpu_capacity</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7719</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">,</span> <span class="n">free</span><span class="p">;</span>
<span class="ln"> 7720</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq</span><span class="p">;</span>
<span class="ln"> 7721</span>
<span class="ln"> 7722</span>	<span class="n">irq</span> <span class="o">=</span> <span class="n">cpu_util_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 7723</span>
<span class="ln"> 7724</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irq</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">))</span>
<span class="ln"> 7725</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7726</span>
<span class="ln"> 7727</span>	<span class="n">used</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_rt</span><span class="p">.</span><span class="n">util_avg</span><span class="p">);</span>
<span class="ln"> 7728</span>	<span class="n">used</span> <span class="o">+=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">avg_dl</span><span class="p">.</span><span class="n">util_avg</span><span class="p">);</span>
<span class="ln"> 7729</span>
<span class="ln"> 7730</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">))</span>
<span class="ln"> 7731</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7732</span>
<span class="ln"> 7733</span>	<span class="n">free</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="n">used</span><span class="p">;</span>
<span class="ln"> 7734</span>
<span class="ln"> 7735</span>	<span class="k">return</span> <span class="n">scale_irq_capacity</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
<span class="ln"> 7736</span><span class="p">}</span>
<span class="ln"> 7737</span>
<span class="ln"> 7738</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_cpu_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 7739</span><span class="p">{</span>
<span class="ln"> 7740</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">scale_rt_capacity</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7741</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sdg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
<span class="ln"> 7742</span>
<span class="ln"> 7743</span>	<span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu_capacity_orig</span> <span class="o">=</span> <span class="n">arch_scale_cpu_capacity</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7744</span>
<span class="ln"> 7745</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capacity</span><span class="p">)</span>
<span class="ln"> 7746</span>		<span class="n">capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7747</span>
<span class="ln"> 7748</span>	<span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cpu_capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 7749</span>	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 7750</span>	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">min_capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 7751</span><span class="p">}</span>
<span class="ln"> 7752</span>
<span class="ln"> 7753</span><span class="kt">void</span> <span class="nf">update_group_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 7754</span><span class="p">{</span>
<span class="ln"> 7755</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
<span class="ln"> 7756</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="o">*</span><span class="n">sdg</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
<span class="ln"> 7757</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">min_capacity</span><span class="p">;</span>
<span class="ln"> 7758</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 7759</span>
<span class="ln"> 7760</span>	<span class="n">interval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span><span class="p">);</span>
<span class="ln"> 7761</span>	<span class="n">interval</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="n">max_load_balance_interval</span><span class="p">);</span>
<span class="ln"> 7762</span>	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">next_update</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 7763</span>
<span class="ln"> 7764</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7765</span>		<span class="n">update_cpu_capacity</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7766</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 7767</span>	<span class="p">}</span>
<span class="ln"> 7768</span>
<span class="ln"> 7769</span>	<span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 7770</span>	<span class="n">min_capacity</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
<span class="ln"> 7771</span>
<span class="ln"> 7772</span>	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_OVERLAP</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7773</span>		<span class="cm">/*
</span><span class="ln"> 7774</span><span class="cm">		 * SD_OVERLAP domains cannot assume that child groups
</span><span class="ln"> 7775</span><span class="cm">		 * span the current group.
</span><span class="ln"> 7776</span><span class="cm">		 */</span>
<span class="ln"> 7777</span>
<span class="ln"> 7778</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">sdg</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7779</span>			<span class="k">struct</span> <span class="n">sched_group_capacity</span> <span class="o">*</span><span class="n">sgc</span><span class="p">;</span>
<span class="ln"> 7780</span>			<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7781</span>
<span class="ln"> 7782</span>			<span class="cm">/*
</span><span class="ln"> 7783</span><span class="cm">			 * build_sched_domains() -&gt; init_sched_groups_capacity()
</span><span class="ln"> 7784</span><span class="cm">			 * gets here before we&#39;ve attached the domains to the
</span><span class="ln"> 7785</span><span class="cm">			 * runqueues.
</span><span class="ln"> 7786</span><span class="cm">			 *
</span><span class="ln"> 7787</span><span class="cm">			 * Use capacity_of(), which is set irrespective of domains
</span><span class="ln"> 7788</span><span class="cm">			 * in update_cpu_capacity().
</span><span class="ln"> 7789</span><span class="cm">			 *
</span><span class="ln"> 7790</span><span class="cm">			 * This avoids capacity from being 0 and
</span><span class="ln"> 7791</span><span class="cm">			 * causing divide-by-zero issues on boot.
</span><span class="ln"> 7792</span><span class="cm">			 */</span>
<span class="ln"> 7793</span>			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 7794</span>				<span class="n">capacity</span> <span class="o">+=</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7795</span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 7796</span>				<span class="n">sgc</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="p">;</span>
<span class="ln"> 7797</span>				<span class="n">capacity</span> <span class="o">+=</span> <span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 7798</span>			<span class="p">}</span>
<span class="ln"> 7799</span>
<span class="ln"> 7800</span>			<span class="n">min_capacity</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">min_capacity</span><span class="p">);</span>
<span class="ln"> 7801</span>		<span class="p">}</span>
<span class="ln"> 7802</span>	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
<span class="ln"> 7803</span>		<span class="cm">/*
</span><span class="ln"> 7804</span><span class="cm">		 * !SD_OVERLAP domains can assume that child groups
</span><span class="ln"> 7805</span><span class="cm">		 * span the current group.
</span><span class="ln"> 7806</span><span class="cm">		 */</span>
<span class="ln"> 7807</span>
<span class="ln"> 7808</span>		<span class="n">group</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
<span class="ln"> 7809</span>		<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 7810</span>			<span class="k">struct</span> <span class="n">sched_group_capacity</span> <span class="o">*</span><span class="n">sgc</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="p">;</span>
<span class="ln"> 7811</span>
<span class="ln"> 7812</span>			<span class="n">capacity</span> <span class="o">+=</span> <span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 7813</span>			<span class="n">min_capacity</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">min_capacity</span><span class="p">,</span> <span class="n">min_capacity</span><span class="p">);</span>
<span class="ln"> 7814</span>			<span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="ln"> 7815</span>		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">group</span> <span class="o">!=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
<span class="ln"> 7816</span>	<span class="p">}</span>
<span class="ln"> 7817</span>
<span class="ln"> 7818</span>	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 7819</span>	<span class="n">sdg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">min_capacity</span> <span class="o">=</span> <span class="n">min_capacity</span><span class="p">;</span>
<span class="ln"> 7820</span><span class="p">}</span>
<span class="ln"> 7821</span>
<span class="ln"> 7822</span><span class="cm">/*
</span><span class="ln"> 7823</span><span class="cm"> * Check whether the capacity of the rq has been noticeably reduced by side
</span><span class="ln"> 7824</span><span class="cm"> * activity. The imbalance_pct is used for the threshold.
</span><span class="ln"> 7825</span><span class="cm"> * Return true is the capacity is reduced
</span><span class="ln"> 7826</span><span class="cm"> */</span>
<span class="ln"> 7827</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="ln"> 7828</span><span class="nf">check_cpu_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="ln"> 7829</span><span class="p">{</span>
<span class="ln"> 7830</span>	<span class="k">return</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_capacity</span> <span class="o">*</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="p">)</span> <span class="o">&lt;</span>
<span class="ln"> 7831</span>				<span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_capacity_orig</span> <span class="o">*</span> <span class="mi">100</span><span class="p">));</span>
<span class="ln"> 7832</span><span class="p">}</span>
<span class="ln"> 7833</span>
<span class="ln"> 7834</span><span class="cm">/*
</span><span class="ln"> 7835</span><span class="cm"> * Group imbalance indicates (and tries to solve) the problem where balancing
</span><span class="ln"> 7836</span><span class="cm"> * groups is inadequate due to -&gt;cpus_allowed constraints.
</span><span class="ln"> 7837</span><span class="cm"> *
</span><span class="ln"> 7838</span><span class="cm"> * Imagine a situation of two groups of 4 CPUs each and 4 tasks each with a
</span><span class="ln"> 7839</span><span class="cm"> * cpumask covering 1 CPU of the first group and 3 CPUs of the second group.
</span><span class="ln"> 7840</span><span class="cm"> * Something like:
</span><span class="ln"> 7841</span><span class="cm"> *
</span><span class="ln"> 7842</span><span class="cm"> *	{ 0 1 2 3 } { 4 5 6 7 }
</span><span class="ln"> 7843</span><span class="cm"> *	        *     * * *
</span><span class="ln"> 7844</span><span class="cm"> *
</span><span class="ln"> 7845</span><span class="cm"> * If we were to balance group-wise we&#39;d place two tasks in the first group and
</span><span class="ln"> 7846</span><span class="cm"> * two tasks in the second group. Clearly this is undesired as it will overload
</span><span class="ln"> 7847</span><span class="cm"> * cpu 3 and leave one of the CPUs in the second group unused.
</span><span class="ln"> 7848</span><span class="cm"> *
</span><span class="ln"> 7849</span><span class="cm"> * The current solution to this issue is detecting the skew in the first group
</span><span class="ln"> 7850</span><span class="cm"> * by noticing the lower domain failed to reach balance and had difficulty
</span><span class="ln"> 7851</span><span class="cm"> * moving tasks due to affinity constraints.
</span><span class="ln"> 7852</span><span class="cm"> *
</span><span class="ln"> 7853</span><span class="cm"> * When this is so detected; this group becomes a candidate for busiest; see
</span><span class="ln"> 7854</span><span class="cm"> * update_sd_pick_busiest(). And calculate_imbalance() and
</span><span class="ln"> 7855</span><span class="cm"> * find_busiest_group() avoid some of the usual balance conditions to allow it
</span><span class="ln"> 7856</span><span class="cm"> * to create an effective group imbalance.
</span><span class="ln"> 7857</span><span class="cm"> *
</span><span class="ln"> 7858</span><span class="cm"> * This is a somewhat tricky proposition since the next run might not find the
</span><span class="ln"> 7859</span><span class="cm"> * group imbalance and decide the groups need to be balanced again. A most
</span><span class="ln"> 7860</span><span class="cm"> * subtle and fragile situation.
</span><span class="ln"> 7861</span><span class="cm"> */</span>
<span class="ln"> 7862</span>
<span class="ln"> 7863</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sg_imbalanced</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="ln"> 7864</span><span class="p">{</span>
<span class="ln"> 7865</span>	<span class="k">return</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">imbalance</span><span class="p">;</span>
<span class="ln"> 7866</span><span class="p">}</span>
<span class="ln"> 7867</span>
<span class="ln"> 7868</span><span class="cm">/*
</span><span class="ln"> 7869</span><span class="cm"> * group_has_capacity returns true if the group has spare capacity that could
</span><span class="ln"> 7870</span><span class="cm"> * be used by some tasks.
</span><span class="ln"> 7871</span><span class="cm"> * We consider that a group has spare capacity if the  * number of task is
</span><span class="ln"> 7872</span><span class="cm"> * smaller than the number of CPUs or if the utilization is lower than the
</span><span class="ln"> 7873</span><span class="cm"> * available capacity for CFS tasks.
</span><span class="ln"> 7874</span><span class="cm"> * For the latter, we use a threshold to stabilize the state, to take into
</span><span class="ln"> 7875</span><span class="cm"> * account the variance of the tasks&#39; load and to return true if the available
</span><span class="ln"> 7876</span><span class="cm"> * capacity in meaningful for the load balancer.
</span><span class="ln"> 7877</span><span class="cm"> * As an example, an available capacity of 1% can appear but it doesn&#39;t make
</span><span class="ln"> 7878</span><span class="cm"> * any benefit for the load balance.
</span><span class="ln"> 7879</span><span class="cm"> */</span>
<span class="ln"> 7880</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="ln"> 7881</span><span class="nf">group_has_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="ln"> 7882</span><span class="p">{</span>
<span class="ln"> 7883</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&lt;</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_weight</span><span class="p">)</span>
<span class="ln"> 7884</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7885</span>
<span class="ln"> 7886</span>	<span class="k">if</span> <span class="p">((</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span>
<span class="ln"> 7887</span>			<span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_util</span> <span class="o">*</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="p">))</span>
<span class="ln"> 7888</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7889</span>
<span class="ln"> 7890</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7891</span><span class="p">}</span>
<span class="ln"> 7892</span>
<span class="ln"> 7893</span><span class="cm">/*
</span><span class="ln"> 7894</span><span class="cm"> *  group_is_overloaded returns true if the group has more tasks than it can
</span><span class="ln"> 7895</span><span class="cm"> *  handle.
</span><span class="ln"> 7896</span><span class="cm"> *  group_is_overloaded is not equals to !group_has_capacity because a group
</span><span class="ln"> 7897</span><span class="cm"> *  with the exact right number of tasks, has no more spare capacity but is not
</span><span class="ln"> 7898</span><span class="cm"> *  overloaded so both group_has_capacity and group_is_overloaded return
</span><span class="ln"> 7899</span><span class="cm"> *  false.
</span><span class="ln"> 7900</span><span class="cm"> */</span>
<span class="ln"> 7901</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="ln"> 7902</span><span class="nf">group_is_overloaded</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="ln"> 7903</span><span class="p">{</span>
<span class="ln"> 7904</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&lt;=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_weight</span><span class="p">)</span>
<span class="ln"> 7905</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7906</span>
<span class="ln"> 7907</span>	<span class="k">if</span> <span class="p">((</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span>
<span class="ln"> 7908</span>			<span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_util</span> <span class="o">*</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span><span class="p">))</span>
<span class="ln"> 7909</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7910</span>
<span class="ln"> 7911</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7912</span><span class="p">}</span>
<span class="ln"> 7913</span>
<span class="ln"> 7914</span><span class="cm">/*
</span><span class="ln"> 7915</span><span class="cm"> * group_smaller_cpu_capacity: Returns true if sched_group sg has smaller
</span><span class="ln"> 7916</span><span class="cm"> * per-CPU capacity than sched_group ref.
</span><span class="ln"> 7917</span><span class="cm"> */</span>
<span class="ln"> 7918</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="ln"> 7919</span><span class="nf">group_smaller_cpu_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="ln"> 7920</span><span class="p">{</span>
<span class="ln"> 7921</span>	<span class="k">return</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">min_capacity</span> <span class="o">*</span> <span class="n">capacity_margin</span> <span class="o">&lt;</span>
<span class="ln"> 7922</span>						<span class="n">ref</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">min_capacity</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
<span class="ln"> 7923</span><span class="p">}</span>
<span class="ln"> 7924</span>
<span class="ln"> 7925</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span>
<span class="ln"> 7926</span><span class="n">group_type</span> <span class="nf">group_classify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
<span class="ln"> 7927</span>			  <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="ln"> 7928</span><span class="p">{</span>
<span class="ln"> 7929</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_no_capacity</span><span class="p">)</span>
<span class="ln"> 7930</span>		<span class="k">return</span> <span class="n">group_overloaded</span><span class="p">;</span>
<span class="ln"> 7931</span>
<span class="ln"> 7932</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sg_imbalanced</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
<span class="ln"> 7933</span>		<span class="k">return</span> <span class="n">group_imbalanced</span><span class="p">;</span>
<span class="ln"> 7934</span>
<span class="ln"> 7935</span>	<span class="k">return</span> <span class="n">group_other</span><span class="p">;</span>
<span class="ln"> 7936</span><span class="p">}</span>
<span class="ln"> 7937</span>
<span class="ln"> 7938</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">update_nohz_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">force</span><span class="p">)</span>
<span class="ln"> 7939</span><span class="p">{</span>
<span class="ln"> 7940</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 7941</span><span class="cp"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 7942</span>
<span class="ln"> 7943</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">has_blocked_load</span><span class="p">)</span>
<span class="ln"> 7944</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7945</span>
<span class="ln"> 7946</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">))</span>
<span class="ln"> 7947</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7948</span>
<span class="ln"> 7949</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">last_blocked_load_update_tick</span><span class="p">))</span>
<span class="ln"> 7950</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7951</span>
<span class="ln"> 7952</span>	<span class="n">update_blocked_averages</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 7953</span>
<span class="ln"> 7954</span>	<span class="k">return</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">has_blocked_load</span><span class="p">;</span>
<span class="ln"> 7955</span><span class="cp">#else
</span><span class="ln"> 7956</span><span class="cp"></span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 7957</span><span class="cp">#endif
</span><span class="ln"> 7958</span><span class="cp"></span><span class="p">}</span>
<span class="ln"> 7959</span>
<span class="ln"> 7960</span><span class="cm">/**
</span><span class="ln"> 7961</span><span class="cm"> * update_sg_lb_stats - Update sched_group&#39;s statistics for load balancing.
</span><span class="ln"> 7962</span><span class="cm"> * @env: The load balancing environment.
</span><span class="ln"> 7963</span><span class="cm"> * @group: sched_group whose statistics are to be updated.
</span><span class="ln"> 7964</span><span class="cm"> * @load_idx: Load index of sched_domain of this_cpu for load calc.
</span><span class="ln"> 7965</span><span class="cm"> * @local_group: Does group contain this_cpu.
</span><span class="ln"> 7966</span><span class="cm"> * @sgs: variable to hold the statistics for this group.
</span><span class="ln"> 7967</span><span class="cm"> * @overload: Indicate more than one runnable task for any CPU.
</span><span class="ln"> 7968</span><span class="cm"> */</span>
<span class="ln"> 7969</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_sg_lb_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
<span class="ln"> 7970</span>			<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">load_idx</span><span class="p">,</span>
<span class="ln"> 7971</span>			<span class="kt">int</span> <span class="n">local_group</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">,</span>
<span class="ln"> 7972</span>			<span class="kt">bool</span> <span class="o">*</span><span class="n">overload</span><span class="p">)</span>
<span class="ln"> 7973</span><span class="p">{</span>
<span class="ln"> 7974</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 7975</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_running</span><span class="p">;</span>
<span class="ln"> 7976</span>
<span class="ln"> 7977</span>	<span class="n">memset</span><span class="p">(</span><span class="n">sgs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sgs</span><span class="p">));</span>
<span class="ln"> 7978</span>
<span class="ln"> 7979</span>	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7980</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln"> 7981</span>
<span class="ln"> 7982</span>		<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_NOHZ_STATS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">update_nohz_stats</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
<span class="ln"> 7983</span>			<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_NOHZ_AGAIN</span><span class="p">;</span>
<span class="ln"> 7984</span>
<span class="ln"> 7985</span>		<span class="cm">/* Bias balancing toward CPUs of our domain: */</span>
<span class="ln"> 7986</span>		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span>
<span class="ln"> 7987</span>			<span class="n">load</span> <span class="o">=</span> <span class="n">target_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
<span class="ln"> 7988</span>		<span class="k">else</span>
<span class="ln"> 7989</span>			<span class="n">load</span> <span class="o">=</span> <span class="n">source_load</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">);</span>
<span class="ln"> 7990</span>
<span class="ln"> 7991</span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_load</span> <span class="o">+=</span> <span class="n">load</span><span class="p">;</span>
<span class="ln"> 7992</span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_util</span> <span class="o">+=</span> <span class="n">cpu_util</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln"> 7993</span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">+=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">;</span>
<span class="ln"> 7994</span>
<span class="ln"> 7995</span>		<span class="n">nr_running</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">;</span>
<span class="ln"> 7996</span>		<span class="k">if</span> <span class="p">(</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 7997</span>			<span class="o">*</span><span class="n">overload</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 7998</span>
<span class="ln"> 7999</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln"> 8000</span><span class="cp"></span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">nr_numa_running</span> <span class="o">+=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_numa_running</span><span class="p">;</span>
<span class="ln"> 8001</span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span> <span class="o">+=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span><span class="p">;</span>
<span class="ln"> 8002</span><span class="cp">#endif
</span><span class="ln"> 8003</span><span class="cp"></span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_weighted_load</span> <span class="o">+=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 8004</span>		<span class="cm">/*
</span><span class="ln"> 8005</span><span class="cm">		 * No need to call idle_cpu() if nr_running is not 0
</span><span class="ln"> 8006</span><span class="cm">		 */</span>
<span class="ln"> 8007</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_running</span> <span class="o">&amp;&amp;</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="ln"> 8008</span>			<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">idle_cpus</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 8009</span>	<span class="p">}</span>
<span class="ln"> 8010</span>
<span class="ln"> 8011</span>	<span class="cm">/* Adjust by relative CPU capacity of the group */</span>
<span class="ln"> 8012</span>	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 8013</span>	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_load</span><span class="o">*</span><span class="n">SCHED_CAPACITY_SCALE</span><span class="p">)</span> <span class="o">/</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8014</span>
<span class="ln"> 8015</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">)</span>
<span class="ln"> 8016</span>		<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_weighted_load</span> <span class="o">/</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">;</span>
<span class="ln"> 8017</span>
<span class="ln"> 8018</span>	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_weight</span> <span class="o">=</span> <span class="n">group</span><span class="o">-&gt;</span><span class="n">group_weight</span><span class="p">;</span>
<span class="ln"> 8019</span>
<span class="ln"> 8020</span>	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_no_capacity</span> <span class="o">=</span> <span class="n">group_is_overloaded</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sgs</span><span class="p">);</span>
<span class="ln"> 8021</span>	<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">group_classify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">sgs</span><span class="p">);</span>
<span class="ln"> 8022</span><span class="p">}</span>
<span class="ln"> 8023</span>
<span class="ln"> 8024</span><span class="cm">/**
</span><span class="ln"> 8025</span><span class="cm"> * update_sd_pick_busiest - return 1 on busiest group
</span><span class="ln"> 8026</span><span class="cm"> * @env: The load balancing environment.
</span><span class="ln"> 8027</span><span class="cm"> * @sds: sched_domain statistics
</span><span class="ln"> 8028</span><span class="cm"> * @sg: sched_group candidate to be checked for being the busiest
</span><span class="ln"> 8029</span><span class="cm"> * @sgs: sched_group statistics
</span><span class="ln"> 8030</span><span class="cm"> *
</span><span class="ln"> 8031</span><span class="cm"> * Determine if @sg is a busier group than the previously selected
</span><span class="ln"> 8032</span><span class="cm"> * busiest group.
</span><span class="ln"> 8033</span><span class="cm"> *
</span><span class="ln"> 8034</span><span class="cm"> * Return: %true if @sg is a busier group than the previously selected
</span><span class="ln"> 8035</span><span class="cm"> * busiest group. %false otherwise.
</span><span class="ln"> 8036</span><span class="cm"> */</span>
<span class="ln"> 8037</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">update_sd_pick_busiest</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
<span class="ln"> 8038</span>				   <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">,</span>
<span class="ln"> 8039</span>				   <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span>
<span class="ln"> 8040</span>				   <span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="ln"> 8041</span><span class="p">{</span>
<span class="ln"> 8042</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">busiest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span><span class="p">;</span>
<span class="ln"> 8043</span>
<span class="ln"> 8044</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">&gt;</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_type</span><span class="p">)</span>
<span class="ln"> 8045</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 8046</span>
<span class="ln"> 8047</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">&lt;</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_type</span><span class="p">)</span>
<span class="ln"> 8048</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 8049</span>
<span class="ln"> 8050</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&lt;=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">)</span>
<span class="ln"> 8051</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 8052</span>
<span class="ln"> 8053</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_CPUCAPACITY</span><span class="p">))</span>
<span class="ln"> 8054</span>		<span class="k">goto</span> <span class="n">asym_packing</span><span class="p">;</span>
<span class="ln"> 8055</span>
<span class="ln"> 8056</span>	<span class="cm">/*
</span><span class="ln"> 8057</span><span class="cm">	 * Candidate sg has no more than one task per CPU and
</span><span class="ln"> 8058</span><span class="cm">	 * has higher per-CPU capacity. Migrating tasks to less
</span><span class="ln"> 8059</span><span class="cm">	 * capable CPUs may harm throughput. Maximize throughput,
</span><span class="ln"> 8060</span><span class="cm">	 * power/energy consequences are not considered.
</span><span class="ln"> 8061</span><span class="cm">	 */</span>
<span class="ln"> 8062</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&lt;=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_weight</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8063</span>	    <span class="n">group_smaller_cpu_capacity</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">local</span><span class="p">,</span> <span class="n">sg</span><span class="p">))</span>
<span class="ln"> 8064</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 8065</span>
<span class="ln"> 8066</span><span class="nl">asym_packing</span><span class="p">:</span>
<span class="ln"> 8067</span>	<span class="cm">/* This is the busiest node in its class. */</span>
<span class="ln"> 8068</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span><span class="p">))</span>
<span class="ln"> 8069</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 8070</span>
<span class="ln"> 8071</span>	<span class="cm">/* No ASYM_PACKING if target CPU is already busy */</span>
<span class="ln"> 8072</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NOT_IDLE</span><span class="p">)</span>
<span class="ln"> 8073</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 8074</span>	<span class="cm">/*
</span><span class="ln"> 8075</span><span class="cm">	 * ASYM_PACKING needs to move all the work to the highest
</span><span class="ln"> 8076</span><span class="cm">	 * prority CPUs in the group, therefore mark all groups
</span><span class="ln"> 8077</span><span class="cm">	 * of lower priority than ourself as busy.
</span><span class="ln"> 8078</span><span class="cm">	 */</span>
<span class="ln"> 8079</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8080</span>	    <span class="n">sched_asym_prefer</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">asym_prefer_cpu</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8081</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="p">)</span>
<span class="ln"> 8082</span>			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 8083</span>
<span class="ln"> 8084</span>		<span class="cm">/* Prefer to move from lowest priority CPU&#39;s work */</span>
<span class="ln"> 8085</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sched_asym_prefer</span><span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">asym_prefer_cpu</span><span class="p">,</span>
<span class="ln"> 8086</span>				      <span class="n">sg</span><span class="o">-&gt;</span><span class="n">asym_prefer_cpu</span><span class="p">))</span>
<span class="ln"> 8087</span>			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 8088</span>	<span class="p">}</span>
<span class="ln"> 8089</span>
<span class="ln"> 8090</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 8091</span><span class="p">}</span>
<span class="ln"> 8092</span>
<span class="ln"> 8093</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln"> 8094</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">fbq_type</span> <span class="nf">fbq_classify_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="ln"> 8095</span><span class="p">{</span>
<span class="ln"> 8096</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&gt;</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">nr_numa_running</span><span class="p">)</span>
<span class="ln"> 8097</span>		<span class="k">return</span> <span class="n">regular</span><span class="p">;</span>
<span class="ln"> 8098</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&gt;</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span><span class="p">)</span>
<span class="ln"> 8099</span>		<span class="k">return</span> <span class="n">remote</span><span class="p">;</span>
<span class="ln"> 8100</span>	<span class="k">return</span> <span class="n">all</span><span class="p">;</span>
<span class="ln"> 8101</span><span class="p">}</span>
<span class="ln"> 8102</span>
<span class="ln"> 8103</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">fbq_type</span> <span class="nf">fbq_classify_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 8104</span><span class="p">{</span>
<span class="ln"> 8105</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_numa_running</span><span class="p">)</span>
<span class="ln"> 8106</span>		<span class="k">return</span> <span class="n">regular</span><span class="p">;</span>
<span class="ln"> 8107</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_preferred_running</span><span class="p">)</span>
<span class="ln"> 8108</span>		<span class="k">return</span> <span class="n">remote</span><span class="p">;</span>
<span class="ln"> 8109</span>	<span class="k">return</span> <span class="n">all</span><span class="p">;</span>
<span class="ln"> 8110</span><span class="p">}</span>
<span class="ln"> 8111</span><span class="cp">#else
</span><span class="ln"> 8112</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">fbq_type</span> <span class="nf">fbq_classify_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span><span class="p">)</span>
<span class="ln"> 8113</span><span class="p">{</span>
<span class="ln"> 8114</span>	<span class="k">return</span> <span class="n">all</span><span class="p">;</span>
<span class="ln"> 8115</span><span class="p">}</span>
<span class="ln"> 8116</span>
<span class="ln"> 8117</span><span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">fbq_type</span> <span class="nf">fbq_classify_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 8118</span><span class="p">{</span>
<span class="ln"> 8119</span>	<span class="k">return</span> <span class="n">regular</span><span class="p">;</span>
<span class="ln"> 8120</span><span class="p">}</span>
<span class="ln"> 8121</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA_BALANCING */</span><span class="cp">
</span><span class="ln"> 8122</span><span class="cp"></span>
<span class="ln"> 8123</span><span class="cm">/**
</span><span class="ln"> 8124</span><span class="cm"> * update_sd_lb_stats - Update sched_domain&#39;s statistics for load balancing.
</span><span class="ln"> 8125</span><span class="cm"> * @env: The load balancing environment.
</span><span class="ln"> 8126</span><span class="cm"> * @sds: variable to hold the statistics for this sched_domain.
</span><span class="ln"> 8127</span><span class="cm"> */</span>
<span class="ln"> 8128</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update_sd_lb_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 8129</span><span class="p">{</span>
<span class="ln"> 8130</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
<span class="ln"> 8131</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
<span class="ln"> 8132</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">local_stat</span><span class="p">;</span>
<span class="ln"> 8133</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="n">tmp_sgs</span><span class="p">;</span>
<span class="ln"> 8134</span>	<span class="kt">int</span> <span class="n">load_idx</span><span class="p">,</span> <span class="n">prefer_sibling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8135</span>	<span class="kt">bool</span> <span class="n">overload</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 8136</span>
<span class="ln"> 8137</span>	<span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="o">&amp;&amp;</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_PREFER_SIBLING</span><span class="p">)</span>
<span class="ln"> 8138</span>		<span class="n">prefer_sibling</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8139</span>
<span class="ln"> 8140</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 8141</span><span class="cp"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span> <span class="o">&amp;&amp;</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">has_blocked</span><span class="p">))</span>
<span class="ln"> 8142</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_NOHZ_STATS</span><span class="p">;</span>
<span class="ln"> 8143</span><span class="cp">#endif
</span><span class="ln"> 8144</span><span class="cp"></span>
<span class="ln"> 8145</span>	<span class="n">load_idx</span> <span class="o">=</span> <span class="n">get_sd_load_idx</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">);</span>
<span class="ln"> 8146</span>
<span class="ln"> 8147</span>	<span class="k">do</span> <span class="p">{</span>
<span class="ln"> 8148</span>		<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">sgs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_sgs</span><span class="p">;</span>
<span class="ln"> 8149</span>		<span class="kt">int</span> <span class="n">local_group</span><span class="p">;</span>
<span class="ln"> 8150</span>
<span class="ln"> 8151</span>		<span class="n">local_group</span> <span class="o">=</span> <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="ln"> 8152</span>		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8153</span>			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">local</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
<span class="ln"> 8154</span>			<span class="n">sgs</span> <span class="o">=</span> <span class="n">local</span><span class="p">;</span>
<span class="ln"> 8155</span>
<span class="ln"> 8156</span>			<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NEWLY_IDLE</span> <span class="o">||</span>
<span class="ln"> 8157</span>			    <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">next_update</span><span class="p">))</span>
<span class="ln"> 8158</span>				<span class="n">update_group_capacity</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 8159</span>		<span class="p">}</span>
<span class="ln"> 8160</span>
<span class="ln"> 8161</span>		<span class="n">update_sg_lb_stats</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">load_idx</span><span class="p">,</span> <span class="n">local_group</span><span class="p">,</span> <span class="n">sgs</span><span class="p">,</span>
<span class="ln"> 8162</span>						<span class="o">&amp;</span><span class="n">overload</span><span class="p">);</span>
<span class="ln"> 8163</span>
<span class="ln"> 8164</span>		<span class="k">if</span> <span class="p">(</span><span class="n">local_group</span><span class="p">)</span>
<span class="ln"> 8165</span>			<span class="k">goto</span> <span class="n">next_group</span><span class="p">;</span>
<span class="ln"> 8166</span>
<span class="ln"> 8167</span>		<span class="cm">/*
</span><span class="ln"> 8168</span><span class="cm">		 * In case the child domain prefers tasks go to siblings
</span><span class="ln"> 8169</span><span class="cm">		 * first, lower the sg capacity so that we&#39;ll try
</span><span class="ln"> 8170</span><span class="cm">		 * and move all the excess tasks away. We lower the capacity
</span><span class="ln"> 8171</span><span class="cm">		 * of a group only if the local group has the capacity to fit
</span><span class="ln"> 8172</span><span class="cm">		 * these excess tasks. The extra check prevents the case where
</span><span class="ln"> 8173</span><span class="cm">		 * you always pull from the heaviest group when it is already
</span><span class="ln"> 8174</span><span class="cm">		 * under-utilized (possible with a large weight task outweighs
</span><span class="ln"> 8175</span><span class="cm">		 * the tasks on the system).
</span><span class="ln"> 8176</span><span class="cm">		 */</span>
<span class="ln"> 8177</span>		<span class="k">if</span> <span class="p">(</span><span class="n">prefer_sibling</span> <span class="o">&amp;&amp;</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">local</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8178</span>		    <span class="n">group_has_capacity</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8179</span>		    <span class="p">(</span><span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">&gt;</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8180</span>			<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_no_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8181</span>			<span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">group_classify</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">sgs</span><span class="p">);</span>
<span class="ln"> 8182</span>		<span class="p">}</span>
<span class="ln"> 8183</span>
<span class="ln"> 8184</span>		<span class="k">if</span> <span class="p">(</span><span class="n">update_sd_pick_busiest</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sds</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sgs</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8185</span>			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span> <span class="o">=</span> <span class="n">sg</span><span class="p">;</span>
<span class="ln"> 8186</span>			<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span> <span class="o">=</span> <span class="o">*</span><span class="n">sgs</span><span class="p">;</span>
<span class="ln"> 8187</span>		<span class="p">}</span>
<span class="ln"> 8188</span>
<span class="ln"> 8189</span><span class="nl">next_group</span><span class="p">:</span>
<span class="ln"> 8190</span>		<span class="cm">/* Now, start updating sd_lb_stats */</span>
<span class="ln"> 8191</span>		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">total_running</span> <span class="o">+=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">;</span>
<span class="ln"> 8192</span>		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">total_load</span> <span class="o">+=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_load</span><span class="p">;</span>
<span class="ln"> 8193</span>		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">total_capacity</span> <span class="o">+=</span> <span class="n">sgs</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8194</span>
<span class="ln"> 8195</span>		<span class="n">sg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="ln"> 8196</span>	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sg</span> <span class="o">!=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>
<span class="ln"> 8197</span>
<span class="ln"> 8198</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 8199</span><span class="cp"></span>	<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_NOHZ_AGAIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8200</span>	    <span class="n">cpumask_subset</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">)))</span> <span class="p">{</span>
<span class="ln"> 8201</span>
<span class="ln"> 8202</span>		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">next_blocked</span><span class="p">,</span>
<span class="ln"> 8203</span>			   <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">LOAD_AVG_PERIOD</span><span class="p">));</span>
<span class="ln"> 8204</span>	<span class="p">}</span>
<span class="ln"> 8205</span><span class="cp">#endif
</span><span class="ln"> 8206</span><span class="cp"></span>
<span class="ln"> 8207</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_NUMA</span><span class="p">)</span>
<span class="ln"> 8208</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">fbq_type</span> <span class="o">=</span> <span class="n">fbq_classify_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span><span class="p">);</span>
<span class="ln"> 8209</span>
<span class="ln"> 8210</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8211</span>		<span class="cm">/* update overload indicator if we are at root domain */</span>
<span class="ln"> 8212</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">overload</span> <span class="o">!=</span> <span class="n">overload</span><span class="p">)</span>
<span class="ln"> 8213</span>			<span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">overload</span> <span class="o">=</span> <span class="n">overload</span><span class="p">;</span>
<span class="ln"> 8214</span>	<span class="p">}</span>
<span class="ln"> 8215</span><span class="p">}</span>
<span class="ln"> 8216</span>
<span class="ln"> 8217</span><span class="cm">/**
</span><span class="ln"> 8218</span><span class="cm"> * check_asym_packing - Check to see if the group is packed into the
</span><span class="ln"> 8219</span><span class="cm"> *			sched domain.
</span><span class="ln"> 8220</span><span class="cm"> *
</span><span class="ln"> 8221</span><span class="cm"> * This is primarily intended to used at the sibling level.  Some
</span><span class="ln"> 8222</span><span class="cm"> * cores like POWER7 prefer to use lower numbered SMT threads.  In the
</span><span class="ln"> 8223</span><span class="cm"> * case of POWER7, it can move to lower SMT modes only when higher
</span><span class="ln"> 8224</span><span class="cm"> * threads are idle.  When in lower SMT modes, the threads will
</span><span class="ln"> 8225</span><span class="cm"> * perform better since they share less core resources.  Hence when we
</span><span class="ln"> 8226</span><span class="cm"> * have idle threads, we want them to be the higher ones.
</span><span class="ln"> 8227</span><span class="cm"> *
</span><span class="ln"> 8228</span><span class="cm"> * This packing function is run on idle threads.  It checks to see if
</span><span class="ln"> 8229</span><span class="cm"> * the busiest CPU in this domain (core in the P7 case) has a higher
</span><span class="ln"> 8230</span><span class="cm"> * CPU number than the packing function is being run on.  Here we are
</span><span class="ln"> 8231</span><span class="cm"> * assuming lower CPU number will be equivalent to lower a SMT thread
</span><span class="ln"> 8232</span><span class="cm"> * number.
</span><span class="ln"> 8233</span><span class="cm"> *
</span><span class="ln"> 8234</span><span class="cm"> * Return: 1 when packing is required and a task should be moved to
</span><span class="ln"> 8235</span><span class="cm"> * this CPU.  The amount of the imbalance is returned in env-&gt;imbalance.
</span><span class="ln"> 8236</span><span class="cm"> *
</span><span class="ln"> 8237</span><span class="cm"> * @env: The load balancing environment.
</span><span class="ln"> 8238</span><span class="cm"> * @sds: Statistics of the sched_domain which is to be packed
</span><span class="ln"> 8239</span><span class="cm"> */</span>
<span class="ln"> 8240</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">check_asym_packing</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 8241</span><span class="p">{</span>
<span class="ln"> 8242</span>	<span class="kt">int</span> <span class="n">busiest_cpu</span><span class="p">;</span>
<span class="ln"> 8243</span>
<span class="ln"> 8244</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span><span class="p">))</span>
<span class="ln"> 8245</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8246</span>
<span class="ln"> 8247</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NOT_IDLE</span><span class="p">)</span>
<span class="ln"> 8248</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8249</span>
<span class="ln"> 8250</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="p">)</span>
<span class="ln"> 8251</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8252</span>
<span class="ln"> 8253</span>	<span class="n">busiest_cpu</span> <span class="o">=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">asym_prefer_cpu</span><span class="p">;</span>
<span class="ln"> 8254</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sched_asym_prefer</span><span class="p">(</span><span class="n">busiest_cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">))</span>
<span class="ln"> 8255</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8256</span>
<span class="ln"> 8257</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">DIV_ROUND_CLOSEST</span><span class="p">(</span>
<span class="ln"> 8258</span>		<span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span><span class="p">.</span><span class="n">avg_load</span> <span class="o">*</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span><span class="p">.</span><span class="n">group_capacity</span><span class="p">,</span>
<span class="ln"> 8259</span>		<span class="n">SCHED_CAPACITY_SCALE</span><span class="p">);</span>
<span class="ln"> 8260</span>
<span class="ln"> 8261</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8262</span><span class="p">}</span>
<span class="ln"> 8263</span>
<span class="ln"> 8264</span><span class="cm">/**
</span><span class="ln"> 8265</span><span class="cm"> * fix_small_imbalance - Calculate the minor imbalance that exists
</span><span class="ln"> 8266</span><span class="cm"> *			amongst the groups of a sched_domain, during
</span><span class="ln"> 8267</span><span class="cm"> *			load balancing.
</span><span class="ln"> 8268</span><span class="cm"> * @env: The load balancing environment.
</span><span class="ln"> 8269</span><span class="cm"> * @sds: Statistics of the sched_domain whose imbalance is to be calculated.
</span><span class="ln"> 8270</span><span class="cm"> */</span>
<span class="ln"> 8271</span><span class="k">static</span> <span class="kr">inline</span>
<span class="ln"> 8272</span><span class="kt">void</span> <span class="nf">fix_small_imbalance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 8273</span><span class="p">{</span>
<span class="ln"> 8274</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">capa_now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">capa_move</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8275</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">imbn</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 8276</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scaled_busy_load_per_task</span><span class="p">;</span>
<span class="ln"> 8277</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8278</span>
<span class="ln"> 8279</span>	<span class="n">local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">local_stat</span><span class="p">;</span>
<span class="ln"> 8280</span>	<span class="n">busiest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span><span class="p">;</span>
<span class="ln"> 8281</span>
<span class="ln"> 8282</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span><span class="p">)</span>
<span class="ln"> 8283</span>		<span class="n">local</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">=</span> <span class="n">cpu_avg_load_per_task</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">);</span>
<span class="ln"> 8284</span>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">&gt;</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">)</span>
<span class="ln"> 8285</span>		<span class="n">imbn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8286</span>
<span class="ln"> 8287</span>	<span class="n">scaled_busy_load_per_task</span> <span class="o">=</span>
<span class="ln"> 8288</span>		<span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">*</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">)</span> <span class="o">/</span>
<span class="ln"> 8289</span>		<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8290</span>
<span class="ln"> 8291</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">+</span> <span class="n">scaled_busy_load_per_task</span> <span class="o">&gt;=</span>
<span class="ln"> 8292</span>	    <span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">+</span> <span class="p">(</span><span class="n">scaled_busy_load_per_task</span> <span class="o">*</span> <span class="n">imbn</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8293</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">;</span>
<span class="ln"> 8294</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 8295</span>	<span class="p">}</span>
<span class="ln"> 8296</span>
<span class="ln"> 8297</span>	<span class="cm">/*
</span><span class="ln"> 8298</span><span class="cm">	 * OK, we don&#39;t have enough imbalance to justify moving tasks,
</span><span class="ln"> 8299</span><span class="cm">	 * however we may be able to increase total CPU capacity used by
</span><span class="ln"> 8300</span><span class="cm">	 * moving them.
</span><span class="ln"> 8301</span><span class="cm">	 */</span>
<span class="ln"> 8302</span>
<span class="ln"> 8303</span>	<span class="n">capa_now</span> <span class="o">+=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">*</span>
<span class="ln"> 8304</span>			<span class="n">min</span><span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">,</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">);</span>
<span class="ln"> 8305</span>	<span class="n">capa_now</span> <span class="o">+=</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">*</span>
<span class="ln"> 8306</span>			<span class="n">min</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">,</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">);</span>
<span class="ln"> 8307</span>	<span class="n">capa_now</span> <span class="o">/=</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>
<span class="ln"> 8308</span>
<span class="ln"> 8309</span>	<span class="cm">/* Amount of load we&#39;d subtract */</span>
<span class="ln"> 8310</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&gt;</span> <span class="n">scaled_busy_load_per_task</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8311</span>		<span class="n">capa_move</span> <span class="o">+=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">*</span>
<span class="ln"> 8312</span>			    <span class="n">min</span><span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">,</span>
<span class="ln"> 8313</span>				<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">-</span> <span class="n">scaled_busy_load_per_task</span><span class="p">);</span>
<span class="ln"> 8314</span>	<span class="p">}</span>
<span class="ln"> 8315</span>
<span class="ln"> 8316</span>	<span class="cm">/* Amount of load we&#39;d add */</span>
<span class="ln"> 8317</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">*</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">&lt;</span>
<span class="ln"> 8318</span>	    <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">*</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8319</span>		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">*</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">)</span> <span class="o">/</span>
<span class="ln"> 8320</span>		      <span class="n">local</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8321</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 8322</span>		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">*</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">)</span> <span class="o">/</span>
<span class="ln"> 8323</span>		      <span class="n">local</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8324</span>	<span class="p">}</span>
<span class="ln"> 8325</span>	<span class="n">capa_move</span> <span class="o">+=</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">group_capacity</span> <span class="o">*</span>
<span class="ln"> 8326</span>		    <span class="n">min</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">,</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">+</span> <span class="n">tmp</span><span class="p">);</span>
<span class="ln"> 8327</span>	<span class="n">capa_move</span> <span class="o">/=</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>
<span class="ln"> 8328</span>
<span class="ln"> 8329</span>	<span class="cm">/* Move if we gain throughput */</span>
<span class="ln"> 8330</span>	<span class="k">if</span> <span class="p">(</span><span class="n">capa_move</span> <span class="o">&gt;</span> <span class="n">capa_now</span><span class="p">)</span>
<span class="ln"> 8331</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">;</span>
<span class="ln"> 8332</span><span class="p">}</span>
<span class="ln"> 8333</span>
<span class="ln"> 8334</span><span class="cm">/**
</span><span class="ln"> 8335</span><span class="cm"> * calculate_imbalance - Calculate the amount of imbalance present within the
</span><span class="ln"> 8336</span><span class="cm"> *			 groups of a given sched_domain during load balance.
</span><span class="ln"> 8337</span><span class="cm"> * @env: load balance environment
</span><span class="ln"> 8338</span><span class="cm"> * @sds: statistics of the sched_domain whose imbalance is to be calculated.
</span><span class="ln"> 8339</span><span class="cm"> */</span>
<span class="ln"> 8340</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">calculate_imbalance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="o">*</span><span class="n">sds</span><span class="p">)</span>
<span class="ln"> 8341</span><span class="p">{</span>
<span class="ln"> 8342</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pull</span><span class="p">,</span> <span class="n">load_above_capacity</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="ln"> 8343</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8344</span>
<span class="ln"> 8345</span>	<span class="n">local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">local_stat</span><span class="p">;</span>
<span class="ln"> 8346</span>	<span class="n">busiest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">busiest_stat</span><span class="p">;</span>
<span class="ln"> 8347</span>
<span class="ln"> 8348</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">==</span> <span class="n">group_imbalanced</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8349</span>		<span class="cm">/*
</span><span class="ln"> 8350</span><span class="cm">		 * In the group_imb case we cannot rely on group-wide averages
</span><span class="ln"> 8351</span><span class="cm">		 * to ensure CPU-load equilibrium, look at wider averages. XXX
</span><span class="ln"> 8352</span><span class="cm">		 */</span>
<span class="ln"> 8353</span>		<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span> <span class="o">=</span>
<span class="ln"> 8354</span>			<span class="n">min</span><span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">,</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">);</span>
<span class="ln"> 8355</span>	<span class="p">}</span>
<span class="ln"> 8356</span>
<span class="ln"> 8357</span>	<span class="cm">/*
</span><span class="ln"> 8358</span><span class="cm">	 * Avg load of busiest sg can be less and avg load of local sg can
</span><span class="ln"> 8359</span><span class="cm">	 * be greater than avg load across all sgs of sd because avg load
</span><span class="ln"> 8360</span><span class="cm">	 * factors in sg capacity and sgs with smaller group_type are
</span><span class="ln"> 8361</span><span class="cm">	 * skipped when updating the busiest sg:
</span><span class="ln"> 8362</span><span class="cm">	 */</span>
<span class="ln"> 8363</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&lt;=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">||</span>
<span class="ln"> 8364</span>	    <span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&gt;=</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8365</span>		<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8366</span>		<span class="k">return</span> <span class="n">fix_small_imbalance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sds</span><span class="p">);</span>
<span class="ln"> 8367</span>	<span class="p">}</span>
<span class="ln"> 8368</span>
<span class="ln"> 8369</span>	<span class="cm">/*
</span><span class="ln"> 8370</span><span class="cm">	 * If there aren&#39;t any idle CPUs, avoid creating some.
</span><span class="ln"> 8371</span><span class="cm">	 */</span>
<span class="ln"> 8372</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">==</span> <span class="n">group_overloaded</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8373</span>	    <span class="n">local</span><span class="o">-&gt;</span><span class="n">group_type</span>   <span class="o">==</span> <span class="n">group_overloaded</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8374</span>		<span class="n">load_above_capacity</span> <span class="o">=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">*</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>
<span class="ln"> 8375</span>		<span class="k">if</span> <span class="p">(</span><span class="n">load_above_capacity</span> <span class="o">&gt;</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8376</span>			<span class="n">load_above_capacity</span> <span class="o">-=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8377</span>			<span class="n">load_above_capacity</span> <span class="o">*=</span> <span class="n">scale_load_down</span><span class="p">(</span><span class="n">NICE_0_LOAD</span><span class="p">);</span>
<span class="ln"> 8378</span>			<span class="n">load_above_capacity</span> <span class="o">/=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">;</span>
<span class="ln"> 8379</span>		<span class="p">}</span> <span class="k">else</span>
<span class="ln"> 8380</span>			<span class="n">load_above_capacity</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="ln"> 8381</span>	<span class="p">}</span>
<span class="ln"> 8382</span>
<span class="ln"> 8383</span>	<span class="cm">/*
</span><span class="ln"> 8384</span><span class="cm">	 * We&#39;re trying to get all the CPUs to the average_load, so we don&#39;t
</span><span class="ln"> 8385</span><span class="cm">	 * want to push ourselves above the average load, nor do we wish to
</span><span class="ln"> 8386</span><span class="cm">	 * reduce the max loaded CPU below the average load. At the same time,
</span><span class="ln"> 8387</span><span class="cm">	 * we also don&#39;t want to reduce the group load below the group
</span><span class="ln"> 8388</span><span class="cm">	 * capacity. Thus we look for the minimum possible imbalance.
</span><span class="ln"> 8389</span><span class="cm">	 */</span>
<span class="ln"> 8390</span>	<span class="n">max_pull</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">-</span> <span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">,</span> <span class="n">load_above_capacity</span><span class="p">);</span>
<span class="ln"> 8391</span>
<span class="ln"> 8392</span>	<span class="cm">/* How much load to actually move to equalise the imbalance */</span>
<span class="ln"> 8393</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span>
<span class="ln"> 8394</span>		<span class="n">max_pull</span> <span class="o">*</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_capacity</span><span class="p">,</span>
<span class="ln"> 8395</span>		<span class="p">(</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">-</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">)</span> <span class="o">*</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">group_capacity</span>
<span class="ln"> 8396</span>	<span class="p">)</span> <span class="o">/</span> <span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>
<span class="ln"> 8397</span>
<span class="ln"> 8398</span>	<span class="cm">/*
</span><span class="ln"> 8399</span><span class="cm">	 * if *imbalance is less than the average load per runnable task
</span><span class="ln"> 8400</span><span class="cm">	 * there is no guarantee that any tasks will be moved so we&#39;ll have
</span><span class="ln"> 8401</span><span class="cm">	 * a think about bumping its value to force at least one task to be
</span><span class="ln"> 8402</span><span class="cm">	 * moved
</span><span class="ln"> 8403</span><span class="cm">	 */</span>
<span class="ln"> 8404</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&lt;</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">load_per_task</span><span class="p">)</span>
<span class="ln"> 8405</span>		<span class="k">return</span> <span class="n">fix_small_imbalance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">sds</span><span class="p">);</span>
<span class="ln"> 8406</span><span class="p">}</span>
<span class="ln"> 8407</span>
<span class="ln"> 8408</span><span class="cm">/******* find_busiest_group() helpers end here *********************/</span>
<span class="ln"> 8409</span>
<span class="ln"> 8410</span><span class="cm">/**
</span><span class="ln"> 8411</span><span class="cm"> * find_busiest_group - Returns the busiest group within the sched_domain
</span><span class="ln"> 8412</span><span class="cm"> * if there is an imbalance.
</span><span class="ln"> 8413</span><span class="cm"> *
</span><span class="ln"> 8414</span><span class="cm"> * Also calculates the amount of weighted load which should be moved
</span><span class="ln"> 8415</span><span class="cm"> * to restore balance.
</span><span class="ln"> 8416</span><span class="cm"> *
</span><span class="ln"> 8417</span><span class="cm"> * @env: The load balancing environment.
</span><span class="ln"> 8418</span><span class="cm"> *
</span><span class="ln"> 8419</span><span class="cm"> * Return:	- The busiest group if imbalance exists.
</span><span class="ln"> 8420</span><span class="cm"> */</span>
<span class="ln"> 8421</span><span class="k">static</span> <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="nf">find_busiest_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 8422</span><span class="p">{</span>
<span class="ln"> 8423</span>	<span class="k">struct</span> <span class="n">sg_lb_stats</span> <span class="o">*</span><span class="n">local</span><span class="p">,</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8424</span>	<span class="k">struct</span> <span class="n">sd_lb_stats</span> <span class="n">sds</span><span class="p">;</span>
<span class="ln"> 8425</span>
<span class="ln"> 8426</span>	<span class="n">init_sd_lb_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sds</span><span class="p">);</span>
<span class="ln"> 8427</span>
<span class="ln"> 8428</span>	<span class="cm">/*
</span><span class="ln"> 8429</span><span class="cm">	 * Compute the various statistics relavent for load balancing at
</span><span class="ln"> 8430</span><span class="cm">	 * this level.
</span><span class="ln"> 8431</span><span class="cm">	 */</span>
<span class="ln"> 8432</span>	<span class="n">update_sd_lb_stats</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">);</span>
<span class="ln"> 8433</span>	<span class="n">local</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">.</span><span class="n">local_stat</span><span class="p">;</span>
<span class="ln"> 8434</span>	<span class="n">busiest</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">.</span><span class="n">busiest_stat</span><span class="p">;</span>
<span class="ln"> 8435</span>
<span class="ln"> 8436</span>	<span class="cm">/* ASYM feature bypasses nice load balance check */</span>
<span class="ln"> 8437</span>	<span class="k">if</span> <span class="p">(</span><span class="n">check_asym_packing</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">))</span>
<span class="ln"> 8438</span>		<span class="k">return</span> <span class="n">sds</span><span class="p">.</span><span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8439</span>
<span class="ln"> 8440</span>	<span class="cm">/* There is no busy sibling group to pull tasks from */</span>
<span class="ln"> 8441</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="p">.</span><span class="n">busiest</span> <span class="o">||</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">sum_nr_running</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 8442</span>		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8443</span>
<span class="ln"> 8444</span>	<span class="cm">/* XXX broken for overlapping NUMA groups */</span>
<span class="ln"> 8445</span>	<span class="n">sds</span><span class="p">.</span><span class="n">avg_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">SCHED_CAPACITY_SCALE</span> <span class="o">*</span> <span class="n">sds</span><span class="p">.</span><span class="n">total_load</span><span class="p">)</span>
<span class="ln"> 8446</span>						<span class="o">/</span> <span class="n">sds</span><span class="p">.</span><span class="n">total_capacity</span><span class="p">;</span>
<span class="ln"> 8447</span>
<span class="ln"> 8448</span>	<span class="cm">/*
</span><span class="ln"> 8449</span><span class="cm">	 * If the busiest group is imbalanced the below checks don&#39;t
</span><span class="ln"> 8450</span><span class="cm">	 * work because they assume all things are equal, which typically
</span><span class="ln"> 8451</span><span class="cm">	 * isn&#39;t true due to cpus_allowed constraints and the like.
</span><span class="ln"> 8452</span><span class="cm">	 */</span>
<span class="ln"> 8453</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">==</span> <span class="n">group_imbalanced</span><span class="p">)</span>
<span class="ln"> 8454</span>		<span class="k">goto</span> <span class="n">force_balance</span><span class="p">;</span>
<span class="ln"> 8455</span>
<span class="ln"> 8456</span>	<span class="cm">/*
</span><span class="ln"> 8457</span><span class="cm">	 * When dst_cpu is idle, prevent SMP nice and/or asymmetric group
</span><span class="ln"> 8458</span><span class="cm">	 * capacities from resulting in underutilization due to avg_load.
</span><span class="ln"> 8459</span><span class="cm">	 */</span>
<span class="ln"> 8460</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NOT_IDLE</span> <span class="o">&amp;&amp;</span> <span class="n">group_has_capacity</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8461</span>	    <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_no_capacity</span><span class="p">)</span>
<span class="ln"> 8462</span>		<span class="k">goto</span> <span class="n">force_balance</span><span class="p">;</span>
<span class="ln"> 8463</span>
<span class="ln"> 8464</span>	<span class="cm">/*
</span><span class="ln"> 8465</span><span class="cm">	 * If the local group is busier than the selected busiest group
</span><span class="ln"> 8466</span><span class="cm">	 * don&#39;t try and pull any tasks.
</span><span class="ln"> 8467</span><span class="cm">	 */</span>
<span class="ln"> 8468</span>	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&gt;=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">)</span>
<span class="ln"> 8469</span>		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8470</span>
<span class="ln"> 8471</span>	<span class="cm">/*
</span><span class="ln"> 8472</span><span class="cm">	 * Don&#39;t pull any tasks if this group is already above the domain
</span><span class="ln"> 8473</span><span class="cm">	 * average load.
</span><span class="ln"> 8474</span><span class="cm">	 */</span>
<span class="ln"> 8475</span>	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&gt;=</span> <span class="n">sds</span><span class="p">.</span><span class="n">avg_load</span><span class="p">)</span>
<span class="ln"> 8476</span>		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8477</span>
<span class="ln"> 8478</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_IDLE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8479</span>		<span class="cm">/*
</span><span class="ln"> 8480</span><span class="cm">		 * This CPU is idle. If the busiest group is not overloaded
</span><span class="ln"> 8481</span><span class="cm">		 * and there is no imbalance between this and busiest group
</span><span class="ln"> 8482</span><span class="cm">		 * wrt idle CPUs, it is balanced. The imbalance becomes
</span><span class="ln"> 8483</span><span class="cm">		 * significant if the diff is greater than 1 otherwise we
</span><span class="ln"> 8484</span><span class="cm">		 * might end up to just move the imbalance on another group
</span><span class="ln"> 8485</span><span class="cm">		 */</span>
<span class="ln"> 8486</span>		<span class="k">if</span> <span class="p">((</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">!=</span> <span class="n">group_overloaded</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8487</span>				<span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">idle_cpus</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">idle_cpus</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
<span class="ln"> 8488</span>			<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8489</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 8490</span>		<span class="cm">/*
</span><span class="ln"> 8491</span><span class="cm">		 * In the CPU_NEWLY_IDLE, CPU_NOT_IDLE cases, use
</span><span class="ln"> 8492</span><span class="cm">		 * imbalance_pct to be conservative.
</span><span class="ln"> 8493</span><span class="cm">		 */</span>
<span class="ln"> 8494</span>		<span class="k">if</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">avg_load</span> <span class="o">&lt;=</span>
<span class="ln"> 8495</span>				<span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span> <span class="o">*</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">avg_load</span><span class="p">)</span>
<span class="ln"> 8496</span>			<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8497</span>	<span class="p">}</span>
<span class="ln"> 8498</span>
<span class="ln"> 8499</span><span class="nl">force_balance</span><span class="p">:</span>
<span class="ln"> 8500</span>	<span class="cm">/* Looks like there is an imbalance. Compute it */</span>
<span class="ln"> 8501</span>	<span class="n">calculate_imbalance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sds</span><span class="p">);</span>
<span class="ln"> 8502</span>	<span class="k">return</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">?</span> <span class="n">sds</span><span class="p">.</span><span class="nl">busiest</span> <span class="p">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 8503</span>
<span class="ln"> 8504</span><span class="nl">out_balanced</span><span class="p">:</span>
<span class="ln"> 8505</span>	<span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8506</span>	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 8507</span><span class="p">}</span>
<span class="ln"> 8508</span>
<span class="ln"> 8509</span><span class="cm">/*
</span><span class="ln"> 8510</span><span class="cm"> * find_busiest_queue - find the busiest runqueue among the CPUs in the group.
</span><span class="ln"> 8511</span><span class="cm"> */</span>
<span class="ln"> 8512</span><span class="k">static</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="nf">find_busiest_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
<span class="ln"> 8513</span>				     <span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">)</span>
<span class="ln"> 8514</span><span class="p">{</span>
<span class="ln"> 8515</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln"> 8516</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">busiest_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">busiest_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8517</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln"> 8518</span>
<span class="ln"> 8519</span>	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8520</span>		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">wl</span><span class="p">;</span>
<span class="ln"> 8521</span>		<span class="k">enum</span> <span class="n">fbq_type</span> <span class="n">rt</span><span class="p">;</span>
<span class="ln"> 8522</span>
<span class="ln"> 8523</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln"> 8524</span>		<span class="n">rt</span> <span class="o">=</span> <span class="n">fbq_classify_rq</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 8525</span>
<span class="ln"> 8526</span>		<span class="cm">/*
</span><span class="ln"> 8527</span><span class="cm">		 * We classify groups/runqueues into three groups:
</span><span class="ln"> 8528</span><span class="cm">		 *  - regular: there are !numa tasks
</span><span class="ln"> 8529</span><span class="cm">		 *  - remote:  there are numa tasks that run on the &#39;wrong&#39; node
</span><span class="ln"> 8530</span><span class="cm">		 *  - all:     there is no distinction
</span><span class="ln"> 8531</span><span class="cm">		 *
</span><span class="ln"> 8532</span><span class="cm">		 * In order to avoid migrating ideally placed numa tasks,
</span><span class="ln"> 8533</span><span class="cm">		 * ignore those when there&#39;s better options.
</span><span class="ln"> 8534</span><span class="cm">		 *
</span><span class="ln"> 8535</span><span class="cm">		 * If we ignore the actual busiest queue to migrate another
</span><span class="ln"> 8536</span><span class="cm">		 * task, the next balance pass can still reduce the busiest
</span><span class="ln"> 8537</span><span class="cm">		 * queue by moving tasks around inside the node.
</span><span class="ln"> 8538</span><span class="cm">		 *
</span><span class="ln"> 8539</span><span class="cm">		 * If we cannot move enough load due to this classification
</span><span class="ln"> 8540</span><span class="cm">		 * the next pass will adjust the group classification and
</span><span class="ln"> 8541</span><span class="cm">		 * allow migration of more tasks.
</span><span class="ln"> 8542</span><span class="cm">		 *
</span><span class="ln"> 8543</span><span class="cm">		 * Both cases only affect the total convergence complexity.
</span><span class="ln"> 8544</span><span class="cm">		 */</span>
<span class="ln"> 8545</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">fbq_type</span><span class="p">)</span>
<span class="ln"> 8546</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 8547</span>
<span class="ln"> 8548</span>		<span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln"> 8549</span>
<span class="ln"> 8550</span>		<span class="n">wl</span> <span class="o">=</span> <span class="n">weighted_cpuload</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 8551</span>
<span class="ln"> 8552</span>		<span class="cm">/*
</span><span class="ln"> 8553</span><span class="cm">		 * When comparing with imbalance, use weighted_cpuload()
</span><span class="ln"> 8554</span><span class="cm">		 * which is not scaled with the CPU capacity.
</span><span class="ln"> 8555</span><span class="cm">		 */</span>
<span class="ln"> 8556</span>
<span class="ln"> 8557</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">wl</span> <span class="o">&gt;</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">imbalance</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8558</span>		    <span class="o">!</span><span class="n">check_cpu_capacity</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">))</span>
<span class="ln"> 8559</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 8560</span>
<span class="ln"> 8561</span>		<span class="cm">/*
</span><span class="ln"> 8562</span><span class="cm">		 * For the load comparisons with the other CPU&#39;s, consider
</span><span class="ln"> 8563</span><span class="cm">		 * the weighted_cpuload() scaled with the CPU capacity, so
</span><span class="ln"> 8564</span><span class="cm">		 * that the load can be moved away from the CPU that is
</span><span class="ln"> 8565</span><span class="cm">		 * potentially running at a lower capacity.
</span><span class="ln"> 8566</span><span class="cm">		 *
</span><span class="ln"> 8567</span><span class="cm">		 * Thus we&#39;re looking for max(wl_i / capacity_i), crosswise
</span><span class="ln"> 8568</span><span class="cm">		 * multiplication to rid ourselves of the division works out
</span><span class="ln"> 8569</span><span class="cm">		 * to: wl_i * capacity_j &gt; wl_j * capacity_i;  where j is
</span><span class="ln"> 8570</span><span class="cm">		 * our previous maximum.
</span><span class="ln"> 8571</span><span class="cm">		 */</span>
<span class="ln"> 8572</span>		<span class="k">if</span> <span class="p">(</span><span class="n">wl</span> <span class="o">*</span> <span class="n">busiest_capacity</span> <span class="o">&gt;</span> <span class="n">busiest_load</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8573</span>			<span class="n">busiest_load</span> <span class="o">=</span> <span class="n">wl</span><span class="p">;</span>
<span class="ln"> 8574</span>			<span class="n">busiest_capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
<span class="ln"> 8575</span>			<span class="n">busiest</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln"> 8576</span>		<span class="p">}</span>
<span class="ln"> 8577</span>	<span class="p">}</span>
<span class="ln"> 8578</span>
<span class="ln"> 8579</span>	<span class="k">return</span> <span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8580</span><span class="p">}</span>
<span class="ln"> 8581</span>
<span class="ln"> 8582</span><span class="cm">/*
</span><span class="ln"> 8583</span><span class="cm"> * Max backoff if we encounter pinned tasks. Pretty arbitrary value, but
</span><span class="ln"> 8584</span><span class="cm"> * so long as it is large enough.
</span><span class="ln"> 8585</span><span class="cm"> */</span>
<span class="ln"> 8586</span><span class="cp">#define MAX_PINNED_INTERVAL	512
</span><span class="ln"> 8587</span><span class="cp"></span>
<span class="ln"> 8588</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">need_active_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 8589</span><span class="p">{</span>
<span class="ln"> 8590</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 8591</span>
<span class="ln"> 8592</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8593</span>
<span class="ln"> 8594</span>		<span class="cm">/*
</span><span class="ln"> 8595</span><span class="cm">		 * ASYM_PACKING needs to force migrate tasks from busy but
</span><span class="ln"> 8596</span><span class="cm">		 * lower priority CPUs in order to pack all tasks in the
</span><span class="ln"> 8597</span><span class="cm">		 * highest priority CPUs.
</span><span class="ln"> 8598</span><span class="cm">		 */</span>
<span class="ln"> 8599</span>		<span class="k">if</span> <span class="p">((</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_ASYM_PACKING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8600</span>		    <span class="n">sched_asym_prefer</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">))</span>
<span class="ln"> 8601</span>			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8602</span>	<span class="p">}</span>
<span class="ln"> 8603</span>
<span class="ln"> 8604</span>	<span class="cm">/*
</span><span class="ln"> 8605</span><span class="cm">	 * The dst_cpu is idle and the src_cpu CPU has only 1 CFS task.
</span><span class="ln"> 8606</span><span class="cm">	 * It&#39;s worth migrating the task if the src_cpu&#39;s capacity is reduced
</span><span class="ln"> 8607</span><span class="cm">	 * because of other sched_class or IRQs if more capacity stays
</span><span class="ln"> 8608</span><span class="cm">	 * available on dst_cpu.
</span><span class="ln"> 8609</span><span class="cm">	 */</span>
<span class="ln"> 8610</span>	<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NOT_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8611</span>	    <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8612</span>		<span class="k">if</span> <span class="p">((</span><span class="n">check_cpu_capacity</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">sd</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8613</span>		    <span class="p">(</span><span class="n">capacity_of</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">src_cpu</span><span class="p">)</span><span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">imbalance_pct</span> <span class="o">&lt;</span> <span class="n">capacity_of</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
<span class="ln"> 8614</span>			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8615</span>	<span class="p">}</span>
<span class="ln"> 8616</span>
<span class="ln"> 8617</span>	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">&gt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="ln"> 8618</span><span class="p">}</span>
<span class="ln"> 8619</span>
<span class="ln"> 8620</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">active_load_balance_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="ln"> 8621</span>
<span class="ln"> 8622</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">should_we_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">lb_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="ln"> 8623</span><span class="p">{</span>
<span class="ln"> 8624</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>
<span class="ln"> 8625</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">balance_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8626</span>
<span class="ln"> 8627</span>	<span class="cm">/*
</span><span class="ln"> 8628</span><span class="cm">	 * Ensure the balancing environment is consistent; can happen
</span><span class="ln"> 8629</span><span class="cm">	 * when the softirq triggers &#39;during&#39; hotplug.
</span><span class="ln"> 8630</span><span class="cm">	 */</span>
<span class="ln"> 8631</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">))</span>
<span class="ln"> 8632</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8633</span>
<span class="ln"> 8634</span>	<span class="cm">/*
</span><span class="ln"> 8635</span><span class="cm">	 * In the newly idle case, we will allow all the CPUs
</span><span class="ln"> 8636</span><span class="cm">	 * to do the newly idle load balance.
</span><span class="ln"> 8637</span><span class="cm">	 */</span>
<span class="ln"> 8638</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span>
<span class="ln"> 8639</span>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8640</span>
<span class="ln"> 8641</span>	<span class="cm">/* Try to find first idle CPU */</span>
<span class="ln"> 8642</span>	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">group_balance_mask</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8643</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 8644</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 8645</span>
<span class="ln"> 8646</span>		<span class="n">balance_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 8647</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln"> 8648</span>	<span class="p">}</span>
<span class="ln"> 8649</span>
<span class="ln"> 8650</span>	<span class="k">if</span> <span class="p">(</span><span class="n">balance_cpu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="ln"> 8651</span>		<span class="n">balance_cpu</span> <span class="o">=</span> <span class="n">group_balance_cpu</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
<span class="ln"> 8652</span>
<span class="ln"> 8653</span>	<span class="cm">/*
</span><span class="ln"> 8654</span><span class="cm">	 * First idle CPU or the first CPU(busiest) in this sched group
</span><span class="ln"> 8655</span><span class="cm">	 * is eligible for doing load balancing at this and above domains.
</span><span class="ln"> 8656</span><span class="cm">	 */</span>
<span class="ln"> 8657</span>	<span class="k">return</span> <span class="n">balance_cpu</span> <span class="o">==</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">dst_cpu</span><span class="p">;</span>
<span class="ln"> 8658</span><span class="p">}</span>
<span class="ln"> 8659</span>
<span class="ln"> 8660</span><span class="cm">/*
</span><span class="ln"> 8661</span><span class="cm"> * Check this_cpu to ensure it is balanced within domain. Attempt to move
</span><span class="ln"> 8662</span><span class="cm"> * tasks if there is an imbalance.
</span><span class="ln"> 8663</span><span class="cm"> */</span>
<span class="ln"> 8664</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">load_balance</span><span class="p">(</span><span class="kt">int</span> <span class="n">this_cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span>
<span class="ln"> 8665</span>			<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">,</span>
<span class="ln"> 8666</span>			<span class="kt">int</span> <span class="o">*</span><span class="n">continue_balancing</span><span class="p">)</span>
<span class="ln"> 8667</span><span class="p">{</span>
<span class="ln"> 8668</span>	<span class="kt">int</span> <span class="n">ld_moved</span><span class="p">,</span> <span class="n">cur_ld_moved</span><span class="p">,</span> <span class="n">active_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8669</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd_parent</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="ln"> 8670</span>	<span class="k">struct</span> <span class="n">sched_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
<span class="ln"> 8671</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8672</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 8673</span>	<span class="k">struct</span> <span class="n">cpumask</span> <span class="o">*</span><span class="n">cpus</span> <span class="o">=</span> <span class="n">this_cpu_cpumask_var_ptr</span><span class="p">(</span><span class="n">load_balance_mask</span><span class="p">);</span>
<span class="ln"> 8674</span>
<span class="ln"> 8675</span>	<span class="k">struct</span> <span class="n">lb_env</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 8676</span>		<span class="p">.</span><span class="n">sd</span>		<span class="o">=</span> <span class="n">sd</span><span class="p">,</span>
<span class="ln"> 8677</span>		<span class="p">.</span><span class="n">dst_cpu</span>	<span class="o">=</span> <span class="n">this_cpu</span><span class="p">,</span>
<span class="ln"> 8678</span>		<span class="p">.</span><span class="n">dst_rq</span>		<span class="o">=</span> <span class="n">this_rq</span><span class="p">,</span>
<span class="ln"> 8679</span>		<span class="p">.</span><span class="n">dst_grpmask</span>    <span class="o">=</span> <span class="n">sched_group_span</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">),</span>
<span class="ln"> 8680</span>		<span class="p">.</span><span class="n">idle</span>		<span class="o">=</span> <span class="n">idle</span><span class="p">,</span>
<span class="ln"> 8681</span>		<span class="p">.</span><span class="n">loop_break</span>	<span class="o">=</span> <span class="n">sched_nr_migrate_break</span><span class="p">,</span>
<span class="ln"> 8682</span>		<span class="p">.</span><span class="n">cpus</span>		<span class="o">=</span> <span class="n">cpus</span><span class="p">,</span>
<span class="ln"> 8683</span>		<span class="p">.</span><span class="n">fbq_type</span>	<span class="o">=</span> <span class="n">all</span><span class="p">,</span>
<span class="ln"> 8684</span>		<span class="p">.</span><span class="n">tasks</span>		<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">tasks</span><span class="p">),</span>
<span class="ln"> 8685</span>	<span class="p">};</span>
<span class="ln"> 8686</span>
<span class="ln"> 8687</span>	<span class="n">cpumask_and</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span> <span class="n">cpu_active_mask</span><span class="p">);</span>
<span class="ln"> 8688</span>
<span class="ln"> 8689</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_count</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 8690</span>
<span class="ln"> 8691</span><span class="nl">redo</span><span class="p">:</span>
<span class="ln"> 8692</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_we_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8693</span>		<span class="o">*</span><span class="n">continue_balancing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8694</span>		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8695</span>	<span class="p">}</span>
<span class="ln"> 8696</span>
<span class="ln"> 8697</span>	<span class="n">group</span> <span class="o">=</span> <span class="n">find_busiest_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
<span class="ln"> 8698</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8699</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_nobusyg</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 8700</span>		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8701</span>	<span class="p">}</span>
<span class="ln"> 8702</span>
<span class="ln"> 8703</span>	<span class="n">busiest</span> <span class="o">=</span> <span class="n">find_busiest_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
<span class="ln"> 8704</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busiest</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8705</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_nobusyq</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 8706</span>		<span class="k">goto</span> <span class="n">out_balanced</span><span class="p">;</span>
<span class="ln"> 8707</span>	<span class="p">}</span>
<span class="ln"> 8708</span>
<span class="ln"> 8709</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">busiest</span> <span class="o">==</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_rq</span><span class="p">);</span>
<span class="ln"> 8710</span>
<span class="ln"> 8711</span>	<span class="n">schedstat_add</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_imbalance</span><span class="p">[</span><span class="n">idle</span><span class="p">],</span> <span class="n">env</span><span class="p">.</span><span class="n">imbalance</span><span class="p">);</span>
<span class="ln"> 8712</span>
<span class="ln"> 8713</span>	<span class="n">env</span><span class="p">.</span><span class="n">src_cpu</span> <span class="o">=</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 8714</span>	<span class="n">env</span><span class="p">.</span><span class="n">src_rq</span> <span class="o">=</span> <span class="n">busiest</span><span class="p">;</span>
<span class="ln"> 8715</span>
<span class="ln"> 8716</span>	<span class="n">ld_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8717</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8718</span>		<span class="cm">/*
</span><span class="ln"> 8719</span><span class="cm">		 * Attempt to move tasks. If find_busiest_group has found
</span><span class="ln"> 8720</span><span class="cm">		 * an imbalance but busiest-&gt;nr_running &lt;= 1, the group is
</span><span class="ln"> 8721</span><span class="cm">		 * still unbalanced. ld_moved simply stays zero, so it is
</span><span class="ln"> 8722</span><span class="cm">		 * correctly treated as an imbalance.
</span><span class="ln"> 8723</span><span class="cm">		 */</span>
<span class="ln"> 8724</span>		<span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_ALL_PINNED</span><span class="p">;</span>
<span class="ln"> 8725</span>		<span class="n">env</span><span class="p">.</span><span class="n">loop_max</span>  <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sysctl_sched_nr_migrate</span><span class="p">,</span> <span class="n">busiest</span><span class="o">-&gt;</span><span class="n">nr_running</span><span class="p">);</span>
<span class="ln"> 8726</span>
<span class="ln"> 8727</span><span class="nl">more_balance</span><span class="p">:</span>
<span class="ln"> 8728</span>		<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">busiest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 8729</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">busiest</span><span class="p">);</span>
<span class="ln"> 8730</span>
<span class="ln"> 8731</span>		<span class="cm">/*
</span><span class="ln"> 8732</span><span class="cm">		 * cur_ld_moved - load moved in current iteration
</span><span class="ln"> 8733</span><span class="cm">		 * ld_moved     - cumulative load moved across iterations
</span><span class="ln"> 8734</span><span class="cm">		 */</span>
<span class="ln"> 8735</span>		<span class="n">cur_ld_moved</span> <span class="o">=</span> <span class="n">detach_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
<span class="ln"> 8736</span>
<span class="ln"> 8737</span>		<span class="cm">/*
</span><span class="ln"> 8738</span><span class="cm">		 * We&#39;ve detached some tasks from busiest_rq. Every
</span><span class="ln"> 8739</span><span class="cm">		 * task is masked &#34;TASK_ON_RQ_MIGRATING&#34;, so we can safely
</span><span class="ln"> 8740</span><span class="cm">		 * unlock busiest-&gt;lock, and we are able to be sure
</span><span class="ln"> 8741</span><span class="cm">		 * that nobody can manipulate the tasks in parallel.
</span><span class="ln"> 8742</span><span class="cm">		 * See task_rq_lock() family for the details.
</span><span class="ln"> 8743</span><span class="cm">		 */</span>
<span class="ln"> 8744</span>
<span class="ln"> 8745</span>		<span class="n">rq_unlock</span><span class="p">(</span><span class="n">busiest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 8746</span>
<span class="ln"> 8747</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cur_ld_moved</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8748</span>			<span class="n">attach_tasks</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
<span class="ln"> 8749</span>			<span class="n">ld_moved</span> <span class="o">+=</span> <span class="n">cur_ld_moved</span><span class="p">;</span>
<span class="ln"> 8750</span>		<span class="p">}</span>
<span class="ln"> 8751</span>
<span class="ln"> 8752</span>		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">rf</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
<span class="ln"> 8753</span>
<span class="ln"> 8754</span>		<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_NEED_BREAK</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8755</span>			<span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LBF_NEED_BREAK</span><span class="p">;</span>
<span class="ln"> 8756</span>			<span class="k">goto</span> <span class="n">more_balance</span><span class="p">;</span>
<span class="ln"> 8757</span>		<span class="p">}</span>
<span class="ln"> 8758</span>
<span class="ln"> 8759</span>		<span class="cm">/*
</span><span class="ln"> 8760</span><span class="cm">		 * Revisit (affine) tasks on src_cpu that couldn&#39;t be moved to
</span><span class="ln"> 8761</span><span class="cm">		 * us and move them to an alternate dst_cpu in our sched_group
</span><span class="ln"> 8762</span><span class="cm">		 * where they can run. The upper limit on how many times we
</span><span class="ln"> 8763</span><span class="cm">		 * iterate on same src_cpu is dependent on number of CPUs in our
</span><span class="ln"> 8764</span><span class="cm">		 * sched_group.
</span><span class="ln"> 8765</span><span class="cm">		 *
</span><span class="ln"> 8766</span><span class="cm">		 * This changes load balance semantics a bit on who can move
</span><span class="ln"> 8767</span><span class="cm">		 * load to a given_cpu. In addition to the given_cpu itself
</span><span class="ln"> 8768</span><span class="cm">		 * (or a ilb_cpu acting on its behalf where given_cpu is
</span><span class="ln"> 8769</span><span class="cm">		 * nohz-idle), we now have balance_cpu in a position to move
</span><span class="ln"> 8770</span><span class="cm">		 * load to given_cpu. In rare situations, this may cause
</span><span class="ln"> 8771</span><span class="cm">		 * conflicts (balance_cpu and given_cpu/ilb_cpu deciding
</span><span class="ln"> 8772</span><span class="cm">		 * _independently_ and at _same_ time to move some load to
</span><span class="ln"> 8773</span><span class="cm">		 * given_cpu) causing exceess load to be moved to given_cpu.
</span><span class="ln"> 8774</span><span class="cm">		 * This however should not happen so much in practice and
</span><span class="ln"> 8775</span><span class="cm">		 * moreover subsequent load balance cycles should correct the
</span><span class="ln"> 8776</span><span class="cm">		 * excess load moved.
</span><span class="ln"> 8777</span><span class="cm">		 */</span>
<span class="ln"> 8778</span>		<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_DST_PINNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">env</span><span class="p">.</span><span class="n">imbalance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8779</span>
<span class="ln"> 8780</span>			<span class="cm">/* Prevent to re-select dst_cpu via env&#39;s CPUs */</span>
<span class="ln"> 8781</span>			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">dst_cpu</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">cpus</span><span class="p">);</span>
<span class="ln"> 8782</span>
<span class="ln"> 8783</span>			<span class="n">env</span><span class="p">.</span><span class="n">dst_rq</span>	 <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">new_dst_cpu</span><span class="p">);</span>
<span class="ln"> 8784</span>			<span class="n">env</span><span class="p">.</span><span class="n">dst_cpu</span>	 <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="n">new_dst_cpu</span><span class="p">;</span>
<span class="ln"> 8785</span>			<span class="n">env</span><span class="p">.</span><span class="n">flags</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="n">LBF_DST_PINNED</span><span class="p">;</span>
<span class="ln"> 8786</span>			<span class="n">env</span><span class="p">.</span><span class="n">loop</span>	 <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8787</span>			<span class="n">env</span><span class="p">.</span><span class="n">loop_break</span>	 <span class="o">=</span> <span class="n">sched_nr_migrate_break</span><span class="p">;</span>
<span class="ln"> 8788</span>
<span class="ln"> 8789</span>			<span class="cm">/*
</span><span class="ln"> 8790</span><span class="cm">			 * Go back to &#34;more_balance&#34; rather than &#34;redo&#34; since we
</span><span class="ln"> 8791</span><span class="cm">			 * need to continue with same src_cpu.
</span><span class="ln"> 8792</span><span class="cm">			 */</span>
<span class="ln"> 8793</span>			<span class="k">goto</span> <span class="n">more_balance</span><span class="p">;</span>
<span class="ln"> 8794</span>		<span class="p">}</span>
<span class="ln"> 8795</span>
<span class="ln"> 8796</span>		<span class="cm">/*
</span><span class="ln"> 8797</span><span class="cm">		 * We failed to reach balance because of affinity.
</span><span class="ln"> 8798</span><span class="cm">		 */</span>
<span class="ln"> 8799</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sd_parent</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8800</span>			<span class="kt">int</span> <span class="o">*</span><span class="n">group_imbalance</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd_parent</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">imbalance</span><span class="p">;</span>
<span class="ln"> 8801</span>
<span class="ln"> 8802</span>			<span class="k">if</span> <span class="p">((</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_SOME_PINNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">env</span><span class="p">.</span><span class="n">imbalance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 8803</span>				<span class="o">*</span><span class="n">group_imbalance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8804</span>		<span class="p">}</span>
<span class="ln"> 8805</span>
<span class="ln"> 8806</span>		<span class="cm">/* All tasks on this runqueue were pinned by CPU affinity */</span>
<span class="ln"> 8807</span>		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_ALL_PINNED</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8808</span>			<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">busiest</span><span class="p">),</span> <span class="n">cpus</span><span class="p">);</span>
<span class="ln"> 8809</span>			<span class="cm">/*
</span><span class="ln"> 8810</span><span class="cm">			 * Attempting to continue load balancing at the current
</span><span class="ln"> 8811</span><span class="cm">			 * sched_domain level only makes sense if there are
</span><span class="ln"> 8812</span><span class="cm">			 * active CPUs remaining as possible busiest CPUs to
</span><span class="ln"> 8813</span><span class="cm">			 * pull load from which are not contained within the
</span><span class="ln"> 8814</span><span class="cm">			 * destination group that is receiving any migrated
</span><span class="ln"> 8815</span><span class="cm">			 * load.
</span><span class="ln"> 8816</span><span class="cm">			 */</span>
<span class="ln"> 8817</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_subset</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">env</span><span class="p">.</span><span class="n">dst_grpmask</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8818</span>				<span class="n">env</span><span class="p">.</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8819</span>				<span class="n">env</span><span class="p">.</span><span class="n">loop_break</span> <span class="o">=</span> <span class="n">sched_nr_migrate_break</span><span class="p">;</span>
<span class="ln"> 8820</span>				<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
<span class="ln"> 8821</span>			<span class="p">}</span>
<span class="ln"> 8822</span>			<span class="k">goto</span> <span class="n">out_all_pinned</span><span class="p">;</span>
<span class="ln"> 8823</span>		<span class="p">}</span>
<span class="ln"> 8824</span>	<span class="p">}</span>
<span class="ln"> 8825</span>
<span class="ln"> 8826</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ld_moved</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8827</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_failed</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 8828</span>		<span class="cm">/*
</span><span class="ln"> 8829</span><span class="cm">		 * Increment the failure counter only on periodic balance.
</span><span class="ln"> 8830</span><span class="cm">		 * We do not want newidle balance, which can be very
</span><span class="ln"> 8831</span><span class="cm">		 * frequent, pollute the failure counter causing
</span><span class="ln"> 8832</span><span class="cm">		 * excessive cache_hot migrations and active balances.
</span><span class="ln"> 8833</span><span class="cm">		 */</span>
<span class="ln"> 8834</span>		<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span>
<span class="ln"> 8835</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 8836</span>
<span class="ln"> 8837</span>		<span class="k">if</span> <span class="p">(</span><span class="n">need_active_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8838</span>			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln"> 8839</span>
<span class="ln"> 8840</span>			<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 8841</span>
<span class="ln"> 8842</span>			<span class="cm">/*
</span><span class="ln"> 8843</span><span class="cm">			 * Don&#39;t kick the active_load_balance_cpu_stop,
</span><span class="ln"> 8844</span><span class="cm">			 * if the curr task on busiest CPU can&#39;t be
</span><span class="ln"> 8845</span><span class="cm">			 * moved to this_cpu:
</span><span class="ln"> 8846</span><span class="cm">			 */</span>
<span class="ln"> 8847</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">cpus_allowed</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8848</span>				<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
<span class="ln"> 8849</span>							    <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 8850</span>				<span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LBF_ALL_PINNED</span><span class="p">;</span>
<span class="ln"> 8851</span>				<span class="k">goto</span> <span class="n">out_one_pinned</span><span class="p">;</span>
<span class="ln"> 8852</span>			<span class="p">}</span>
<span class="ln"> 8853</span>
<span class="ln"> 8854</span>			<span class="cm">/*
</span><span class="ln"> 8855</span><span class="cm">			 * -&gt;active_balance synchronizes accesses to
</span><span class="ln"> 8856</span><span class="cm">			 * -&gt;active_balance_work.  Once set, it&#39;s cleared
</span><span class="ln"> 8857</span><span class="cm">			 * only after active load balance is finished.
</span><span class="ln"> 8858</span><span class="cm">			 */</span>
<span class="ln"> 8859</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">active_balance</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8860</span>				<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">active_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8861</span>				<span class="n">busiest</span><span class="o">-&gt;</span><span class="n">push_cpu</span> <span class="o">=</span> <span class="n">this_cpu</span><span class="p">;</span>
<span class="ln"> 8862</span>				<span class="n">active_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8863</span>			<span class="p">}</span>
<span class="ln"> 8864</span>			<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln"> 8865</span>
<span class="ln"> 8866</span>			<span class="k">if</span> <span class="p">(</span><span class="n">active_balance</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8867</span>				<span class="n">stop_one_cpu_nowait</span><span class="p">(</span><span class="n">cpu_of</span><span class="p">(</span><span class="n">busiest</span><span class="p">),</span>
<span class="ln"> 8868</span>					<span class="n">active_load_balance_cpu_stop</span><span class="p">,</span> <span class="n">busiest</span><span class="p">,</span>
<span class="ln"> 8869</span>					<span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">active_balance_work</span><span class="p">);</span>
<span class="ln"> 8870</span>			<span class="p">}</span>
<span class="ln"> 8871</span>
<span class="ln"> 8872</span>			<span class="cm">/* We&#39;ve kicked active balancing, force task migration. */</span>
<span class="ln"> 8873</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">cache_nice_tries</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8874</span>		<span class="p">}</span>
<span class="ln"> 8875</span>	<span class="p">}</span> <span class="k">else</span>
<span class="ln"> 8876</span>		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8877</span>
<span class="ln"> 8878</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">active_balance</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8879</span>		<span class="cm">/* We were unbalanced, so reset the balancing interval */</span>
<span class="ln"> 8880</span>		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">min_interval</span><span class="p">;</span>
<span class="ln"> 8881</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 8882</span>		<span class="cm">/*
</span><span class="ln"> 8883</span><span class="cm">		 * If we&#39;ve begun active balancing, start to back off. This
</span><span class="ln"> 8884</span><span class="cm">		 * case may not be covered by the all_pinned logic if there
</span><span class="ln"> 8885</span><span class="cm">		 * is only 1 task on the busy runqueue (because we don&#39;t call
</span><span class="ln"> 8886</span><span class="cm">		 * detach_tasks).
</span><span class="ln"> 8887</span><span class="cm">		 */</span>
<span class="ln"> 8888</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">&lt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_interval</span><span class="p">)</span>
<span class="ln"> 8889</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 8890</span>	<span class="p">}</span>
<span class="ln"> 8891</span>
<span class="ln"> 8892</span>	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 8893</span>
<span class="ln"> 8894</span><span class="nl">out_balanced</span><span class="p">:</span>
<span class="ln"> 8895</span>	<span class="cm">/*
</span><span class="ln"> 8896</span><span class="cm">	 * We reach balance although we may have faced some affinity
</span><span class="ln"> 8897</span><span class="cm">	 * constraints. Clear the imbalance flag only if other tasks got
</span><span class="ln"> 8898</span><span class="cm">	 * a chance to move and fix the imbalance.
</span><span class="ln"> 8899</span><span class="cm">	 */</span>
<span class="ln"> 8900</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd_parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_ALL_PINNED</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 8901</span>		<span class="kt">int</span> <span class="o">*</span><span class="n">group_imbalance</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd_parent</span><span class="o">-&gt;</span><span class="n">groups</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">imbalance</span><span class="p">;</span>
<span class="ln"> 8902</span>
<span class="ln"> 8903</span>		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">group_imbalance</span><span class="p">)</span>
<span class="ln"> 8904</span>			<span class="o">*</span><span class="n">group_imbalance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8905</span>	<span class="p">}</span>
<span class="ln"> 8906</span>
<span class="ln"> 8907</span><span class="nl">out_all_pinned</span><span class="p">:</span>
<span class="ln"> 8908</span>	<span class="cm">/*
</span><span class="ln"> 8909</span><span class="cm">	 * We reach balance because all tasks are pinned at this level so
</span><span class="ln"> 8910</span><span class="cm">	 * we can&#39;t migrate them. Let the imbalance flag set so parent level
</span><span class="ln"> 8911</span><span class="cm">	 * can try to migrate them.
</span><span class="ln"> 8912</span><span class="cm">	 */</span>
<span class="ln"> 8913</span>	<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">lb_balanced</span><span class="p">[</span><span class="n">idle</span><span class="p">]);</span>
<span class="ln"> 8914</span>
<span class="ln"> 8915</span>	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8916</span>
<span class="ln"> 8917</span><span class="nl">out_one_pinned</span><span class="p">:</span>
<span class="ln"> 8918</span>	<span class="n">ld_moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8919</span>
<span class="ln"> 8920</span>	<span class="cm">/*
</span><span class="ln"> 8921</span><span class="cm">	 * idle_balance() disregards balance intervals, so we could repeatedly
</span><span class="ln"> 8922</span><span class="cm">	 * reach this code, which would lead to balance_interval skyrocketting
</span><span class="ln"> 8923</span><span class="cm">	 * in a short amount of time. Skip the balance_interval increase logic
</span><span class="ln"> 8924</span><span class="cm">	 * to avoid that.
</span><span class="ln"> 8925</span><span class="cm">	 */</span>
<span class="ln"> 8926</span>	<span class="k">if</span> <span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span>
<span class="ln"> 8927</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 8928</span>
<span class="ln"> 8929</span>	<span class="cm">/* tune up the balancing interval */</span>
<span class="ln"> 8930</span>	<span class="k">if</span> <span class="p">(((</span><span class="n">env</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LBF_ALL_PINNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 8931</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">&lt;</span> <span class="n">MAX_PINNED_INTERVAL</span><span class="p">)</span> <span class="o">||</span>
<span class="ln"> 8932</span>			<span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">&lt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_interval</span><span class="p">))</span>
<span class="ln"> 8933</span>		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="ln"> 8934</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 8935</span>	<span class="k">return</span> <span class="n">ld_moved</span><span class="p">;</span>
<span class="ln"> 8936</span><span class="p">}</span>
<span class="ln"> 8937</span>
<span class="ln"> 8938</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="ln"> 8939</span><span class="nf">get_sd_balance_interval</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu_busy</span><span class="p">)</span>
<span class="ln"> 8940</span><span class="p">{</span>
<span class="ln"> 8941</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">balance_interval</span><span class="p">;</span>
<span class="ln"> 8942</span>
<span class="ln"> 8943</span>	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_busy</span><span class="p">)</span>
<span class="ln"> 8944</span>		<span class="n">interval</span> <span class="o">*=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">busy_factor</span><span class="p">;</span>
<span class="ln"> 8945</span>
<span class="ln"> 8946</span>	<span class="cm">/* scale ms to jiffies */</span>
<span class="ln"> 8947</span>	<span class="n">interval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">interval</span><span class="p">);</span>
<span class="ln"> 8948</span>	<span class="n">interval</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">,</span> <span class="n">max_load_balance_interval</span><span class="p">);</span>
<span class="ln"> 8949</span>
<span class="ln"> 8950</span>	<span class="k">return</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 8951</span><span class="p">}</span>
<span class="ln"> 8952</span>
<span class="ln"> 8953</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="ln"> 8954</span><span class="nf">update_next_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">next_balance</span><span class="p">)</span>
<span class="ln"> 8955</span><span class="p">{</span>
<span class="ln"> 8956</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
<span class="ln"> 8957</span>
<span class="ln"> 8958</span>	<span class="cm">/* used by idle balance, so cpu_busy = 0 */</span>
<span class="ln"> 8959</span>	<span class="n">interval</span> <span class="o">=</span> <span class="n">get_sd_balance_interval</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 8960</span>	<span class="n">next</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 8961</span>
<span class="ln"> 8962</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="o">*</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
<span class="ln"> 8963</span>		<span class="o">*</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="ln"> 8964</span><span class="p">}</span>
<span class="ln"> 8965</span>
<span class="ln"> 8966</span><span class="cm">/*
</span><span class="ln"> 8967</span><span class="cm"> * active_load_balance_cpu_stop is run by the CPU stopper. It pushes
</span><span class="ln"> 8968</span><span class="cm"> * running tasks off the busiest CPU onto idle CPUs. It requires at
</span><span class="ln"> 8969</span><span class="cm"> * least 1 task to be running on each physical CPU where possible, and
</span><span class="ln"> 8970</span><span class="cm"> * avoids physical / logical imbalances.
</span><span class="ln"> 8971</span><span class="cm"> */</span>
<span class="ln"> 8972</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">active_load_balance_cpu_stop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="ln"> 8973</span><span class="p">{</span>
<span class="ln"> 8974</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest_rq</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="ln"> 8975</span>	<span class="kt">int</span> <span class="n">busiest_cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">);</span>
<span class="ln"> 8976</span>	<span class="kt">int</span> <span class="n">target_cpu</span> <span class="o">=</span> <span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">push_cpu</span><span class="p">;</span>
<span class="ln"> 8977</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">target_rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">);</span>
<span class="ln"> 8978</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 8979</span>	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln"> 8980</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 8981</span>
<span class="ln"> 8982</span>	<span class="n">rq_lock_irq</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 8983</span>	<span class="cm">/*
</span><span class="ln"> 8984</span><span class="cm">	 * Between queueing the stop-work and running it is a hole in which
</span><span class="ln"> 8985</span><span class="cm">	 * CPUs can become inactive. We should not move tasks from or to
</span><span class="ln"> 8986</span><span class="cm">	 * inactive CPUs.
</span><span class="ln"> 8987</span><span class="cm">	 */</span>
<span class="ln"> 8988</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">busiest_cpu</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">))</span>
<span class="ln"> 8989</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln"> 8990</span>
<span class="ln"> 8991</span>	<span class="cm">/* Make sure the requested CPU hasn&#39;t gone down in the meantime: */</span>
<span class="ln"> 8992</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">busiest_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">()</span> <span class="o">||</span>
<span class="ln"> 8993</span>		     <span class="o">!</span><span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">active_balance</span><span class="p">))</span>
<span class="ln"> 8994</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln"> 8995</span>
<span class="ln"> 8996</span>	<span class="cm">/* Is there any task to move? */</span>
<span class="ln"> 8997</span>	<span class="k">if</span> <span class="p">(</span><span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="ln"> 8998</span>		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="ln"> 8999</span>
<span class="ln"> 9000</span>	<span class="cm">/*
</span><span class="ln"> 9001</span><span class="cm">	 * This condition is &#34;impossible&#34;, if it occurs
</span><span class="ln"> 9002</span><span class="cm">	 * we need to fix it. Originally reported by
</span><span class="ln"> 9003</span><span class="cm">	 * Bjorn Helgaas on a 128-CPU setup.
</span><span class="ln"> 9004</span><span class="cm">	 */</span>
<span class="ln"> 9005</span>	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">busiest_rq</span> <span class="o">==</span> <span class="n">target_rq</span><span class="p">);</span>
<span class="ln"> 9006</span>
<span class="ln"> 9007</span>	<span class="cm">/* Search for an sd spanning us and the target CPU. */</span>
<span class="ln"> 9008</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9009</span>	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">target_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9010</span>		<span class="k">if</span> <span class="p">((</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 9011</span>		    <span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">busiest_cpu</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span>
<span class="ln"> 9012</span>				<span class="k">break</span><span class="p">;</span>
<span class="ln"> 9013</span>	<span class="p">}</span>
<span class="ln"> 9014</span>
<span class="ln"> 9015</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9016</span>		<span class="k">struct</span> <span class="n">lb_env</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln"> 9017</span>			<span class="p">.</span><span class="n">sd</span>		<span class="o">=</span> <span class="n">sd</span><span class="p">,</span>
<span class="ln"> 9018</span>			<span class="p">.</span><span class="n">dst_cpu</span>	<span class="o">=</span> <span class="n">target_cpu</span><span class="p">,</span>
<span class="ln"> 9019</span>			<span class="p">.</span><span class="n">dst_rq</span>		<span class="o">=</span> <span class="n">target_rq</span><span class="p">,</span>
<span class="ln"> 9020</span>			<span class="p">.</span><span class="n">src_cpu</span>	<span class="o">=</span> <span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
<span class="ln"> 9021</span>			<span class="p">.</span><span class="n">src_rq</span>		<span class="o">=</span> <span class="n">busiest_rq</span><span class="p">,</span>
<span class="ln"> 9022</span>			<span class="p">.</span><span class="n">idle</span>		<span class="o">=</span> <span class="n">CPU_IDLE</span><span class="p">,</span>
<span class="ln"> 9023</span>			<span class="cm">/*
</span><span class="ln"> 9024</span><span class="cm">			 * can_migrate_task() doesn&#39;t need to compute new_dst_cpu
</span><span class="ln"> 9025</span><span class="cm">			 * for active balancing. Since we have CPU_IDLE, but no
</span><span class="ln"> 9026</span><span class="cm">			 * @dst_grpmask we need to make that test go away with lying
</span><span class="ln"> 9027</span><span class="cm">			 * about DST_PINNED.
</span><span class="ln"> 9028</span><span class="cm">			 */</span>
<span class="ln"> 9029</span>			<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">LBF_DST_PINNED</span><span class="p">,</span>
<span class="ln"> 9030</span>		<span class="p">};</span>
<span class="ln"> 9031</span>
<span class="ln"> 9032</span>		<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">alb_count</span><span class="p">);</span>
<span class="ln"> 9033</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">);</span>
<span class="ln"> 9034</span>
<span class="ln"> 9035</span>		<span class="n">p</span> <span class="o">=</span> <span class="n">detach_one_task</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
<span class="ln"> 9036</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9037</span>			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">alb_pushed</span><span class="p">);</span>
<span class="ln"> 9038</span>			<span class="cm">/* Active balancing done, reset the failure counter. */</span>
<span class="ln"> 9039</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nr_balance_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9040</span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln"> 9041</span>			<span class="n">schedstat_inc</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">alb_failed</span><span class="p">);</span>
<span class="ln"> 9042</span>		<span class="p">}</span>
<span class="ln"> 9043</span>	<span class="p">}</span>
<span class="ln"> 9044</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9045</span><span class="nl">out_unlock</span><span class="p">:</span>
<span class="ln"> 9046</span>	<span class="n">busiest_rq</span><span class="o">-&gt;</span><span class="n">active_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9047</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">busiest_rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9048</span>
<span class="ln"> 9049</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9050</span>		<span class="n">attach_one_task</span><span class="p">(</span><span class="n">target_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="ln"> 9051</span>
<span class="ln"> 9052</span>	<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="ln"> 9053</span>
<span class="ln"> 9054</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9055</span><span class="p">}</span>
<span class="ln"> 9056</span>
<span class="ln"> 9057</span><span class="k">static</span> <span class="nf">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">balancing</span><span class="p">);</span>
<span class="ln"> 9058</span>
<span class="ln"> 9059</span><span class="cm">/*
</span><span class="ln"> 9060</span><span class="cm"> * Scale the max load_balance interval with the number of CPUs in the system.
</span><span class="ln"> 9061</span><span class="cm"> * This trades load-balance latency on larger machines for less cross talk.
</span><span class="ln"> 9062</span><span class="cm"> */</span>
<span class="ln"> 9063</span><span class="kt">void</span> <span class="nf">update_max_interval</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 9064</span><span class="p">{</span>
<span class="ln"> 9065</span>	<span class="n">max_load_balance_interval</span> <span class="o">=</span> <span class="n">HZ</span><span class="o">*</span><span class="n">num_online_cpus</span><span class="p">()</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
<span class="ln"> 9066</span><span class="p">}</span>
<span class="ln"> 9067</span>
<span class="ln"> 9068</span><span class="cm">/*
</span><span class="ln"> 9069</span><span class="cm"> * It checks each scheduling domain to see if it is due to be balanced,
</span><span class="ln"> 9070</span><span class="cm"> * and initiates a balancing operation if so.
</span><span class="ln"> 9071</span><span class="cm"> *
</span><span class="ln"> 9072</span><span class="cm"> * Balancing parameters are set up in init_sched_domains.
</span><span class="ln"> 9073</span><span class="cm"> */</span>
<span class="ln"> 9074</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">rebalance_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="ln"> 9075</span><span class="p">{</span>
<span class="ln"> 9076</span>	<span class="kt">int</span> <span class="n">continue_balancing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9077</span>	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 9078</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 9079</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 9080</span>	<span class="cm">/* Earliest time when we have to do rebalance again */</span>
<span class="ln"> 9081</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">60</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
<span class="ln"> 9082</span>	<span class="kt">int</span> <span class="n">update_next_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9083</span>	<span class="kt">int</span> <span class="n">need_serialize</span><span class="p">,</span> <span class="n">need_decay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9084</span>	<span class="n">u64</span> <span class="n">max_cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9085</span>
<span class="ln"> 9086</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9087</span>	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9088</span>		<span class="cm">/*
</span><span class="ln"> 9089</span><span class="cm">		 * Decay the newidle max times here because this is a regular
</span><span class="ln"> 9090</span><span class="cm">		 * visit to all the domains. Decay ~1% per second.
</span><span class="ln"> 9091</span><span class="cm">		 */</span>
<span class="ln"> 9092</span>		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">next_decay_max_lb_cost</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9093</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_newidle_lb_cost</span> <span class="o">=</span>
<span class="ln"> 9094</span>				<span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_newidle_lb_cost</span> <span class="o">*</span> <span class="mi">253</span><span class="p">)</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
<span class="ln"> 9095</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">next_decay_max_lb_cost</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
<span class="ln"> 9096</span>			<span class="n">need_decay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9097</span>		<span class="p">}</span>
<span class="ln"> 9098</span>		<span class="n">max_cost</span> <span class="o">+=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_newidle_lb_cost</span><span class="p">;</span>
<span class="ln"> 9099</span>
<span class="ln"> 9100</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span>
<span class="ln"> 9101</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 9102</span>
<span class="ln"> 9103</span>		<span class="cm">/*
</span><span class="ln"> 9104</span><span class="cm">		 * Stop the load balance at this level. There is another
</span><span class="ln"> 9105</span><span class="cm">		 * CPU in our sched group which is doing load balancing more
</span><span class="ln"> 9106</span><span class="cm">		 * actively.
</span><span class="ln"> 9107</span><span class="cm">		 */</span>
<span class="ln"> 9108</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">continue_balancing</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9109</span>			<span class="k">if</span> <span class="p">(</span><span class="n">need_decay</span><span class="p">)</span>
<span class="ln"> 9110</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 9111</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 9112</span>		<span class="p">}</span>
<span class="ln"> 9113</span>
<span class="ln"> 9114</span>		<span class="n">interval</span> <span class="o">=</span> <span class="n">get_sd_balance_interval</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_IDLE</span><span class="p">);</span>
<span class="ln"> 9115</span>
<span class="ln"> 9116</span>		<span class="n">need_serialize</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_SERIALIZE</span><span class="p">;</span>
<span class="ln"> 9117</span>		<span class="k">if</span> <span class="p">(</span><span class="n">need_serialize</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9118</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balancing</span><span class="p">))</span>
<span class="ln"> 9119</span>				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 9120</span>		<span class="p">}</span>
<span class="ln"> 9121</span>
<span class="ln"> 9122</span>		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9123</span>			<span class="k">if</span> <span class="p">(</span><span class="n">load_balance</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">idle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">continue_balancing</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9124</span>				<span class="cm">/*
</span><span class="ln"> 9125</span><span class="cm">				 * The LBF_DST_PINNED logic could have changed
</span><span class="ln"> 9126</span><span class="cm">				 * env-&gt;dst_cpu, so we can&#39;t know our idle
</span><span class="ln"> 9127</span><span class="cm">				 * state even if we migrated tasks. Update it.
</span><span class="ln"> 9128</span><span class="cm">				 */</span>
<span class="ln"> 9129</span>				<span class="n">idle</span> <span class="o">=</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="o">?</span> <span class="nl">CPU_IDLE</span> <span class="p">:</span> <span class="n">CPU_NOT_IDLE</span><span class="p">;</span>
<span class="ln"> 9130</span>			<span class="p">}</span>
<span class="ln"> 9131</span>			<span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 9132</span>			<span class="n">interval</span> <span class="o">=</span> <span class="n">get_sd_balance_interval</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_IDLE</span><span class="p">);</span>
<span class="ln"> 9133</span>		<span class="p">}</span>
<span class="ln"> 9134</span>		<span class="k">if</span> <span class="p">(</span><span class="n">need_serialize</span><span class="p">)</span>
<span class="ln"> 9135</span>			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">balancing</span><span class="p">);</span>
<span class="ln"> 9136</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 9137</span>		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9138</span>			<span class="n">next_balance</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">last_balance</span> <span class="o">+</span> <span class="n">interval</span><span class="p">;</span>
<span class="ln"> 9139</span>			<span class="n">update_next_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9140</span>		<span class="p">}</span>
<span class="ln"> 9141</span>	<span class="p">}</span>
<span class="ln"> 9142</span>	<span class="k">if</span> <span class="p">(</span><span class="n">need_decay</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9143</span>		<span class="cm">/*
</span><span class="ln"> 9144</span><span class="cm">		 * Ensure the rq-wide value also decays but keep it at a
</span><span class="ln"> 9145</span><span class="cm">		 * reasonable floor to avoid funnies with rq-&gt;avg_idle.
</span><span class="ln"> 9146</span><span class="cm">		 */</span>
<span class="ln"> 9147</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">max_idle_balance_cost</span> <span class="o">=</span>
<span class="ln"> 9148</span>			<span class="n">max</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">sysctl_sched_migration_cost</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">);</span>
<span class="ln"> 9149</span>	<span class="p">}</span>
<span class="ln"> 9150</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9151</span>
<span class="ln"> 9152</span>	<span class="cm">/*
</span><span class="ln"> 9153</span><span class="cm">	 * next_balance will be updated only when there is a need.
</span><span class="ln"> 9154</span><span class="cm">	 * When the cpu is attached to null domain for ex, it will not be
</span><span class="ln"> 9155</span><span class="cm">	 * updated.
</span><span class="ln"> 9156</span><span class="cm">	 */</span>
<span class="ln"> 9157</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">update_next_balance</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9158</span>		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">next_balance</span><span class="p">;</span>
<span class="ln"> 9159</span>
<span class="ln"> 9160</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 9161</span><span class="cp"></span>		<span class="cm">/*
</span><span class="ln"> 9162</span><span class="cm">		 * If this CPU has been elected to perform the nohz idle
</span><span class="ln"> 9163</span><span class="cm">		 * balance. Other idle CPUs have already rebalanced with
</span><span class="ln"> 9164</span><span class="cm">		 * nohz_idle_balance() and nohz.next_balance has been
</span><span class="ln"> 9165</span><span class="cm">		 * updated accordingly. This CPU is now running the idle load
</span><span class="ln"> 9166</span><span class="cm">		 * balance for itself and we need to update the
</span><span class="ln"> 9167</span><span class="cm">		 * nohz.next_balance accordingly.
</span><span class="ln"> 9168</span><span class="cm">		 */</span>
<span class="ln"> 9169</span>		<span class="k">if</span> <span class="p">((</span><span class="n">idle</span> <span class="o">==</span> <span class="n">CPU_IDLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">))</span>
<span class="ln"> 9170</span>			<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">;</span>
<span class="ln"> 9171</span><span class="cp">#endif
</span><span class="ln"> 9172</span><span class="cp"></span>	<span class="p">}</span>
<span class="ln"> 9173</span><span class="p">}</span>
<span class="ln"> 9174</span>
<span class="ln"> 9175</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">on_null_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 9176</span><span class="p">{</span>
<span class="ln"> 9177</span>	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rcu_dereference_sched</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">));</span>
<span class="ln"> 9178</span><span class="p">}</span>
<span class="ln"> 9179</span>
<span class="ln"> 9180</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln"> 9181</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 9182</span><span class="cm"> * idle load balancing details
</span><span class="ln"> 9183</span><span class="cm"> * - When one of the busy CPUs notice that there may be an idle rebalancing
</span><span class="ln"> 9184</span><span class="cm"> *   needed, they will kick the idle load balancer, which then does idle
</span><span class="ln"> 9185</span><span class="cm"> *   load balancing for all the idle CPUs.
</span><span class="ln"> 9186</span><span class="cm"> * - HK_FLAG_MISC CPUs are used for this task, because HK_FLAG_SCHED not set
</span><span class="ln"> 9187</span><span class="cm"> *   anywhere yet.
</span><span class="ln"> 9188</span><span class="cm"> */</span>
<span class="ln"> 9189</span>
<span class="ln"> 9190</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find_new_ilb</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln"> 9191</span><span class="p">{</span>
<span class="ln"> 9192</span>	<span class="kt">int</span> <span class="n">ilb</span><span class="p">;</span>
<span class="ln"> 9193</span>
<span class="ln"> 9194</span>	<span class="n">for_each_cpu_and</span><span class="p">(</span><span class="n">ilb</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">,</span>
<span class="ln"> 9195</span>			      <span class="n">housekeeping_cpumask</span><span class="p">(</span><span class="n">HK_FLAG_MISC</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9196</span>		<span class="k">if</span> <span class="p">(</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">ilb</span><span class="p">))</span>
<span class="ln"> 9197</span>			<span class="k">return</span> <span class="n">ilb</span><span class="p">;</span>
<span class="ln"> 9198</span>	<span class="p">}</span>
<span class="ln"> 9199</span>
<span class="ln"> 9200</span>	<span class="k">return</span> <span class="n">nr_cpu_ids</span><span class="p">;</span>
<span class="ln"> 9201</span><span class="p">}</span>
<span class="ln"> 9202</span>
<span class="ln"> 9203</span><span class="cm">/*
</span><span class="ln"> 9204</span><span class="cm"> * Kick a CPU to do the nohz balancing, if it is time for it. We pick any
</span><span class="ln"> 9205</span><span class="cm"> * idle CPU in the HK_FLAG_MISC housekeeping set (if there is one).
</span><span class="ln"> 9206</span><span class="cm"> */</span>
<span class="ln"> 9207</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">kick_ilb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="ln"> 9208</span><span class="p">{</span>
<span class="ln"> 9209</span>	<span class="kt">int</span> <span class="n">ilb_cpu</span><span class="p">;</span>
<span class="ln"> 9210</span>
<span class="ln"> 9211</span>	<span class="cm">/*
</span><span class="ln"> 9212</span><span class="cm">	 * Increase nohz.next_balance only when if full ilb is triggered but
</span><span class="ln"> 9213</span><span class="cm">	 * not if we only update stats.
</span><span class="ln"> 9214</span><span class="cm">	 */</span>
<span class="ln"> 9215</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOHZ_BALANCE_KICK</span><span class="p">)</span>
<span class="ln"> 9216</span>		<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9217</span>
<span class="ln"> 9218</span>	<span class="n">ilb_cpu</span> <span class="o">=</span> <span class="n">find_new_ilb</span><span class="p">();</span>
<span class="ln"> 9219</span>
<span class="ln"> 9220</span>	<span class="k">if</span> <span class="p">(</span><span class="n">ilb_cpu</span> <span class="o">&gt;=</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
<span class="ln"> 9221</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9222</span>
<span class="ln"> 9223</span>	<span class="n">flags</span> <span class="o">=</span> <span class="n">atomic_fetch_or</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">ilb_cpu</span><span class="p">));</span>
<span class="ln"> 9224</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">)</span>
<span class="ln"> 9225</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9226</span>
<span class="ln"> 9227</span>	<span class="cm">/*
</span><span class="ln"> 9228</span><span class="cm">	 * Use smp_send_reschedule() instead of resched_cpu().
</span><span class="ln"> 9229</span><span class="cm">	 * This way we generate a sched IPI on the target CPU which
</span><span class="ln"> 9230</span><span class="cm">	 * is idle. And the softirq performing nohz idle load balance
</span><span class="ln"> 9231</span><span class="cm">	 * will be run before returning from the IPI.
</span><span class="ln"> 9232</span><span class="cm">	 */</span>
<span class="ln"> 9233</span>	<span class="n">smp_send_reschedule</span><span class="p">(</span><span class="n">ilb_cpu</span><span class="p">);</span>
<span class="ln"> 9234</span><span class="p">}</span>
<span class="ln"> 9235</span>
<span class="ln"> 9236</span><span class="cm">/*
</span><span class="ln"> 9237</span><span class="cm"> * Current heuristic for kicking the idle load balancer in the presence
</span><span class="ln"> 9238</span><span class="cm"> * of an idle cpu in the system.
</span><span class="ln"> 9239</span><span class="cm"> *   - This rq has more than one task.
</span><span class="ln"> 9240</span><span class="cm"> *   - This rq has at least one CFS task and the capacity of the CPU is
</span><span class="ln"> 9241</span><span class="cm"> *     significantly reduced because of RT tasks or IRQs.
</span><span class="ln"> 9242</span><span class="cm"> *   - At parent of LLC scheduler domain level, this cpu&#39;s scheduler group has
</span><span class="ln"> 9243</span><span class="cm"> *     multiple busy cpu.
</span><span class="ln"> 9244</span><span class="cm"> *   - For SD_ASYM_PACKING, if the lower numbered cpu&#39;s in the scheduler
</span><span class="ln"> 9245</span><span class="cm"> *     domain span are idle.
</span><span class="ln"> 9246</span><span class="cm"> */</span>
<span class="ln"> 9247</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">nohz_balancer_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 9248</span><span class="p">{</span>
<span class="ln"> 9249</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 9250</span>	<span class="k">struct</span> <span class="n">sched_domain_shared</span> <span class="o">*</span><span class="n">sds</span><span class="p">;</span>
<span class="ln"> 9251</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 9252</span>	<span class="kt">int</span> <span class="n">nr_busy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 9253</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9254</span>
<span class="ln"> 9255</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_balance</span><span class="p">))</span>
<span class="ln"> 9256</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9257</span>
<span class="ln"> 9258</span>	<span class="cm">/*
</span><span class="ln"> 9259</span><span class="cm">	 * We may be recently in ticked or tickless idle mode. At the first
</span><span class="ln"> 9260</span><span class="cm">	 * busy tick after returning from idle, we will update the busy stats.
</span><span class="ln"> 9261</span><span class="cm">	 */</span>
<span class="ln"> 9262</span>	<span class="n">nohz_balance_exit_idle</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9263</span>
<span class="ln"> 9264</span>	<span class="cm">/*
</span><span class="ln"> 9265</span><span class="cm">	 * None are in tickless mode and hence no need for NOHZ idle load
</span><span class="ln"> 9266</span><span class="cm">	 * balancing.
</span><span class="ln"> 9267</span><span class="cm">	 */</span>
<span class="ln"> 9268</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">nr_cpus</span><span class="p">)))</span>
<span class="ln"> 9269</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9270</span>
<span class="ln"> 9271</span>	<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">has_blocked</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 9272</span>	    <span class="n">time_after</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">next_blocked</span><span class="p">)))</span>
<span class="ln"> 9273</span>		<span class="n">flags</span> <span class="o">=</span> <span class="n">NOHZ_STATS_KICK</span><span class="p">;</span>
<span class="ln"> 9274</span>
<span class="ln"> 9275</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span><span class="p">))</span>
<span class="ln"> 9276</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 9277</span>
<span class="ln"> 9278</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9279</span>		<span class="n">flags</span> <span class="o">=</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">;</span>
<span class="ln"> 9280</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 9281</span>	<span class="p">}</span>
<span class="ln"> 9282</span>
<span class="ln"> 9283</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9284</span>	<span class="n">sds</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc_shared</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 9285</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sds</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9286</span>		<span class="cm">/*
</span><span class="ln"> 9287</span><span class="cm">		 * XXX: write a coherent comment on why we do this.
</span><span class="ln"> 9288</span><span class="cm">		 * See also: http://lkml.kernel.org/r/20111202010832.602203411@sbsiddha-desk.sc.intel.com
</span><span class="ln"> 9289</span><span class="cm">		 */</span>
<span class="ln"> 9290</span>		<span class="n">nr_busy</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sds</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">);</span>
<span class="ln"> 9291</span>		<span class="k">if</span> <span class="p">(</span><span class="n">nr_busy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9292</span>			<span class="n">flags</span> <span class="o">=</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">;</span>
<span class="ln"> 9293</span>			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 9294</span>		<span class="p">}</span>
<span class="ln"> 9295</span>
<span class="ln"> 9296</span>	<span class="p">}</span>
<span class="ln"> 9297</span>
<span class="ln"> 9298</span>	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">);</span>
<span class="ln"> 9299</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9300</span>		<span class="k">if</span> <span class="p">((</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="ln"> 9301</span>				<span class="n">check_cpu_capacity</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9302</span>			<span class="n">flags</span> <span class="o">=</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">;</span>
<span class="ln"> 9303</span>			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 9304</span>		<span class="p">}</span>
<span class="ln"> 9305</span>	<span class="p">}</span>
<span class="ln"> 9306</span>
<span class="ln"> 9307</span>	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_asym</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 9308</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9309</span>		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9310</span>			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span> <span class="o">||</span>
<span class="ln"> 9311</span>			    <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">))</span>
<span class="ln"> 9312</span>				<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 9313</span>
<span class="ln"> 9314</span>			<span class="k">if</span> <span class="p">(</span><span class="n">sched_asym_prefer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cpu</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9315</span>				<span class="n">flags</span> <span class="o">=</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">;</span>
<span class="ln"> 9316</span>				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 9317</span>			<span class="p">}</span>
<span class="ln"> 9318</span>		<span class="p">}</span>
<span class="ln"> 9319</span>	<span class="p">}</span>
<span class="ln"> 9320</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln"> 9321</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9322</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 9323</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
<span class="ln"> 9324</span>		<span class="n">kick_ilb</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="ln"> 9325</span><span class="p">}</span>
<span class="ln"> 9326</span>
<span class="ln"> 9327</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_cpu_sd_state_busy</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 9328</span><span class="p">{</span>
<span class="ln"> 9329</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 9330</span>
<span class="ln"> 9331</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9332</span>	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 9333</span>
<span class="ln"> 9334</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span> <span class="o">||</span> <span class="o">!</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">nohz_idle</span><span class="p">)</span>
<span class="ln"> 9335</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 9336</span>	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nohz_idle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9337</span>
<span class="ln"> 9338</span>	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">);</span>
<span class="ln"> 9339</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln"> 9340</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9341</span><span class="p">}</span>
<span class="ln"> 9342</span>
<span class="ln"> 9343</span><span class="kt">void</span> <span class="nf">nohz_balance_exit_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 9344</span><span class="p">{</span>
<span class="ln"> 9345</span>	<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">rq</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="p">());</span>
<span class="ln"> 9346</span>
<span class="ln"> 9347</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_tick_stopped</span><span class="p">))</span>
<span class="ln"> 9348</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9349</span>
<span class="ln"> 9350</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_tick_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9351</span>	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">);</span>
<span class="ln"> 9352</span>	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">nr_cpus</span><span class="p">);</span>
<span class="ln"> 9353</span>
<span class="ln"> 9354</span>	<span class="n">set_cpu_sd_state_busy</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 9355</span><span class="p">}</span>
<span class="ln"> 9356</span>
<span class="ln"> 9357</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_cpu_sd_state_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 9358</span><span class="p">{</span>
<span class="ln"> 9359</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 9360</span>
<span class="ln"> 9361</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9362</span>	<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">sd_llc</span><span class="p">,</span> <span class="n">cpu</span><span class="p">));</span>
<span class="ln"> 9363</span>
<span class="ln"> 9364</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span> <span class="o">||</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">nohz_idle</span><span class="p">)</span>
<span class="ln"> 9365</span>		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="ln"> 9366</span>	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">nohz_idle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9367</span>
<span class="ln"> 9368</span>	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">shared</span><span class="o">-&gt;</span><span class="n">nr_busy_cpus</span><span class="p">);</span>
<span class="ln"> 9369</span><span class="nl">unlock</span><span class="p">:</span>
<span class="ln"> 9370</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9371</span><span class="p">}</span>
<span class="ln"> 9372</span>
<span class="ln"> 9373</span><span class="cm">/*
</span><span class="ln"> 9374</span><span class="cm"> * This routine will record that the CPU is going idle with tick stopped.
</span><span class="ln"> 9375</span><span class="cm"> * This info will be used in performing idle load balancing in the future.
</span><span class="ln"> 9376</span><span class="cm"> */</span>
<span class="ln"> 9377</span><span class="kt">void</span> <span class="nf">nohz_balance_enter_idle</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln"> 9378</span><span class="p">{</span>
<span class="ln"> 9379</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 9380</span>
<span class="ln"> 9381</span>	<span class="n">SCHED_WARN_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="ln"> 9382</span>
<span class="ln"> 9383</span>	<span class="cm">/* If this CPU is going down, then nothing needs to be done: */</span>
<span class="ln"> 9384</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">))</span>
<span class="ln"> 9385</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9386</span>
<span class="ln"> 9387</span>	<span class="cm">/* Spare idle load balancing on CPUs that don&#39;t want to be disturbed: */</span>
<span class="ln"> 9388</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">HK_FLAG_SCHED</span><span class="p">))</span>
<span class="ln"> 9389</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9390</span>
<span class="ln"> 9391</span>	<span class="cm">/*
</span><span class="ln"> 9392</span><span class="cm">	 * Can be set safely without rq-&gt;lock held
</span><span class="ln"> 9393</span><span class="cm">	 * If a clear happens, it will have evaluated last additions because
</span><span class="ln"> 9394</span><span class="cm">	 * rq-&gt;lock is held during the check and the clear
</span><span class="ln"> 9395</span><span class="cm">	 */</span>
<span class="ln"> 9396</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">has_blocked_load</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9397</span>
<span class="ln"> 9398</span>	<span class="cm">/*
</span><span class="ln"> 9399</span><span class="cm">	 * The tick is still stopped but load could have been added in the
</span><span class="ln"> 9400</span><span class="cm">	 * meantime. We set the nohz.has_blocked flag to trig a check of the
</span><span class="ln"> 9401</span><span class="cm">	 * *_avg. The CPU is already part of nohz.idle_cpus_mask so the clear
</span><span class="ln"> 9402</span><span class="cm">	 * of nohz.has_blocked can only happen after checking the new load
</span><span class="ln"> 9403</span><span class="cm">	 */</span>
<span class="ln"> 9404</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_tick_stopped</span><span class="p">)</span>
<span class="ln"> 9405</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 9406</span>
<span class="ln"> 9407</span>	<span class="cm">/* If we&#39;re a completely isolated CPU, we don&#39;t play: */</span>
<span class="ln"> 9408</span>	<span class="k">if</span> <span class="p">(</span><span class="n">on_null_domain</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span>
<span class="ln"> 9409</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9410</span>
<span class="ln"> 9411</span>	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nohz_tick_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9412</span>
<span class="ln"> 9413</span>	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">);</span>
<span class="ln"> 9414</span>	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">nr_cpus</span><span class="p">);</span>
<span class="ln"> 9415</span>
<span class="ln"> 9416</span>	<span class="cm">/*
</span><span class="ln"> 9417</span><span class="cm">	 * Ensures that if nohz_idle_balance() fails to observe our
</span><span class="ln"> 9418</span><span class="cm">	 * @idle_cpus_mask store, it must observe the @has_blocked
</span><span class="ln"> 9419</span><span class="cm">	 * store.
</span><span class="ln"> 9420</span><span class="cm">	 */</span>
<span class="ln"> 9421</span>	<span class="n">smp_mb__after_atomic</span><span class="p">();</span>
<span class="ln"> 9422</span>
<span class="ln"> 9423</span>	<span class="n">set_cpu_sd_state_idle</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 9424</span>
<span class="ln"> 9425</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 9426</span>	<span class="cm">/*
</span><span class="ln"> 9427</span><span class="cm">	 * Each time a cpu enter idle, we assume that it has blocked load and
</span><span class="ln"> 9428</span><span class="cm">	 * enable the periodic update of the load of idle cpus
</span><span class="ln"> 9429</span><span class="cm">	 */</span>
<span class="ln"> 9430</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">has_blocked</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 9431</span><span class="p">}</span>
<span class="ln"> 9432</span>
<span class="ln"> 9433</span><span class="cm">/*
</span><span class="ln"> 9434</span><span class="cm"> * Internal function that runs load balance for all idle cpus. The load balance
</span><span class="ln"> 9435</span><span class="cm"> * can be a simple update of blocked load or a complete load balance with
</span><span class="ln"> 9436</span><span class="cm"> * tasks movement depending of flags.
</span><span class="ln"> 9437</span><span class="cm"> * The function returns false if the loop has stopped before running
</span><span class="ln"> 9438</span><span class="cm"> * through all idle CPUs.
</span><span class="ln"> 9439</span><span class="cm"> */</span>
<span class="ln"> 9440</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">_nohz_idle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
<span class="ln"> 9441</span>			       <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="ln"> 9442</span><span class="p">{</span>
<span class="ln"> 9443</span>	<span class="cm">/* Earliest time when we have to do rebalance again */</span>
<span class="ln"> 9444</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln"> 9445</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="mi">60</span><span class="o">*</span><span class="n">HZ</span><span class="p">;</span>
<span class="ln"> 9446</span>	<span class="kt">bool</span> <span class="n">has_blocked_load</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9447</span>	<span class="kt">int</span> <span class="n">update_next_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9448</span>	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 9449</span>	<span class="kt">int</span> <span class="n">balance_cpu</span><span class="p">;</span>
<span class="ln"> 9450</span>	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9451</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln"> 9452</span>
<span class="ln"> 9453</span>	<span class="n">SCHED_WARN_ON</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">NOHZ_BALANCE_KICK</span><span class="p">);</span>
<span class="ln"> 9454</span>
<span class="ln"> 9455</span>	<span class="cm">/*
</span><span class="ln"> 9456</span><span class="cm">	 * We assume there will be no idle load after this update and clear
</span><span class="ln"> 9457</span><span class="cm">	 * the has_blocked flag. If a cpu enters idle in the mean time, it will
</span><span class="ln"> 9458</span><span class="cm">	 * set the has_blocked flag and trig another update of idle load.
</span><span class="ln"> 9459</span><span class="cm">	 * Because a cpu that becomes idle, is added to idle_cpus_mask before
</span><span class="ln"> 9460</span><span class="cm">	 * setting the flag, we are sure to not clear the state and not
</span><span class="ln"> 9461</span><span class="cm">	 * check the load of an idle cpu.
</span><span class="ln"> 9462</span><span class="cm">	 */</span>
<span class="ln"> 9463</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">has_blocked</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 9464</span>
<span class="ln"> 9465</span>	<span class="cm">/*
</span><span class="ln"> 9466</span><span class="cm">	 * Ensures that if we miss the CPU, we must see the has_blocked
</span><span class="ln"> 9467</span><span class="cm">	 * store from nohz_balance_enter_idle().
</span><span class="ln"> 9468</span><span class="cm">	 */</span>
<span class="ln"> 9469</span>	<span class="n">smp_mb</span><span class="p">();</span>
<span class="ln"> 9470</span>
<span class="ln"> 9471</span>	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">,</span> <span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9472</span>		<span class="k">if</span> <span class="p">(</span><span class="n">balance_cpu</span> <span class="o">==</span> <span class="n">this_cpu</span> <span class="o">||</span> <span class="o">!</span><span class="n">idle_cpu</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">))</span>
<span class="ln"> 9473</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 9474</span>
<span class="ln"> 9475</span>		<span class="cm">/*
</span><span class="ln"> 9476</span><span class="cm">		 * If this CPU gets work to do, stop the load balancing
</span><span class="ln"> 9477</span><span class="cm">		 * work being done for other CPUs. Next load
</span><span class="ln"> 9478</span><span class="cm">		 * balancing owner will pick it up.
</span><span class="ln"> 9479</span><span class="cm">		 */</span>
<span class="ln"> 9480</span>		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
<span class="ln"> 9481</span>			<span class="n">has_blocked_load</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 9482</span>			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
<span class="ln"> 9483</span>		<span class="p">}</span>
<span class="ln"> 9484</span>
<span class="ln"> 9485</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">balance_cpu</span><span class="p">);</span>
<span class="ln"> 9486</span>
<span class="ln"> 9487</span>		<span class="n">has_blocked_load</span> <span class="o">|=</span> <span class="n">update_nohz_stats</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="ln"> 9488</span>
<span class="ln"> 9489</span>		<span class="cm">/*
</span><span class="ln"> 9490</span><span class="cm">		 * If time for next balance is due,
</span><span class="ln"> 9491</span><span class="cm">		 * do the balance.
</span><span class="ln"> 9492</span><span class="cm">		 */</span>
<span class="ln"> 9493</span>		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9494</span>			<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 9495</span>
<span class="ln"> 9496</span>			<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9497</span>			<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9498</span>			<span class="n">cpu_load_update_idle</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9499</span>			<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9500</span>
<span class="ln"> 9501</span>			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOHZ_BALANCE_KICK</span><span class="p">)</span>
<span class="ln"> 9502</span>				<span class="n">rebalance_domains</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">CPU_IDLE</span><span class="p">);</span>
<span class="ln"> 9503</span>		<span class="p">}</span>
<span class="ln"> 9504</span>
<span class="ln"> 9505</span>		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9506</span>			<span class="n">next_balance</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">;</span>
<span class="ln"> 9507</span>			<span class="n">update_next_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9508</span>		<span class="p">}</span>
<span class="ln"> 9509</span>	<span class="p">}</span>
<span class="ln"> 9510</span>
<span class="ln"> 9511</span>	<span class="cm">/*
</span><span class="ln"> 9512</span><span class="cm">	 * next_balance will be updated only when there is a need.
</span><span class="ln"> 9513</span><span class="cm">	 * When the CPU is attached to null domain for ex, it will not be
</span><span class="ln"> 9514</span><span class="cm">	 * updated.
</span><span class="ln"> 9515</span><span class="cm">	 */</span>
<span class="ln"> 9516</span>	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">update_next_balance</span><span class="p">))</span>
<span class="ln"> 9517</span>		<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">next_balance</span><span class="p">;</span>
<span class="ln"> 9518</span>
<span class="ln"> 9519</span>	<span class="cm">/* Newly idle CPU doesn&#39;t need an update */</span>
<span class="ln"> 9520</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9521</span>		<span class="n">update_blocked_averages</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
<span class="ln"> 9522</span>		<span class="n">has_blocked_load</span> <span class="o">|=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">has_blocked_load</span><span class="p">;</span>
<span class="ln"> 9523</span>	<span class="p">}</span>
<span class="ln"> 9524</span>
<span class="ln"> 9525</span>	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOHZ_BALANCE_KICK</span><span class="p">)</span>
<span class="ln"> 9526</span>		<span class="n">rebalance_domains</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">CPU_IDLE</span><span class="p">);</span>
<span class="ln"> 9527</span>
<span class="ln"> 9528</span>	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">next_blocked</span><span class="p">,</span>
<span class="ln"> 9529</span>		<span class="n">now</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">LOAD_AVG_PERIOD</span><span class="p">));</span>
<span class="ln"> 9530</span>
<span class="ln"> 9531</span>	<span class="cm">/* The full idle balance loop has been done */</span>
<span class="ln"> 9532</span>	<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 9533</span>
<span class="ln"> 9534</span><span class="nl">abort</span><span class="p">:</span>
<span class="ln"> 9535</span>	<span class="cm">/* There is still blocked load, enable periodic update */</span>
<span class="ln"> 9536</span>	<span class="k">if</span> <span class="p">(</span><span class="n">has_blocked_load</span><span class="p">)</span>
<span class="ln"> 9537</span>		<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">has_blocked</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 9538</span>
<span class="ln"> 9539</span>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="ln"> 9540</span><span class="p">}</span>
<span class="ln"> 9541</span>
<span class="ln"> 9542</span><span class="cm">/*
</span><span class="ln"> 9543</span><span class="cm"> * In CONFIG_NO_HZ_COMMON case, the idle balance kickee will do the
</span><span class="ln"> 9544</span><span class="cm"> * rebalancing for all the cpus for whom scheduler ticks are stopped.
</span><span class="ln"> 9545</span><span class="cm"> */</span>
<span class="ln"> 9546</span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">nohz_idle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="ln"> 9547</span><span class="p">{</span>
<span class="ln"> 9548</span>	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 9549</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln"> 9550</span>
<span class="ln"> 9551</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="n">nohz_flags</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">))</span>
<span class="ln"> 9552</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9553</span>
<span class="ln"> 9554</span>	<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">!=</span> <span class="n">CPU_IDLE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9555</span>		<span class="n">atomic_andnot</span><span class="p">(</span><span class="n">NOHZ_KICK_MASK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">));</span>
<span class="ln"> 9556</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9557</span>	<span class="p">}</span>
<span class="ln"> 9558</span>
<span class="ln"> 9559</span>	<span class="cm">/*
</span><span class="ln"> 9560</span><span class="cm">	 * barrier, pairs with nohz_balance_enter_idle(), ensures ...
</span><span class="ln"> 9561</span><span class="cm">	 */</span>
<span class="ln"> 9562</span>	<span class="n">flags</span> <span class="o">=</span> <span class="n">atomic_fetch_andnot</span><span class="p">(</span><span class="n">NOHZ_KICK_MASK</span><span class="p">,</span> <span class="n">nohz_flags</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">));</span>
<span class="ln"> 9563</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NOHZ_KICK_MASK</span><span class="p">))</span>
<span class="ln"> 9564</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9565</span>
<span class="ln"> 9566</span>	<span class="n">_nohz_idle_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">idle</span><span class="p">);</span>
<span class="ln"> 9567</span>
<span class="ln"> 9568</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 9569</span><span class="p">}</span>
<span class="ln"> 9570</span>
<span class="ln"> 9571</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">nohz_newidle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="ln"> 9572</span><span class="p">{</span>
<span class="ln"> 9573</span>	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 9574</span>
<span class="ln"> 9575</span>	<span class="cm">/*
</span><span class="ln"> 9576</span><span class="cm">	 * This CPU doesn&#39;t want to be disturbed by scheduler
</span><span class="ln"> 9577</span><span class="cm">	 * housekeeping
</span><span class="ln"> 9578</span><span class="cm">	 */</span>
<span class="ln"> 9579</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">housekeeping_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">HK_FLAG_SCHED</span><span class="p">))</span>
<span class="ln"> 9580</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9581</span>
<span class="ln"> 9582</span>	<span class="cm">/* Will wake up very soon. No time for doing anything else*/</span>
<span class="ln"> 9583</span>	<span class="k">if</span> <span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">&lt;</span> <span class="n">sysctl_sched_migration_cost</span><span class="p">)</span>
<span class="ln"> 9584</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9585</span>
<span class="ln"> 9586</span>	<span class="cm">/* Don&#39;t need to update blocked load of idle CPUs*/</span>
<span class="ln"> 9587</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">has_blocked</span><span class="p">)</span> <span class="o">||</span>
<span class="ln"> 9588</span>	    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">nohz</span><span class="p">.</span><span class="n">next_blocked</span><span class="p">)))</span>
<span class="ln"> 9589</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9590</span>
<span class="ln"> 9591</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 9592</span>	<span class="cm">/*
</span><span class="ln"> 9593</span><span class="cm">	 * This CPU is going to be idle and blocked load of idle CPUs
</span><span class="ln"> 9594</span><span class="cm">	 * need to be updated. Run the ilb locally as it is a good
</span><span class="ln"> 9595</span><span class="cm">	 * candidate for ilb instead of waking up another idle CPU.
</span><span class="ln"> 9596</span><span class="cm">	 * Kick an normal ilb if we failed to do the update.
</span><span class="ln"> 9597</span><span class="cm">	 */</span>
<span class="ln"> 9598</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_nohz_idle_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">NOHZ_STATS_KICK</span><span class="p">,</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">))</span>
<span class="ln"> 9599</span>		<span class="n">kick_ilb</span><span class="p">(</span><span class="n">NOHZ_STATS_KICK</span><span class="p">);</span>
<span class="ln"> 9600</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 9601</span><span class="p">}</span>
<span class="ln"> 9602</span>
<span class="ln"> 9603</span><span class="cp">#else </span><span class="cm">/* !CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 9604</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nohz_balancer_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 9605</span>
<span class="ln"> 9606</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">nohz_idle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span><span class="p">)</span>
<span class="ln"> 9607</span><span class="p">{</span>
<span class="ln"> 9608</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9609</span><span class="p">}</span>
<span class="ln"> 9610</span>
<span class="ln"> 9611</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nohz_newidle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 9612</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NO_HZ_COMMON */</span><span class="cp">
</span><span class="ln"> 9613</span><span class="cp"></span>
<span class="ln"> 9614</span><span class="cm">/*
</span><span class="ln"> 9615</span><span class="cm"> * idle_balance is called by schedule() if this_cpu is about to become
</span><span class="ln"> 9616</span><span class="cm"> * idle. Attempts to pull tasks from other CPUs.
</span><span class="ln"> 9617</span><span class="cm"> */</span>
<span class="ln"> 9618</span><span class="k">static</span> <span class="kt">int</span> <span class="nf">idle_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="ln"> 9619</span><span class="p">{</span>
<span class="ln"> 9620</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
<span class="ln"> 9621</span>	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>
<span class="ln"> 9622</span>	<span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="ln"> 9623</span>	<span class="kt">int</span> <span class="n">pulled_task</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9624</span>	<span class="n">u64</span> <span class="n">curr_cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9625</span>
<span class="ln"> 9626</span>	<span class="cm">/*
</span><span class="ln"> 9627</span><span class="cm">	 * We must set idle_stamp _before_ calling idle_balance(), such that we
</span><span class="ln"> 9628</span><span class="cm">	 * measure the duration of idle_balance() as idle time.
</span><span class="ln"> 9629</span><span class="cm">	 */</span>
<span class="ln"> 9630</span>	<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="n">rq_clock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="ln"> 9631</span>
<span class="ln"> 9632</span>	<span class="cm">/*
</span><span class="ln"> 9633</span><span class="cm">	 * Do not pull tasks towards !active CPUs...
</span><span class="ln"> 9634</span><span class="cm">	 */</span>
<span class="ln"> 9635</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpu_active</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">))</span>
<span class="ln"> 9636</span>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9637</span>
<span class="ln"> 9638</span>	<span class="cm">/*
</span><span class="ln"> 9639</span><span class="cm">	 * This is OK, because current is on_cpu, which avoids it being picked
</span><span class="ln"> 9640</span><span class="cm">	 * for load-balance and preemption/IRQs are still disabled avoiding
</span><span class="ln"> 9641</span><span class="cm">	 * further scheduler activity on it and we&#39;re being very careful to
</span><span class="ln"> 9642</span><span class="cm">	 * re-start the picking loop.
</span><span class="ln"> 9643</span><span class="cm">	 */</span>
<span class="ln"> 9644</span>	<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9645</span>
<span class="ln"> 9646</span>	<span class="k">if</span> <span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">&lt;</span> <span class="n">sysctl_sched_migration_cost</span> <span class="o">||</span>
<span class="ln"> 9647</span>	    <span class="o">!</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">overload</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9648</span>
<span class="ln"> 9649</span>		<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9650</span>		<span class="n">sd</span> <span class="o">=</span> <span class="n">rcu_dereference_check_sched_domain</span><span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">);</span>
<span class="ln"> 9651</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">)</span>
<span class="ln"> 9652</span>			<span class="n">update_next_balance</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_balance</span><span class="p">);</span>
<span class="ln"> 9653</span>		<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9654</span>
<span class="ln"> 9655</span>		<span class="n">nohz_newidle_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="ln"> 9656</span>
<span class="ln"> 9657</span>		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="ln"> 9658</span>	<span class="p">}</span>
<span class="ln"> 9659</span>
<span class="ln"> 9660</span>	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 9661</span>
<span class="ln"> 9662</span>	<span class="n">update_blocked_averages</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
<span class="ln"> 9663</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln"> 9664</span>	<span class="n">for_each_domain</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9665</span>		<span class="kt">int</span> <span class="n">continue_balancing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9666</span>		<span class="n">u64</span> <span class="n">t0</span><span class="p">,</span> <span class="n">domain_cost</span><span class="p">;</span>
<span class="ln"> 9667</span>
<span class="ln"> 9668</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_LOAD_BALANCE</span><span class="p">))</span>
<span class="ln"> 9669</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln"> 9670</span>
<span class="ln"> 9671</span>		<span class="k">if</span> <span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">avg_idle</span> <span class="o">&lt;</span> <span class="n">curr_cost</span> <span class="o">+</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_newidle_lb_cost</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9672</span>			<span class="n">update_next_balance</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_balance</span><span class="p">);</span>
<span class="ln"> 9673</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 9674</span>		<span class="p">}</span>
<span class="ln"> 9675</span>
<span class="ln"> 9676</span>		<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SD_BALANCE_NEWIDLE</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9677</span>			<span class="n">t0</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">);</span>
<span class="ln"> 9678</span>
<span class="ln"> 9679</span>			<span class="n">pulled_task</span> <span class="o">=</span> <span class="n">load_balance</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">,</span> <span class="n">this_rq</span><span class="p">,</span>
<span class="ln"> 9680</span>						   <span class="n">sd</span><span class="p">,</span> <span class="n">CPU_NEWLY_IDLE</span><span class="p">,</span>
<span class="ln"> 9681</span>						   <span class="o">&amp;</span><span class="n">continue_balancing</span><span class="p">);</span>
<span class="ln"> 9682</span>
<span class="ln"> 9683</span>			<span class="n">domain_cost</span> <span class="o">=</span> <span class="n">sched_clock_cpu</span><span class="p">(</span><span class="n">this_cpu</span><span class="p">)</span> <span class="o">-</span> <span class="n">t0</span><span class="p">;</span>
<span class="ln"> 9684</span>			<span class="k">if</span> <span class="p">(</span><span class="n">domain_cost</span> <span class="o">&gt;</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_newidle_lb_cost</span><span class="p">)</span>
<span class="ln"> 9685</span>				<span class="n">sd</span><span class="o">-&gt;</span><span class="n">max_newidle_lb_cost</span> <span class="o">=</span> <span class="n">domain_cost</span><span class="p">;</span>
<span class="ln"> 9686</span>
<span class="ln"> 9687</span>			<span class="n">curr_cost</span> <span class="o">+=</span> <span class="n">domain_cost</span><span class="p">;</span>
<span class="ln"> 9688</span>		<span class="p">}</span>
<span class="ln"> 9689</span>
<span class="ln"> 9690</span>		<span class="n">update_next_balance</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_balance</span><span class="p">);</span>
<span class="ln"> 9691</span>
<span class="ln"> 9692</span>		<span class="cm">/*
</span><span class="ln"> 9693</span><span class="cm">		 * Stop searching for tasks to pull if there are
</span><span class="ln"> 9694</span><span class="cm">		 * now runnable tasks on this rq.
</span><span class="ln"> 9695</span><span class="cm">		 */</span>
<span class="ln"> 9696</span>		<span class="k">if</span> <span class="p">(</span><span class="n">pulled_task</span> <span class="o">||</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="ln"> 9697</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 9698</span>	<span class="p">}</span>
<span class="ln"> 9699</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln"> 9700</span>
<span class="ln"> 9701</span>	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="ln"> 9702</span>
<span class="ln"> 9703</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr_cost</span> <span class="o">&gt;</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">max_idle_balance_cost</span><span class="p">)</span>
<span class="ln"> 9704</span>		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">max_idle_balance_cost</span> <span class="o">=</span> <span class="n">curr_cost</span><span class="p">;</span>
<span class="ln"> 9705</span>
<span class="ln"> 9706</span><span class="nl">out</span><span class="p">:</span>
<span class="ln"> 9707</span>	<span class="cm">/*
</span><span class="ln"> 9708</span><span class="cm">	 * While browsing the domains, we released the rq lock, a task could
</span><span class="ln"> 9709</span><span class="cm">	 * have been enqueued in the meantime. Since we&#39;re not going idle,
</span><span class="ln"> 9710</span><span class="cm">	 * pretend we pulled a task.
</span><span class="ln"> 9711</span><span class="cm">	 */</span>
<span class="ln"> 9712</span>	<span class="k">if</span> <span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pulled_task</span><span class="p">)</span>
<span class="ln"> 9713</span>		<span class="n">pulled_task</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9714</span>
<span class="ln"> 9715</span>	<span class="cm">/* Move the next balance forward */</span>
<span class="ln"> 9716</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">,</span> <span class="n">next_balance</span><span class="p">))</span>
<span class="ln"> 9717</span>		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">next_balance</span><span class="p">;</span>
<span class="ln"> 9718</span>
<span class="ln"> 9719</span>	<span class="cm">/* Is there a task of a high priority class? */</span>
<span class="ln"> 9720</span>	<span class="k">if</span> <span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">!=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">)</span>
<span class="ln"> 9721</span>		<span class="n">pulled_task</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 9722</span>
<span class="ln"> 9723</span>	<span class="k">if</span> <span class="p">(</span><span class="n">pulled_task</span><span class="p">)</span>
<span class="ln"> 9724</span>		<span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">idle_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9725</span>
<span class="ln"> 9726</span>	<span class="n">rq_repin_lock</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9727</span>
<span class="ln"> 9728</span>	<span class="k">return</span> <span class="n">pulled_task</span><span class="p">;</span>
<span class="ln"> 9729</span><span class="p">}</span>
<span class="ln"> 9730</span>
<span class="ln"> 9731</span><span class="cm">/*
</span><span class="ln"> 9732</span><span class="cm"> * run_rebalance_domains is triggered when needed from the scheduler tick.
</span><span class="ln"> 9733</span><span class="cm"> * Also triggered for nohz idle balancing (with nohz_balancing_kick set).
</span><span class="ln"> 9734</span><span class="cm"> */</span>
<span class="ln"> 9735</span><span class="k">static</span> <span class="n">__latent_entropy</span> <span class="kt">void</span> <span class="nf">run_rebalance_domains</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="ln"> 9736</span><span class="p">{</span>
<span class="ln"> 9737</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln"> 9738</span>	<span class="k">enum</span> <span class="n">cpu_idle_type</span> <span class="n">idle</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">?</span>
<span class="ln"> 9739</span>						<span class="nl">CPU_IDLE</span> <span class="p">:</span> <span class="n">CPU_NOT_IDLE</span><span class="p">;</span>
<span class="ln"> 9740</span>
<span class="ln"> 9741</span>	<span class="cm">/*
</span><span class="ln"> 9742</span><span class="cm">	 * If this CPU has a pending nohz_balance_kick, then do the
</span><span class="ln"> 9743</span><span class="cm">	 * balancing on behalf of the other idle CPUs whose ticks are
</span><span class="ln"> 9744</span><span class="cm">	 * stopped. Do nohz_idle_balance *before* rebalance_domains to
</span><span class="ln"> 9745</span><span class="cm">	 * give the idle CPUs a chance to load balance. Else we may
</span><span class="ln"> 9746</span><span class="cm">	 * load balance only within the local sched_domain hierarchy
</span><span class="ln"> 9747</span><span class="cm">	 * and abort nohz_idle_balance altogether if we pull some load.
</span><span class="ln"> 9748</span><span class="cm">	 */</span>
<span class="ln"> 9749</span>	<span class="k">if</span> <span class="p">(</span><span class="n">nohz_idle_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">idle</span><span class="p">))</span>
<span class="ln"> 9750</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9751</span>
<span class="ln"> 9752</span>	<span class="cm">/* normal load balance */</span>
<span class="ln"> 9753</span>	<span class="n">update_blocked_averages</span><span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln"> 9754</span>	<span class="n">rebalance_domains</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">idle</span><span class="p">);</span>
<span class="ln"> 9755</span><span class="p">}</span>
<span class="ln"> 9756</span>
<span class="ln"> 9757</span><span class="cm">/*
</span><span class="ln"> 9758</span><span class="cm"> * Trigger the SCHED_SOFTIRQ if it is time to do periodic load balancing.
</span><span class="ln"> 9759</span><span class="cm"> */</span>
<span class="ln"> 9760</span><span class="kt">void</span> <span class="nf">trigger_load_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 9761</span><span class="p">{</span>
<span class="ln"> 9762</span>	<span class="cm">/* Don&#39;t need to rebalance while attached to NULL domain */</span>
<span class="ln"> 9763</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">on_null_domain</span><span class="p">(</span><span class="n">rq</span><span class="p">)))</span>
<span class="ln"> 9764</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9765</span>
<span class="ln"> 9766</span>	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">next_balance</span><span class="p">))</span>
<span class="ln"> 9767</span>		<span class="n">raise_softirq</span><span class="p">(</span><span class="n">SCHED_SOFTIRQ</span><span class="p">);</span>
<span class="ln"> 9768</span>
<span class="ln"> 9769</span>	<span class="n">nohz_balancer_kick</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9770</span><span class="p">}</span>
<span class="ln"> 9771</span>
<span class="ln"> 9772</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_online_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 9773</span><span class="p">{</span>
<span class="ln"> 9774</span>	<span class="n">update_sysctl</span><span class="p">();</span>
<span class="ln"> 9775</span>
<span class="ln"> 9776</span>	<span class="n">update_runtime_enabled</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9777</span><span class="p">}</span>
<span class="ln"> 9778</span>
<span class="ln"> 9779</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">rq_offline_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln"> 9780</span><span class="p">{</span>
<span class="ln"> 9781</span>	<span class="n">update_sysctl</span><span class="p">();</span>
<span class="ln"> 9782</span>
<span class="ln"> 9783</span>	<span class="cm">/* Ensure any throttled groups are reachable by pick_next_task */</span>
<span class="ln"> 9784</span>	<span class="n">unthrottle_offline_cfs_rqs</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9785</span><span class="p">}</span>
<span class="ln"> 9786</span>
<span class="ln"> 9787</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SMP */</span><span class="cp">
</span><span class="ln"> 9788</span><span class="cp"></span>
<span class="ln"> 9789</span><span class="cm">/*
</span><span class="ln"> 9790</span><span class="cm"> * scheduler tick hitting a task of our scheduling class.
</span><span class="ln"> 9791</span><span class="cm"> *
</span><span class="ln"> 9792</span><span class="cm"> * NOTE: This function can be called remotely by the tick offload that
</span><span class="ln"> 9793</span><span class="cm"> * goes along full dynticks. Therefore no local assumption can be made
</span><span class="ln"> 9794</span><span class="cm"> * and everything must be accessed through the @rq and @curr passed in
</span><span class="ln"> 9795</span><span class="cm"> * parameters.
</span><span class="ln"> 9796</span><span class="cm"> */</span>
<span class="ln"> 9797</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_tick_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="ln"> 9798</span><span class="p">{</span>
<span class="ln"> 9799</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 9800</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 9801</span>
<span class="ln"> 9802</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9803</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9804</span>		<span class="n">entity_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">queued</span><span class="p">);</span>
<span class="ln"> 9805</span>	<span class="p">}</span>
<span class="ln"> 9806</span>
<span class="ln"> 9807</span>	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_numa_balancing</span><span class="p">))</span>
<span class="ln"> 9808</span>		<span class="n">task_tick_numa</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="ln"> 9809</span><span class="p">}</span>
<span class="ln"> 9810</span>
<span class="ln"> 9811</span><span class="cm">/*
</span><span class="ln"> 9812</span><span class="cm"> * called on fork with the child task as argument from the parent&#39;s context
</span><span class="ln"> 9813</span><span class="cm"> *  - child not yet on the tasklist
</span><span class="ln"> 9814</span><span class="cm"> *  - preemption disabled
</span><span class="ln"> 9815</span><span class="cm"> */</span>
<span class="ln"> 9816</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_fork_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9817</span><span class="p">{</span>
<span class="ln"> 9818</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 9819</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 9820</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">this_rq</span><span class="p">();</span>
<span class="ln"> 9821</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln"> 9822</span>
<span class="ln"> 9823</span>	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9824</span>	<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9825</span>
<span class="ln"> 9826</span>	<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">task_cfs_rq</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="ln"> 9827</span>	<span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
<span class="ln"> 9828</span>	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9829</span>		<span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln"> 9830</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">;</span>
<span class="ln"> 9831</span>	<span class="p">}</span>
<span class="ln"> 9832</span>	<span class="n">place_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 9833</span>
<span class="ln"> 9834</span>	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_sched_child_runs_first</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">entity_before</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">se</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9835</span>		<span class="cm">/*
</span><span class="ln"> 9836</span><span class="cm">		 * Upon rescheduling, sched_class::put_prev_task() will place
</span><span class="ln"> 9837</span><span class="cm">		 * &#39;current&#39; within the tree based on its new key value.
</span><span class="ln"> 9838</span><span class="cm">		 */</span>
<span class="ln"> 9839</span>		<span class="n">swap</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">,</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span><span class="p">);</span>
<span class="ln"> 9840</span>		<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9841</span>	<span class="p">}</span>
<span class="ln"> 9842</span>
<span class="ln"> 9843</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 9844</span>	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln"> 9845</span><span class="p">}</span>
<span class="ln"> 9846</span>
<span class="ln"> 9847</span><span class="cm">/*
</span><span class="ln"> 9848</span><span class="cm"> * Priority of the task has changed. Check to see if we preempt
</span><span class="ln"> 9849</span><span class="cm"> * the current task.
</span><span class="ln"> 9850</span><span class="cm"> */</span>
<span class="ln"> 9851</span><span class="k">static</span> <span class="kt">void</span>
<span class="ln"> 9852</span><span class="nf">prio_changed_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="ln"> 9853</span><span class="p">{</span>
<span class="ln"> 9854</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 9855</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln"> 9856</span>
<span class="ln"> 9857</span>	<span class="cm">/*
</span><span class="ln"> 9858</span><span class="cm">	 * Reschedule if we are currently running on this runqueue and
</span><span class="ln"> 9859</span><span class="cm">	 * our priority decreased, or if we are not currently running on
</span><span class="ln"> 9860</span><span class="cm">	 * this runqueue and our priority is higher than the current&#39;s
</span><span class="ln"> 9861</span><span class="cm">	 */</span>
<span class="ln"> 9862</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9863</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">oldprio</span><span class="p">)</span>
<span class="ln"> 9864</span>			<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9865</span>	<span class="p">}</span> <span class="k">else</span>
<span class="ln"> 9866</span>		<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 9867</span><span class="p">}</span>
<span class="ln"> 9868</span>
<span class="ln"> 9869</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">vruntime_normalized</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9870</span><span class="p">{</span>
<span class="ln"> 9871</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 9872</span>
<span class="ln"> 9873</span>	<span class="cm">/*
</span><span class="ln"> 9874</span><span class="cm">	 * In both the TASK_ON_RQ_QUEUED and TASK_ON_RQ_MIGRATING cases,
</span><span class="ln"> 9875</span><span class="cm">	 * the dequeue_entity(.flags=0) will already have normalized the
</span><span class="ln"> 9876</span><span class="cm">	 * vruntime.
</span><span class="ln"> 9877</span><span class="cm">	 */</span>
<span class="ln"> 9878</span>	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span>
<span class="ln"> 9879</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 9880</span>
<span class="ln"> 9881</span>	<span class="cm">/*
</span><span class="ln"> 9882</span><span class="cm">	 * When !on_rq, vruntime of the task has usually NOT been normalized.
</span><span class="ln"> 9883</span><span class="cm">	 * But there are some cases where it has already been normalized:
</span><span class="ln"> 9884</span><span class="cm">	 *
</span><span class="ln"> 9885</span><span class="cm">	 * - A forked child which is waiting for being woken up by
</span><span class="ln"> 9886</span><span class="cm">	 *   wake_up_new_task().
</span><span class="ln"> 9887</span><span class="cm">	 * - A task which has been woken up by try_to_wake_up() and
</span><span class="ln"> 9888</span><span class="cm">	 *   waiting for actually being woken up by sched_ttwu_pending().
</span><span class="ln"> 9889</span><span class="cm">	 */</span>
<span class="ln"> 9890</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">||</span>
<span class="ln"> 9891</span>	    <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_WAKING</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_remote_wakeup</span><span class="p">))</span>
<span class="ln"> 9892</span>		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="ln"> 9893</span>
<span class="ln"> 9894</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="ln"> 9895</span><span class="p">}</span>
<span class="ln"> 9896</span>
<span class="ln"> 9897</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 9898</span><span class="cp"></span><span class="cm">/*
</span><span class="ln"> 9899</span><span class="cm"> * Propagate the changes of the sched_entity across the tg tree to make it
</span><span class="ln"> 9900</span><span class="cm"> * visible to the root
</span><span class="ln"> 9901</span><span class="cm"> */</span>
<span class="ln"> 9902</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">propagate_entity_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 9903</span><span class="p">{</span>
<span class="ln"> 9904</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln"> 9905</span>
<span class="ln"> 9906</span>	<span class="cm">/* Start to propagate at parent */</span>
<span class="ln"> 9907</span>	<span class="n">se</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="ln"> 9908</span>
<span class="ln"> 9909</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 9910</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9911</span>
<span class="ln"> 9912</span>		<span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq_throttled</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">))</span>
<span class="ln"> 9913</span>			<span class="k">break</span><span class="p">;</span>
<span class="ln"> 9914</span>
<span class="ln"> 9915</span>		<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln"> 9916</span>	<span class="p">}</span>
<span class="ln"> 9917</span><span class="p">}</span>
<span class="ln"> 9918</span><span class="cp">#else
</span><span class="ln"> 9919</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">propagate_entity_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln"> 9920</span><span class="cp">#endif
</span><span class="ln"> 9921</span><span class="cp"></span>
<span class="ln"> 9922</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_entity_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 9923</span><span class="p">{</span>
<span class="ln"> 9924</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9925</span>
<span class="ln"> 9926</span>	<span class="cm">/* Catch up with the cfs_rq and remove our load when we leave */</span>
<span class="ln"> 9927</span>	<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 9928</span>	<span class="n">detach_entity_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln"> 9929</span>	<span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln"> 9930</span>	<span class="n">propagate_entity_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9931</span><span class="p">}</span>
<span class="ln"> 9932</span>
<span class="ln"> 9933</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_entity_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="ln"> 9934</span><span class="p">{</span>
<span class="ln"> 9935</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9936</span>
<span class="ln"> 9937</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln"> 9938</span><span class="cp"></span>	<span class="cm">/*
</span><span class="ln"> 9939</span><span class="cm">	 * Since the real-depth could have been changed (only FAIR
</span><span class="ln"> 9940</span><span class="cm">	 * class maintain depth value), reset depth properly.
</span><span class="ln"> 9941</span><span class="cm">	 */</span>
<span class="ln"> 9942</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">?</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9943</span><span class="cp">#endif
</span><span class="ln"> 9944</span><span class="cp"></span>
<span class="ln"> 9945</span>	<span class="cm">/* Synchronize entity with its cfs_rq */</span>
<span class="ln"> 9946</span>	<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">sched_feat</span><span class="p">(</span><span class="n">ATTACH_AGE_LOAD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">SKIP_AGE_LOAD</span><span class="p">);</span>
<span class="ln"> 9947</span>	<span class="n">attach_entity_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 9948</span>	<span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="ln"> 9949</span>	<span class="n">propagate_entity_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9950</span><span class="p">}</span>
<span class="ln"> 9951</span>
<span class="ln"> 9952</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_task_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9953</span><span class="p">{</span>
<span class="ln"> 9954</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 9955</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9956</span>
<span class="ln"> 9957</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vruntime_normalized</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9958</span>		<span class="cm">/*
</span><span class="ln"> 9959</span><span class="cm">		 * Fix up our vruntime so that the current sleep doesn&#39;t
</span><span class="ln"> 9960</span><span class="cm">		 * cause &#39;unlimited&#39; sleep bonus.
</span><span class="ln"> 9961</span><span class="cm">		 */</span>
<span class="ln"> 9962</span>		<span class="n">place_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 9963</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">-=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 9964</span>	<span class="p">}</span>
<span class="ln"> 9965</span>
<span class="ln"> 9966</span>	<span class="n">detach_entity_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9967</span><span class="p">}</span>
<span class="ln"> 9968</span>
<span class="ln"> 9969</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_task_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9970</span><span class="p">{</span>
<span class="ln"> 9971</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln"> 9972</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9973</span>
<span class="ln"> 9974</span>	<span class="n">attach_entity_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln"> 9975</span>
<span class="ln"> 9976</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vruntime_normalized</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
<span class="ln"> 9977</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln"> 9978</span><span class="p">}</span>
<span class="ln"> 9979</span>
<span class="ln"> 9980</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">switched_from_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9981</span><span class="p">{</span>
<span class="ln"> 9982</span>	<span class="n">detach_task_cfs_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 9983</span><span class="p">}</span>
<span class="ln"> 9984</span>
<span class="ln"> 9985</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">switched_to_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln"> 9986</span><span class="p">{</span>
<span class="ln"> 9987</span>	<span class="n">attach_task_cfs_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln"> 9988</span>
<span class="ln"> 9989</span>	<span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="ln"> 9990</span>		<span class="cm">/*
</span><span class="ln"> 9991</span><span class="cm">		 * We were most likely switched from sched_rt, so
</span><span class="ln"> 9992</span><span class="cm">		 * kick off the schedule if running, otherwise just see
</span><span class="ln"> 9993</span><span class="cm">		 * if we can still preempt the current task.
</span><span class="ln"> 9994</span><span class="cm">		 */</span>
<span class="ln"> 9995</span>		<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
<span class="ln"> 9996</span>			<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln"> 9997</span>		<span class="k">else</span>
<span class="ln"> 9998</span>			<span class="n">check_preempt_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 9999</span>	<span class="p">}</span>
<span class="ln">10000</span><span class="p">}</span>
<span class="ln">10001</span>
<span class="ln">10002</span><span class="cm">/* Account for a task changing its policy or group.
</span><span class="ln">10003</span><span class="cm"> *
</span><span class="ln">10004</span><span class="cm"> * This routine is mostly called to set cfs_rq-&gt;curr field when a task
</span><span class="ln">10005</span><span class="cm"> * migrates between groups/classes.
</span><span class="ln">10006</span><span class="cm"> */</span>
<span class="ln">10007</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">set_curr_task_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="ln">10008</span><span class="p">{</span>
<span class="ln">10009</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln">10010</span>
<span class="ln">10011</span>	<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10012</span>		<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">10013</span>
<span class="ln">10014</span>		<span class="n">set_next_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">);</span>
<span class="ln">10015</span>		<span class="cm">/* ensure bandwidth has been allocated on our new cfs_rq */</span>
<span class="ln">10016</span>		<span class="n">account_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">10017</span>	<span class="p">}</span>
<span class="ln">10018</span><span class="p">}</span>
<span class="ln">10019</span>
<span class="ln">10020</span><span class="kt">void</span> <span class="nf">init_cfs_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">10021</span><span class="p">{</span>
<span class="ln">10022</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tasks_timeline</span> <span class="o">=</span> <span class="n">RB_ROOT_CACHED</span><span class="p">;</span>
<span class="ln">10023</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="o">-</span><span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">));</span>
<span class="ln">10024</span><span class="cp">#ifndef CONFIG_64BIT
</span><span class="ln">10025</span><span class="cp"></span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime_copy</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">min_vruntime</span><span class="p">;</span>
<span class="ln">10026</span><span class="cp">#endif
</span><span class="ln">10027</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">10028</span><span class="cp"></span>	<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">removed</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="ln">10029</span><span class="cp">#endif
</span><span class="ln">10030</span><span class="cp"></span><span class="p">}</span>
<span class="ln">10031</span>
<span class="ln">10032</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">10033</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_set_group_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">10034</span><span class="p">{</span>
<span class="ln">10035</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln">10036</span>
<span class="ln">10037</span>	<span class="n">set_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln">10038</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">?</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10039</span><span class="p">}</span>
<span class="ln">10040</span>
<span class="ln">10041</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_move_group_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="ln">10042</span><span class="p">{</span>
<span class="ln">10043</span>	<span class="n">detach_task_cfs_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">10044</span>	<span class="n">set_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="ln">10045</span>
<span class="ln">10046</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">10047</span><span class="cp"></span>	<span class="cm">/* Tell se&#39;s cfs_rq has been changed -- migrated */</span>
<span class="ln">10048</span>	<span class="n">p</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10049</span><span class="cp">#endif
</span><span class="ln">10050</span><span class="cp"></span>	<span class="n">attach_task_cfs_rq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">10051</span><span class="p">}</span>
<span class="ln">10052</span>
<span class="ln">10053</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_change_group_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="ln">10054</span><span class="p">{</span>
<span class="ln">10055</span>	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10056</span>	<span class="k">case</span> <span class="nl">TASK_SET_GROUP</span><span class="p">:</span>
<span class="ln">10057</span>		<span class="n">task_set_group_fair</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">10058</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">10059</span>
<span class="ln">10060</span>	<span class="k">case</span> <span class="nl">TASK_MOVE_GROUP</span><span class="p">:</span>
<span class="ln">10061</span>		<span class="n">task_move_group_fair</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="ln">10062</span>		<span class="k">break</span><span class="p">;</span>
<span class="ln">10063</span>	<span class="p">}</span>
<span class="ln">10064</span><span class="p">}</span>
<span class="ln">10065</span>
<span class="ln">10066</span><span class="kt">void</span> <span class="nf">free_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">10067</span><span class="p">{</span>
<span class="ln">10068</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">10069</span>
<span class="ln">10070</span>	<span class="n">destroy_cfs_bandwidth</span><span class="p">(</span><span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">));</span>
<span class="ln">10071</span>
<span class="ln">10072</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10073</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">10074</span>			<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="ln">10075</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span>
<span class="ln">10076</span>			<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="ln">10077</span>	<span class="p">}</span>
<span class="ln">10078</span>
<span class="ln">10079</span>	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">10080</span>	<span class="n">kfree</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">);</span>
<span class="ln">10081</span><span class="p">}</span>
<span class="ln">10082</span>
<span class="ln">10083</span><span class="kt">int</span> <span class="nf">alloc_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="ln">10084</span><span class="p">{</span>
<span class="ln">10085</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln">10086</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln">10087</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">10088</span>
<span class="ln">10089</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="ln">10090</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">10091</span>		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">10092</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="ln">10093</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">)</span>
<span class="ln">10094</span>		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">10095</span>
<span class="ln">10096</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">=</span> <span class="n">NICE_0_LOAD</span><span class="p">;</span>
<span class="ln">10097</span>
<span class="ln">10098</span>	<span class="n">init_cfs_bandwidth</span><span class="p">(</span><span class="n">tg_cfs_bandwidth</span><span class="p">(</span><span class="n">tg</span><span class="p">));</span>
<span class="ln">10099</span>
<span class="ln">10100</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10101</span>		<span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span><span class="p">),</span>
<span class="ln">10102</span>				      <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="ln">10103</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="ln">10104</span>			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="ln">10105</span>
<span class="ln">10106</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_entity</span><span class="p">),</span>
<span class="ln">10107</span>				  <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="ln">10108</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
<span class="ln">10109</span>			<span class="k">goto</span> <span class="n">err_free_rq</span><span class="p">;</span>
<span class="ln">10110</span>
<span class="ln">10111</span>		<span class="n">init_cfs_rq</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">10112</span>		<span class="n">init_tg_cfs_entry</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="ln">10113</span>		<span class="n">init_entity_runnable_average</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">10114</span>	<span class="p">}</span>
<span class="ln">10115</span>
<span class="ln">10116</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">10117</span>
<span class="ln">10118</span><span class="nl">err_free_rq</span><span class="p">:</span>
<span class="ln">10119</span>	<span class="n">kfree</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">10120</span><span class="nl">err</span><span class="p">:</span>
<span class="ln">10121</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10122</span><span class="p">}</span>
<span class="ln">10123</span>
<span class="ln">10124</span><span class="kt">void</span> <span class="nf">online_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">10125</span><span class="p">{</span>
<span class="ln">10126</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
<span class="ln">10127</span>	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">10128</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">10129</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">10130</span>
<span class="ln">10131</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10132</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln">10133</span>		<span class="n">se</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln">10134</span>		<span class="n">rq_lock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">10135</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">10136</span>		<span class="n">attach_entity_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">10137</span>		<span class="n">sync_throttle</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="ln">10138</span>		<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">10139</span>	<span class="p">}</span>
<span class="ln">10140</span><span class="p">}</span>
<span class="ln">10141</span>
<span class="ln">10142</span><span class="kt">void</span> <span class="nf">unregister_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span>
<span class="ln">10143</span><span class="p">{</span>
<span class="ln">10144</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="ln">10145</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
<span class="ln">10146</span>	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="ln">10147</span>
<span class="ln">10148</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10149</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
<span class="ln">10150</span>			<span class="n">remove_entity_load_avg</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
<span class="ln">10151</span>
<span class="ln">10152</span>		<span class="cm">/*
</span><span class="ln">10153</span><span class="cm">		 * Only empty task groups can be destroyed; so we can speculatively
</span><span class="ln">10154</span><span class="cm">		 * check on_list without danger of it being re-added.
</span><span class="ln">10155</span><span class="cm">		 */</span>
<span class="ln">10156</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">)</span>
<span class="ln">10157</span>			<span class="k">continue</span><span class="p">;</span>
<span class="ln">10158</span>
<span class="ln">10159</span>		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">10160</span>
<span class="ln">10161</span>		<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">10162</span>		<span class="n">list_del_leaf_cfs_rq</span><span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
<span class="ln">10163</span>		<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="ln">10164</span>	<span class="p">}</span>
<span class="ln">10165</span><span class="p">}</span>
<span class="ln">10166</span>
<span class="ln">10167</span><span class="kt">void</span> <span class="nf">init_tg_cfs_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span>
<span class="ln">10168</span>			<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
<span class="ln">10169</span>			<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="ln">10170</span><span class="p">{</span>
<span class="ln">10171</span>	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="ln">10172</span>
<span class="ln">10173</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="p">;</span>
<span class="ln">10174</span>	<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
<span class="ln">10175</span>	<span class="n">init_cfs_rq_runtime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">10176</span>
<span class="ln">10177</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">cfs_rq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln">10178</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
<span class="ln">10179</span>
<span class="ln">10180</span>	<span class="cm">/* se could be NULL for root_task_group */</span>
<span class="ln">10181</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="p">)</span>
<span class="ln">10182</span>		<span class="k">return</span><span class="p">;</span>
<span class="ln">10183</span>
<span class="ln">10184</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10185</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">;</span>
<span class="ln">10186</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10187</span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">10188</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">my_q</span><span class="p">;</span>
<span class="ln">10189</span>		<span class="n">se</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">10190</span>	<span class="p">}</span>
<span class="ln">10191</span>
<span class="ln">10192</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">my_q</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="p">;</span>
<span class="ln">10193</span>	<span class="cm">/* guarantee group entities always have weight */</span>
<span class="ln">10194</span>	<span class="n">update_load_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">,</span> <span class="n">NICE_0_LOAD</span><span class="p">);</span>
<span class="ln">10195</span>	<span class="n">se</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
<span class="ln">10196</span><span class="p">}</span>
<span class="ln">10197</span>
<span class="ln">10198</span><span class="k">static</span> <span class="nf">DEFINE_MUTEX</span><span class="p">(</span><span class="n">shares_mutex</span><span class="p">);</span>
<span class="ln">10199</span>
<span class="ln">10200</span><span class="kt">int</span> <span class="nf">sched_group_set_shares</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shares</span><span class="p">)</span>
<span class="ln">10201</span><span class="p">{</span>
<span class="ln">10202</span>	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="ln">10203</span>
<span class="ln">10204</span>	<span class="cm">/*
</span><span class="ln">10205</span><span class="cm">	 * We can&#39;t change the weight of the root cgroup.
</span><span class="ln">10206</span><span class="cm">	 */</span>
<span class="ln">10207</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="ln">10208</span>		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="ln">10209</span>
<span class="ln">10210</span>	<span class="n">shares</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">shares</span><span class="p">,</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">MIN_SHARES</span><span class="p">),</span> <span class="n">scale_load</span><span class="p">(</span><span class="n">MAX_SHARES</span><span class="p">));</span>
<span class="ln">10211</span>
<span class="ln">10212</span>	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shares_mutex</span><span class="p">);</span>
<span class="ln">10213</span>	<span class="k">if</span> <span class="p">(</span><span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">==</span> <span class="n">shares</span><span class="p">)</span>
<span class="ln">10214</span>		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="ln">10215</span>
<span class="ln">10216</span>	<span class="n">tg</span><span class="o">-&gt;</span><span class="n">shares</span> <span class="o">=</span> <span class="n">shares</span><span class="p">;</span>
<span class="ln">10217</span>	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10218</span>		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="ln">10219</span>		<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">tg</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln">10220</span>		<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
<span class="ln">10221</span>
<span class="ln">10222</span>		<span class="cm">/* Propagate contribution to hierarchy */</span>
<span class="ln">10223</span>		<span class="n">rq_lock_irqsave</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">10224</span>		<span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="ln">10225</span>		<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10226</span>			<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">,</span> <span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="ln">10227</span>			<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="ln">10228</span>		<span class="p">}</span>
<span class="ln">10229</span>		<span class="n">rq_unlock_irqrestore</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="ln">10230</span>	<span class="p">}</span>
<span class="ln">10231</span>
<span class="ln">10232</span><span class="nl">done</span><span class="p">:</span>
<span class="ln">10233</span>	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shares_mutex</span><span class="p">);</span>
<span class="ln">10234</span>	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10235</span><span class="p">}</span>
<span class="ln">10236</span><span class="cp">#else </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">10237</span><span class="cp"></span>
<span class="ln">10238</span><span class="kt">void</span> <span class="nf">free_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">10239</span>
<span class="ln">10240</span><span class="kt">int</span> <span class="nf">alloc_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="ln">10241</span><span class="p">{</span>
<span class="ln">10242</span>	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">10243</span><span class="p">}</span>
<span class="ln">10244</span>
<span class="ln">10245</span><span class="kt">void</span> <span class="nf">online_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">10246</span>
<span class="ln">10247</span><span class="kt">void</span> <span class="nf">unregister_fair_sched_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_group</span> <span class="o">*</span><span class="n">tg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="ln">10248</span>
<span class="ln">10249</span><span class="cp">#endif </span><span class="cm">/* CONFIG_FAIR_GROUP_SCHED */</span><span class="cp">
</span><span class="ln">10250</span><span class="cp"></span>
<span class="ln">10251</span>
<span class="ln">10252</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get_rr_interval_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="ln">10253</span><span class="p">{</span>
<span class="ln">10254</span>	<span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span>
<span class="ln">10255</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rr_interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10256</span>
<span class="ln">10257</span>	<span class="cm">/*
</span><span class="ln">10258</span><span class="cm">	 * Time slice is 0 for SCHED_OTHER tasks that are on an otherwise
</span><span class="ln">10259</span><span class="cm">	 * idle runqueue:
</span><span class="ln">10260</span><span class="cm">	 */</span>
<span class="ln">10261</span>	<span class="k">if</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
<span class="ln">10262</span>		<span class="n">rr_interval</span> <span class="o">=</span> <span class="n">NS_TO_JIFFIES</span><span class="p">(</span><span class="n">sched_slice</span><span class="p">(</span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">),</span> <span class="n">se</span><span class="p">));</span>
<span class="ln">10263</span>
<span class="ln">10264</span>	<span class="k">return</span> <span class="n">rr_interval</span><span class="p">;</span>
<span class="ln">10265</span><span class="p">}</span>
<span class="ln">10266</span>
<span class="ln">10267</span><span class="cm">/*
</span><span class="ln">10268</span><span class="cm"> * All the scheduling class methods:
</span><span class="ln">10269</span><span class="cm"> */</span>
<span class="ln">10270</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fair_sched_class</span> <span class="o">=</span> <span class="p">{</span>
<span class="ln">10271</span>	<span class="p">.</span><span class="n">next</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">,</span>
<span class="ln">10272</span>	<span class="p">.</span><span class="n">enqueue_task</span>		<span class="o">=</span> <span class="n">enqueue_task_fair</span><span class="p">,</span>
<span class="ln">10273</span>	<span class="p">.</span><span class="n">dequeue_task</span>		<span class="o">=</span> <span class="n">dequeue_task_fair</span><span class="p">,</span>
<span class="ln">10274</span>	<span class="p">.</span><span class="n">yield_task</span>		<span class="o">=</span> <span class="n">yield_task_fair</span><span class="p">,</span>
<span class="ln">10275</span>	<span class="p">.</span><span class="n">yield_to_task</span>		<span class="o">=</span> <span class="n">yield_to_task_fair</span><span class="p">,</span>
<span class="ln">10276</span>
<span class="ln">10277</span>	<span class="p">.</span><span class="n">check_preempt_curr</span>	<span class="o">=</span> <span class="n">check_preempt_wakeup</span><span class="p">,</span>
<span class="ln">10278</span>
<span class="ln">10279</span>	<span class="p">.</span><span class="n">pick_next_task</span>		<span class="o">=</span> <span class="n">pick_next_task_fair</span><span class="p">,</span>
<span class="ln">10280</span>	<span class="p">.</span><span class="n">put_prev_task</span>		<span class="o">=</span> <span class="n">put_prev_task_fair</span><span class="p">,</span>
<span class="ln">10281</span>
<span class="ln">10282</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">10283</span><span class="cp"></span>	<span class="p">.</span><span class="n">select_task_rq</span>		<span class="o">=</span> <span class="n">select_task_rq_fair</span><span class="p">,</span>
<span class="ln">10284</span>	<span class="p">.</span><span class="n">migrate_task_rq</span>	<span class="o">=</span> <span class="n">migrate_task_rq_fair</span><span class="p">,</span>
<span class="ln">10285</span>
<span class="ln">10286</span>	<span class="p">.</span><span class="n">rq_online</span>		<span class="o">=</span> <span class="n">rq_online_fair</span><span class="p">,</span>
<span class="ln">10287</span>	<span class="p">.</span><span class="n">rq_offline</span>		<span class="o">=</span> <span class="n">rq_offline_fair</span><span class="p">,</span>
<span class="ln">10288</span>
<span class="ln">10289</span>	<span class="p">.</span><span class="n">task_dead</span>		<span class="o">=</span> <span class="n">task_dead_fair</span><span class="p">,</span>
<span class="ln">10290</span>	<span class="p">.</span><span class="n">set_cpus_allowed</span>	<span class="o">=</span> <span class="n">set_cpus_allowed_common</span><span class="p">,</span>
<span class="ln">10291</span><span class="cp">#endif
</span><span class="ln">10292</span><span class="cp"></span>
<span class="ln">10293</span>	<span class="p">.</span><span class="n">set_curr_task</span>          <span class="o">=</span> <span class="n">set_curr_task_fair</span><span class="p">,</span>
<span class="ln">10294</span>	<span class="p">.</span><span class="n">task_tick</span>		<span class="o">=</span> <span class="n">task_tick_fair</span><span class="p">,</span>
<span class="ln">10295</span>	<span class="p">.</span><span class="n">task_fork</span>		<span class="o">=</span> <span class="n">task_fork_fair</span><span class="p">,</span>
<span class="ln">10296</span>
<span class="ln">10297</span>	<span class="p">.</span><span class="n">prio_changed</span>		<span class="o">=</span> <span class="n">prio_changed_fair</span><span class="p">,</span>
<span class="ln">10298</span>	<span class="p">.</span><span class="n">switched_from</span>		<span class="o">=</span> <span class="n">switched_from_fair</span><span class="p">,</span>
<span class="ln">10299</span>	<span class="p">.</span><span class="n">switched_to</span>		<span class="o">=</span> <span class="n">switched_to_fair</span><span class="p">,</span>
<span class="ln">10300</span>
<span class="ln">10301</span>	<span class="p">.</span><span class="n">get_rr_interval</span>	<span class="o">=</span> <span class="n">get_rr_interval_fair</span><span class="p">,</span>
<span class="ln">10302</span>
<span class="ln">10303</span>	<span class="p">.</span><span class="n">update_curr</span>		<span class="o">=</span> <span class="n">update_curr_fair</span><span class="p">,</span>
<span class="ln">10304</span>
<span class="ln">10305</span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="ln">10306</span><span class="cp"></span>	<span class="p">.</span><span class="n">task_change_group</span>	<span class="o">=</span> <span class="n">task_change_group_fair</span><span class="p">,</span>
<span class="ln">10307</span><span class="cp">#endif
</span><span class="ln">10308</span><span class="cp"></span><span class="p">};</span>
<span class="ln">10309</span>
<span class="ln">10310</span><span class="cp">#ifdef CONFIG_SCHED_DEBUG
</span><span class="ln">10311</span><span class="cp"></span><span class="kt">void</span> <span class="nf">print_cfs_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="ln">10312</span><span class="p">{</span>
<span class="ln">10313</span>	<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
<span class="ln">10314</span>
<span class="ln">10315</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">10316</span>	<span class="n">for_each_leaf_cfs_rq_safe</span><span class="p">(</span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">),</span> <span class="n">cfs_rq</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="ln">10317</span>		<span class="n">print_cfs_rq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">cfs_rq</span><span class="p">);</span>
<span class="ln">10318</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">10319</span><span class="p">}</span>
<span class="ln">10320</span>
<span class="ln">10321</span><span class="cp">#ifdef CONFIG_NUMA_BALANCING
</span><span class="ln">10322</span><span class="cp"></span><span class="kt">void</span> <span class="nf">show_numa_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="ln">10323</span><span class="p">{</span>
<span class="ln">10324</span>	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
<span class="ln">10325</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tsf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tpf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gsf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gpf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">10326</span>	<span class="k">struct</span> <span class="n">numa_group</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
<span class="ln">10327</span>
<span class="ln">10328</span>	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="ln">10329</span>	<span class="n">ng</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_group</span><span class="p">);</span>
<span class="ln">10330</span>	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10331</span>		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10332</span>			<span class="n">tsf</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
<span class="ln">10333</span>			<span class="n">tpf</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">numa_faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
<span class="ln">10334</span>		<span class="p">}</span>
<span class="ln">10335</span>		<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">10336</span>			<span class="n">gsf</span> <span class="o">=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="ln">10337</span>			<span class="n">gpf</span> <span class="o">=</span> <span class="n">ng</span><span class="o">-&gt;</span><span class="n">faults</span><span class="p">[</span><span class="n">task_faults_idx</span><span class="p">(</span><span class="n">NUMA_MEM</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
<span class="ln">10338</span>		<span class="p">}</span>
<span class="ln">10339</span>		<span class="n">print_numa_stats</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tsf</span><span class="p">,</span> <span class="n">tpf</span><span class="p">,</span> <span class="n">gsf</span><span class="p">,</span> <span class="n">gpf</span><span class="p">);</span>
<span class="ln">10340</span>	<span class="p">}</span>
<span class="ln">10341</span>	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="ln">10342</span><span class="p">}</span>
<span class="ln">10343</span><span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA_BALANCING */</span><span class="cp">
</span><span class="ln">10344</span><span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_DEBUG */</span><span class="cp">
</span><span class="ln">10345</span><span class="cp"></span>
<span class="ln">10346</span><span class="n">__init</span> <span class="kt">void</span> <span class="nf">init_sched_fair_class</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="ln">10347</span><span class="p">{</span>
<span class="ln">10348</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="ln">10349</span><span class="cp"></span>	<span class="n">open_softirq</span><span class="p">(</span><span class="n">SCHED_SOFTIRQ</span><span class="p">,</span> <span class="n">run_rebalance_domains</span><span class="p">);</span>
<span class="ln">10350</span>
<span class="ln">10351</span><span class="cp">#ifdef CONFIG_NO_HZ_COMMON
</span><span class="ln">10352</span><span class="cp"></span>	<span class="n">nohz</span><span class="p">.</span><span class="n">next_balance</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln">10353</span>	<span class="n">nohz</span><span class="p">.</span><span class="n">next_blocked</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="ln">10354</span>	<span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nohz</span><span class="p">.</span><span class="n">idle_cpus_mask</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
<span class="ln">10355</span><span class="cp">#endif
</span><span class="ln">10356</span><span class="cp">#endif </span><span class="cm">/* SMP */</span><span class="cp">
</span><span class="ln">10357</span><span class="cp"></span>
<span class="ln">10358</span><span class="p">}</span>
</code></pre></div></div><hr /><div class="post-navs d-flex mb-3 justify-content-evenly">
  <div class="post-nav post-prev"><i class="fas fa-fw fa-chevron-left"></i>
    <a href="https://mengdemao.github.io/posts/tkinter/">Tkinter
</a>
  </div><div class="post-nav post-next">
    <a href="https://mengdemao.github.io/posts/idle/">Idle
</a>
    <i class="fas fa-fw fa-chevron-right"></i>
  </div></div><section class="related-posts-wrapper">
    <h3>相关文章</h3>
    <ul class="related-posts"><li><a href="https://mengdemao.github.io/posts/sched/">系统调度
</a></li><li><a href="https://mengdemao.github.io/posts/drivermodel/">驱动模型
</a></li></ul>
  </section></div>
    </article></div>
</div><aside class="col-lg-4 sidebar d-flex">
  <div class="container">
    
    <section class="card row text-center profile component">
  <div class="card-body">
    <div class="col-12 d-flex align-items-center justify-content-center"><img class="profile-avatar rounded-circle" alt="MengDemao" src="https://mengdemao.github.io/images/profile.webp" loading="lazy"
   width="400" height="400"
   />
</div>
    <div class="col-12 profile-meta"><div class="profile-name">MengDemao</div><div class="profile-bio">面向玄学编程</div><div class="profile-company"><i class="fas fa-fw fa-building"></i>Company</div><div class="profile-location"><i class="fas fa-fw fa-map-marker-alt"></i>Earth</div><div class="profile-about"><i class="fas fa-fw fa-user"></i><a href="https://mengdemao.github.io/about/">About</a></div></div>
  </div>
</section>
  <section class="recent-posts row card component">
  <div class="card-body">
    <h2 class="card-title">最近文章</h2>
    <ul><li><a href="https://mengdemao.github.io/posts/bsdiff/">Bsdiff
</a></li><li><a href="https://mengdemao.github.io/posts/arm/">Arm
</a></li><li><a href="https://mengdemao.github.io/posts/idle/">Idle
</a></li><li><a href="https://mengdemao.github.io/posts/fair/">Fair
</a></li><li><a href="https://mengdemao.github.io/posts/tkinter/">Tkinter
</a></li></ul>
  </div>
</section><section class="taxonomies row card component">
      <div class="card-body">
        <h2 class="card-title">
          <a href="https://mengdemao.github.io/categories">分类</a>
        </h2>
        <div><a href="https://mengdemao.github.io/categories/linux/" class="badge bg-primary text-white rounded post-taxonomy" title="linux">
            linux
          </a><a href="https://mengdemao.github.io/categories/python/" class="badge bg-primary text-white rounded post-taxonomy" title="python">
            python
          </a></div>
      </div>
    </section><section class="taxonomies row card component">
      <div class="card-body">
        <h2 class="card-title">
          <a href="https://mengdemao.github.io/tags">标签</a>
        </h2>
        <div><a href="https://mengdemao.github.io/tags/kernel/" class="badge bg-primary text-white rounded post-taxonomy" title="kernel">
            kernel
          </a><a href="https://mengdemao.github.io/tags/compiler/" class="badge bg-primary text-white rounded post-taxonomy" title="compiler">
            compiler
          </a><a href="https://mengdemao.github.io/tags/nfs/" class="badge bg-primary text-white rounded post-taxonomy" title="nfs">
            nfs
          </a><a href="https://mengdemao.github.io/tags/%E6%8A%80%E5%B7%A7/" class="badge bg-primary text-white rounded post-taxonomy" title="技巧">
            技巧
          </a><a href="https://mengdemao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="badge bg-primary text-white rounded post-taxonomy" title="编译原理">
            编译原理
          </a></div>
      </div>
    </section>
    
  </div>
</aside>
</div>
    </main><footer class="footer mt-auto py-3 text-center container"><nav class="social-links nav my-2 justify-content-center"></nav>
<div class="copyright mb-2">
  Copyright © 2020-2021 Meng Demao. All Rights Reserved.
</div>
<div class="powered-by mb-2">
  Powered by <a href="https://gohugo.io" target="_blank" rel="noopener noreferrer">Hugo</a> and the <a href="https://github.com/razonyang/hugo-theme-bootstrap" target="_blank" rel="noopener noreferrer">Bootstrap</a> theme.
</div></footer>
<script src="https://mengdemao.github.io/js/bundle.min.c239d20348986c1e4276d9e85953f4e281ec3b6ed6dafe05a5e64002622759e5.js" integrity="sha256-wjnSA0iYbB5CdtnoWVP04oHsO27W2v4FpeZAAmInWeU=" crossorigin="anonymous" defer></script><script defer src="https://mengdemao.github.io/js/viewer.min.9f39f897757e616b3f6faf1d7955ea42a180a4e71d898e80f1c13d45e59b9abb.js" integrity="sha256-nzn4l3V&#43;YWs/b68deVXqQqGApOcdiY6A8cE9ReWbmrs=" crossorigin="anonymous"></script>
</body>
</html>

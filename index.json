[{"categories":[],"content":"TinyCC  TinyCC (aka TCC) is a small but hyper fast C compiler. Unlike other C compilers, it is meant to be self-relying: you do not need an external assembler or linker because TCC does that for you.\n TCC 执行概览 TCC组成代码\n   文件名 解释     tcc.c/libtcc.c tcc运行代码   tccpp.c    tccelf.c tcccoff.c    tccasm.c    tccrun.c    tccgen.c    x86_64-gen.c x86_64-link.c i386-asm.c 不同架构的生成器    TCC状态信息 1struct TCCState { 2 unsigned char verbose; /* if true, display some information during compilation */ 3 unsigned char nostdinc; /* if true, no standard headers are added */ 4 unsigned char nostdlib; /* if true, no standard libraries are added */ 5 unsigned char nocommon; /* if true, do not use common symbols for .bss data */ 6 unsigned char static_link; /* if true, static linking is performed */ 7 unsigned char rdynamic; /* if true, all symbols are exported */ 8 unsigned char symbolic; /* if true, resolve symbols in the current module first */ 9 unsigned char filetype; /* file type for compilation (NONE,C,ASM) */ 10 unsigned char optimize; /* only to #define __OPTIMIZE__ */ 11 unsigned char option_pthread; /* -pthread option */ 12 unsigned char enable_new_dtags; /* -Wl,--enable-new-dtags */ 13 unsigned int cversion; /* supported C ISO version, 199901 (the default), 201112, ... */ 14 15 /* C language options */ 16 unsigned char char_is_unsigned; 17 unsigned char leading_underscore; 18 unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */ 19 unsigned char dollars_in_identifiers; /* allows \u0026#39;$\u0026#39; char in identifiers */ 20 unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */ 21 22 /* warning switches */ 23 unsigned char warn_none; 24 unsigned char warn_all; 25 unsigned char warn_error; 26 unsigned char warn_write_strings; 27 unsigned char warn_unsupported; 28 unsigned char warn_implicit_function_declaration; 29 unsigned char warn_discarded_qualifiers; 30 #define WARN_ON 1 /* warning is on (-Woption) */31 unsigned char warn_num; /* temp var for tcc_warning_c() */ 32 33 unsigned char option_r; /* option -r */ 34 unsigned char do_bench; /* option -bench */ 35 unsigned char just_deps; /* option -M */ 36 unsigned char gen_deps; /* option -MD */ 37 unsigned char include_sys_deps; /* option -MD */ 38 39 /* compile with debug symbol (and use them if error during execution) */ 40 unsigned char do_debug; 41 unsigned char do_backtrace; 42#ifdef CONFIG_TCC_BCHECK 43 /* compile with built-in memory and bounds checker */ 44 unsigned char do_bounds_check; 45#endif 46 unsigned char test_coverage; /* generate test coverage code */ 47 48 /* use GNU C extensions */ 49 unsigned char gnu_ext; 50 /* use TinyCC extensions */ 51 unsigned char tcc_ext; 52 53 unsigned char dflag; /* -dX value */ 54 unsigned char Pflag; /* -P switch (LINE_MACRO_OUTPUT_FORMAT) */ 55 56#ifdef TCC_TARGET_X86_64 57 unsigned char nosse; /* For -mno-sse support. */ 58#endif 59#ifdef TCC_TARGET_ARM 60 unsigned char float_abi; /* float ABI of the generated code*/ 61#endif 62 63 unsigned char has_text_addr; 64 addr_t text_addr; /* address of text section */ 65 unsigned section_align; /* section alignment */ 66#ifdef TCC_TARGET_I386 67 int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */ 68#endif 69 70 char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */ 71 char *soname; /* as specified on the command line (-soname) */ 72 char *rpath; /* as specified on the command line (-Wl,-rpath=) */ 73 74 char *init_symbol; /* symbols to call at load-time (not used currently) */ 75 char *fini_symbol; /* symbols to call at unload-time (not used currently) */ 76 77 /* output type, see TCC_OUTPUT_XXX */ 78 int output_type; 79 /* output format, see TCC_OUTPUT_FORMAT_xxx */ 80 int output_format; 81 /* nth test to run with -dt -run */ 82 int run_test; 83 84 /* array of all loaded dlls (including those referenced by loaded dlls) */ 85 DLLReference **loaded_dlls; 86 int nb_loaded_dlls; 87 88 /* include paths */ 89 char **include_paths; 90 int nb_include_paths; 91 92 char **sysinclude_paths; 93 int nb_sysinclude_paths; 94 95 /* library paths */ 96 char **library_paths; 97 int nb_library_paths; 98 99 /* crt?.o object path */ 100 char **crt_paths; 101 int nb_crt_paths; 102 103 /* -D / -U options */ 104 CString cmdline_defs; 105 /* -include options */ 106 CString cmdline_incl; 107 108 /* error handling */ 109 void *error_opaque; 110 void (*error_func)(void *opaque, const char *msg); 111 int error_set_jmp_enabled; 112 jmp_buf error_jmp_buf; 113 int nb_errors; 114 115 /* output file for preprocessing (-E) */ 116 FILE *ppfp; 117 118 /* for -MD/-MF: collected dependencies for this compilation */ 119 char **target_deps; 120 int nb_target_deps; 121 122 /* compilation */ 123 BufferedFile *include_stack[INCLUDE_STACK_SIZE]; 124 BufferedFile **include_stack_ptr; 125 126 int ifdef_stack[IFDEF_STACK_SIZE]; 127 int *ifdef_stack_ptr; 128 129 /* included files enclosed with #ifndef MACRO */ 130 int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE]; 131 CachedInclude **cached_includes; 132 int nb_cached_includes; 133 134 /* #pragma pack stack */ 135 int pack_stack[PACK_STACK_SIZE]; 136 int *pack_stack_ptr; 137 char **pragma_libs; 138 int nb_pragma_libs; 139 140 /* inline functions are stored as token lists and compiled last 141only if referenced */ 142 struct InlineFunc **inline_fns; 143 int nb_inline_fns; 144 145 /* sections */ 146 Section **sections; 147 int nb_sections; /* number of sections, including first dummy section */ 148 149 Section **priv_sections; 150 int nb_priv_sections; /* number of private sections */ 151 152 /* got \u0026amp; plt handling */ 153 Section *got; 154 Section *plt; 155 156 /* predefined sections */ 157 Section *text_section, *data_section, *rodata_section, *bss_section; 158 Section *common_section; 159 Section *cur_text_section; /* current section where function code is generated */ 160#ifdef CONFIG_TCC_BCHECK 161 /* bound check related sections */ 162 Section *bounds_section; /* contains global data bound description */ 163 Section *lbounds_section; /* contains local data bound description */ 164#endif 165 /* test coverage */ 166 Section *tcov_section; 167 /* symbol sections */ 168 Section *symtab_section; 169 /* debug sections */ 170 Section *stab_section; 171 /* Is there a new undefined sym since last new_undef_sym() */ 172 int new_undef_sym; 173 174 /* temporary dynamic symbol sections (for dll loading) */ 175 Section *dynsymtab_section; 176 /* exported dynamic symbol section */ 177 Section *dynsym; 178 /* copy of the global symtab_section variable */ 179 Section *symtab; 180 /* extra attributes (eg. GOT/PLT value) for symtab symbols */ 181 struct sym_attr *sym_attrs; 182 int nb_sym_attrs; 183 /* ptr to next reloc entry reused */ 184 ElfW_Rel *qrel; 185 #define qrel s1-\u0026gt;qrel 186 187#ifdef TCC_TARGET_RISCV64 188 struct pcrel_hi { addr_t addr, val; } last_hi; 189 #define last_hi s1-\u0026gt;last_hi 190#endif 191 192#ifdef TCC_TARGET_PE 193 /* PE info */ 194 int pe_subsystem; 195 unsigned pe_characteristics; 196 unsigned pe_file_align; 197 unsigned pe_stack_size; 198 addr_t pe_imagebase; 199# ifdef TCC_TARGET_X86_64 200 Section *uw_pdata; 201 int uw_sym; 202 unsigned uw_offs; 203# endif 204#endif 205 206#ifndef ELF_OBJ_ONLY 207 int nb_sym_versions; 208 struct sym_version *sym_versions; 209 int nb_sym_to_version; 210 int *sym_to_version; 211 int dt_verneednum; 212 Section *versym_section; 213 Section *verneed_section; 214#endif 215 216#ifdef TCC_IS_NATIVE 217 const char *runtime_main; 218 void **runtime_mem; 219 int nb_runtime_mem; 220#endif 221 222#ifdef CONFIG_TCC_BACKTRACE 223 int rt_num_callers; 224#endif 225 226 /* benchmark info */ 227 int total_idents; 228 int total_lines; 229 int total_bytes; 230 int total_output[4]; 231 232 /* option -dnum (for general development purposes) */ 233 int g_debug; 234 235 /* used by tcc_load_ldscript */ 236 int fd, cc; 237 238 /* for warnings/errors for object files */ 239 const char *current_filename; 240 241 /* used by main and tcc_parse_args only */ 242 struct filespec **files; /* files seen on command line */ 243 int nb_files; /* number thereof */ 244 int nb_libraries; /* number of libs thereof */ 245 char *outfile; /* output filename */ 246 char *deps_outfile; /* option -MF */ 247 int argc; 248 char **argv; 249}; 1LIBTCCAPI TCCState *tcc_new(void) 2{ 3 TCCState *s; 4 5 s = tcc_mallocz(sizeof(TCCState)); 6 if (!s) 7 return NULL; 8#ifdef MEM_DEBUG 9 ++nb_states; 10#endif 11 12#undef gnu_ext 13 14 s-\u0026gt;gnu_ext = 1; 15 s-\u0026gt;tcc_ext = 1; 16 s-\u0026gt;nocommon = 1; 17 s-\u0026gt;dollars_in_identifiers = 1; /*on by default like in gcc/clang*/ 18 s-\u0026gt;cversion = 199901; /* default unless -std=c11 is supplied */ 19 s-\u0026gt;warn_implicit_function_declaration = 1; 20 s-\u0026gt;warn_discarded_qualifiers = 1; 21 s-\u0026gt;ms_extensions = 1; 22 23#ifdef CHAR_IS_UNSIGNED 24 s-\u0026gt;char_is_unsigned = 1; 25#endif 26#ifdef TCC_TARGET_I386 27 s-\u0026gt;seg_size = 32; 28#endif 29 /* enable this if you want symbols with leading underscore on windows: */ 30#if defined TCC_TARGET_MACHO /* || defined TCC_TARGET_PE */31 s-\u0026gt;leading_underscore = 1; 32#endif 33#ifdef TCC_TARGET_ARM 34 s-\u0026gt;float_abi = ARM_FLOAT_ABI; 35#endif 36 37 s-\u0026gt;ppfp = stdout; 38 /* might be used in error() before preprocess_start() */ 39 s-\u0026gt;include_stack_ptr = s-\u0026gt;include_stack; 40 41 tccelf_new(s); 42 43 tcc_set_lib_path(s, CONFIG_TCCDIR); 44 return s; 45} 46 47LIBTCCAPI void tcc_delete(TCCState *s1) 48{ 49 /* free sections */ 50 tccelf_delete(s1); 51 52 /* free library paths */ 53 dynarray_reset(\u0026amp;s1-\u0026gt;library_paths, \u0026amp;s1-\u0026gt;nb_library_paths); 54 dynarray_reset(\u0026amp;s1-\u0026gt;crt_paths, \u0026amp;s1-\u0026gt;nb_crt_paths); 55 56 /* free include paths */ 57 dynarray_reset(\u0026amp;s1-\u0026gt;include_paths, \u0026amp;s1-\u0026gt;nb_include_paths); 58 dynarray_reset(\u0026amp;s1-\u0026gt;sysinclude_paths, \u0026amp;s1-\u0026gt;nb_sysinclude_paths); 59 60 tcc_free(s1-\u0026gt;tcc_lib_path); 61 tcc_free(s1-\u0026gt;soname); 62 tcc_free(s1-\u0026gt;rpath); 63 tcc_free(s1-\u0026gt;init_symbol); 64 tcc_free(s1-\u0026gt;fini_symbol); 65 tcc_free(s1-\u0026gt;outfile); 66 tcc_free(s1-\u0026gt;deps_outfile); 67 dynarray_reset(\u0026amp;s1-\u0026gt;files, \u0026amp;s1-\u0026gt;nb_files); 68 dynarray_reset(\u0026amp;s1-\u0026gt;target_deps, \u0026amp;s1-\u0026gt;nb_target_deps); 69 dynarray_reset(\u0026amp;s1-\u0026gt;pragma_libs, \u0026amp;s1-\u0026gt;nb_pragma_libs); 70 dynarray_reset(\u0026amp;s1-\u0026gt;argv, \u0026amp;s1-\u0026gt;argc); 71 cstr_free(\u0026amp;s1-\u0026gt;cmdline_defs); 72 cstr_free(\u0026amp;s1-\u0026gt;cmdline_incl); 73#ifdef TCC_IS_NATIVE 74 /* free runtime memory */ 75 tcc_run_free(s1); 76#endif 77 78 tcc_free(s1); 79#ifdef MEM_DEBUG 80 if (0 == --nb_states) 81 tcc_memcheck(); 82#endif 83} 文件读取 文件描述信息 1typedef struct BufferedFile { 2 uint8_t *buf_ptr; 3 uint8_t *buf_end; 4 int fd; 5 struct BufferedFile *prev; 6 int line_num; /* current line number - here to simplify code */ 7 int line_ref; /* tcc -E: last printed line */ 8 int ifndef_macro; /* #ifndef macro / #endif search */ 9 int ifndef_macro_saved; /* saved ifndef_macro */ 10 int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */ 11 int include_next_index; /* next search path */ 12 char filename[1024]; /* filename */ 13 char *true_filename; /* filename not modified by # line directive */ 14 unsigned char unget[4]; 15 unsigned char buffer[1]; /* extra size for CH_EOB char */ 16} BufferedFile; 文件相关操作 1static int _tcc_open(TCCState *s1, const char *filename) 2{ 3 int fd; 4 if (strcmp(filename, \u0026#34;-\u0026#34;) == 0) 5 fd = 0, filename = \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;; 6 else 7 fd = open(filename, O_RDONLY | O_BINARY); 8 if ((s1-\u0026gt;verbose == 2 \u0026amp;\u0026amp; fd \u0026gt;= 0) || s1-\u0026gt;verbose == 3) 9 printf(\u0026#34;%s %*s%s\\n\u0026#34;, fd \u0026lt; 0 ? \u0026#34;nf\u0026#34;:\u0026#34;-\u0026gt;\u0026#34;, 10 (int)(s1-\u0026gt;include_stack_ptr - s1-\u0026gt;include_stack), \u0026#34;\u0026#34;, filename); 11 return fd; 12} 13 14ST_FUNC int tcc_open(TCCState *s1, const char *filename) 15{ 16 int fd = _tcc_open(s1, filename); 17 if (fd \u0026lt; 0) 18 return -1; 19 tcc_open_bf(s1, filename, 0); 20 file-\u0026gt;fd = fd; 21 return 0; 22} 23 24ST_FUNC void tcc_close(void) 25{ 26 TCCState *s1 = tcc_state; 27 BufferedFile *bf = file; 28 if (bf-\u0026gt;fd \u0026gt; 0) { 29 close(bf-\u0026gt;fd); 30 total_lines += bf-\u0026gt;line_num; 31 } 32 if (bf-\u0026gt;true_filename != bf-\u0026gt;filename) 33 tcc_free(bf-\u0026gt;true_filename); 34 file = bf-\u0026gt;prev; 35 tcc_free(bf); 36} 词法分析 语法分析 类型检查 符号表 段机制 代码生成 ","date":"Nov 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/tinycc/","series":null,"tags":[],"title":"Tinycc"},{"categories":[],"content":"个人服务器安装记录 配置交换文件 1# 创建交换文件 2sudo fallocate -l 2G /swapfile 3 4# 修改权限只允许ROOT使用 5sudo chmod 600 /swapfile 6 7# 创建swapfile 8sudo mkswap /swapfile 9 10# 开启swapfile 11sudo swapon /swapfile 12 13# 写入fstab 14echo \u0026#39;/swapfile none swap sw 0 0\u0026#39; | sudo tee -a /etc/fstab jenkins安装 安装jdk 1sudo apt install default-jdk 安装jenkins 1wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - 2sudo sh -c \u0026#39;echo deb https://pkg.jenkins.io/debian-stable binary/ \u0026gt; /etc/apt/sources.list.d/jenkins.list\u0026#39; 3sudo apt-get update 4sudo apt-get install jenkins docker安装 安装依赖 1sudo apt install \\ 2 apt-transport-https \\ 3 ca-certificates \\ 4 curl \\ 5 gnupg-agent \\ 6 software-properties-common 安装公钥 1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 设置仓库 1sudo add-apt-repository \\ 2 \u0026#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\ 3$(lsb_release -cs)\\ 4stable\u0026#34; 安装Docker 1sudo apt update 2sudo apt install docker-ce docker-ce-cli containerd.io 添加root组 1sudo usermod -aG docker `whoami` docker辅助工具  docker-compose lazydocker  嵌入式开发工具链 arm编译工具链 1sudo apt install gcc-arm-linux-gnueabihf 2sudo apt install gcc-arm-linux-gnueabi 3sudo apt install gcc-arm-none-eabi 测试工具 1sudo apt install qemu 2sudo apt install qemu-system-arm 3sudo apt install qemu-user-static 4sudo apt install qemu-user 5sudo apt install qemu-user-binfmt 打包工具 1sudo apt install u-boot-tools ","date":"Nov 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/server/","series":null,"tags":[],"title":"Server"},{"categories":[],"content":"bsdiff  bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u0026gt; sorting (specifically, Larsson and Sadakane\u0026rsquo;s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) \u0026ndash; 直接摘抄自官网\n 详情可以查看bsdiff官网 ,存在这个详细描述.\n测试 新建立两个文件old.c与new.c,二者的差别是\n1// new.c 2#include \u0026lt;stdio.h\u0026gt;3int main(void) 4{ 5\tprintf(\u0026#34;Hello World\\r\\n\u0026#34;); 6\treturn 0; 7} 1#include \u0026lt;stdio.h\u0026gt;2int main(void) 3{ 4\treturn 0; 5} 测试的情况\n1# 执行编译 2gcc old.c -o old \u0026amp;\u0026amp; ./old 3gcc new.c -o new \u0026amp;\u0026amp; ./new 计算md5\n1md5sum old 2# d08fd167e74f279522fe8aa64d8e27dd old 3 4md5sum new 5# b0b4be993de61064a118d32a692bf795 new 6 7md5sum mid 8# b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试\n1# 生成diff 2bsdiff old new test.diff 3 4# 打入补丁--\u0026gt;mid 5bspatch old mid test.diff 分析 接口分析 1struct bsdiff_stream 2{ 3\tvoid* opaque;\t/* bzip文件 */ 4 5\tvoid* (*malloc)(size_t size);\t/* 内存申请接口 */ 6\tvoid (*free)(void* ptr);\t/* 内存释放接口 */ 7\tint (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ 8 const void* buffer, int size); 9}; 10 11struct bspatch_stream 12{ 13\tvoid* opaque;\t/* bzip文件 */ 14\tint (*read)(const struct bspatch_stream* stream, /* 读取文件接口 */ 15 void* buffer, int length); 16}; 17 18int bsdiff(const uint8_t* old, int64_t oldsize, 19 const uint8_t* new, int64_t newsize, 20 struct bsdiff_stream* stream); 21 22int bspatch(const uint8_t* old, int64_t oldsize, 23 uint8_t* new, int64_t newsize, 24 struct bspatch_stream* stream); 25 diff算法核心 bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block\n Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件  每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容   diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件  Header的结构:    start/bytes length/bytes content     0 8 \u0026ldquo;BSDIFF40\u0026rdquo;   8 8 the length of ctrl block   16 8 the length of diff block   24 8 新文件的大小     BSDIFF40 0x93 \u0026ndash;\u0026gt; 147 0x313 \u0026ndash;\u0026gt; 787 0x3ED0 \u0026ndash;\u0026gt; 16080 可以匹配新生成的文件  代码分析 偏移信息与字符串信息相互转化 1/* 一般情况下,buf的长度为8个字节 */ 2static int64_t offtin(uint8_t *buf) 3{ 4\tint64_t y; 5 6\ty=buf[7]\u0026amp;0x7F; /* 提取绝对值 */ 7 8\ty=y*256;y+=buf[6]; 9\ty=y*256;y+=buf[5]; 10\ty=y*256;y+=buf[4]; 11\ty=y*256;y+=buf[3]; 12\ty=y*256;y+=buf[2]; 13\ty=y*256;y+=buf[1]; 14\ty=y*256;y+=buf[0]; 15 16 /* 根据最高位置确定正负 */ 17\tif (buf[7] \u0026amp; 0x80) { 18 y=-y; 19 } 20 21\treturn y; 22} 23static void offtout(int64_t x,uint8_t *buf) 24{ 25\tint64_t y; 26 27 /* 保证 y = |x| */ 28\tif (x \u0026lt; 0) { 29 y = -x; 30 } 31 else { 32 y = x; 33 } 34 35\tbuf[0]=y%256;y-=buf[0]; 36\ty=y/256;buf[1]=y%256;y-=buf[1]; 37\ty=y/256;buf[2]=y%256;y-=buf[2]; 38\ty=y/256;buf[3]=y%256;y-=buf[3]; 39\ty=y/256;buf[4]=y%256;y-=buf[4]; 40\ty=y/256;buf[5]=y%256;y-=buf[5]; 41\ty=y/256;buf[6]=y%256;y-=buf[6]; 42\ty=y/256;buf[7]=y%256; 43 44\tif(x\u0026lt;0) buf[7]|=0x80; 45} patch代码分析 总体的执行路径 1int bspatch(const uint8_t* old, int64_t oldsize, 2 uint8_t* new, int64_t newsize, 3 struct bspatch_stream* stream) 4{ 5\tuint8_t buf[8]; 6\tint64_t oldpos; 7 int64_t newpos; 8\tint64_t ctrl[3]; 9\tint64_t i; 10 11\toldpos=0; 12 newpos=0; 13\twhile (newpos \u0026lt; newsize) { 14\t/* Read control data 3*8个为一组,每次生成3个控制数据 */ 15\tfor(i=0;i\u0026lt;=2;i++) { 16\tif (stream-\u0026gt;read(stream, buf, 8)) 17\treturn -1; 18\tctrl[i]=offtin(buf); 19\t}; 20 21\t/* 健壮性检查 */ 22\tif (ctrl[0]\u0026lt;0 || ctrl[0]\u0026gt;INT_MAX || 23\tctrl[1]\u0026lt;0 || ctrl[1]\u0026gt;INT_MAX || 24\tnewpos+ctrl[0]\u0026gt;newsize) 25\treturn -1; 26 27\t/* Read diff string */ 28\tif (stream-\u0026gt;read(stream, new + newpos, ctrl[0])) 29\treturn -1; 30 31\t/* Add old data to diff string */ 32\tfor(i=0;i\u0026lt;ctrl[0];i++) 33\tif((oldpos+i\u0026gt;=0) \u0026amp;\u0026amp; (oldpos+i\u0026lt;oldsize)) 34\tnew[newpos+i]+=old[oldpos+i]; 35 36\t/* Adjust pointers */ 37\tnewpos+=ctrl[0]; 38\toldpos+=ctrl[0]; 39 40\t/* Sanity-check */ 41\tif(newpos+ctrl[1]\u0026gt;newsize) 42\treturn -1; 43 44\t/* Read extra string */ 45\tif (stream-\u0026gt;read(stream, new + newpos, ctrl[1])) 46\treturn -1; 47 48\t/* Adjust pointers */ 49\tnewpos+=ctrl[1]; 50\toldpos+=ctrl[2]; 51\t}; 52 53\treturn 0; 54} 主要函数的调用路线\nqsufsort  调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解\n 参数分析:\n I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小  1static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) 2{ 3\tint64_t buckets[256]; 4\tint64_t i,h,len; 5 6\tfor(i=0;i\u0026lt;256;i++) buckets[i]=0; 7\tfor(i=0;i\u0026lt;oldsize;i++) buckets[old[i]]++; 8\tfor(i=1;i\u0026lt;256;i++) buckets[i]+=buckets[i-1]; 9\tfor(i=255;i\u0026gt;0;i--) buckets[i]=buckets[i-1]; 10\tbuckets[0]=0; 11 12\tfor(i=0;i\u0026lt;oldsize;i++) I[++buckets[old[i]]]=i; 13\tI[0]=oldsize; 14\tfor(i=0;i\u0026lt;oldsize;i++) V[i]=buckets[old[i]]; 15\tV[oldsize]=0; 16\tfor(i=1;i\u0026lt;256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; 17\tI[0]=-1; 18 19\tfor(h=1;I[0]!=-(oldsize+1);h+=h) { 20\tlen=0; 21\tfor(i=0;i\u0026lt;oldsize+1;) { 22\tif(I[i]\u0026lt;0) { 23\tlen-=I[i]; 24\ti-=I[i]; 25\t} else { 26\tif(len) I[i-len]=-len; 27\tlen=V[I[i]]+1-i; 28\tsplit(I,V,i,len,h); 29\ti+=len; 30\tlen=0; 31\t}; 32\t}; 33\tif(len) I[i-len]=-len; 34\t}; 35 36\tfor(i=0;i\u0026lt;oldsize+1;i++) I[V[i]]=i; 37} 38 39static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) 40{ 41\tint64_t i,j,k,x,tmp,jj,kk; 42 43\tif(len\u0026lt;16) { 44\tfor(k=start;k\u0026lt;start+len;k+=j) { 45\tj=1;x=V[I[k]+h]; 46\tfor(i=1;k+i\u0026lt;start+len;i++) { 47\tif(V[I[k+i]+h]\u0026lt;x) { 48\tx=V[I[k+i]+h]; 49\tj=0; 50\t}; 51\tif(V[I[k+i]+h]==x) { 52\ttmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; 53\tj++; 54\t}; 55\t}; 56\tfor(i=0;i\u0026lt;j;i++) V[I[k+i]]=k+j-1; 57\tif(j==1) I[k]=-1; 58\t}; 59\treturn; 60\t}; 61 62\tx=V[I[start+len/2]+h]; 63\tjj=0;kk=0; 64\tfor(i=start;i\u0026lt;start+len;i++) { 65\tif(V[I[i]+h]\u0026lt;x) jj++; 66\tif(V[I[i]+h]==x) kk++; 67\t}; 68\tjj+=start;kk+=jj; 69 70\ti=start;j=0;k=0; 71\twhile(i\u0026lt;jj) { 72\tif(V[I[i]+h]\u0026lt;x) { 73\ti++; 74\t} else if(V[I[i]+h]==x) { 75\ttmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; 76\tj++; 77\t} else { 78\ttmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; 79\tk++; 80\t}; 81\t}; 82 83\twhile(jj+j\u0026lt;kk) { 84\tif(V[I[jj+j]+h]==x) { 85\tj++; 86\t} else { 87\ttmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; 88\tk++; 89\t}; 90\t}; 91 92\tif(jj\u0026gt;start) split(I,V,start,jj-start,h); 93 94\tfor(i=0;i\u0026lt;kk-jj;i++) V[I[jj+i]]=kk-1; 95\tif(jj==kk-1) I[jj]=-1; 96 97\tif(start+len\u0026gt;kk) split(I,V,kk,start+len-kk,h); 98} search 1static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) 2{ 3\tint64_t i; 4 5\tfor(i=0;(i\u0026lt;oldsize)\u0026amp;\u0026amp;(i\u0026lt;newsize);i++) 6\tif(old[i]!=new[i]) break; 7 8\treturn i; 9} 10static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, 11\tconst uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) 12{ 13\tint64_t x,y; 14 15\tif(en-st\u0026lt;2) { 16\tx=matchlen(old+I[st],oldsize-I[st],new,newsize); 17\ty=matchlen(old+I[en],oldsize-I[en],new,newsize); 18 19\tif(x\u0026gt;y) { 20\t*pos=I[st]; 21\treturn x; 22\t} else { 23\t*pos=I[en]; 24\treturn y; 25\t} 26\t}; 27 28\tx=st+(en-st)/2; 29\tif(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u0026lt;0) { 30\treturn search(I,old,oldsize,new,newsize,x,en,pos); 31\t} else { 32\treturn search(I,old,oldsize,new,newsize,st,x,pos); 33\t}; 34} writedata 1static int64_t writedata(struct bsdiff_stream* stream, 2\tconst void* buffer, int64_t length) 3{ 4\tint64_t result = 0; 5 6\twhile (length \u0026gt; 0) 7\t{ 8\tconst int smallsize = (int)MIN(length, INT_MAX); 9\tconst int writeresult = stream-\u0026gt;write(stream, buffer, smallsize); 10\tif (writeresult == -1) 11\t{ 12\treturn -1; 13\t} 14 15\tresult += writeresult; 16\tlength -= smallsize; 17\tbuffer = (uint8_t*)buffer + smallsize; 18\t} 19 20\treturn result; 21} diff文件生成核心代码 1struct bsdiff_request 2{ 3\tconst uint8_t* old; 4\tint64_t oldsize; 5\tconst uint8_t* new; 6\tint64_t newsize; 7\tstruct bsdiff_stream* stream; 8\tint64_t *I; 9\tuint8_t *buffer; 10}; 11 12static int bsdiff_internal(const struct bsdiff_request req) 13{ 14\tint64_t *I,*V; 15\tint64_t scan,pos,len; 16\tint64_t lastscan,lastpos,lastoffset; 17\tint64_t oldscore,scsc; 18\tint64_t s,Sf,lenf,Sb,lenb; 19\tint64_t overlap,Ss,lens; 20\tint64_t i; 21\tuint8_t *buffer; 22\tuint8_t buf[8 * 3]; 23 24\tif((V=req.stream-\u0026gt;malloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; 25\tI = req.I; 26 27\tqsufsort(I,V,req.old,req.oldsize); 28 29\treq.stream-\u0026gt;free(V); 30 31\tbuffer = req.buffer; 32 33\t/* Compute the differences, writing ctrl as we go */ 34\tscan=0;len=0;pos=0; 35\tlastscan=0;lastpos=0;lastoffset=0; 36\twhile(scan\u0026lt;req.newsize) { 37\toldscore=0; 38 39\tfor(scsc=scan+=len;scan\u0026lt;req.newsize;scan++) { 40\tlen=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 41\t0,req.oldsize,\u0026amp;pos); 42 43\tfor(;scsc\u0026lt;scan+len;scsc++) 44\tif((scsc+lastoffset\u0026lt;req.oldsize) \u0026amp;\u0026amp; 45\t(req.old[scsc+lastoffset] == req.new[scsc])) 46\toldscore++; 47 48\tif(((len==oldscore) \u0026amp;\u0026amp; (len!=0)) || 49\t(len\u0026gt;oldscore+8)) break; 50 51\tif((scan+lastoffset\u0026lt;req.oldsize) \u0026amp;\u0026amp; 52\t(req.old[scan+lastoffset] == req.new[scan])) 53\toldscore--; 54\t}; 55 56\tif((len!=oldscore) || (scan==req.newsize)) { 57\ts=0;Sf=0;lenf=0; 58\tfor(i=0;(lastscan+i\u0026lt;scan)\u0026amp;\u0026amp;(lastpos+i\u0026lt;req.oldsize);) { 59\tif(req.old[lastpos+i]==req.new[lastscan+i]) s++; 60\ti++; 61\tif(s*2-i\u0026gt;Sf*2-lenf) { Sf=s; lenf=i; }; 62\t}; 63 64\tlenb=0; 65\tif(scan\u0026lt;req.newsize) { 66\ts=0;Sb=0; 67\tfor(i=1;(scan\u0026gt;=lastscan+i)\u0026amp;\u0026amp;(pos\u0026gt;=i);i++) { 68\tif(req.old[pos-i]==req.new[scan-i]) s++; 69\tif(s*2-i\u0026gt;Sb*2-lenb) { Sb=s; lenb=i; }; 70\t}; 71\t}; 72 73\tif(lastscan+lenf\u0026gt;scan-lenb) { 74\toverlap=(lastscan+lenf)-(scan-lenb); 75\ts=0;Ss=0;lens=0; 76\tfor(i=0;i\u0026lt;overlap;i++) { 77\tif(req.new[lastscan+lenf-overlap+i]== 78\treq.old[lastpos+lenf-overlap+i]) s++; 79\tif(req.new[scan-lenb+i]== 80\treq.old[pos-lenb+i]) s--; 81\tif(s\u0026gt;Ss) { Ss=s; lens=i+1; }; 82\t}; 83 84\tlenf+=lens-overlap; 85\tlenb-=lens; 86\t}; 87 88\tofftout(lenf,buf); 89\tofftout((scan-lenb)-(lastscan+lenf),buf+8); 90\tofftout((pos-lenb)-(lastpos+lenf),buf+16); 91 92\t/* Write control data */ 93\tif (writedata(req.stream, buf, sizeof(buf))) 94\treturn -1; 95 96\t/* Write diff data */ 97\tfor(i=0;i\u0026lt;lenf;i++) 98\tbuffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; 99\tif (writedata(req.stream, buffer, lenf)) 100\treturn -1; 101 102\t/* Write extra data */ 103\tfor(i=0;i\u0026lt;(scan-lenb)-(lastscan+lenf);i++) 104\tbuffer[i]=req.new[lastscan+lenf+i]; 105\tif (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) 106\treturn -1; 107 108\tlastscan=scan-lenb; 109\tlastpos=pos-lenb; 110\tlastoffset=pos-scan; 111\t}; 112\t}; 113 114\treturn 0; 115} ","date":"Oct 30, 2021","img":"","permalink":"https://mengdemao.github.io/posts/bsdiff/","series":null,"tags":[],"title":"Bsdiff"},{"categories":[],"content":"ARM笔记 ARM体系结构 相关术语  流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE  工具链    文件名 详解     addr2line 把程序地址转化为文件名和行号   ar 建立、修改和提取归档文件   as 汇编编译器   ld 链接器   nm 列出文件的符号   objcopy 文件个数格式转换   objdump 反汇编   ranlib 产生索引,并且保存进入文件中   readelf 显示elf文件信息   size 列出文件大小   string 打印文件可打印字符串   strip 丢弃文件符号    交叉工具链测试\n1arm-none-linux-gnueabihf-addr2line arm-none-linux-gnueabihf-gdb 2arm-none-linux-gnueabihf-ar arm-none-linux-gnueabihf-gdb-add-index 3arm-none-linux-gnueabihf-as arm-none-linux-gnueabihf-gfortran 4arm-none-linux-gnueabihf-c++ arm-none-linux-gnueabihf-gprof 5arm-none-linux-gnueabihf-c++filt arm-none-linux-gnueabihf-ld 6arm-none-linux-gnueabihf-cpp arm-none-linux-gnueabihf-ld.bfd 7arm-none-linux-gnueabihf-dwp arm-none-linux-gnueabihf-ld.gold 8arm-none-linux-gnueabihf-elfedit arm-none-linux-gnueabihf-lto-dump 9arm-none-linux-gnueabihf-g++ arm-none-linux-gnueabihf-nm 10arm-none-linux-gnueabihf-gcc arm-none-linux-gnueabihf-objcopy 11arm-none-linux-gnueabihf-gcc-10.2.1 arm-none-linux-gnueabihf-objdump 12arm-none-linux-gnueabihf-gcc-ar arm-none-linux-gnueabihf-ranlib 13arm-none-linux-gnueabihf-gcc-nm arm-none-linux-gnueabihf-readelf 14arm-none-linux-gnueabihf-gcc-ranlib arm-none-linux-gnueabihf-size 15arm-none-linux-gnueabihf-gcov arm-none-linux-gnueabihf-strings 16arm-none-linux-gnueabihf-gcov-dump arm-none-linux-gnueabihf-strip 17arm-none-linux-gnueabihf-gcov-tool ARMv7处理器模式    模式 编码 功能 安全 优先级     User (USR) 10000 大多数运行的非特权模式 Both PL0   FIQ 10001 FIQ中断 Both PL1   IRQ 10010 IRQ中断 Both PL1   Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1   Monitor (MON) 10110 安全扩展实现 only PL1   Abort (ABT) 10111 内存权限异常 Both PL1   Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2   Undef (UND) 11011 未定义指令调用 Both PL1   System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1    不同的处理器模式上寄存器共享的情况\nARM指令集 翻译结果 统一汇编语言 分支指令 数据处理指令 状态寄存器访问指令 加载存储指令 加载存储多条指令 杂项指令 异常生成与处理指令 协处理器指令 SIMD指令 ","date":"Oct 30, 2021","img":"","permalink":"https://mengdemao.github.io/posts/arm/","series":null,"tags":[],"title":"Arm"},{"categories":["linux"],"content":"IDLE调度器类 1/* 2* Generic entry points for the idle threads and 3* implementation of the idle task scheduling class. 4* 5* (NOTE: these are not related to SCHED_IDLE batch scheduled 6* tasks which are handled in sched/fair.c ) 7*/ 8#include \u0026#34;sched.h\u0026#34;9 10#include \u0026lt;trace/events/power.h\u0026gt;11 12/* Linker adds these: start and end of __cpuidle functions */ 13extern char __cpuidle_text_start[], __cpuidle_text_end[]; 14 15/** 16* sched_idle_set_state - Record idle state for the current CPU. 17* @idle_state: State to record. 18*/ 19void sched_idle_set_state(struct cpuidle_state *idle_state) 20{ 21\tidle_set_state(this_rq(), idle_state); 22} 23 24static int __read_mostly cpu_idle_force_poll; 25 26void cpu_idle_poll_ctrl(bool enable) 27{ 28\tif (enable) { 29\tcpu_idle_force_poll++; 30\t} else { 31\tcpu_idle_force_poll--; 32\tWARN_ON_ONCE(cpu_idle_force_poll \u0026lt; 0); 33\t} 34} 35 36#ifdef CONFIG_GENERIC_IDLE_POLL_SETUP 37static int __init cpu_idle_poll_setup(char *__unused) 38{ 39\tcpu_idle_force_poll = 1; 40 41\treturn 1; 42} 43__setup(\u0026#34;nohlt\u0026#34;, cpu_idle_poll_setup); 44 45static int __init cpu_idle_nopoll_setup(char *__unused) 46{ 47\tcpu_idle_force_poll = 0; 48 49\treturn 1; 50} 51__setup(\u0026#34;hlt\u0026#34;, cpu_idle_nopoll_setup); 52#endif 53 54static noinline int __cpuidle cpu_idle_poll(void) 55{ 56\trcu_idle_enter(); 57\ttrace_cpu_idle_rcuidle(0, smp_processor_id()); 58\tlocal_irq_enable(); 59\tstop_critical_timings(); 60 61\twhile (!tif_need_resched() \u0026amp;\u0026amp; 62\t(cpu_idle_force_poll || tick_check_broadcast_expired())) 63\tcpu_relax(); 64\tstart_critical_timings(); 65\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id()); 66\trcu_idle_exit(); 67 68\treturn 1; 69} 70 71/* Weak implementations for optional arch specific functions */ 72void __weak arch_cpu_idle_prepare(void) { } 73void __weak arch_cpu_idle_enter(void) { } 74void __weak arch_cpu_idle_exit(void) { } 75void __weak arch_cpu_idle_dead(void) { } 76void __weak arch_cpu_idle(void) 77{ 78\tcpu_idle_force_poll = 1; 79\tlocal_irq_enable(); 80} 81 82/** 83* default_idle_call - Default CPU idle routine. 84* 85* To use when the cpuidle framework cannot be used. 86*/ 87void __cpuidle default_idle_call(void) 88{ 89\tif (current_clr_polling_and_test()) { 90\tlocal_irq_enable(); 91\t} else { 92\tstop_critical_timings(); 93\tarch_cpu_idle(); 94\tstart_critical_timings(); 95\t} 96} 97 98static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev, 99\tint next_state) 100{ 101\t/* 102* The idle task must be scheduled, it is pointless to go to idle, just 103* update no idle residency and return. 104*/ 105\tif (current_clr_polling_and_test()) { 106\tdev-\u0026gt;last_residency = 0; 107\tlocal_irq_enable(); 108\treturn -EBUSY; 109\t} 110 111\t/* 112* Enter the idle state previously returned by the governor decision. 113* This function will block until an interrupt occurs and will take 114* care of re-enabling the local interrupts 115*/ 116\treturn cpuidle_enter(drv, dev, next_state); 117} 118 119/** 120* cpuidle_idle_call - the main idle function 121* 122* NOTE: no locks or semaphores should be used here 123* 124* On archs that support TIF_POLLING_NRFLAG, is called with polling 125* set, and it returns with polling set. If it ever stops polling, it 126* must clear the polling bit. 127*/ 128static void cpuidle_idle_call(void) 129{ 130\tstruct cpuidle_device *dev = cpuidle_get_device(); 131\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev); 132\tint next_state, entered_state; 133 134\t/* 135* Check if the idle task must be rescheduled. If it is the 136* case, exit the function after re-enabling the local irq. 137*/ 138\tif (need_resched()) { 139\tlocal_irq_enable(); 140\treturn; 141\t} 142 143\t/* 144* The RCU framework needs to be told that we are entering an idle 145* section, so no more rcu read side critical sections and one more 146* step to the grace period 147*/ 148 149\tif (cpuidle_not_available(drv, dev)) { 150\ttick_nohz_idle_stop_tick(); 151\trcu_idle_enter(); 152 153\tdefault_idle_call(); 154\tgoto exit_idle; 155\t} 156 157\t/* 158* Suspend-to-idle (\u0026#34;s2idle\u0026#34;) is a system state in which all user space 159* has been frozen, all I/O devices have been suspended and the only 160* activity happens here and in iterrupts (if any). In that case bypass 161* the cpuidle governor and go stratight for the deepest idle state 162* available. Possibly also suspend the local tick and the entire 163* timekeeping to prevent timer interrupts from kicking us out of idle 164* until a proper wakeup interrupt happens. 165*/ 166 167\tif (idle_should_enter_s2idle() || dev-\u0026gt;use_deepest_state) { 168\tif (idle_should_enter_s2idle()) { 169\trcu_idle_enter(); 170 171\tentered_state = cpuidle_enter_s2idle(drv, dev); 172\tif (entered_state \u0026gt; 0) { 173\tlocal_irq_enable(); 174\tgoto exit_idle; 175\t} 176 177\trcu_idle_exit(); 178\t} 179 180\ttick_nohz_idle_stop_tick(); 181\trcu_idle_enter(); 182 183\tnext_state = cpuidle_find_deepest_state(drv, dev); 184\tcall_cpuidle(drv, dev, next_state); 185\t} else { 186\tbool stop_tick = true; 187 188\t/* 189* Ask the cpuidle framework to choose a convenient idle state. 190*/ 191\tnext_state = cpuidle_select(drv, dev, \u0026amp;stop_tick); 192 193\tif (stop_tick || tick_nohz_tick_stopped()) 194\ttick_nohz_idle_stop_tick(); 195\telse 196\ttick_nohz_idle_retain_tick(); 197 198\trcu_idle_enter(); 199 200\tentered_state = call_cpuidle(drv, dev, next_state); 201\t/* 202* Give the governor an opportunity to reflect on the outcome 203*/ 204\tcpuidle_reflect(dev, entered_state); 205\t} 206 207exit_idle: 208\t__current_set_polling(); 209 210\t/* 211* It is up to the idle functions to reenable local interrupts 212*/ 213\tif (WARN_ON_ONCE(irqs_disabled())) 214\tlocal_irq_enable(); 215 216\trcu_idle_exit(); 217} 218 219/* 220* Generic idle loop implementation 221* 222* Called with polling cleared. 223*/ 224static void do_idle(void) 225{ 226\tint cpu = smp_processor_id(); 227\t/* 228* If the arch has a polling bit, we maintain an invariant: 229* 230* Our polling bit is clear if we\u0026#39;re not scheduled (i.e. if rq-\u0026gt;curr != 231* rq-\u0026gt;idle). This means that, if rq-\u0026gt;idle has the polling bit set, 232* then setting need_resched is guaranteed to cause the CPU to 233* reschedule. 234*/ 235 236\t__current_set_polling(); 237\ttick_nohz_idle_enter(); 238 239\twhile (!need_resched()) { 240\tcheck_pgt_cache(); 241\trmb(); 242 243\tlocal_irq_disable(); 244 245\tif (cpu_is_offline(cpu)) { 246\ttick_nohz_idle_stop_tick(); 247\tcpuhp_report_idle_dead(); 248\tarch_cpu_idle_dead(); 249\t} 250 251\tarch_cpu_idle_enter(); 252 253\t/* 254* In poll mode we reenable interrupts and spin. Also if we 255* detected in the wakeup from idle path that the tick 256* broadcast device expired for us, we don\u0026#39;t want to go deep 257* idle as we know that the IPI is going to arrive right away. 258*/ 259\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) { 260\ttick_nohz_idle_restart_tick(); 261\tcpu_idle_poll(); 262\t} else { 263\tcpuidle_idle_call(); 264\t} 265\tarch_cpu_idle_exit(); 266\t} 267 268\t/* 269* Since we fell out of the loop above, we know TIF_NEED_RESCHED must 270* be set, propagate it into PREEMPT_NEED_RESCHED. 271* 272* This is required because for polling idle loops we will not have had 273* an IPI to fold the state for us. 274*/ 275\tpreempt_set_need_resched(); 276\ttick_nohz_idle_exit(); 277\t__current_clr_polling(); 278 279\t/* 280* We promise to call sched_ttwu_pending() and reschedule if 281* need_resched() is set while polling is set. That means that clearing 282* polling needs to be visible before doing these things. 283*/ 284\tsmp_mb__after_atomic(); 285 286\tsched_ttwu_pending(); 287\tschedule_idle(); 288 289\tif (unlikely(klp_patch_pending(current))) 290\tklp_update_patch_state(current); 291} 292 293bool cpu_in_idle(unsigned long pc) 294{ 295\treturn pc \u0026gt;= (unsigned long)__cpuidle_text_start \u0026amp;\u0026amp; 296\tpc \u0026lt; (unsigned long)__cpuidle_text_end; 297} 298 299struct idle_timer { 300\tstruct hrtimer timer; 301\tint done; 302}; 303 304static enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer) 305{ 306\tstruct idle_timer *it = container_of(timer, struct idle_timer, timer); 307 308\tWRITE_ONCE(it-\u0026gt;done, 1); 309\tset_tsk_need_resched(current); 310 311\treturn HRTIMER_NORESTART; 312} 313 314void play_idle(unsigned long duration_ms) 315{ 316\tstruct idle_timer it; 317 318\t/* 319* Only FIFO tasks can disable the tick since they don\u0026#39;t need the forced 320* preemption. 321*/ 322\tWARN_ON_ONCE(current-\u0026gt;policy != SCHED_FIFO); 323\tWARN_ON_ONCE(current-\u0026gt;nr_cpus_allowed != 1); 324\tWARN_ON_ONCE(!(current-\u0026gt;flags \u0026amp; PF_KTHREAD)); 325\tWARN_ON_ONCE(!(current-\u0026gt;flags \u0026amp; PF_NO_SETAFFINITY)); 326\tWARN_ON_ONCE(!duration_ms); 327 328\trcu_sleep_check(); 329\tpreempt_disable(); 330\tcurrent-\u0026gt;flags |= PF_IDLE; 331\tcpuidle_use_deepest_state(true); 332 333\tit.done = 0; 334\thrtimer_init_on_stack(\u0026amp;it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); 335\tit.timer.function = idle_inject_timer_fn; 336\thrtimer_start(\u0026amp;it.timer, ms_to_ktime(duration_ms), HRTIMER_MODE_REL_PINNED); 337 338\twhile (!READ_ONCE(it.done)) 339\tdo_idle(); 340 341\tcpuidle_use_deepest_state(false); 342\tcurrent-\u0026gt;flags \u0026amp;= ~PF_IDLE; 343 344\tpreempt_fold_need_resched(); 345\tpreempt_enable(); 346} 347EXPORT_SYMBOL_GPL(play_idle); 348 349void cpu_startup_entry(enum cpuhp_state state) 350{ 351\t/* 352* This #ifdef needs to die, but it\u0026#39;s too late in the cycle to 353* make this generic (ARM and SH have never invoked the canary 354* init for the non boot CPUs!). Will be fixed in 3.11 355*/ 356#ifdef CONFIG_X86 357\t/* 358* If we\u0026#39;re the non-boot CPU, nothing set the stack canary up 359* for us. The boot CPU already has it initialized but no harm 360* in doing it again. This is a good place for updating it, as 361* we wont ever return from this function (so the invalid 362* canaries already on the stack wont ever trigger). 363*/ 364\tboot_init_stack_canary(); 365#endif 366\tarch_cpu_idle_prepare(); 367\tcpuhp_online_idle(state); 368\twhile (1) 369\tdo_idle(); 370} 371 372/* 373* idle-task scheduling class. 374*/ 375 376#ifdef CONFIG_SMP 377static int 378select_task_rq_idle(struct task_struct *p, int cpu, int sd_flag, int flags) 379{ 380\treturn task_cpu(p); /* IDLE tasks as never migrated */ 381} 382#endif 383 384/* 385* Idle tasks are unconditionally rescheduled: 386*/ 387static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags) 388{ 389\tresched_curr(rq); 390} 391 392static struct task_struct * 393pick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) 394{ 395\tput_prev_task(rq, prev); 396\tupdate_idle_core(rq); 397\tschedstat_inc(rq-\u0026gt;sched_goidle); 398 399\treturn rq-\u0026gt;idle; 400} 401 402/* 403* It is not legal to sleep in the idle task - print a warning 404* message if some code attempts to do it: 405*/ 406static void 407dequeue_task_idle(struct rq *rq, struct task_struct *p, int flags) 408{ 409\traw_spin_unlock_irq(\u0026amp;rq-\u0026gt;lock); 410\tprintk(KERN_ERR \u0026#34;bad: scheduling from the idle thread!\\n\u0026#34;); 411\tdump_stack(); 412\traw_spin_lock_irq(\u0026amp;rq-\u0026gt;lock); 413} 414 415static void put_prev_task_idle(struct rq *rq, struct task_struct *prev) 416{ 417} 418 419/* 420* scheduler tick hitting a task of our scheduling class. 421* 422* NOTE: This function can be called remotely by the tick offload that 423* goes along full dynticks. Therefore no local assumption can be made 424* and everything must be accessed through the @rq and @curr passed in 425* parameters. 426*/ 427static void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued) 428{ 429} 430 431static void set_curr_task_idle(struct rq *rq) 432{ 433} 434 435static void switched_to_idle(struct rq *rq, struct task_struct *p) 436{ 437\tBUG(); 438} 439 440static void 441prio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio) 442{ 443\tBUG(); 444} 445 446static unsigned int get_rr_interval_idle(struct rq *rq, struct task_struct *task) 447{ 448\treturn 0; 449} 450 451static void update_curr_idle(struct rq *rq) 452{ 453} 454 455/* 456* Simple, special scheduling class for the per-CPU idle tasks: 457*/ 458const struct sched_class idle_sched_class = { 459\t/* .next is NULL */ 460\t/* no enqueue/yield_task for idle tasks */ 461 462\t/* dequeue is not valid, we print a debug message there: */ 463\t.dequeue_task\t= dequeue_task_idle, 464 465\t.check_preempt_curr\t= check_preempt_curr_idle, 466 467\t.pick_next_task\t= pick_next_task_idle, 468\t.put_prev_task\t= put_prev_task_idle, 469 470#ifdef CONFIG_SMP 471\t.select_task_rq\t= select_task_rq_idle, 472\t.set_cpus_allowed\t= set_cpus_allowed_common, 473#endif 474 475\t.set_curr_task = set_curr_task_idle, 476\t.task_tick\t= task_tick_idle, 477 478\t.get_rr_interval\t= get_rr_interval_idle, 479 480\t.prio_changed\t= prio_changed_idle, 481\t.switched_to\t= switched_to_idle, 482\t.update_curr\t= update_curr_idle, 483}; ","date":"Oct 28, 2021","img":"","permalink":"https://mengdemao.github.io/posts/idle/","series":null,"tags":["kernel"],"title":"Idle"},{"categories":["linux"],"content":"完全公平调度器 1const struct sched_class fair_sched_class = { 2\t.next\t= \u0026amp;idle_sched_class, 3\t.enqueue_task\t= enqueue_task_fair, 4\t.dequeue_task\t= dequeue_task_fair, 5\t.yield_task\t= yield_task_fair, 6\t.yield_to_task\t= yield_to_task_fair, 7 8\t.check_preempt_curr\t= check_preempt_wakeup, 9 10\t.pick_next_task\t= pick_next_task_fair, 11\t.put_prev_task\t= put_prev_task_fair, 12 13#ifdef CONFIG_SMP 14\t.select_task_rq\t= select_task_rq_fair, 15\t.migrate_task_rq\t= migrate_task_rq_fair, 16 17\t.rq_online\t= rq_online_fair, 18\t.rq_offline\t= rq_offline_fair, 19 20\t.task_dead\t= task_dead_fair, 21\t.set_cpus_allowed\t= set_cpus_allowed_common, 22#endif 23 24\t.set_curr_task = set_curr_task_fair, 25\t.task_tick\t= task_tick_fair, 26\t.task_fork\t= task_fork_fair, 27 28\t.prio_changed\t= prio_changed_fair, 29\t.switched_from\t= switched_from_fair, 30\t.switched_to\t= switched_to_fair, 31 32\t.get_rr_interval\t= get_rr_interval_fair, 33 34\t.update_curr\t= update_curr_fair, 35 36#ifdef CONFIG_FAIR_GROUP_SCHED 37\t.task_change_group\t= task_change_group_fair, 38#endif 39}; 调度器类分析\n1struct sched_class { 2\tconst struct sched_class *next; 3 4\tvoid (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); 5\tvoid (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); 6\tvoid (*yield_task) (struct rq *rq); 7\tbool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); 8 9\tvoid (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); 10 11\t/* 12* It is the responsibility of the pick_next_task() method that will 13* return the next task to call put_prev_task() on the @prev task or 14* something equivalent. 15* 16* May return RETRY_TASK when it finds a higher prio class has runnable 17* tasks. 18*/ 19\tstruct task_struct * (*pick_next_task)(struct rq *rq, 20\tstruct task_struct *prev, 21\tstruct rq_flags *rf); 22\tvoid (*put_prev_task)(struct rq *rq, struct task_struct *p); 23 24#ifdef CONFIG_SMP 25\tint (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); 26\tvoid (*migrate_task_rq)(struct task_struct *p, int new_cpu); 27 28\tvoid (*task_woken)(struct rq *this_rq, struct task_struct *task); 29 30\tvoid (*set_cpus_allowed)(struct task_struct *p, 31\tconst struct cpumask *newmask); 32 33\tvoid (*rq_online)(struct rq *rq); 34\tvoid (*rq_offline)(struct rq *rq); 35#endif 36 37\tvoid (*set_curr_task)(struct rq *rq); 38\tvoid (*task_tick)(struct rq *rq, struct task_struct *p, int queued); 39\tvoid (*task_fork)(struct task_struct *p); 40\tvoid (*task_dead)(struct task_struct *p); 41 42\t/* 43* The switched_from() call is allowed to drop rq-\u0026gt;lock, therefore we 44* cannot assume the switched_from/switched_to pair is serliazed by 45* rq-\u0026gt;lock. They are however serialized by p-\u0026gt;pi_lock. 46*/ 47\tvoid (*switched_from)(struct rq *this_rq, struct task_struct *task); 48\tvoid (*switched_to) (struct rq *this_rq, struct task_struct *task); 49\tvoid (*prio_changed) (struct rq *this_rq, struct task_struct *task, 50\tint oldprio); 51 52\tunsigned int (*get_rr_interval)(struct rq *rq, 53\tstruct task_struct *task); 54 55\tvoid (*update_curr)(struct rq *rq); 56 57#define TASK_SET_GROUP\t0 58#define TASK_MOVE_GROUP\t1 59 60#ifdef CONFIG_FAIR_GROUP_SCHED 61\tvoid (*task_change_group)(struct task_struct *p, int type); 62#endif 63}; enqueue_task_fair 1static void 2enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) 3{ 4\tstruct cfs_rq *cfs_rq; 5\tstruct sched_entity *se = \u0026amp;p-\u0026gt;se; 6 7\t/* 8* The code below (indirectly) updates schedutil which looks at 9* the cfs_rq utilization to select a frequency. 10* Let\u0026#39;s add the task\u0026#39;s estimated utilization to the cfs_rq\u0026#39;s 11* estimated utilization, before we update schedutil. 12*/ 13\tutil_est_enqueue(\u0026amp;rq-\u0026gt;cfs, p); 14 15\t/* 16* If in_iowait is set, the code below may not trigger any cpufreq 17* utilization updates, so do it here explicitly with the IOWAIT flag 18* passed. 19*/ 20\tif (p-\u0026gt;in_iowait) 21\tcpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); 22 23\tfor_each_sched_entity(se) { 24\tif (se-\u0026gt;on_rq) 25\tbreak; 26\tcfs_rq = cfs_rq_of(se); 27\tenqueue_entity(cfs_rq, se, flags); 28 29\t/* 30* end evaluation on encountering a throttled cfs_rq 31* 32* note: in the case of encountering a throttled cfs_rq we will 33* post the final h_nr_running increment below. 34*/ 35\tif (cfs_rq_throttled(cfs_rq)) 36\tbreak; 37\tcfs_rq-\u0026gt;h_nr_running++; 38 39\tflags = ENQUEUE_WAKEUP; 40\t} 41 42\tfor_each_sched_entity(se) { 43\tcfs_rq = cfs_rq_of(se); 44\tcfs_rq-\u0026gt;h_nr_running++; 45 46\tif (cfs_rq_throttled(cfs_rq)) 47\tbreak; 48 49\tupdate_load_avg(cfs_rq, se, UPDATE_TG); 50\tupdate_cfs_group(se); 51\t} 52 53\tif (!se) 54\tadd_nr_running(rq, 1); 55 56\tif (cfs_bandwidth_used()) { 57\t/* 58* When bandwidth control is enabled; the cfs_rq_throttled() 59* breaks in the above iteration can result in incomplete 60* leaf list maintenance, resulting in triggering the assertion 61* below. 62*/ 63\tfor_each_sched_entity(se) { 64\tcfs_rq = cfs_rq_of(se); 65 66\tif (list_add_leaf_cfs_rq(cfs_rq)) 67\tbreak; 68\t} 69\t} 70 71\tassert_list_leaf_cfs_rq(rq); 72 73\thrtick_update(rq); 74} dequeue_task_fair 1static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) 2{ 3\tstruct cfs_rq *cfs_rq; 4\tstruct sched_entity *se = \u0026amp;p-\u0026gt;se; 5\tint task_sleep = flags \u0026amp; DEQUEUE_SLEEP; 6 7\tfor_each_sched_entity(se) { 8\tcfs_rq = cfs_rq_of(se); 9\tdequeue_entity(cfs_rq, se, flags); 10 11\t/* 12* end evaluation on encountering a throttled cfs_rq 13* 14* note: in the case of encountering a throttled cfs_rq we will 15* post the final h_nr_running decrement below. 16*/ 17\tif (cfs_rq_throttled(cfs_rq)) 18\tbreak; 19\tcfs_rq-\u0026gt;h_nr_running--; 20 21\t/* Don\u0026#39;t dequeue parent if it has other entities besides us */ 22\tif (cfs_rq-\u0026gt;load.weight) { 23\t/* Avoid re-evaluating load for this entity: */ 24\tse = parent_entity(se); 25\t/* 26* Bias pick_next to pick a task from this cfs_rq, as 27* p is sleeping when it is within its sched_slice. 28*/ 29\tif (task_sleep \u0026amp;\u0026amp; se \u0026amp;\u0026amp; !throttled_hierarchy(cfs_rq)) 30\tset_next_buddy(se); 31\tbreak; 32\t} 33\tflags |= DEQUEUE_SLEEP; 34\t} 35 36\tfor_each_sched_entity(se) { 37\tcfs_rq = cfs_rq_of(se); 38\tcfs_rq-\u0026gt;h_nr_running--; 39 40\tif (cfs_rq_throttled(cfs_rq)) 41\tbreak; 42 43\tupdate_load_avg(cfs_rq, se, UPDATE_TG); 44\tupdate_cfs_group(se); 45\t} 46 47\tif (!se) 48\tsub_nr_running(rq, 1); 49 50\tutil_est_dequeue(\u0026amp;rq-\u0026gt;cfs, p, task_sleep); 51\thrtick_update(rq); 52} yield_task_fair yield_to_task_fair ","date":"Oct 28, 2021","img":"","permalink":"https://mengdemao.github.io/posts/fair/","series":null,"tags":["kernel"],"title":"Fair"},{"categories":["python"],"content":"python基础绘图\n","date":"Oct 16, 2021","img":"","permalink":"https://mengdemao.github.io/posts/tkinter/","series":null,"tags":[],"title":"Tkinter"},{"categories":[],"content":"","date":"Oct 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/javascript/","series":null,"tags":[],"title":"Javascript"},{"categories":[],"content":"CSS开始(层叠样式表) HTML + CSS + JavaScript 名词 + 形容词 + 动词 相当于对原始的HTML进行美化\n快速入门  CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画  什么是CSS 美化:字体, 颜色,高度,宽度, 背景图片\nCSS的优势:  内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件  CSS导入的方法  行内样式  1\u0026lt;h1 style=\u0026#34;color: red\u0026#34;\u0026gt;一级标题\u0026lt;/h1\u0026gt; style标签  1\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 外部样式   链接方式  1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt;  导入式  1\u0026lt;style\u0026gt; 2\t@import url(\u0026#34;css/style.css\u0026#34;); 3\u0026lt;/style\u0026gt; 基本语法 1/* 注释语法 */ 2selector { 3\t/* 声明 */ 4\tattr:value; 5} 选择器 基本选择器   标签选择器\n  类选择器\n  ID选择器\n  标签选择器 1h1 { 2 color: red; 3} 4h2 { 5 color: black; 6} 7h3 { 8 color: yellow; 9} 10h4 { 11 color: red; 12} 类选择器 1\u0026lt;h1 class=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/h1\u0026gt; 此时,可以讲HTML选中\n1.test { 2 color: black; 3} ID选择器 1\u0026lt;h1 id=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/h1\u0026gt; 1#test { 2\tcolor: black; 3} ID唯一确定,不可以共享;\n层次选择器 ","date":"Oct 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/css/","series":null,"tags":[],"title":"Css"},{"categories":[],"content":"开始 网页基础结构\n1\u0026lt;!-- 告诉浏览器,需要使用的规范 --\u0026gt; 2\u0026lt;!DOCTYPE html\u0026gt; 3\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 4 5\u0026lt;!-- 网页标题 --\u0026gt; 6\u0026lt;head\u0026gt; 7 \u0026lt;!-- 描述标签 --\u0026gt; 8 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 9 10 \u0026lt;!-- 网页标题 --\u0026gt; 11 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 12\u0026lt;/head\u0026gt; 13 14\u0026lt;!-- 网页主体 --\u0026gt; 15\u0026lt;body\u0026gt; 16\u0026lt;/body\u0026gt; 17\u0026lt;/html\u0026gt; 网页基本标签 标题标签 1\u0026lt;h1\u0026gt;一级标签\u0026lt;/h1\u0026gt; 2\u0026lt;h2\u0026gt;二级标签\u0026lt;/h2\u0026gt; 3\u0026lt;h3\u0026gt;三级标签\u0026lt;/h3\u0026gt; 4\u0026lt;h4\u0026gt;四级标签\u0026lt;/h4\u0026gt; 5\u0026lt;h5\u0026gt;五级标签\u0026lt;/h5\u0026gt; 6\u0026lt;h6\u0026gt;六级标签\u0026lt;/h6\u0026gt; 段落标签 1\u0026lt;p\u0026gt;段落标签\u0026lt;/p\u0026gt; 换行标签 1\u0026lt;br/\u0026gt; 水平线标签 1\u0026lt;hr/\u0026gt; 字体样式标签 1\u0026lt;!-- 字体样式标签 --\u0026gt; 2\u0026lt;strong\u0026gt;粗体\u0026lt;/strong\u0026gt;\u0026lt;br/\u0026gt; 3\u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt;\u0026lt;br/\u0026gt; 图片标签 1\u0026lt;img src=\u0026#34;测试.png\u0026#34; alt=\u0026#34;测试\u0026#34; title=\u0026#34;测试\u0026#34;/\u0026gt; 链接 1\u0026lt;!-- 当前页打开 --\u0026gt; 2\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 3\u0026lt;!-- 新建页打开 --\u0026gt; 4\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 行内元素和块元素 列表标签 有序列表 1\u0026lt;ol\u0026gt; 2 \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; 3 \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; 4 \u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; 5\u0026lt;/ol\u0026gt; 无序列表 1\u0026lt;ul\u0026gt; 2 \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; 3 \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; 4 \u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; 5\u0026lt;/ul\u0026gt; 定义列表 1\u0026lt;dl\u0026gt; 2 \u0026lt;dt\u0026gt;前端\u0026lt;/dt\u0026gt; 3 \u0026lt;dd\u0026gt;html\u0026lt;/dd\u0026gt; 4 \u0026lt;dd\u0026gt;CSS\u0026lt;/dd\u0026gt; 5 \u0026lt;dd\u0026gt;JavaScript\u0026lt;/dd\u0026gt; 6\u0026lt;/dl\u0026gt; 表格 1\u0026lt;table border=\u0026#34;1px\u0026#34;\u0026gt; 2\t\u0026lt;tr\u0026gt; 3\t\u0026lt;td\u0026gt;1-1\u0026lt;/td\u0026gt; 4\t\u0026lt;td\u0026gt;1-2\u0026lt;/td\u0026gt; 5\t\u0026lt;/tr\u0026gt; 6\t\u0026lt;tr\u0026gt; 7\t\u0026lt;td\u0026gt;2-1\u0026lt;/td\u0026gt; 8\t\u0026lt;td\u0026gt;2-2\u0026lt;/td\u0026gt; 9\t\u0026lt;/tr\u0026gt; 10\u0026lt;/table\u0026gt; 页面结构分析    元素名 描述     header 标题头部区域   footer 标记尾部内容   section web页面中一块独立的区域   article 独立文章内容   aside 相关页面或者内容   nav 导航类辅助内容    iframe内联框架 1\u0026lt;iframe src=\u0026#34;path\u0026#34; name=\u0026#34;mainFrame\u0026#34;\u0026gt;\u0026lt;/frame\u0026gt; bilibili的例子\n1\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=55631961\u0026amp;bvid=BV1x4411V75C\u0026amp;cid=97257967\u0026amp;page=11\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 表单 表单form\n1\u0026lt;form action=\u0026#34;开始.html\u0026#34; method=\u0026#34;GET/POST\u0026#34;\u0026gt; 2 \u0026lt;p\u0026gt;名字: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 3 \u0026lt;p\u0026gt;密码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 4 \u0026lt;p\u0026gt; 5 \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; 6 \u0026lt;input type=\u0026#34;reset\u0026#34;\u0026gt; 7 \u0026lt;/p\u0026gt; 8\u0026lt;/form\u0026gt; 产生的效果\n1?name=111\u0026amp;password= ","date":"Oct 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/html5/","series":null,"tags":[],"title":"Html5"},{"categories":[],"content":" A C dynamic strings library C语言版本动态字符串库\n SDS SDS的类型就是\n1typedef char *sds; 可以明显的看到,sds就是普通的char类型\n下面是sds的数据类型 1+--------+-------------------------------+-----------+ 2| Header | Binary safe C alike string... | Null term | 3+--------+-------------------------------+-----------+ 4 | 5 -\u0026gt; Pointer returned to the user. 1#define SDS_HDR_VAR(T,s) \\ 2struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); 3#define SDS_HDR(T,s) \\ 4((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 5#define SDS_TYPE_5_LEN(f) ((f)\u0026gt;\u0026gt;SDS_TYPE_BITS) SDS 头 根据不同的标志计算不同的头部数据\n   宏定义 标志     SDS_TYPE_5 sdshdr5   SDS_TYPE_8 sdshdr8   SDS_TYPE_16 sdshdr16   SDS_TYPE_32 sdshdr32   SDS_TYPE_64 sdshdr64    flag标志:\n1unsigned char flags = s[-1]; /* 最后一个头部数据 */ 1#define SDS_TYPE_5 0 2#define SDS_TYPE_8 1 3#define SDS_TYPE_16 2 4#define SDS_TYPE_32 3 5#define SDS_TYPE_64 4 1/* Note: sdshdr5 is never used, we just access the flags byte directly. 2* However is here to document the layout of type 5 SDS strings. */ 3struct __attribute__ ((__packed__)) sdshdr5 { 4 unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ 5 char buf[]; 6}; 7struct __attribute__ ((__packed__)) sdshdr8 { 8 uint8_t len; /* used */ 9 uint8_t alloc; /* excluding the header and null terminator */ 10 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 11 char buf[]; 12}; 13struct __attribute__ ((__packed__)) sdshdr16 { 14 uint16_t len; /* used */ 15 uint16_t alloc; /* excluding the header and null terminator */ 16 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 17 char buf[]; 18}; 19struct __attribute__ ((__packed__)) sdshdr32 { 20 uint32_t len; /* used */ 21 uint32_t alloc; /* excluding the header and null terminator */ 22 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 23 char buf[]; 24}; 25struct __attribute__ ((__packed__)) sdshdr64 { 26 uint64_t len; /* used */ 27 uint64_t alloc; /* excluding the header and null terminator */ 28 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 29 char buf[]; 30}; 1#define SDS_TYPE_MASK 7 2#define SDS_TYPE_BITS 3 创建SDS 函数原型\n1sds sdsnewlen(const void *init, size_t initlen); 扩张字符串缓存区 1sds sdsMakeRoomFor(sds s, size_t addlen) 2{ 3 void *sh; 4 void *newsh; 5 size_t avail = sdsavail(s);\t/* 计算剩余的可以使用的大小 */ 6 size_t len; 7 size_t newlen; 8 char type, oldtype = s[-1] \u0026amp; SDS_TYPE_MASK; 9 int hdrlen; 10 11 if (avail \u0026gt;= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ 12 return s; 13 } 14 len = sdslen(s);\t/* 计算字符串大小 */ 15 sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ 16 17 /* 计算得到新的长度 */ 18 newlen = (len+addlen); 19 if (newlen \u0026lt; SDS_MAX_PREALLOC) 20 newlen *= 2; 21 else 22 newlen += SDS_MAX_PREALLOC; 23\t/* 重新生成类型 */ 24 type = sdsReqType(newlen); 25 26 /* Don\u0026#39;t use type 5: the user is appending to the string and type 5 is 27* not able to remember empty space, so sdsMakeRoomFor() must be called 28* at every appending operation. */ 29 if (type == SDS_TYPE_5) { 30 type = SDS_TYPE_8; 31\t} 32\t33 /* 计算头部大小 */ 34 hdrlen = sdsHdrSize(type); 35 36 if (oldtype == type) { 37 newsh = s_realloc(sh, hdrlen + newlen + 1); 38 if (newsh == NULL) { 39 return NULL; 40 } 41 s = (char*)newsh + hdrlen; 42 } else { 43 /* Since the header size changes, need to move the string forward, 44* and can\u0026#39;t use realloc */ 45 newsh = s_malloc(hdrlen+newlen+1); 46 if (newsh == NULL) { 47 return NULL; 48 } 49 memcpy((char*)newsh+hdrlen, s, len+1); 50 s_free(sh); 51 52 s = (char*)newsh + hdrlen; 53 s[-1] = type; 54 55 sdssetlen(s, len); 56 } 57 58 sdssetalloc(s, newlen); 59 return s; 60} 追加字符串 1sds sdscatlen(sds s, const void *t, size_t len) 2{ 3 size_t curlen = sdslen(s);\t/* 计算字符串的长度 */ 4 5 s = sdsMakeRoomFor(s,len);\t/* 扩展字符串缓冲区长度 */ 6 if (s == NULL) { 7 return NULL; 8 } 9 memcpy(s+curlen, t, len);\t/* 添加字符串 */ 10 sdssetlen(s, curlen+len);\t/* 设置长度标志 */ 11 s[curlen+len] = \u0026#39;\\0\u0026#39;;\t/* 补全结束符 */ 12 return s; 13} ","date":"Oct 6, 2021","img":"","permalink":"https://mengdemao.github.io/posts/sds/","series":null,"tags":[],"title":"Sds"},{"categories":[],"content":" STL称为标准模板库(Standard Template Library) 广义上可以分为容器,算法,迭代器 容器和算法通过迭代器进行无缝连接 STL几乎所有的代码都采用了函数模版或者类模板\n STL组件    序号 名称 解释     1 容器 各种数据结构   2 算法 各种常用的算法   3 迭代器 容器域算法的胶合   4 仿函数 行为类似函数   5 适配器 修饰容器或者仿函数迭代器   6 空间配置器 负责空间的配置和管理    容器算法和迭代器 vector vector使用 1/* 创建vector容器 */ 2vector\u0026lt;int\u0026gt; v; 3/* 插入数据 */ 4v.push_back(10); 5v.push_back(20); 6v.push_back(30); 7v.push_back(40); 迭代器使用 迭代器方案1 1vector\u0026lt;int\u0026gt;::iterator itBegin = v.begin(); 2vector\u0026lt;int\u0026gt;::iterator itEnd = v.end(); 3while (itBegin != itEnd) { 4\tcout \u0026lt;\u0026lt; *itBegin \u0026lt;\u0026lt; endl; 5\titBegin += 1; 6} 迭代器2 1for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 2{ 3\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; 4} 遍历算法 1template \u0026lt;class T\u0026gt; 2void myPrint(T val) 3{ 4\tcout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 5} 6 7/* 可惜回调函数不支持自动推导 */ 8for_each(v.begin(), v.end(), myPrint\u0026lt;int\u0026gt;); 容器自定义数据 容器嵌套容器 1vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;v; // 外部大容器 2vector\u0026lt;int\u0026gt; vx[10]; // 内部小容器 3 4/* 插入容器 */ 5for (int i = 0; i \u0026lt; 10; i++) 6{ 7\tfor (int j = 0; j \u0026lt; 30; j++) 8\t{ 9\tvx[i].push_back(i + j + 10); 10\t} 11\tv.push_back(vx[i]); 12} 13 14/* 遍历容器 */ 15for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 16{ 17\tfor (vector\u0026lt;int\u0026gt;::iterator vit = it-\u0026gt;begin(); vit != it-\u0026gt;end(); vit++) 18\t{ 19\tcout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 20\t} 21\tcout \u0026lt;\u0026lt; endl; 22} string string本质上是一个类,封装了char*,提供了许多的成员方法;\n构造函数 1string s1(str); 2string s2 = \u0026#34;Hello World\u0026#34;; 3string s3(s2); 赋值操作  重载操作符**=**  1string s1; 2s1 = \u0026#34;Hello World\u0026#34;; 成员函数assign  1string str; 2str.assign(\u0026#34;Hello World\u0026#34;); 追加操作  重载操作符**+=** 成员函数append  查找和替换 find replace 比较 compare 字符存取  [] at  插入和删除 insert earse 子串 substr array deque hashtable map list queue stack set rbtree ","date":"Oct 6, 2021","img":"","permalink":"https://mengdemao.github.io/posts/stl/","series":null,"tags":[],"title":"STL学习笔记"},{"categories":[],"content":"HelloWorld 1#!/bin/python3 2 3if __name__ == \u0026#39;__main__\u0026#39;: 4 print(\u0026#39;Hello World\u0026#39;) 数据类型 Numbers(数字) 1intA = 10 2print(intA) 布尔类型 1true 2false String(字符串) 1strB = \u0026#34;Hello\u0026#34; 2print(strB) List(列表) 1listC = [\u0026#34;12\u0026#34;, 3, 4] 2print(listC) Tuple(元组) 1tupleD = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) 2print(tupleD) Dictionary(字典) 1DictE = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;b\u0026#39;: \u0026#39;3\u0026#39;} 2print(DictE) 运算符 控制结构 条件语句 单执行语句 1if 判断条件： 2\t执行语句 3else： 4\t执行语句 多条件语句 1if 判断条件1: 2 执行语句1…… 3elif 判断条件2: 4 执行语句2…… 5elif 判断条件3: 6\t执行语句3…… 7else: 8 执行语句4…… while循环 1c = 0 2while (c \u0026lt; 10): 3 print(c) 4 c += 1 5print(\u0026#34;while Loop finish\u0026#34;) ###　for循环\n函数 面向对象 ","date":"Oct 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/python/","series":null,"tags":[],"title":"Python学习笔记"},{"categories":[],"content":"输入子设备分为三层\n handle core device  input的相关结构体 1 struct input_dev {\t/* 输入设备的描述 */ 2 const char *name;\t/* 设备名称 */ 3\tconst char *phys; 4\tconst char *uniq; 5\tstruct input_id id; 6 7\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; 8 9\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)]; 10\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; 11\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)]; 12\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; 13\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; 14\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; 15\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; 16\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; 17\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)]; 18 19\tunsigned int hint_events_per_packet; 20 21\tunsigned int keycodemax; 22\tunsigned int keycodesize; 23\tvoid *keycode; 24 25\tint (*setkeycode)(struct input_dev *dev, 26\tconst struct input_keymap_entry *ke, 27\tunsigned int *old_keycode); 28\tint (*getkeycode)(struct input_dev *dev, 29\tstruct input_keymap_entry *ke); 30 31\tstruct ff_device *ff; 32 33\tunsigned int repeat_key; 34\tstruct timer_list timer; 35 36\tint rep[REP_CNT]; 37 38\tstruct input_mt *mt; 39 40\tstruct input_absinfo *absinfo; 41 42\tunsigned long key[BITS_TO_LONGS(KEY_CNT)]; 43\tunsigned long led[BITS_TO_LONGS(LED_CNT)]; 44\tunsigned long snd[BITS_TO_LONGS(SND_CNT)]; 45\tunsigned long sw[BITS_TO_LONGS(SW_CNT)]; 46 47\tint (*open)(struct input_dev *dev); 48\tvoid (*close)(struct input_dev *dev); 49\tint (*flush)(struct input_dev *dev, struct file *file); 50\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); 51 52\tstruct input_handle __rcu *grab; 53 54\tspinlock_t event_lock; 55\tstruct mutex mutex; 56 57\tunsigned int users; 58\tbool going_away; 59 60\tstruct device dev; 61 62\tstruct list_head\th_list; 63\tstruct list_head\tnode; 64 65\tunsigned int num_vals; 66\tunsigned int max_vals; 67\tstruct input_value *vals; 68 69\tbool devres_managed; 70 }; 71#define to_input_dev(d) container_of(d, struct input_dev, dev) input子系统使用 input子系统分析  Makefile编写  1obj-$(CONFIG_INPUT)\t+= input-core.o 2input-core-y := input.o input-compat.o input-mt.o ff-core.o 开始判断下面的第一个文件 input.c  1subsys_initcall(input_init); 2module_exit(input_exit); 输入子系统的设备号\n1#define INPUT_MAJOR 13 安装驱动\n1 static int __init input_init(void) 2 { 3\tint err; 4\t/* 注册设备类 */ 5\terr = class_register(\u0026amp;input_class); 6\tif (err) { 7\tpr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 8\treturn err; 9\t} 10 11\t/* 注册proc文件系统 */ 12\terr = input_proc_init(); 13\tif (err) 14\tgoto fail1; 15\t/* 注册设备 */ 16\terr = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), 17\tINPUT_MAX_CHAR_DEVICES, \u0026#34;input\u0026#34;); 18\tif (err) { 19\tpr_err(\u0026#34;unable to register char major %d\u0026#34;, INPUT_MAJOR); 20\tgoto fail2; 21\t} 22 23\treturn 0; 24 25 fail2:\tinput_proc_exit(); 26 fail1:\tclass_unregister(\u0026amp;input_class); 27\treturn err; 28 } 卸载驱动\n1 static void __exit input_exit(void) 2 { 3\t/* 卸载proc文件系统 */ 4\tinput_proc_exit(); 5 6\t/* 注销设备号 */ 7\tunregister_chrdev_region(MKDEV(INPUT_MAJOR, 0), 8\tINPUT_MAX_CHAR_DEVICES); 9 10\t/* 注销CLass */ 11\tclass_unregister(\u0026amp;input_class); 12 } 设备类操作\n1\t/* 设备类型 */ 2\tstruct class input_class = { 3\t.name\t= \u0026#34;input\u0026#34;, 4\t.devnode\t= input_devnode, 5\t}; 6\tEXPORT_SYMBOL_GPL(input_class); 7 8\t/* 注册设备 */ 9\terr = class_register(\u0026amp;input_class); 10\tif (err) { 11\tpr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 12\treturn err; 13\t} 14 15\t/* 卸载设备 */ 16 class_unregister(\u0026amp;input_class); Proc文件系统操作\nProc文件系统添加\n1static int __init input_proc_init(void) 2{ 3\tstruct proc_dir_entry *entry; 4 5\tproc_bus_input_dir = proc_mkdir(\u0026#34;bus/input\u0026#34;, NULL); 6\tif (!proc_bus_input_dir) 7\treturn -ENOMEM; 8 9\tentry = proc_create(\u0026#34;devices\u0026#34;, 0, proc_bus_input_dir, 10\t\u0026amp;input_devices_fileops); 11\tif (!entry) 12\tgoto fail1; 13 14\tentry = proc_create(\u0026#34;handlers\u0026#34;, 0, proc_bus_input_dir, 15\t\u0026amp;input_handlers_fileops); 16\tif (!entry) 17\tgoto fail2; 18 19\treturn 0; 20 21 fail2:\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 22 fail1: remove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 23\treturn -ENOMEM; 24} Proc文件系统卸载\n1static void input_proc_exit(void) 2{ 3\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 4\tremove_proc_entry(\u0026#34;handlers\u0026#34;, proc_bus_input_dir); 5\tremove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 6} 接口部分 Handler操作 1/** 2* 注册 input handler 3* input_register_handler - register a new input handler 4* @handler: handler to be registered 5* 6* This function registers a new input handler (interface) for input 7* devices in the system and attaches it to all input devices that 8* are compatible with the handler. 9*/ 10int input_register_handler(struct input_handler *handler) 11{ 12\tstruct input_dev *dev; 13\tint error; 14 15\terror = mutex_lock_interruptible(\u0026amp;input_mutex); 16\tif (error) 17\treturn error; 18 19\tINIT_LIST_HEAD(\u0026amp;handler-\u0026gt;h_list); 20 21\tlist_add_tail(\u0026amp;handler-\u0026gt;node, \u0026amp;input_handler_list); 22 23\tlist_for_each_entry(dev, \u0026amp;input_dev_list, node) 24\tinput_attach_handler(dev, handler); 25 26\tinput_wakeup_procfs_readers(); 27 28\tmutex_unlock(\u0026amp;input_mutex); 29\treturn 0; 30} 31EXPORT_SYMBOL(input_register_handler); 32 33/** 34* 解除注册 input handler 35* input_unregister_handler - unregisters an input handler 36* @handler: handler to be unregistered 37* 38* This function disconnects a handler from its input devices and 39* removes it from lists of known handlers. 40*/ 41void input_unregister_handler(struct input_handler *handler) 42{ 43\tstruct input_handle *handle, *next; 44 45\tmutex_lock(\u0026amp;input_mutex); 46 47\tlist_for_each_entry_safe(handle, next, \u0026amp;handler-\u0026gt;h_list, h_node) 48\thandler-\u0026gt;disconnect(handle); 49\tWARN_ON(!list_empty(\u0026amp;handler-\u0026gt;h_list)); 50 51\tlist_del_init(\u0026amp;handler-\u0026gt;node); 52 53\tinput_wakeup_procfs_readers(); 54 55\tmutex_unlock(\u0026amp;input_mutex); 56} 57EXPORT_SYMBOL(input_unregister_handler); 注册设备 1/** 2* 注册一个设备 3* input_register_device - register device with input core 4* @dev: device to be registered 5* 6* This function registers device with input core. The device must be 7* allocated with input_allocate_device() and all it\u0026#39;s capabilities 8* set up before registering. 9* If function fails the device must be freed with input_free_device(). 10* Once device has been successfully registered it can be unregistered 11* with input_unregister_device(); input_free_device() should not be 12* called in this case. 13* 14* Note that this function is also used to register managed input devices 15* (ones allocated with devm_input_allocate_device()). Such managed input 16* devices need not be explicitly unregistered or freed, their tear down 17* is controlled by the devres infrastructure. It is also worth noting 18* that tear down of managed input devices is internally a 2-step process: 19* registered managed input device is first unregistered, but stays in 20* memory and can still handle input_event() calls (although events will 21* not be delivered anywhere). The freeing of managed input device will 22* happen later, when devres stack is unwound to the point where device 23* allocation was made. 24*/ 25int input_register_device(struct input_dev *dev) 26{ 27\tstruct input_devres *devres = NULL; 28\tstruct input_handler *handler; 29\tunsigned int packet_size; 30\tconst char *path; 31\tint error; 32 33\tif (dev-\u0026gt;devres_managed) { 34\tdevres = devres_alloc(devm_input_device_unregister, 35\tsizeof(struct input_devres), GFP_KERNEL); 36\tif (!devres) 37\treturn -ENOMEM; 38 39\tdevres-\u0026gt;input = dev; 40\t} 41 42\t/* Every input device generates EV_SYN/SYN_REPORT events. */ 43\t__set_bit(EV_SYN, dev-\u0026gt;evbit); 44 45\t/* KEY_RESERVED is not supposed to be transmitted to userspace. */ 46\t__clear_bit(KEY_RESERVED, dev-\u0026gt;keybit); 47 48\t/* Make sure that bitmasks not mentioned in dev-\u0026gt;evbit are clean. */ 49\tinput_cleanse_bitmasks(dev); 50 51\tpacket_size = input_estimate_events_per_packet(dev); 52\tif (dev-\u0026gt;hint_events_per_packet \u0026lt; packet_size) 53\tdev-\u0026gt;hint_events_per_packet = packet_size; 54 55\tdev-\u0026gt;max_vals = dev-\u0026gt;hint_events_per_packet + 2; 56\tdev-\u0026gt;vals = kcalloc(dev-\u0026gt;max_vals, sizeof(*dev-\u0026gt;vals), GFP_KERNEL); 57\tif (!dev-\u0026gt;vals) { 58\terror = -ENOMEM; 59\tgoto err_devres_free; 60\t} 61 62\t/* 63* If delay and period are pre-set by the driver, then autorepeating 64* is handled by the driver itself and we don\u0026#39;t do it in input.c. 65*/ 66\tif (!dev-\u0026gt;rep[REP_DELAY] \u0026amp;\u0026amp; !dev-\u0026gt;rep[REP_PERIOD]) { 67\tdev-\u0026gt;timer.data = (long) dev; 68\tdev-\u0026gt;timer.function = input_repeat_key; 69\tdev-\u0026gt;rep[REP_DELAY] = 250; 70\tdev-\u0026gt;rep[REP_PERIOD] = 33; 71\t} 72 73\tif (!dev-\u0026gt;getkeycode) 74\tdev-\u0026gt;getkeycode = input_default_getkeycode; 75 76\tif (!dev-\u0026gt;setkeycode) 77\tdev-\u0026gt;setkeycode = input_default_setkeycode; 78 79\terror = device_add(\u0026amp;dev-\u0026gt;dev); 80\tif (error) 81\tgoto err_free_vals; 82 83\tpath = kobject_get_path(\u0026amp;dev-\u0026gt;dev.kobj, GFP_KERNEL); 84\tpr_info(\u0026#34;%s as %s\\n\u0026#34;, 85\tdev-\u0026gt;name ? dev-\u0026gt;name : \u0026#34;Unspecified device\u0026#34;, 86\tpath ? path : \u0026#34;N/A\u0026#34;); 87\tkfree(path); 88 89\terror = mutex_lock_interruptible(\u0026amp;input_mutex); 90\tif (error) 91\tgoto err_device_del; 92 93\tlist_add_tail(\u0026amp;dev-\u0026gt;node, \u0026amp;input_dev_list); 94 95\tlist_for_each_entry(handler, \u0026amp;input_handler_list, node) 96\tinput_attach_handler(dev, handler); 97 98\tinput_wakeup_procfs_readers(); 99 100\tmutex_unlock(\u0026amp;input_mutex); 101 102\tif (dev-\u0026gt;devres_managed) { 103\tdev_dbg(dev-\u0026gt;dev.parent, \u0026#34;%s: registering %s with devres.\\n\u0026#34;, 104\t__func__, dev_name(\u0026amp;dev-\u0026gt;dev)); 105\tdevres_add(dev-\u0026gt;dev.parent, devres); 106\t} 107\treturn 0; 108 109err_device_del: 110\tdevice_del(\u0026amp;dev-\u0026gt;dev); 111err_free_vals: 112\tkfree(dev-\u0026gt;vals); 113\tdev-\u0026gt;vals = NULL; 114err_devres_free: 115\tdevres_free(devres); 116\treturn error; 117} 118EXPORT_SYMBOL(input_register_device); 119 120/** 121* 解除注册设备 122* input_unregister_device - unregister previously registered device 123* @dev: device to be unregistered 124* 125* This function unregisters an input device. Once device is unregistered 126* the caller should not try to access it as it may get freed at any moment. 127*/ 128void input_unregister_device(struct input_dev *dev) 129{ 130\tif (dev-\u0026gt;devres_managed) { 131\tWARN_ON(devres_destroy(dev-\u0026gt;dev.parent, 132\tdevm_input_device_unregister, 133\tdevm_input_device_match, 134\tdev)); 135\t__input_unregister_device(dev); 136\t/* 137* We do not do input_put_device() here because it will be done 138* when 2nd devres fires up. 139*/ 140\t} else { 141\t__input_unregister_device(dev); 142\tinput_put_device(dev); 143\t} 144} 145EXPORT_SYMBOL(input_unregister_device); ","date":"Oct 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/input_drive/","series":null,"tags":[],"title":"输入子系统"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/slab/","series":null,"tags":[],"title":"Slab"},{"categories":[],"content":"MMU内存管理单元  ARM内存管理单元分析\n ","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/mmu/","series":null,"tags":[],"title":"Mmu"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/page/","series":null,"tags":[],"title":"Page"},{"categories":[],"content":"fork  linux创建线程的函数 fork \u0026ndash;\u0026gt; do_fork\n do_fork的执行线路 do_fork \u0026ndash;\u0026gt; copy_process \u0026ndash;\u0026gt; get_task_pid \u0026ndash;\u0026gt; wake_up_new_task \u0026ndash;\u0026gt; put_pid\ndo_fork函数原型\n1long _do_fork(unsigned long clone_flags, 2\tunsigned long stack_start, 3\tunsigned long stack_size, 4\tint __user *parent_tidptr, 5\tint __user *child_tidptr, 6\tunsigned long tls);  clone_flags stack_start stack_size parent_tidptr child_tidptr tls  copy_process get_task_pid wake_up_new_task ","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/fork/","series":null,"tags":[],"title":"Fork"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/task/","series":null,"tags":[],"title":"任务管理"},{"categories":["linux"],"content":"系统调度 调度核心函数实现 1static void __sched notrace __schedule(bool preempt) 2{ 3\tstruct task_struct *prev, *next; 4\tunsigned long *switch_count; 5\tstruct rq_flags rf; 6\tstruct rq *rq; 7\tint cpu; 8 9\tcpu = smp_processor_id(); 10\trq = cpu_rq(cpu); 11\tprev = rq-\u0026gt;curr; 12 13\tschedule_debug(prev); 14 15\tif (sched_feat(HRTICK)) 16\thrtick_clear(rq); 17 18\tlocal_irq_disable(); 19\trcu_note_context_switch(preempt); 20 21\trq_lock(rq, \u0026amp;rf); 22\tsmp_mb__after_spinlock(); 23 24\trq-\u0026gt;clock_update_flags \u0026lt;\u0026lt;= 1; 25\tupdate_rq_clock(rq); 26 27\tswitch_count = \u0026amp;prev-\u0026gt;nivcsw; 28\tif (!preempt \u0026amp;\u0026amp; prev-\u0026gt;state) { 29\tif (unlikely(signal_pending_state(prev-\u0026gt;state, prev))) { 30\tprev-\u0026gt;state = TASK_RUNNING; 31\t} else { 32\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK); 33\tprev-\u0026gt;on_rq = 0; 34 35\tif (prev-\u0026gt;in_iowait) { 36\tatomic_inc(\u0026amp;rq-\u0026gt;nr_iowait); 37\tdelayacct_blkio_start(); 38\t} 39\tif (prev-\u0026gt;flags \u0026amp; PF_WQ_WORKER) { 40\tstruct task_struct *to_wakeup; 41 42\tto_wakeup = wq_worker_sleeping(prev); 43\tif (to_wakeup) 44\ttry_to_wake_up_local(to_wakeup, \u0026amp;rf); 45\t} 46\t} 47\tswitch_count = \u0026amp;prev-\u0026gt;nvcsw; 48\t} 49 50\tnext = pick_next_task(rq, prev, \u0026amp;rf); 51\tclear_tsk_need_resched(prev); 52\tclear_preempt_need_resched(); 53 54\tif (likely(prev != next)) { 55\trq-\u0026gt;nr_switches++; 56\trq-\u0026gt;curr = next; 57\t++*switch_count; 58 59\ttrace_sched_switch(preempt, prev, next); 60\trq = context_switch(rq, prev, next, \u0026amp;rf); 61\t} else { 62\trq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); 63\trq_unlock_irq(rq, \u0026amp;rf); 64\t} 65 66\tbalance_callback(rq); 67} 寻找最高优先级任务 1/* 2* Pick up the highest-prio task: 3*/ 4static inline struct task_struct * 5pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) 6{ 7\tconst struct sched_class *class; 8\tstruct task_struct *p; 9 10\t/* 11* Optimization: we know that if all tasks are in the fair class we can 12* call that function directly, but only if the @prev task wasn\u0026#39;t of a 13* higher scheduling class, because otherwise those loose the 14* opportunity to pull in more work from other CPUs. 15*/ 16\tif (likely((prev-\u0026gt;sched_class == \u0026amp;idle_sched_class || 17\tprev-\u0026gt;sched_class == \u0026amp;fair_sched_class) \u0026amp;\u0026amp; 18\trq-\u0026gt;nr_running == rq-\u0026gt;cfs.h_nr_running)) { 19 20\tp = fair_sched_class.pick_next_task(rq, prev, rf); 21\tif (unlikely(p == RETRY_TASK)) 22\tgoto again; 23 24\t/* Assumes fair_sched_class-\u0026gt;next == idle_sched_class */ 25\tif (unlikely(!p)) 26\tp = idle_sched_class.pick_next_task(rq, prev, rf); 27 28\treturn p; 29\t} 30 31again: 32\tfor_each_class(class) { 33\tp = class-\u0026gt;pick_next_task(rq, prev, rf); 34\tif (p) { 35\tif (unlikely(p == RETRY_TASK)) 36\tgoto again; 37\treturn p; 38\t} 39\t} 40 41\t/* The idle class should always have a runnable task: */ 42\tBUG(); 43} 任务切换 1static __always_inline struct rq * 2context_switch(struct rq *rq, struct task_struct *prev, 3\tstruct task_struct *next, struct rq_flags *rf) 4{ 5\tstruct mm_struct *mm, *oldmm; 6 7\tprepare_task_switch(rq, prev, next); 8 9\tmm = next-\u0026gt;mm; 10\toldmm = prev-\u0026gt;active_mm; 11\t/* 12* For paravirt, this is coupled with an exit in switch_to to 13* combine the page table reload and the switch backend into 14* one hypercall. 15*/ 16\tarch_start_context_switch(prev); 17 18\t/* 19* If mm is non-NULL, we pass through switch_mm(). If mm is 20* NULL, we will pass through mmdrop() in finish_task_switch(). 21* Both of these contain the full memory barrier required by 22* membarrier after storing to rq-\u0026gt;curr, before returning to 23* user-space. 24*/ 25\tif (!mm) { 26\tnext-\u0026gt;active_mm = oldmm; 27\tmmgrab(oldmm); 28\tenter_lazy_tlb(oldmm, next); 29\t} else 30\tswitch_mm_irqs_off(oldmm, mm, next); 31 32\tif (!prev-\u0026gt;mm) { 33\tprev-\u0026gt;active_mm = NULL; 34\trq-\u0026gt;prev_mm = oldmm; 35\t} 36 37\trq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); 38 39\tprepare_lock_switch(rq, next, rf); 40 41\t/* Here we just switch the register state and the stack. */ 42\tswitch_to(prev, next, prev); 43\tbarrier(); 44 45\treturn finish_task_switch(prev); 46} 定时调度函数 1void scheduler_tick(void) 2{ 3\tint cpu = smp_processor_id(); 4\tstruct rq *rq = cpu_rq(cpu); 5\tstruct task_struct *curr = rq-\u0026gt;curr; 6\tstruct rq_flags rf; 7 8\tsched_clock_tick(); 9 10\trq_lock(rq, \u0026amp;rf); 11 12\tupdate_rq_clock(rq); 13\tcurr-\u0026gt;sched_class-\u0026gt;task_tick(rq, curr, 0); 14\tcpu_load_update_active(rq); 15\tcalc_global_load_tick(rq); 16 17\trq_unlock(rq, \u0026amp;rf); 18 19\tperf_event_task_tick(); 20 21#ifdef CONFIG_SMP 22\trq-\u0026gt;idle_balance = idle_cpu(cpu); 23\ttrigger_load_balance(rq); 24#endif 25} ","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/sched/","series":null,"tags":["kernel"],"title":"系统调度"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/rime/","series":null,"tags":[],"title":"Rime"},{"categories":[],"content":"WASM笔记 ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/wasm/","series":null,"tags":[],"title":"Wasm"},{"categories":[],"content":"jupyter 安装 1conda install jupyter 基本配置 生成配置 1jupyter notebook --generate-config 自动生成配置文件 ~/.jupyter/jupyter_notebook_config.py\n设置密码 1jupyter notebook password  ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/jupyter/","series":null,"tags":[],"title":"Jupyter"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/conda/","series":null,"tags":[],"title":"Conda"},{"categories":[],"content":"RUST学习笔记\n====\n安装  添加环境变量.bashrc/profile  1set RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 2set RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 安装工具链  1curl https://mirrors.ustc.edu.cn/rust-static/rustup/rustup-init.sh | sh 设置rust的环境变量.bashrc/profile  1source ~/.cargo/env 2set PATH=~/.cargo/bin;$PATH 入门基础 HelloWorld  创建工程  1cargo new hello_world 编译  1cargo build 运行  1cargo run 数据类型    长度 有符号 无符号     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128   arch isize usize    1// 创建变量 2let_xi32: i32 =5;3let_xu32: u32 =5;4let_xi64: i64 =10;5let_xu64: u64 =10;6let_xi128: i128=5;7let_xu128: u128=5;8let_xisize: isize =10;9let_xusize: usize =10;函数 1// 有返回值 2fn function_return()-\u0026gt; i32 {3println!(\u0026#34;Hello, World!\u0026#34;);4return0;5}67// 无返回值 8fn function_noreturn(){9println!(\u0026#34;Hello, World!\u0026#34;);10} 必须明确表示是否存在返回值 语法校验比较严格,  条件语句 1if\u0026lt;cond\u0026gt;{2do;3}1if\u0026lt;cond\u0026gt;{2Do1;3}else{4Do2;5}1if\u0026lt;cond1\u0026gt;{2Do1;3}elseif\u0026lt;cond2\u0026gt;{4Do2;5}else{6Do3;7}","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/rust/","series":null,"tags":[],"title":"Rust"},{"categories":[],"content":"C++基础语法 第一个程序 1#include \u0026lt;iostream\u0026gt;2 3using namespace std; 4 5int main(int argc, char *argv[]) 6{ 7\tcout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; 8\treturn 0; 9} 注释类型  单行注释  1// 这个是一个单行注释  多行注释  1/* 2这个里面是一个注释 3*/ 变量 变量的存在意义:方便我们管理内存\n变量创建的语法\n1数据类型 变量名 = 变量初始化; 常量 作用: 记录程序中不可以改变的数据\n define 宏常量(预编译期) const 修饰变量(编译期)  关键字    关键字        asm else new this   auto enum operator throw   bool explicit private true   break export protected try   case extern public typedef   catch false register typeid   char float reinterpret_cast typename   class for return union   const friend short unsigned   const_cast goto signed using   continue if sizeof virtual   default inline static void   delete int static_cast volatile   do long struct wchar_t   double mutable switch while   dynamic_cast namespace template     标识符命名规则  标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写  数据类型 指定类型,分配内存\n整形 浮点型  单精度float 双精度double  字符型 转义字符 字符串  C风格  1char 变量名[] = \u0026#34;字符串值\u0026#34;; C++风格  1string 变量名 = \u0026#34;字符串值\u0026#34;; 布尔类型 1bool A = true; 2bool B = false; 运算符 基本运算符 取模运算 就是取余数\n自增自减运算 1a1++; 2a2--; 赋值运算    运算符 术语 示例 结果     =      +=      -=      *=      /=      %=       比较运算符 逻辑运算符 程序流程结构 顺序结构 if语句 三目运算符 1表达式1? 表达式2:表达式3 选择结构 1switch(condition) 2{ 3case 条件1: 4\tbreak; 5case 条件2: 6\tbreak; 7default: 8\tbreak; 9} 循环结构 while循环 1while(条件) 2{ 3\t循环体; 4} dowhile循环 1do { 2 3} while(条件) for循环 1for (起始表达式; 条件表达式; 末尾循环体) 2{ 3\t循环体; 4} 跳转语句 break continue goto 数组 函数定义  返回值类型 函数名 参数列表 函数体语句 return表达式  1返回值类型 函数名字(参数列表) 2{ 3\t函数体语句; 4\treturn 表达式; 5} 值传递 类似数值拷贝\n函数的常见样式  无参无返 有参无返 无参有反 有参有返  函数的声明 作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现;\n函数的分文件编写 指针 指针的定义和使用 指针所占用空间 空指针 含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的\n野指针 指针指向非法的内存空间\nconst与指针  const修饰指针 const修饰常量 const既修饰指针又修饰常量  1const int *p = \u0026amp;a; 2 3int const *p = \u0026amp;a; 4 5const int *const p = \u0026amp;a; 指针与数组 指针与函数 结构体 结构体数组 结构体指针 结构体嵌套 C++核心编程 本阶段主要对面向对象进行详细讲解\nC++内存分区 c++程序在运行时,将内存分为4个区域\n 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放  new/delete操作符 C++利用new操作符在堆区开辟内存\n引用 作用: 给变量起别名 语法: 数据类型 \u0026amp;别名 = 原名;\n引用做参数 1#include \u0026lt;iostream\u0026gt;2void swap(int \u0026amp;a, int \u0026amp;b) 3{ 4 int t; t = a;a = b;b = t; 5} 6int main(int argc, char *argv[]) 7{ 8 int a = 10;int b = 12; 9 std::cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 10 swap(a, b); 11 std::cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 12 return 0; 13} 执行结果\n引用做返回值 引用的本质 引用的本质是C++内部实现的一个指针常量\n常量引用 1const int \u0026amp;ref = 10; 函数提高 函数默认值  某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突)  1void test_default_param(int a = 0, int b = 0, int c = 0) 2{ 3 std::cout \u0026lt;\u0026lt; a + b + c \u0026lt;\u0026lt; std::endl; 4} 函数的占位参数 占位参数还可以有默认值\n1void test(int a, int = 10) { 2 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; 3} 函数重载 作用:函数名相同,提高复用性\n重载的条件:\n  相同作用域\n  函数名相同\n  参数不同(类型, 个数,顺序)\n  注意事项:\n 引用作为重载条件 函数重载碰到默认参数  类和对象 类的访问属性\n public: protected: private:  class与struct的区别 class默认权限是private struct默认权限是public\n构造函数和析构函数 对象的初始化和清理\n 构造函数有参数 析构函数没有参数 二者都没有返回值  拷贝构造函数 1class Person { 2public: 3 /* 构造函数 */ 4 Person(std::string name, int age) { 5 std::cout \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 6 } 7 /* 析构函数 */ 8 ~Person() { 9 std::cout \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; std::endl; 10 } 11 /* 拷贝构造函数 */ 12 Person(const Person \u0026amp;p) { 13 std::cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 14 } 15};  调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果  1Person testPerson();\t// 表面上是执行构造函数 2int func();\t// 类似函数声明 拷贝构造函数的调用时机  使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象  构造函数的调用规则 默认情况下:C++编译器至少给一个类添加3个函数\n 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝  构造函数构造规则如下:\n 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数  深拷贝和浅拷贝  浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作  初始化列表 作用:C++提供了初始化列表语法,用来初始化属性;\n语法:\n1构造函数(): 属性1(值1),属性2(值2),属性3(值3) 2{ 3\t/* 函数体 */ 4} 类对象作为类成员 静态成员 静态成员就是在静态成员变量和成员函数前加上static,称为静态成员;\n 静态成员变量  所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化   静态成员函数  所有对象共享同一个函数 静态成员函数只能访问静态成员变量    1class Person { 2public: 3 static int age; 4 static void func() 5 { 6 std::cout \u0026lt;\u0026lt; \u0026#34;静态成员函数\u0026#34; \u0026lt;\u0026lt; std::endl; 7 } 8}; 9/* 通过对象访问 */ 10Person p; 11p.func(); 12/* 通过类访问 */ 13Person::func(); 成员变量和成员函数分开存储  非静态成员,\t属于类的对象 静态成员,\t不属于类的对象 非静态成员函数,\t不属于类的对象 静态成员函数, 不属于类的对象  空对象大小为1\nC++对象模型 this指针 this指针指向被调用成员函数所属的对象 this指针本质：指针常量\n空指针访问成员函数 C++空指针也是可以访问成员函数的,但是要注意的this指针;\nconst修饰成员函数 常函数:\n 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数  执行原理\n1this ==\u0026gt; Person * const this; 2后面新追加的const则会造成 3const Person * const this; 1class Person { 2public: 3 int m_A; 4 mutable int m_B; 5 void showPerson() const 6 { 7 m_A = 10; /* 错误,不可修改 */ 8 m_B = 10; /* 正确,可以修改 */ 9 } 10}; 友元  全局函数 全局类 成员函数  运算符重载 重载的原理:对已有的运算符进行重新定义,赋予新的功能含义;\n通过成员函数重载运算符 1class Person { 2public: 3 int m_A; 4 int m_B; 5 6 /* 使用成员函数实现 */ 7 Person PersonAddPerson(Person \u0026amp;p) 8 { 9 Person t; 10 t.m_A = this-\u0026gt;m_A + p.m_A; 11 t.m_B = this-\u0026gt;m_B + p.m_B; 12 return t; 13 } 14 15 /* 重载+ */ 16 Person operator+(Person \u0026amp;p) 17 { 18 Person t; 19 t.m_A = this-\u0026gt;m_A + p.m_A; 20 t.m_B = this-\u0026gt;m_B + p.m_B; 21 return t; 22 } 23}; 24 25int main(int argc, char *argv[]) 26{ 27 Person p1; 28 Person p2; 29 30 Person p3 = p1.PersonAddPerson(p2); 31 32 Person p4 = p1.operator+(p2); 33 34 Person p5 = p1 + p2; 35 36 return 0; 37} 通过全局函数重载 1Person operator+(Person \u0026amp;p1, Person \u0026amp;p2) 2{ 3 Person t; 4 t.m_A = p1.m_A + p2.m_A; 5 t.m_B = p2.m_B + p2.m_B; 6 return t; 7} 重载左移运算符 1std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Person \u0026amp;p) 2{ 3 cout \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; p.m_B; 4 return cout; 5} 递增重载++ 注意:\n 前置递增 p++ 后置递增 ++p  重载例子(复数) 1#include \u0026lt;iostream\u0026gt;2 3class Complex { 4 friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p); 5 6public: 7 Complex(int i, int j); 8 9 Complex(); 10 11 /* 重载+ */ 12 Complex operator+(Complex \u0026amp;p) 13 { 14 Complex t; 15 t.i = this-\u0026gt;i + p.i; 16 t.j = this-\u0026gt;j + p.j; 17 return t; 18 } 19 /* 重载前置++ */ 20 Complex\u0026amp; operator++() 21 { 22 this-\u0026gt;i++; 23 this-\u0026gt;j++; 24 return *this; 25 } 26 27 /* 重载后置++ */ 28 Complex operator++(int) 29 { 30 Complex t; 31 32 /* 记录 */ 33 t.i = this-\u0026gt;i; 34 t.j = this-\u0026gt;j; 35 36 /* 递增 */ 37 this-\u0026gt;i++; 38 this-\u0026gt;j++; 39 40 return t; 41 } 42 43 /* 重载= */ 44 Complex\u0026amp; operator=(Complex \u0026amp;p) 45 { 46 this-\u0026gt;i = p.i; 47 this-\u0026gt;j = p.j; 48 49 return *this; 50 } 51private: 52 int i; /* 实部 */ 53 int j; /* 虚部 */ 54}; 55 56/* 构造函数 */ 57Complex::Complex(int i, int j) 58{ 59 this-\u0026gt;i = i; 60 this-\u0026gt;j = j; 61} 62 63Complex::Complex() 64{ 65 this-\u0026gt;i = 0; 66 this-\u0026gt;j = 0; 67} 68 69std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p) 70{ 71 cout \u0026lt;\u0026lt; p.i \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; p.j \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; 72 return cout; 73} 74 75int main(int argc, char *argv[]) 76{ 77 Complex p1(1, 2); 78 Complex p2(3, 4); 79 80 std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; std::endl; 81 std::cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl; 82 std::cout \u0026lt;\u0026lt; p1 + p2 \u0026lt;\u0026lt; std::endl; 83 84 std::cout \u0026lt;\u0026lt; ++p1 \u0026lt;\u0026lt; std::endl; 85 std::cout \u0026lt;\u0026lt; p2++ \u0026lt;\u0026lt; std::endl; 86 87 Complex p3 = p2 = p1; 88 std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p3 \u0026lt;\u0026lt; std::endl; 89 90 return 0; 91} 继承 减少重复代码\n1class 子类 : 继承方式 父类 父类:基类 子类:派生类\n继承方式  公共继承 保护继承 私有继承  继承中的对象模型 构造和析构的顺序  先构造父类再构造子类 先析构子类再析构父类\n 继承中同名成员处理  访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A  多重继承 C++允许一个类继承多个基类\n1class 子类 : 继承方式 父类1, 继承方式 父类2...  冲突解决：加上类名\n 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。\n 多重继承数据会产生二义性 数据只需要一份即可  1/* 动物类 */ 2class Animal { 3public: 4 int m_age; 5}; 6class Sheep : public Animal {}; /* 羊类 */ 7class Camel : public Animal {}; /* 驼类 */ 8class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ 9int main(int argc, char *argv[]) 10{ 11 Alpaca a; 12 a.Sheep::m_age = 18; 13 a.Camel::m_age = 18; 14 return 0; 15}  虚继承\n 1class Sheep : virtual public Animal {}; /* 羊类 */ 2class Camel : virtual public Animal {}; /* 驼类 */ 虚基类指针(vbptr) vbptr \u0026ndash;\u0026gt; vbtable\n多态  分类  静态多态: 重载 动态多态:虚函数   区别  静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址    父类接收子类的对象,在程序运行期间确定具体改调用那个函数;\n  有继承关系\n  子类重写父类的虚函数 重写：函数完全一致\n  纯虚函数  只要有一个纯虚函数，就称为抽象类\n  抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类  原理 虚析构和纯虚析构 C++提高编程  泛型编程/STL\n 模版 建立通用的模板,提高复用；\nC++提供两种模版机制:函数模版和类模板\n函数模版 1template \u0026lt;typename T\u0026gt; 2函数声明和定义  template \u0026ndash; 声明创建模版 typename \u0026ndash; 表明后面的符号是数据类型可以用class代替 T \u0026ndash; 通用的数据类型  实例 1/* 两个数据交换 */ 2template \u0026lt;typename T\u0026gt; 3void swap(T \u0026amp;a, T \u0026amp;b) 4{ 5 T t= a; a = b; b = t; 6} 注意事项  自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用  普通函数和函数模版的区别  普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换  模版函数\n1template \u0026lt;typename T\u0026gt; 2T add(T a, T b) 3{ 4 return a + b; 5} 调用方法\n1/* 自动推导 */ 2std::cout \u0026lt;\u0026lt; add(10, 20) \u0026lt;\u0026lt; std::endl; 3/* 显示指定 */ 4std::cout \u0026lt;\u0026lt; add\u0026lt;int\u0026gt;(10, 3.14) \u0026lt;\u0026lt; std::endl; 普通函数和模版函数调用规则  普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u0026lt;\u0026gt;(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版  类模板 1template \u0026lt;class T\u0026gt; 2类 例子\n1template \u0026lt;class NameType, class AgeType\u0026gt; 2class Person { 3public: 4 Person(NameType Name, AgeType Age) 5 { 6 m_Name = Name; 7 m_Age = Age; 8 } 9 NameType m_Name; 10 AgeType m_Age; 11}; 调用\n1Person\u0026lt;std::string, int\u0026gt; p(\u0026#34;Hello\u0026#34;, 99); ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/c++/","series":null,"tags":[],"title":"C++笔记"},{"categories":[],"content":"doxygen教程 开始 ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/doxygen/","series":null,"tags":[],"title":"Doxygen"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/engineering_compiler/","series":null,"tags":["compiler"],"title":"Engineering_compiler"},{"categories":[],"content":"简述  驱动模型\n    顶级kobject 解释     block 块设备链接\u0026ndash;\u0026gt;/sys/deives相关文件   bus 存放各种总线文件   class 各种设备类   dev 存放(字符/块)设备主副设备号链接文件\u0026ndash;\u0026gt;/sys/deives   devices 设备的具体存放文件   firmware 固件存放   fs 文件类型   kernel kernel子系统   module 模块信息   power 能源管理    底层机制 kobject  内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面\n 数据结构 1struct kobject { 2\tconst char\t*name;\t/* 名字 */ 3\tstruct list_head\tentry;\t/* 链表:链接进入kset */ 4\tstruct kobject\t*parent;\t/* 指向父对象,建立层次结构 */ 5\tstruct kset\t*kset;\t/* 对象集合 */ 6\tstruct kobj_type\t*ktype;\t/* 对象类型 */ 7\tstruct kernfs_node\t*sd; /* sysfs directory entry */ 8\tstruct kref\tkref;\t/* 引用计数 */ 9 10 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE 11\tstruct delayed_work\trelease; 12\t#endif 13\t14 unsigned int state_initialized:1;\t/* 标志位:初始化 */ 15\tunsigned int state_in_sysfs:1;\t/* 标志位:在sysfs中 */ 16\tunsigned int state_add_uevent_sent:1;\t/* 标志位:发出KOBJ_ADD uevent */ 17\tunsigned int state_remove_uevent_sent:1;\t/* 标志位:发出KOBJ_REMOVE uevent */ 18\tunsigned int uevent_suppress:1;\t/* 标志位:禁止发出uevent */ 19}; 初始化 1/** 2* kobject_init - initialize a kobject structure 3* @kobj: pointer to the kobject to initialize 4* @ktype: pointer to the ktype for this kobject. 5* 6* This function will properly initialize a kobject such that it can then 7* be passed to the kobject_add() call. 8* 9* After this function is called, the kobject MUST be cleaned up by a call 10* to kobject_put(), not by a call to kfree directly to ensure that all of 11* the memory is cleaned up properly. 12*/ 13void kobject_init(struct kobject *kobj, struct kobj_type *ktype) 14{ 15\tchar *err_str;\t/** 错误信息 */ 16 17\t/** 校验参数NULL */ 18\tif (!kobj) { 19\terr_str = \u0026#34;invalid kobject pointer!\u0026#34;; 20\tgoto error; 21\t} 22\tif (!ktype) { 23\terr_str = \u0026#34;must have a ktype to be initialized properly!\\n\u0026#34;; 24\tgoto error; 25\t} 26 27\t/** kobject是否已经初始化 */ 28\tif (kobj-\u0026gt;state_initialized) { 29\t/* do not error out as sometimes we can recover */ 30\tpr_err(\u0026#34;kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\u0026#34;, 31\tkobj); 32\tdump_stack(); /** 回溯堆栈 */ 33\t} 34 35\t/** 调用具体初始化函数 */ 36\tkobject_init_internal(kobj); 37 38\t/* 设置类型 */ 39\tkobj-\u0026gt;ktype = ktype; 40\treturn; 41 42error: 43\tpr_err(\u0026#34;kobject (%p): %s\\n\u0026#34;, kobj, err_str); 44\tdump_stack(); 45} 46EXPORT_SYMBOL(kobject_init); 添加 1int kobject_add(struct kobject *kobj, /* 需要添加kobject */ 2\tstruct kobject *parent, /* 父指针 */ 3\tconst char *fmt, ...) /* 命名 */ 4{ 5\tva_list args; 6\tint retval; 7\t8\t/* 校验kobject */ 9\tif (!kobj) 10\treturn -EINVAL; 11\t12\t/* 是否已经初始化 */ 13\tif (!kobj-\u0026gt;state_initialized) { 14\tpr_err(\u0026#34;kobject \u0026#39;%s\u0026#39; (%p): tried to add an uninitialized object, something is seriously wrong.\\n\u0026#34;, 15\tkobject_name(kobj), kobj); 16\tdump_stack(); 17\treturn -EINVAL; 18\t} 19\tva_start(args, fmt); 20\t/* 设置名字并且将父指针添加到parent */ 21\tretval = kobject_add_varg(kobj, parent, fmt, args); 22\tva_end(args); 23\t24\treturn retval; 25} 最终调用添加函数\n1static int kobject_add_internal(struct kobject *kobj) 2{ 3\tint error = 0; 4\tstruct kobject *parent; 5\t6 /* 判断参数NULL */ 7\tif (!kobj) 8\treturn -ENOENT; 9\t10 /* 判断名字是否有效 */ 11\tif (!kobj-\u0026gt;name || !kobj-\u0026gt;name[0]) { 12\tWARN(1, 13\t\u0026#34;kobject: (%p): attempted to be registered with empty name!\\n\u0026#34;, 14\tkobj); 15\treturn -EINVAL; 16\t} 17\t18 /** 获取父指针 */ 19\tparent = kobject_get(kobj-\u0026gt;parent); 20 21\t/* join kset if set, use it as parent if we do not already have one */ 22\tif (kobj-\u0026gt;kset) {\t/* kset已经设置 */ 23\tif (!parent)\t/* 不存在父指针 */ 24\t/* kset的kobject作为父指针 */ 25 parent = kobject_get(\u0026amp;kobj-\u0026gt;kset-\u0026gt;kobj); 26\t/* 将kobject加入kset */ 27 kobj_kset_join(kobj); 28\t29 /* 保存父指针 */ 30 kobj-\u0026gt;parent = parent; 31\t} 32 33\tpr_debug(\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): %s: parent: \u0026#39;%s\u0026#39;, set: \u0026#39;%s\u0026#39;\\n\u0026#34;, 34\tkobject_name(kobj), kobj, __func__, 35\tparent ? kobject_name(parent) : \u0026#34;\u0026lt;NULL\u0026gt;\u0026#34;, 36\tkobj-\u0026gt;kset ? kobject_name(\u0026amp;kobj-\u0026gt;kset-\u0026gt;kobj) : \u0026#34;\u0026lt;NULL\u0026gt;\u0026#34;); 37\t38 /* 创建dir */ 39\terror = create_dir(kobj); 40\tif (error) { /* 出错,清理 */ 41\tkobj_kset_leave(kobj); 42\tkobject_put(parent); 43\tkobj-\u0026gt;parent = NULL; 44 45\t/* be noisy on error issues */ 46\tif (error == -EEXIST) 47\tpr_err(\u0026#34;%s failed for %s with -EEXIST, don\u0026#39;t try to register things with the same name in the same directory.\\n\u0026#34;, 48\t__func__, kobject_name(kobj)); 49\telse 50\tpr_err(\u0026#34;%s failed for %s (error: %d parent: %s)\\n\u0026#34;, 51\t__func__, kobject_name(kobj), error, 52\tparent ? kobject_name(parent) : \u0026#34;\u0026#39;none\u0026#39;\u0026#34;); 53\t} else 54\tkobj-\u0026gt;state_in_sysfs = 1; /* 添加到sysfs中 */ 55 56\treturn error; 57} sysfs文件夹生成 1static int create_dir(struct kobject *kobj) 2{ 3\tconst struct kobj_ns_type_operations *ops; 4\tint error; 5 6\terror = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); 7\tif (error) 8\treturn error; 9 10\terror = populate_dir(kobj); 11\tif (error) { 12\tsysfs_remove_dir(kobj); 13\treturn error; 14\t} 15 16\t/* 17* @kobj-\u0026gt;sd may be deleted by an ancestor going away. Hold an 18* extra reference so that it stays until @kobj is gone. 19*/ 20\tsysfs_get(kobj-\u0026gt;sd); 21 22\t/* 23* If @kobj has ns_ops, its children need to be filtered based on 24* their namespace tags. Enable namespace support on @kobj-\u0026gt;sd. 25*/ 26\tops = kobj_child_ns_ops(kobj); 27\tif (ops) { 28\tBUG_ON(ops-\u0026gt;type \u0026lt;= KOBJ_NS_TYPE_NONE); 29\tBUG_ON(ops-\u0026gt;type \u0026gt;= KOBJ_NS_TYPES); 30\tBUG_ON(!kobj_ns_type_registered(ops-\u0026gt;type)); 31 32\tsysfs_enable_ns(kobj-\u0026gt;sd); 33\t} 34 35\treturn 0; 36} 删除 1void kobject_del(struct kobject *kobj) 2{ 3\tstruct kernfs_node *sd; 4 5\tif (!kobj) 6\treturn; 7 8\tsd = kobj-\u0026gt;sd; 9\tsysfs_remove_dir(kobj); 10\tsysfs_put(sd); 11 12\tkobj-\u0026gt;state_in_sysfs = 0; 13\tkobj_kset_leave(kobj); 14\tkobject_put(kobj-\u0026gt;parent); 15\tkobj-\u0026gt;parent = NULL; 16} 引用计数 1struct kobject *kobject_get(struct kobject *kobj) 2{ 3\tif (kobj) { 4\tif (!kobj-\u0026gt;state_initialized) 5\tWARN(1, KERN_WARNING 6\t\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): is not initialized, yet kobject_get() is being called.\\n\u0026#34;, 7\tkobject_name(kobj), kobj); 8\tkref_get(\u0026amp;kobj-\u0026gt;kref); 9\t} 10\treturn kobj; 11} 12 13void kobject_put(struct kobject *kobj) 14{ 15\tif (kobj) { 16\tif (!kobj-\u0026gt;state_initialized) 17\tWARN(1, KERN_WARNING 18\t\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): is not initialized, yet kobject_put() is being called.\\n\u0026#34;, 19\tkobject_name(kobj), kobj); 20\tkref_put(\u0026amp;kobj-\u0026gt;kref, kobject_release); 21\t} 22} kset 数据结构 1struct kset { 2\tstruct list_head list; 3\tspinlock_t list_lock; 4\tstruct kobject kobj; 5\tconst struct kset_uevent_ops *uevent_ops; 6} __randomize_layout; ktype 数据结构 1struct kobj_type { 2\tvoid (*release)(struct kobject *kobj); 3\tconst struct sysfs_ops *sysfs_ops; 4\tstruct attribute **default_attrs; 5\tconst struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); 6\tconst void *(*namespace)(struct kobject *kobj); 7\tvoid (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); 8}; class  设备类描述\n 1struct class { 2\tconst char\t*name; 3\tstruct module\t*owner; 4 5\tconst struct attribute_group\t**class_groups; 6\tconst struct attribute_group\t**dev_groups; 7\tstruct kobject\t*dev_kobj; 8 9\tint (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); 10\tchar *(*devnode)(struct device *dev, umode_t *mode); 11 12\tvoid (*class_release)(struct class *class); 13\tvoid (*dev_release)(struct device *dev); 14 15\tint (*shutdown_pre)(struct device *dev); 16 17\tconst struct kobj_ns_type_operations *ns_type; 18\tconst void *(*namespace)(struct device *dev); 19 20\tvoid (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid); 21 22\tconst struct dev_pm_ops *pm; 23 24\tstruct subsys_private *p; 25}; bus  设备总线描述\n 总线类型 1# ls 2amba cpu nvmem platform virtio 3clockevents event_source pci scsi workqueue 4clocksource gpio pci_express serio 5container hid pcmcia spi 其中每一个总线具有如下信息\n1# ls 2devices drivers_autoprobe uevent 3drivers drivers_probe 1struct bus_type { 2\tconst char\t*name; 3\tconst char\t*dev_name; 4\tstruct device\t*dev_root; 5\tconst struct attribute_group **bus_groups; 6\tconst struct attribute_group **dev_groups; 7\tconst struct attribute_group **drv_groups; 8 9\tint (*match)(struct device *dev, struct device_driver *drv); 10\tint (*uevent)(struct device *dev, struct kobj_uevent_env *env); 11\tint (*probe)(struct device *dev); 12\tint (*remove)(struct device *dev); 13\tvoid (*shutdown)(struct device *dev); 14 15\tint (*online)(struct device *dev); 16\tint (*offline)(struct device *dev); 17 18\tint (*suspend)(struct device *dev, pm_message_t state); 19\tint (*resume)(struct device *dev); 20 21\tint (*num_vf)(struct device *dev); 22 23\tint (*dma_configure)(struct device *dev); 24 25\tconst struct dev_pm_ops *pm; 26 27\tconst struct iommu_ops *iommu_ops; 28 29\tstruct subsys_private *p; 30\tstruct lock_class_key lock_key; 31 32\tbool need_parent_lock; 33}; 设备总线注册 1int bus_register(struct bus_type *bus) 2{ 3\tint retval; 4\tstruct subsys_private *priv; 5\tstruct lock_class_key *key = \u0026amp;bus-\u0026gt;lock_key; 6 7\tpriv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); 8\tif (!priv) 9\treturn -ENOMEM; 10 11\tpriv-\u0026gt;bus = bus; 12\tbus-\u0026gt;p = priv; 13 14\tBLOCKING_INIT_NOTIFIER_HEAD(\u0026amp;priv-\u0026gt;bus_notifier); 15 16\tretval = kobject_set_name(\u0026amp;priv-\u0026gt;subsys.kobj, \u0026#34;%s\u0026#34;, bus-\u0026gt;name); 17\tif (retval) 18\tgoto out; 19 20\tpriv-\u0026gt;subsys.kobj.kset = bus_kset; 21\tpriv-\u0026gt;subsys.kobj.ktype = \u0026amp;bus_ktype; 22\tpriv-\u0026gt;drivers_autoprobe = 1; 23 24\tretval = kset_register(\u0026amp;priv-\u0026gt;subsys); 25\tif (retval) 26\tgoto out; 27 28\tretval = bus_create_file(bus, \u0026amp;bus_attr_uevent); 29\tif (retval) 30\tgoto bus_uevent_fail; 31 32\tpriv-\u0026gt;devices_kset = kset_create_and_add(\u0026#34;devices\u0026#34;, NULL, 33\t\u0026amp;priv-\u0026gt;subsys.kobj); 34\tif (!priv-\u0026gt;devices_kset) { 35\tretval = -ENOMEM; 36\tgoto bus_devices_fail; 37\t} 38 39\tpriv-\u0026gt;drivers_kset = kset_create_and_add(\u0026#34;drivers\u0026#34;, NULL, 40\t\u0026amp;priv-\u0026gt;subsys.kobj); 41\tif (!priv-\u0026gt;drivers_kset) { 42\tretval = -ENOMEM; 43\tgoto bus_drivers_fail; 44\t} 45 46\tINIT_LIST_HEAD(\u0026amp;priv-\u0026gt;interfaces); 47\t__mutex_init(\u0026amp;priv-\u0026gt;mutex, \u0026#34;subsys mutex\u0026#34;, key); 48\tklist_init(\u0026amp;priv-\u0026gt;klist_devices, klist_devices_get, klist_devices_put); 49\tklist_init(\u0026amp;priv-\u0026gt;klist_drivers, NULL, NULL); 50 51\tretval = add_probe_files(bus); 52\tif (retval) 53\tgoto bus_probe_files_fail; 54 55\tretval = bus_add_groups(bus, bus-\u0026gt;bus_groups); 56\tif (retval) 57\tgoto bus_groups_fail; 58 59\tpr_debug(\u0026#34;bus: \u0026#39;%s\u0026#39;: registered\\n\u0026#34;, bus-\u0026gt;name); 60\treturn 0; 61 62bus_groups_fail: 63\tremove_probe_files(bus); 64bus_probe_files_fail: 65\tkset_unregister(bus-\u0026gt;p-\u0026gt;drivers_kset); 66bus_drivers_fail: 67\tkset_unregister(bus-\u0026gt;p-\u0026gt;devices_kset); 68bus_devices_fail: 69\tbus_remove_file(bus, \u0026amp;bus_attr_uevent); 70bus_uevent_fail: 71\tkset_unregister(\u0026amp;bus-\u0026gt;p-\u0026gt;subsys); 72out: 73\tkfree(bus-\u0026gt;p); 74\tbus-\u0026gt;p = NULL; 75\treturn retval; 76} 77 设备总线卸载 1void bus_unregister(struct bus_type *bus) 2{ 3\tpr_debug(\u0026#34;bus: \u0026#39;%s\u0026#39;: unregistering\\n\u0026#34;, bus-\u0026gt;name); 4\tif (bus-\u0026gt;dev_root) 5\tdevice_unregister(bus-\u0026gt;dev_root); 6\tbus_remove_groups(bus, bus-\u0026gt;bus_groups); 7\tremove_probe_files(bus); 8\tkset_unregister(bus-\u0026gt;p-\u0026gt;drivers_kset); 9\tkset_unregister(bus-\u0026gt;p-\u0026gt;devices_kset); 10\tbus_remove_file(bus, \u0026amp;bus_attr_uevent); 11\tkset_unregister(\u0026amp;bus-\u0026gt;p-\u0026gt;subsys); 12} devices  设备文件具体描述: device(设备描述) device_driver(驱动描述) bus_type(总线信息)\n 1|-- breakpoint 2|-- kprobe 3|-- platform 4|-- software 5|-- system 6|-- tracepoint 7|-- uprobe 8`-- virtual  device  描述设备\n 1struct device { 2\tstruct device\t*parent; 3 4\tstruct device_private\t*p; 5 6\tstruct kobject kobj; 7\tconst char\t*init_name; /* initial name of the device */ 8\tconst struct device_type *type; 9 10\tstruct mutex\tmutex;\t/* mutex to synchronize calls to 11* its driver. 12*/ 13 14\tstruct bus_type\t*bus;\t/* type of bus device is on */ 15\tstruct device_driver *driver;\t/* which driver has allocated this 16device */ 17\tvoid\t*platform_data;\t/* Platform specific data, device 18core doesn\u0026#39;t touch it */ 19\tvoid\t*driver_data;\t/* Driver data, set and get with 20dev_set/get_drvdata */ 21\tstruct dev_links_info\tlinks; 22\tstruct dev_pm_info\tpower; 23\tstruct dev_pm_domain\t*pm_domain; 24 25#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN 26\tstruct irq_domain\t*msi_domain; 27#endif 28#ifdef CONFIG_PINCTRL 29\tstruct dev_pin_info\t*pins; 30#endif 31#ifdef CONFIG_GENERIC_MSI_IRQ 32\tstruct list_head\tmsi_list; 33#endif 34 35#ifdef CONFIG_NUMA 36\tint\tnuma_node;\t/* NUMA node this device is close to */ 37#endif 38\tconst struct dma_map_ops *dma_ops; 39\tu64\t*dma_mask;\t/* dma mask (if dma\u0026#39;able device) */ 40\tu64\tcoherent_dma_mask;/* Like dma_mask, but for 41alloc_coherent mappings as 42not all hardware supports 4364 bit addresses for consistent 44allocations such descriptors. */ 45\tu64\tbus_dma_mask;\t/* upstream dma_mask constraint */ 46\tunsigned long\tdma_pfn_offset; 47 48\tstruct device_dma_parameters *dma_parms; 49 50\tstruct list_head\tdma_pools;\t/* dma pools (if dma\u0026#39;ble) */ 51 52\tstruct dma_coherent_mem\t*dma_mem; /* internal for coherent mem 53override */ 54#ifdef CONFIG_DMA_CMA 55\tstruct cma *cma_area;\t/* contiguous memory area for dma 56allocations */ 57#endif 58\t/* arch specific additions */ 59\tstruct dev_archdata\tarchdata; 60 61\tstruct device_node\t*of_node; /* associated device tree node */ 62\tstruct fwnode_handle\t*fwnode; /* firmware device node */ 63 64\tdev_t\tdevt;\t/* dev_t, creates the sysfs \u0026#34;dev\u0026#34; */ 65\tu32\tid;\t/* device instance */ 66 67\tspinlock_t\tdevres_lock; 68\tstruct list_head\tdevres_head; 69 70\tstruct klist_node\tknode_class; 71\tstruct class\t*class; 72\tconst struct attribute_group **groups;\t/* optional groups */ 73 74\tvoid\t(*release)(struct device *dev); 75\tstruct iommu_group\t*iommu_group; 76\tstruct iommu_fwspec\t*iommu_fwspec; 77 78\tbool\toffline_disabled:1; 79\tbool\toffline:1; 80\tbool\tof_node_reused:1; 81}; driver  描述驱动\n 1struct device_driver { 2\tconst char\t*name; 3\tstruct bus_type\t*bus; 4 5\tstruct module\t*owner; 6\tconst char\t*mod_name;\t/* used for built-in modules */ 7 8\tbool suppress_bind_attrs;\t/* disables bind/unbind via sysfs */ 9\tenum probe_type probe_type; 10 11\tconst struct of_device_id\t*of_match_table; 12\tconst struct acpi_device_id\t*acpi_match_table; 13 14\tint (*probe) (struct device *dev); 15\tint (*remove) (struct device *dev); 16\tvoid (*shutdown) (struct device *dev); 17\tint (*suspend) (struct device *dev, pm_message_t state); 18\tint (*resume) (struct device *dev); 19\tconst struct attribute_group **groups; 20 21\tconst struct dev_pm_ops *pm; 22\tvoid (*coredump) (struct device *dev); 23 24\tstruct driver_private *p; 25}; kernel  kernel子系统\n module  模块信息\n ","date":"Oct 1, 2021","img":"","permalink":"https://mengdemao.github.io/posts/drivermodel/","series":null,"tags":["kernel"],"title":"驱动模型"},{"categories":null,"content":"LuaJIT Lua语法 基本语法 1\tprint(\u0026#34;Hello World\u0026#34;) 表(table) LuaJIT分析 LuaJIT主函数 1int main(int argc, char **argv) 2{ 3\tint status; /* 返回值 */ 4\tlua_State *L = lua_open(); /* 创建LUA状态机 */ 5\tif (L == NULL) { 6\tl_message(argv[0], \u0026#34;cannot create state: not enough memory\u0026#34;); 7\treturn EXIT_FAILURE; 8\t} 9\t10\t/* smain只存在三个参数,主要作用是向pmain传递数据 */ 11\tsmain.argc = argc; 12\tsmain.argv = argv; 13\t14\tstatus = lua_cpcall(L, pmain, NULL);\t/* 启动函数调用 */ 15\t16\treport(L, status); /* 提取报错参数 */ 17\t18\tlua_close(L);\t/* 销毁状态机 */ 19\t20\treturn (status || smain.status \u0026gt; 0) ? EXIT_FAILURE : EXIT_SUCCESS; 21} Lua状态机 1struct lua_State { 2\tGCObject*next; 3 4 lu_byte tt; 5 lu_byte marked; 6\tlu_byte status; 7\t8 StkId top; 9\tStkId base; 10\t11 global_State *l_G;\t/* 全局状态信息 */ 12\t13 CallInfo*ci; 14\t15 const Instruction*savedpc; 16\tStkId stack_last; 17\tStkId stack; 18\t19 CallInfo*end_ci; 20\tCallInfo*base_ci; 21\t22 int stacksize; 23\tint size_ci; 24\tunsigned short nCcalls; 25\tunsigned short baseCcalls; 26\t27 lu_byte hookmask; 28\tlu_byte allowhook; 29\t30 int basehookcount; 31\tint hookcount; 32\t33 lua_Hook hook; 34\t35 TValue l_gt; 36\tTValue env; 37\t38 GCObject*openupval; 39\tGCObject*gclist; 40\t41 struct lua_longjmp*errorJmp; 42\t43 ptrdiff_t errfunc; 44}; 创建状态 1/* 此函数实际不存在,程序内部使用的是宏定义 */ 2void lua_open(void); 3 4/* 实际调用位置 */ 5LUALIB_API lua_State *luaL_newstate(void); 6 7/* 根据编译期64位信息选择调用 */ 8#if LJ_64 \u0026amp;\u0026amp; !LJ_GC64 \u0026amp;\u0026amp; !(defined(LUAJIT_USE_VALGRIND) \u0026amp;\u0026amp; defined(LUAJIT_USE_SYSMALLOC)) 9lua_State *lj_state_newstate(lua_Alloc allocf, void *allocd); 10#else 11LUA_API lua_State *lua_newstate(lua_Alloc allocf, void *allocd); 12#endif 函数调用 1LUA_API int lua_cpcall(lua_State *L, lua_CFunction func, void *ud); 2LUA_API int lua_pcall(lua_State *L, int nargs, int nresults, int errfunc); 3LUA_API void lua_call(lua_State *L, int nargs, int nresults); lua_cpcall函数调用\n执行原理 FFI分析 ","date":"Sep 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/luajit/","series":null,"tags":null,"title":"LuaJIT"},{"categories":null,"content":"编译原理 基础概念 词法分析 RE NFA DFA 语法分析 上下文无关文法(CFG) 自上而下(Top Down) 自下而上(Bottom Up) 语义分析 中间代码 目标代码 ","date":"Sep 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/compilerprinciples/","series":null,"tags":null,"title":"编译原理"},{"categories":null,"content":"页面分配器 核心函数: __alloc_pages_nodemask\n gfp_mask : 分配掩码 order : 分配阶数 preferred_nid nodemask  核心函数 1struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) 2{ 3\tstruct page *page;\t// 分配变量 4\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\t// 分配标志 5\tgfp_t alloc_mask; // 真实分配掩码 6\tstruct alloc_context ac = { };\t// 保存相关参数 7 8\t/* 9* There are several places where we assume that the order value is sane 10* so bail out early if the request is out of bound. 11* 限制分配的大小 12*/ 13\tif (unlikely(order \u0026gt;= MAX_ORDER)) { 14\tWARN_ON_ONCE(!(gfp_mask \u0026amp; __GFP_NOWARN)); 15\treturn NULL; 16\t} 17 18\tgfp_mask \u0026amp;= gfp_allowed_mask; 19\talloc_mask = gfp_mask; 20\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026amp;ac, \u0026amp;alloc_mask, \u0026amp;alloc_flags)) 21\treturn NULL; 22 23\tfinalise_ac(gfp_mask, \u0026amp;ac); 24 25\t/* First allocation attempt */ 26\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026amp;ac); 27\tif (likely(page)) 28\tgoto out; 29 30\t/* 31* Apply scoped allocation constraints. This is mainly about GFP_NOFS 32* resp. GFP_NOIO which has to be inherited for all allocation requests 33* from a particular context which has been marked by 34* memalloc_no{fs,io}_{save,restore}. 35*/ 36\talloc_mask = current_gfp_context(gfp_mask); 37\tac.spread_dirty_pages = false; 38 39\t/* 40* Restore the original nodemask if it was potentially replaced with 41* \u0026amp;cpuset_current_mems_allowed to optimize the fast-path attempt. 42*/ 43\tif (unlikely(ac.nodemask != nodemask)) 44\tac.nodemask = nodemask; 45 46\tpage = __alloc_pages_slowpath(alloc_mask, order, \u0026amp;ac); 47 48out: 49\tif (memcg_kmem_enabled() \u0026amp;\u0026amp; (gfp_mask \u0026amp; __GFP_ACCOUNT) \u0026amp;\u0026amp; page \u0026amp;\u0026amp; 50\tunlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) { 51\t__free_pages(page, order); 52\tpage = NULL; 53\t} 54 55\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); 56 57\treturn page; 58} prepare_alloc_pages 1static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, 2\tint preferred_nid, nodemask_t *nodemask, 3\tstruct alloc_context *ac, gfp_t *alloc_mask, 4\tunsigned int *alloc_flags) 5{ 6\tac-\u0026gt;high_zoneidx = gfp_zone(gfp_mask); 7\tac-\u0026gt;zonelist = node_zonelist(preferred_nid, gfp_mask); 8\tac-\u0026gt;nodemask = nodemask; 9\tac-\u0026gt;migratetype = gfpflags_to_migratetype(gfp_mask); 10 11\tif (cpusets_enabled()) { 12\t*alloc_mask |= __GFP_HARDWALL; 13\tif (!ac-\u0026gt;nodemask) 14\tac-\u0026gt;nodemask = \u0026amp;cpuset_current_mems_allowed; 15\telse 16\t*alloc_flags |= ALLOC_CPUSET; 17\t} 18 19\tfs_reclaim_acquire(gfp_mask); 20\tfs_reclaim_release(gfp_mask); 21 22\tmight_sleep_if(gfp_mask \u0026amp; __GFP_DIRECT_RECLAIM); 23 24\tif (should_fail_alloc_page(gfp_mask, order)) 25\treturn false; 26 27\tif (IS_ENABLED(CONFIG_CMA) \u0026amp;\u0026amp; ac-\u0026gt;migratetype == MIGRATE_MOVABLE) 28\t*alloc_flags |= ALLOC_CMA; 29 30\treturn true; 31} get_page_from_freelist 1static struct page * 2get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, 3\tconst struct alloc_context *ac) 4{ 5\tstruct zoneref *z = ac-\u0026gt;preferred_zoneref; 6\tstruct zone *zone; 7\tstruct pglist_data *last_pgdat_dirty_limit = NULL; 8 9\t/* 10* Scan zonelist, looking for a zone with enough free. 11* See also __cpuset_node_allowed() comment in kernel/cpuset.c. 12*/ 13\tfor_next_zone_zonelist_nodemask(zone, z, ac-\u0026gt;zonelist, ac-\u0026gt;high_zoneidx, 14\tac-\u0026gt;nodemask) { 15\tstruct page *page; 16\tunsigned long mark; 17 18\tif (cpusets_enabled() \u0026amp;\u0026amp; 19\t(alloc_flags \u0026amp; ALLOC_CPUSET) \u0026amp;\u0026amp; 20\t!__cpuset_zone_allowed(zone, gfp_mask)) 21\tcontinue; 22\t/* 23* When allocating a page cache page for writing, we 24* want to get it from a node that is within its dirty 25* limit, such that no single node holds more than its 26* proportional share of globally allowed dirty pages. 27* The dirty limits take into account the node\u0026#39;s 28* lowmem reserves and high watermark so that kswapd 29* should be able to balance it without having to 30* write pages from its LRU list. 31* 32* XXX: For now, allow allocations to potentially 33* exceed the per-node dirty limit in the slowpath 34* (spread_dirty_pages unset) before going into reclaim, 35* which is important when on a NUMA setup the allowed 36* nodes are together not big enough to reach the 37* global limit. The proper fix for these situations 38* will require awareness of nodes in the 39* dirty-throttling and the flusher threads. 40*/ 41\tif (ac-\u0026gt;spread_dirty_pages) { 42\tif (last_pgdat_dirty_limit == zone-\u0026gt;zone_pgdat) 43\tcontinue; 44 45\tif (!node_dirty_ok(zone-\u0026gt;zone_pgdat)) { 46\tlast_pgdat_dirty_limit = zone-\u0026gt;zone_pgdat; 47\tcontinue; 48\t} 49\t} 50 51\tmark = zone-\u0026gt;watermark[alloc_flags \u0026amp; ALLOC_WMARK_MASK]; 52\tif (!zone_watermark_fast(zone, order, mark, 53\tac_classzone_idx(ac), alloc_flags)) { 54\tint ret; 55 56#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 57\t/* 58* Watermark failed for this zone, but see if we can 59* grow this zone if it contains deferred pages. 60*/ 61\tif (static_branch_unlikely(\u0026amp;deferred_pages)) { 62\tif (_deferred_grow_zone(zone, order)) 63\tgoto try_this_zone; 64\t} 65#endif 66\t/* Checked here to keep the fast path fast */ 67\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS \u0026lt; NR_WMARK); 68\tif (alloc_flags \u0026amp; ALLOC_NO_WATERMARKS) 69\tgoto try_this_zone; 70 71\tif (node_reclaim_mode == 0 || 72\t!zone_allows_reclaim(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone)) 73\tcontinue; 74 75\tret = node_reclaim(zone-\u0026gt;zone_pgdat, gfp_mask, order); 76\tswitch (ret) { 77\tcase NODE_RECLAIM_NOSCAN: 78\t/* did not scan */ 79\tcontinue; 80\tcase NODE_RECLAIM_FULL: 81\t/* scanned but unreclaimable */ 82\tcontinue; 83\tdefault: 84\t/* did we reclaim enough */ 85\tif (zone_watermark_ok(zone, order, mark, 86\tac_classzone_idx(ac), alloc_flags)) 87\tgoto try_this_zone; 88 89\tcontinue; 90\t} 91\t} 92 93try_this_zone: 94\tpage = rmqueue(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone, order, 95\tgfp_mask, alloc_flags, ac-\u0026gt;migratetype); 96\tif (page) { 97\tprep_new_page(page, order, gfp_mask, alloc_flags); 98 99\t/* 100* If this is a high-order atomic allocation then check 101* if the pageblock should be reserved for the future 102*/ 103\tif (unlikely(order \u0026amp;\u0026amp; (alloc_flags \u0026amp; ALLOC_HARDER))) 104\treserve_highatomic_pageblock(page, zone, order); 105 106\treturn page; 107\t} else { 108#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 109\t/* Try again if zone has deferred pages */ 110\tif (static_branch_unlikely(\u0026amp;deferred_pages)) { 111\tif (_deferred_grow_zone(zone, order)) 112\tgoto try_this_zone; 113\t} 114#endif 115\t} 116\t} 117 118\treturn NULL; 119} ","date":"May 9, 2021","img":"","permalink":"https://mengdemao.github.io/posts/page_allocator/","series":null,"tags":null,"title":"Page_allocator"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制\n使用 等待队列头 1struct __wait_queue_head { 2\twq_lock_t lock; 3\tstruct list_head task_list; 4}; 5typedef struct __wait_queue_head wait_queue_head_t; 等待队列实体 1struct __wait_queue { 2\tunsigned int flags; 3\tstruct task_struct * task; 4\tstruct list_head task_list; 5}; 6typedef struct __wait_queue wait_queue_t; 初始化等待队列头 1void __init_waitqueue_head(struct wait_queue_head *wq_head, 2\tconst char *name, struct lock_class_key *); 3void init_waitqueue_head(struct wait_queue_head *wq_head); 初始化等待队列 1#define __WAITQUEUE_INITIALIZER(name, tsk) \\ 2{\t\\ 3.private\t= tsk,\t\\ 4.func\t= default_wake_function,\t\\ 5.entry\t= { NULL, NULL }\t\\ 6} 7 8#define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) 9 10// 但是，一般直接 11DECLARE_WAITQUEUE(wait, current);  等待队列入口 等待的任务  等待队列操作 1void add_wait_queue(struct wait_queue_head *wq_head, 2\tstruct wait_queue_entry *wq_entry); 3void remove_wait_queue(struct wait_queue_head *wq_head, 4\tstruct wait_queue_entry *wq_entry);  等待队列头 等待队列实体  等待事件 1void wait_event(wq, condition); 2void wait_event_interruptible(wq, condition); 唤醒队列  wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync  例子 写端 1ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) 2{ 3\tDECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4\tint ret = -1; 5\tPTRACE; 6 7\tmutex_lock(\u0026amp;wait_device.mutex); 8\t/* 非阻塞模式直接写入 */ 9\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10\tpr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11\tgoto pure_write; 12\t} 13 14\tadd_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 15\twhile (wait_device.wait_flag == true) { 16\tpr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17\t__set_current_state(TASK_INTERRUPTIBLE); 18\tmutex_unlock(\u0026amp;wait_device.mutex); 19\tschedule(); 20\tif (signal_pending(current)) { 21\tret = -ERESTARTSYS; 22\tremove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 23\t__set_current_state(TASK_RUNNING); 24\tgoto out; 25\t} 26\t} 27\tremove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 28 29pure_write: 30\twait_device.wait_flag = true; 31\tpr_err(\u0026#34;Write Successful\u0026#34;); 32 33\twake_up_interruptible(\u0026amp;wait_device.wait_r); 34\tpr_err(\u0026#34;Wakeup Read\u0026#34;); 35\tgoto out; 36 37out: 38\tmutex_unlock(\u0026amp;wait_device.mutex); 39\treturn ret; 40} 读端 1 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) 2{ 3\tDECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4\tint ret = 0; 5\tPTRACE; 6 7\tmutex_lock(\u0026amp;wait_device.mutex); 8\t/* 非阻塞模式直接写入 */ 9\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10\tpr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11\tgoto pure_read; 12\t} 13 14\tadd_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 15\twhile (wait_device.wait_flag == false) { 16\tpr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17\t__set_current_state(TASK_INTERRUPTIBLE); 18\tmutex_unlock(\u0026amp;wait_device.mutex); 19\tschedule(); 20\tif (signal_pending(current)) { 21\tret = -ERESTARTSYS; 22\tremove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 23\t__set_current_state(TASK_RUNNING); 24\tgoto out; 25\t} 26\t} 27\tremove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 28 29pure_read: 30\twait_device.wait_flag = false; 31\tpr_err(\u0026#34;Read Successful\u0026#34;); 32 33\twake_up_interruptible(\u0026amp;wait_device.wait_w); 34\tpr_err(\u0026#34;Wakeup Write\u0026#34;); 35 36\tgoto out; 37 38out: 39\tmutex_unlock(\u0026amp;wait_device.mutex); 40\treturn 0; 41} 原理 ","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/wait_queue/","series":null,"tags":null,"title":"Linux等待队列实现"},{"categories":null,"content":"简介  ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件.\n 类似于flex/bison,根据描述文件，自动生成词法语法分析器\n安装说明  下载antlr  设置path和classpath 编写相关脚本  语法设计 错误处理 解析器 测试程序 antlr4编译器 1#!/bin/sh 2antlr4 Expr.g4 编译生成的java文件 1javac *.java 运行编译的结果 1grun Expr prog -tree 1(prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) 1grun Expr prog -gui\t1grun Expr prog -tokens 1[@0,0:0=\u0026#39;1\u0026#39;,\u0026lt;INT\u0026gt;,1:0] 2[@1,1:1=\u0026#39;+\u0026#39;,\u0026lt;\u0026#39;+\u0026#39;\u0026gt;,1:1] 3[@2,2:2=\u0026#39;2\u0026#39;,\u0026lt;INT\u0026gt;,1:2] 4[@3,3:3=\u0026#39;+\u0026#39;,\u0026lt;\u0026#39;+\u0026#39;\u0026gt;,1:3] 5[@4,4:4=\u0026#39;3\u0026#39;,\u0026lt;INT\u0026gt;,1:4] 6[@5,5:6=\u0026#39;\\r\\n\u0026#39;,\u0026lt;NEWLINE\u0026gt;,1:5] 7[@6,7:6=\u0026#39;\u0026lt;EOF\u0026gt;\u0026#39;,\u0026lt;EOF\u0026gt;,2:0] antlr语法详解 Hello 1// antlr4 Hello.g42// javac *.java3// grun Hello r -gui4grammarHello;// 定义一个Hello的grammer5r:\u0026#39;hello\u0026#39;ID;// 开头是hello后面接着一个ID6ID:[a-z]+;// ID由小写字母组成7WS:[\\t\\r\\n]+-\u0026gt;skip;// 控制符清除ArrayInit 1// antlr4 ArrayInit.g42// javac *.java3// grun ArrayInit init -gui4grammarArrayInit;// 定义一个ArrayInit的grammer5init:\u0026#39;{\u0026#39;value(\u0026#39;,\u0026#39;value)*\u0026#39;}\u0026#39;;// 6value:init// 嵌套定义7|INT// 定义整数8;9INT:[0-9]+;10WS:[\\t\\r\\n]+-\u0026gt;skip;()* \u0026ndash;\u0026gt; 相当于扩展\nExpr 1// antlr4 Expr.g42// javac *.java3// grun Expr prog -gui4grammarExpr;56prog:stat+;78stat:exprNEWLINE#printExpr9|ID\u0026#39;=\u0026#39;exprNEWLINE#assign10|NEWLINE#blank11;1213expr:exprop=(\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39;)expr#MulDiv14|exprop=(\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;)expr#AddSub15|INT#int16|ID#id17|\u0026#39;(\u0026#39;expr\u0026#39;)\u0026#39;#parens18;1920MUL:\u0026#39;*\u0026#39;;// assigns token name to \u0026#39;*\u0026#39; used above in grammar21DIV:\u0026#39;/\u0026#39;;22ADD:\u0026#39;+\u0026#39;;23SUB:\u0026#39;-\u0026#39;;24ID:[a-zA-Z]+;25INT:[0-9]+;26NEWLINE:\u0026#39;\\r\u0026#39;?\u0026#39;\\n\u0026#39;;27WS:[\\t]+-\u0026gt;skip;json  在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础\n 1grammar JSON;\t// 声明一个grammar 2 3json 4 : value\t// 一个value候选 5 ; 6 7obj\t// 对象类型 8 : \u0026#39;{\u0026#39; pair (\u0026#39;,\u0026#39; pair)* \u0026#39;}\u0026#39; 9 | \u0026#39;{\u0026#39; \u0026#39;}\u0026#39; 10 ; 11 12pair 13 : STRING \u0026#39;:\u0026#39; value 14 ; 15 16arr 17 : \u0026#39;[\u0026#39; value (\u0026#39;,\u0026#39; value)* \u0026#39;]\u0026#39; 18 | \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; 19 ; 20 21value 22 : STRING 23 | NUMBER 24 | obj 25 | arr 26 | \u0026#39;true\u0026#39; 27 | \u0026#39;false\u0026#39; 28 | \u0026#39;null\u0026#39; 29 ; 30 31 32STRING 33 : \u0026#39;\u0026#34;\u0026#39; (ESC | SAFECODEPOINT)* \u0026#39;\u0026#34;\u0026#39; 34 ; 35 36 37fragment ESC 38 : \u0026#39;\\\\\u0026#39; ([\u0026#34;\\\\/bfnrt] | UNICODE) 39 ; 40 41 42fragment UNICODE 43 : \u0026#39;u\u0026#39; HEX HEX HEX HEX 44 ; 45 46 47fragment HEX 48 : [0-9a-fA-F] 49 ; 50 51 52fragment SAFECODEPOINT 53 : ~ [\u0026#34;\\\\\\u0000-\\u001F] 54 ; 55 56 57NUMBER 58 : \u0026#39;-\u0026#39;? INT (\u0026#39;.\u0026#39; [0-9] +)? EXP? 59 ; 60 61 62fragment INT 63 : \u0026#39;0\u0026#39; | [1-9] [0-9]* 64 ; 65 66// no leading zeros 67 68fragment EXP 69 : [Ee] [+\\-]? INT 70 ; 71 72// \\- since - means \u0026#34;range\u0026#34; inside [...] 73 74WS 75 : [ \\t\\n\\r] + -\u0026gt; skip 76 ; 测试例子\n1{ 2 \u0026#34;glossary\u0026#34;: { 3 \u0026#34;title\u0026#34;: \u0026#34;example glossary\u0026#34;, 4\t\u0026#34;GlossDiv\u0026#34;: { 5 \u0026#34;title\u0026#34;: \u0026#34;S\u0026#34;, 6\t\u0026#34;GlossList\u0026#34;: { 7 \u0026#34;GlossEntry\u0026#34;: { 8 \u0026#34;ID\u0026#34;: \u0026#34;SGML\u0026#34;, 9\t\u0026#34;SortAs\u0026#34;: \u0026#34;SGML\u0026#34;, 10\t\u0026#34;GlossTerm\u0026#34;: \u0026#34;Standard Generalized Markup Language\u0026#34;, 11\t\u0026#34;Acronym\u0026#34;: \u0026#34;SGML\u0026#34;, 12\t\u0026#34;Abbrev\u0026#34;: \u0026#34;ISO 8879:1986\u0026#34;, 13\t\u0026#34;GlossDef\u0026#34;: { 14 \u0026#34;para\u0026#34;: \u0026#34;A meta-markup language\u0026#34;, 15\t\u0026#34;GlossSeeAlso\u0026#34;: [\u0026#34;GML\u0026#34;, \u0026#34;XML\u0026#34;] 16 }, 17\t\u0026#34;GlossSee\u0026#34;: \u0026#34;markup\u0026#34; 18 } 19 } 20 } 21 } 22} 显示结果：\nXML  孤岛语法:\n dot 1grammarDOT;23graph4:STRICT?(GRAPH|DIGRAPH)id_?\u0026#39;{\u0026#39;stmt_list\u0026#39;}\u0026#39;5;67stmt_list8:(stmt\u0026#39;;\u0026#39;?)*9;1011stmt12:node_stmt|edge_stmt|attr_stmt|id_\u0026#39;=\u0026#39;id_|subgraph13;1415attr_stmt16:(GRAPH|NODE|EDGE)attr_list17;1819attr_list20:(\u0026#39;[\u0026#39;a_list?\u0026#39;]\u0026#39;)+21;2223a_list24:(id_(\u0026#39;=\u0026#39;id_)?\u0026#39;,\u0026#39;?)+25;2627edge_stmt28:(node_id|subgraph)edgeRHSattr_list?29;3031edgeRHS32:(edgeop(node_id|subgraph))+33;3435edgeop36:\u0026#39;-\u0026gt;\u0026#39;|\u0026#39;--\u0026#39;37;3839node_stmt40:node_idattr_list?41;4243node_id44:id_port?45;4647port48:\u0026#39;:\u0026#39;id_(\u0026#39;:\u0026#39;id_)?49;5051subgraph52:(SUBGRAPHid_?)?\u0026#39;{\u0026#39;stmt_list\u0026#39;}\u0026#39;53;5455id_56:ID|STRING|HTML_STRING|NUMBER57;5859// \u0026#34;The keywords node, edge, graph, digraph, subgraph, and strict are60// case-independent\u0026#34;6162STRICT63:[Ss][Tt][Rr][Ii][Cc][Tt]64;656667GRAPH68:[Gg][Rr][Aa][Pp][Hh]69;707172DIGRAPH73:[Dd][Ii][Gg][Rr][Aa][Pp][Hh]74;757677NODE78:[Nn][Oo][Dd][Ee]79;808182EDGE83:[Ee][Dd][Gg][Ee]84;858687SUBGRAPH88:[Ss][Uu][Bb][Gg][Rr][Aa][Pp][Hh]89;909192/** \u0026#34;a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\u0026#34; */NUMBER93:\u0026#39;-\u0026#39;?(\u0026#39;.\u0026#39;DIGIT+|DIGIT+(\u0026#39;.\u0026#39;DIGIT*)?)94;959697fragmentDIGIT98:[0-9]99;100101102/** \u0026#34;any double-quoted string (\u0026#34;...\u0026#34;) possibly containing escaped quotes\u0026#34; */STRING103:\u0026#39;\u0026#34;\u0026#39;(\u0026#39;\\\\\u0026#34;\u0026#39;|.)*?\u0026#39;\u0026#34;\u0026#39;104;105106107/** \u0026#34;Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores 108* (\u0026#39;_\u0026#39;) or digits ([0-9]), not beginning with a digit\u0026#34; 109*/ID110:LETTER(LETTER|DIGIT)*111;112113114fragmentLETTER115:[a-zA-Z\\u0080-\\u00FF_]116;117118119/** \u0026#34;HTML strings, angle brackets must occur in matched pairs, and 120* unescaped newlines are allowed.\u0026#34; 121*/HTML_STRING122:\u0026#39;\u0026lt;\u0026#39;(TAG|~[\u0026lt;\u0026gt;])*\u0026#39;\u0026gt;\u0026#39;123;124125126fragmentTAG127:\u0026#39;\u0026lt;\u0026#39;.*?\u0026#39;\u0026gt;\u0026#39;128;129130131COMMENT132:\u0026#39;/*\u0026#39;.*?\u0026#39;*/\u0026#39;-\u0026gt;skip133;134135136LINE_COMMENT137:\u0026#39;//\u0026#39;.*?\u0026#39;\\r\u0026#39;?\u0026#39;\\n\u0026#39;-\u0026gt;skip138;139140141/** \u0026#34;a \u0026#39;#\u0026#39; character is considered a line output from a C preprocessor (e.g., 142* # 34 to indicate line 34 ) and discarded\u0026#34; 143*/PREPROC144:\u0026#39;#\u0026#39;~[\\r\\n]*-\u0026gt;skip145;146147148WS149:[\\t\\n\\r]+-\u0026gt;skip150;","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/antlr/","series":null,"tags":["编译原理"],"title":"Antlr教程"},{"categories":null,"content":"基本操作 安装hugo 在linux/windows上只能通过直接release 下载,\n创建网站 1hugo new site 路径 添加主题  将主题直接添加到theme文件下面 将主题作为一个submodule  创建文档 1hugo new posts/hugo.md 设置预览 1 hugo server -D --disableFastRender 文件结构 1. 2├── archetypes 3├── config 4├── content 5├── data 6├── layouts 7├── static 8├── themes 9├── static 10└── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。\narchetypes hugo模板,在创建文件时作为模板自动生成\nassets 存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录\nconfig Hugo配置目录\ncontent 此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分.\ndata 该目录用于存储 Hugo 在生成网站时可以使用的配置文件\nlayouts 以 .html文件的形式存储模板.\nstatic 存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制\n编写工具 typora 使用typora作为markdown编写工具\npicgo ","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/hugo/","series":null,"tags":["技巧"],"title":"Hugo教程"},{"categories":null,"content":"nfs服务 安装 1sudo apt-get install nfs-kernel-server 设置导出 1/home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 开启服务 1sudo /etc/init.d/nfs-kernel-server restart 测试 1sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt 2ls /mnt ","date":"May 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/nfs/","series":null,"tags":["nfs"],"title":"Nfs"}]
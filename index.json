[{"categories":[],"content":"pthread源码分析 基于musl源码库与glibc库,其中musl提供分析的思路,glibc分析具体实现\npthread句柄 1/// musl实现 2struct pthread { 3 4\tstruct pthread *self; 5 6 #ifndef TLS_ABOVE_TP 7\tuintptr_t *dtv; 8\t#endif 9\t10 /* 线程链表项 */ 11 struct pthread *prev, *next; /* non-ABI */ 12 13 /* 系统信息 */ 14\tuintptr_t sysinfo; 15\t16 #ifndef TLS_ABOVE_TP 17\t#ifdef CANARY_PAD 18\tuintptr_t canary_pad; 19\t#endif 20\tuintptr_t canary; 21\t#endif /* TLS_ABOVE_TP */ 22 23\tint tid; // 线程ID 24\t25 int errno_val; 26\t27 volatile int detach_state; // 分离状态 28\t29 volatile int cancel;\t// cancle启动标志 30 volatile unsigned char canceldisable; // cancle控制 31 volatile unsigned char cancelasync; // cancle同步标志 32\t33 unsigned char tsd_used:1; 34\tunsigned char dlerror_flag:1; 35\t36 unsigned char *map_base;\t// mmap 37\tsize_t map_size; 38\t39 void *stack;\t// 堆栈 40\tsize_t stack_size; 41\t42 size_t guard_size; 43\t44 void *result; // 返回结果, 45 46 /* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ 47\tstruct __ptcb *cancelbuf; 48\t49 void **tsd; 50\t51 struct { 52\tvolatile void *volatile head; 53\tlong off; 54\tvolatile void *volatile pending; 55\t} robust_list; 56\t57 int h_errno_val; 58 59\tvolatile int timer_id; 60\t61 locale_t locale; 62\t63 volatile int killlock[1];\t// 退出锁 64\t65 char *dlerror_buf; 66\t67 void *stdio_locks; 68 69\t#ifdef TLS_ABOVE_TP 70\tuintptr_t canary; 71\tuintptr_t *dtv; 72\t#endif 73 74}; 75 76// glibc实现 77struct __pthread 78{ 79 /* 线程ID: typedef unsigned long int pthread_t; */ 80 pthread_t thread; 81 82 unsigned int nr_refs;\t83 /* Detached threads have a self reference only, 84\twhile joinable threads have two references. 85\tThese are used to keep the structure valid at 86\tthread destruction. Detaching/joining a thread 87\tdrops a reference. */ 88 89 /* Cancellation. */ 90 pthread_mutex_t cancel_lock;\t/* Protect cancel_xxx members. */ 91 void (*cancel_hook) (void *);\t92 /* Called to unblock a thread blocking 93\tin a cancellation point (namely, 94\t__pthread_cond_timedwait_internal). */ 95 void *cancel_hook_arg; 96 int cancel_state; 97 int cancel_type; 98 int cancel_pending; 99 100\t/* Thread stack. */ 101\tvoid *stackaddr;\t/* 堆栈地址 */ 102\tsize_t stacksize;\t/* 堆栈大小 */ 103\tsize_t guardsize;\t/* 预留用来保护堆栈大小的字节 */ 104\tint stack;\t/* Nonzero if the stack was allocated. */ 105 106\t/* Exit status. */ 107\tvoid *status; 108 109\t/* Thread state. */ 110\tenum pthread_state state; 111\tpthread_mutex_t state_lock;\t/* Locks the state. */ 112\tpthread_cond_t state_cond;\t/* Signalled when the state changes. */ 113\tbool terminated;\t/* Whether the kernel thread is over 114\tand we can reuse this structure. */ 115 116\t/* Resolver state. */ 117\tstruct __res_state res_state; 118 119\t/* Indicates whether is a C11 thread created by thrd_creat. */ 120\tbool c11; 121 122\t/* Initial sigset for the thread. */ 123\tsigset_t init_sigset; 124 125\t/* Thread context. */ 126\tstruct pthread_mcontext mcontext; 127 128\tPTHREAD_KEY_MEMBERS 129\t/* 130\tvoid **thread_specifics;\t131 // This is only resized by the thread, and always growing 132\tunsigned thread_specifics_size;\t133\t// Number of entries in thread_specifics 134\t*/ 135 136\tPTHREAD_SYSDEP_MEMBERS 137 /* 138\tthread_t kernel_thread; 139\tmach_msg_header_t wakeupmsg; 140\t*/ 141\t142\t/* 线程控制块:与系统进行沟通 */ 143 tcbhead_t *tcb; 144 145\t/* Queue links. Since PREVP is used to determine 146\tif a thread has been awaken, 147\tit must be protected by the queue lock. */ 148\tstruct __pthread *next, **prevp; 149}; 但是在我们使用的时候发现与我们正常的使用不太一致,在用户层,我们一般认为pthread为线程ID，但是内部实现好像都是指针,因此出现了什么特殊的原因；\n在musl中,直接抹掉了内部结构;\n1// 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 2#ifdef __cplusplus 3typedef unsigned long pthread_t; 4#else 5typedef struct __pthread* pthread_t; 6#endif 而在glibc中,线程ID仅仅是线程结构体中的一个成员,因此,glibc的处理更加安全, 下面分析一下id的实现,\n1__pthread_create (pthread_t * thread, const pthread_attr_t * attr, 2\tvoid *(*start_routine) (void *), void *arg) 3{ 4 int err; 5 struct __pthread *pthread; 6 7 err = __pthread_create_internal (\u0026amp;pthread, attr, start_routine, arg); 8 if (!err) 9 *thread = pthread-\u0026gt;thread; 10 else if (err == ENOMEM) 11 err = EAGAIN; 12 13 return err; 14} 15 16/* 那么可以明白,线程ID */ 17int _dl_pthread_num_threads; 18struct __pthread **_dl_pthread_threads; 19__libc_rwlock_define_initialized (, _dl_pthread_threads_lock) 20 21/* 下面的代码实现线程ID的分配:只保留了成功的部分,没有考虑意外情况 */ 22__libc_rwlock_wrlock (GL(dl_pthread_threads_lock)); 23if (GL(dl_pthread_num_threads) \u0026lt; __pthread_max_threads) 24{ 25\t/* We have a free slot. Use the slot number plus one as the 26\tthread ID for the new thread. */ 27\tnew-\u0026gt;thread = 1 + GL(dl_pthread_num_threads)++; 28\tGL(dl_pthread_threads)[new-\u0026gt;thread - 1] = NULL; 29 30\t__libc_rwlock_unlock (GL(dl_pthread_threads_lock)); 31 32\t*pthread = new; 33\treturn 0; 34} 但是GL是什么呢?hehe #define GL(x) _##x\n所有的函数 线程基础 1// 线程创建 2int pthread_create(pthread_t *__restrict, 3 const pthread_attr_t *__restrict, 4 void *(*)(void *), void *__restrict); 5 6// 线程退出 7void pthread_exit(void *); 8 9// 线程属性 10int pthread_attr_init(pthread_attr_t *); 11int pthread_attr_destroy(pthread_attr_t *); 12 13int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); 14int pthread_attr_setguardsize(pthread_attr_t *, size_t); 15int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); 16int pthread_attr_setstacksize(pthread_attr_t *, size_t); 17int pthread_attr_getdetachstate(const pthread_attr_t *, int *); 18int pthread_attr_setdetachstate(pthread_attr_t *, int); 19int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); 20int pthread_attr_setstack(pthread_attr_t *, void *, size_t); 21int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); 22int pthread_attr_setscope(pthread_attr_t *, int); 23int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); 24int pthread_attr_setschedpolicy(pthread_attr_t *, int); 25int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); 26int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); 27int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); 28int pthread_attr_setinheritsched(pthread_attr_t *, int); 线程分离 1// 线程分离 2int pthread_detach(pthread_t); 3 4// 线程等待 5int pthread_join(pthread_t, void **); 1// 获取线程自己的ID 2pthread_t pthread_self(void); 3 4// 判断线程是否相等 5int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 线程取消 1int pthread_setcancelstate(int, int *); 2int pthread_setcanceltype(int, int *); 3void pthread_testcancel(void); 4int pthread_cancel(pthread_t); 调度相关 1int pthread_getschedparam(pthread_t t, 2 int *restrict policy, 3 struct sched_param *restrict param); 4__syscall(SYS_sched_getparam, pthread_t-\u0026gt;tid, sched_param); 5__syscall(SYS_sched_getscheduler, pthread_t-\u0026gt;tid); 6 7int pthread_setschedparam(pthread_t t, 8 int policy, 9 const struct sched_param *param); 10__syscall(SYS_sched_setscheduler, pthread_t-\u0026gt;tid, policy, sched_param); 11// sched_param保存着优先级参数 12 13int pthread_setschedprio(pthread_t t, int prio); 14__syscall(SYS_sched_setparam, pthread_t-\u0026gt;tid, \u0026amp;prio); 线程同步 互斥锁 1int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); 2int pthread_mutex_lock(pthread_mutex_t *); 3int pthread_mutex_unlock(pthread_mutex_t *); 4int pthread_mutex_trylock(pthread_mutex_t *); 5int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); 6int pthread_mutex_destroy(pthread_mutex_t *); 7int pthread_mutex_consistent(pthread_mutex_t *); 8 9int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); 10int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); 11 12int pthread_mutexattr_destroy(pthread_mutexattr_t *); 13int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); 14int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); 15int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); 16int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); 17int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); 18int pthread_mutexattr_init(pthread_mutexattr_t *); 19int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); 20int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); 21int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); 22int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); 23int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 条件变量 1int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); 2int pthread_cond_destroy(pthread_cond_t *); 3int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); 4int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); 5int pthread_cond_broadcast(pthread_cond_t *); 6int pthread_cond_signal(pthread_cond_t *); 7 8int pthread_condattr_init(pthread_condattr_t *); 9int pthread_condattr_destroy(pthread_condattr_t *); 10int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); 11int pthread_condattr_setpshared(pthread_condattr_t *, int); 12int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); 13int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 读写锁 1int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); 2int pthread_rwlock_destroy(pthread_rwlock_t *); 3int pthread_rwlock_rdlock(pthread_rwlock_t *); 4int pthread_rwlock_tryrdlock(pthread_rwlock_t *); 5int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); 6int pthread_rwlock_wrlock(pthread_rwlock_t *); 7int pthread_rwlock_trywrlock(pthread_rwlock_t *); 8int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); 9int pthread_rwlock_unlock(pthread_rwlock_t *); 10int pthread_rwlockattr_init(pthread_rwlockattr_t *); 11int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); 12int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); 13int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 自旋锁 1int pthread_spin_init(pthread_spinlock_t *, int); 2int pthread_spin_destroy(pthread_spinlock_t *); 3int pthread_spin_lock(pthread_spinlock_t *); 4int pthread_spin_trylock(pthread_spinlock_t *); 5int pthread_spin_unlock(pthread_spinlock_t *); 屏障 1int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); 2int pthread_barrier_destroy(pthread_barrier_t *); 3int pthread_barrier_wait(pthread_barrier_t *); 4int pthread_barrierattr_destroy(pthread_barrierattr_t *); 5int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); 6int pthread_barrierattr_init(pthread_barrierattr_t *); 7int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); 线程资源 1int pthread_key_create(pthread_key_t *, void (*)(void *)); 2int pthread_key_delete(pthread_key_t); 3void *pthread_getspecific(pthread_key_t); 4int pthread_setspecific(pthread_key_t, const void *); 补充知识 Linux线程实现 系统调用实现 1#define __asm_syscall(...) 2do { 3\t__asm__ __volatile__ ( \u0026#34;svc 0\u0026#34; : \u0026#34;=r\u0026#34;(r0) : __VA_ARGS__ : \u0026#34;memory\u0026#34;); 4\treturn r0; 5} while (0); 6 7#define R7_OPERAND \u0026#34;r\u0026#34;(r7) 8static inline long __syscall0(long n) 9{ 10\tregister long r7 __ASM____R7__ = n; //使用R7传递个数 11\tregister long r0 __asm__(\u0026#34;r0\u0026#34;); 12\t__asm_syscall(R7_OPERAND); 13} 14 15static inline long __syscall1(long n, long a) 16{ 17\tregister long r7 __ASM____R7__ = n; 18\tregister long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 19\t__asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0)); 20} 21 22static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) 23{ 24\tregister long r7 __ASM____R7__ = n; 25\tregister long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 26\tregister long r1 __asm__(\u0026#34;r1\u0026#34;) = b; 27\tregister long r2 __asm__(\u0026#34;r2\u0026#34;) = c; 28\tregister long r3 __asm__(\u0026#34;r3\u0026#34;) = d; 29\tregister long r4 __asm__(\u0026#34;r4\u0026#34;) = e; 30\tregister long r5 __asm__(\u0026#34;r5\u0026#34;) = f; 31\t__asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0), \u0026#34;r\u0026#34;(r1), \u0026#34;r\u0026#34;(r2), \u0026#34;r\u0026#34;(r3), \u0026#34;r\u0026#34;(r4), \u0026#34;r\u0026#34;(r5)); 32} 33 34// 一个相当巧妙的宏定义的实现 35#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n 36#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) 37// 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 38 39// 拼装函数调用 40#define __SYSCALL_CONCAT_X(a,b) a##b 41#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) 42#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) 43 44// __syscall_ret仅仅检查了系统调用号 45#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) 46#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束 系统调用号实现\n1#ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H 2#define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 3#define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) 4#define __NR_exit (__NR_SYSCALL_BASE + 1) 5#define __NR_fork (__NR_SYSCALL_BASE + 2) 6#define __NR_read (__NR_SYSCALL_BASE + 3) 7#define __NR_write (__NR_SYSCALL_BASE + 4) 8#define __NR_open (__NR_SYSCALL_BASE + 5) 9#define __NR_close (__NR_SYSCALL_BASE + 6) 10#define __NR_creat (__NR_SYSCALL_BASE + 8) 11... 12#define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) 13#endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */ glibc系统调用 同样的道理,可以分析一下glibc的系统调用时如何进行 但是在一般的情况下此时就可以明白,与musl相同的调用方式时一样的\n1INLINE_SYSCALL_CALL --\u0026gt; __INLINE_SYSCALL_DISP 2__INLINE_SYSCALL_DISP --\u0026gt; __SYSCALL_CONCAT 生成一条调用指令的语言\n1# define INTERNAL_SYSCALL_RAW(name, nr, args...)\t\\ 2 ({\t\\ 3 register int _a1 asm (\u0026#34;r0\u0026#34;), _nr asm (\u0026#34;r7\u0026#34;);\t\\ 4 LOAD_ARGS_##nr (args)\t\\ 5 _nr = name;\t\\ 6 asm volatile (\u0026#34;swi\t0x0\t@ syscall \u0026#34; #name\t\\ 7\t: \u0026#34;=r\u0026#34; (_a1)\t\\ 8\t: \u0026#34;r\u0026#34; (_nr) ASM_ARGS_##nr\t\\ 9\t: \u0026#34;memory\u0026#34;);\t\\ 10 _a1; }) clone系统调用 1int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...); 2 3// 但是实现的地方却存在着异常 4 5__clone: 6\tstmfd sp!,{r4,r5,r6,r7} 7 8\tmov r7,#120 9 10\tmov r6,r3 11\tmov r5,r0 12\tmov r0,r2 13 14\tand r1,r1,#-16 15\tldr r2,[sp,#16] 16\tldr r3,[sp,#20] 17\tldr r4,[sp,#24] 18\tsvc 0 19\t20 tst r0,r0 21\tbeq 1f 22 23\tldmfd sp!,{r4,r5,r6,r7} 24\tbx lr Futex设计与实现 Futex 是Fast Userspace muTexes的缩写\n但是我并没有搞明白futex实现的原理,造成我发继续分析, 因此只能分析别人的文档(注:不分析原理 ,只进行使用)\n主要存在文件futex-internal.c/futex-internal.h,lowlevellock-futex.h,lowlevellock.c\n另外lll-\u0026gt;lowlevellock缩写形式\n其中futex提供的最重要的两个操作wait和wake\n常用的锁都是通过futex实现的\nmutex (互斥锁) rwlock (读写锁) cond (条件变量) 1#define lll_trylock(lock) 原子的(lock 0 --\u0026gt; 1) // 不等待 2#define lll_cond_trylock(lock) 原子的(lock 0 --\u0026gt; 2)\t// 不等待 3 4#define lll_lock(futex, private) 51. 原子的(futex 0 --\u0026gt; 1) // 等待 62. __lll_lock_wait (futex, private) 7 8#define __lll_cond_lock(futex, private) 91. 原子的(futex 0 --\u0026gt; 2) // 等待 102. __lll_lock_wait (futex, private) 11 12#define __lll_unlock(futex, private) 131. 原子的(futex ? --\u0026gt; 0) // 等待 142. __lll_lock_wait (futex, private) 15 16void __lll_lock_wake_private (int *futex); 17void __lll_lock_wait_private (int *futex); 18void __lll_lock_wait (int *futex, int private); 19void __lll_lock_wake (int *futex, int private); 20 21int lll_futex_wake(int *futex, int nr, int private); 22int lll_futex_wait(int *futex, int val, int private); 23 24int futex_wait (unsigned int *futex_word, unsigned int expected, int private); 25void futex_wake (unsigned int* futex_word, int processes_to_wake, int private); 26 27// 进入系统调用阶段 28int lll_futex_syscall(int nargs, int *futexp, int op, ...); 那么进入到最后可以得知,一般会进行一些原子操作,启动的操作都是INTERNAL_SYSCALL进行实现的,然后就是swi指令实现的原理\n1// 可以使用的op定义类型 2#define FUTEX_WAIT\t0 3#define FUTEX_WAKE\t1 4#define FUTEX_REQUEUE\t3 5#define FUTEX_CMP_REQUEUE\t4 6#define FUTEX_WAKE_OP\t5 7 8#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE\t((4 \u0026lt;\u0026lt; 24) | 1) 9 10#define FUTEX_LOCK_PI\t6 11#define FUTEX_UNLOCK_PI\t7 12#define FUTEX_TRYLOCK_PI\t8 13 14#define FUTEX_WAIT_BITSET\t9 15#define FUTEX_WAKE_BITSET\t10 16 17#define FUTEX_WAIT_REQUEUE_PI 11 18#define FUTEX_CMP_REQUEUE_PI 12 19 20#define FUTEX_LOCK_PI2\t13 21 22#define FUTEX_PRIVATE_FLAG\t128 23#define FUTEX_CLOCK_REALTIME\t256 线程基础 线程创建 1typedef struct { 2 union { 3 int __i[sizeof(long)==8?14:9]; 4 volatile int __vi[sizeof(long)==8?14:9]; 5 unsigned long __s[sizeof(long)==8?7:9]; 6 } __u; 7} pthread_attr_t; 8 9#define __SU (sizeof(size_t)/sizeof(int)) 10 11#define _a_stacksize __u.__s[0] 12#define _a_guardsize __u.__s[1] 13#define _a_stackaddr __u.__s[2] 14#define _a_detach __u.__i[3*__SU+0] 15#define _a_sched __u.__i[3*__SU+1] 16#define _a_policy __u.__i[3*__SU+2] 17#define _a_prio __u.__i[3*__SU+3] 18#define _m_type __u.__i[0] 19#define _m_lock __u.__vi[1] 20#define _m_waiters __u.__vi[2] 21#define _m_prev __u.__p[3] 22#define _m_next __u.__p[4] 23#define _m_count __u.__i[5] 24#define _c_shared __u.__p[0] 25#define _c_seq __u.__vi[2] 26#define _c_waiters __u.__vi[3] 27#define _c_clock __u.__i[4] 28#define _c_lock __u.__vi[8] 29#define _c_head __u.__p[1] 30#define _c_tail __u.__p[5] 31#define _rw_lock __u.__vi[0] 32#define _rw_waiters __u.__vi[1] 33#define _rw_shared __u.__i[2] 34#define _b_lock __u.__vi[0] 35#define _b_waiters __u.__vi[1] 36#define _b_limit __u.__i[2] 37#define _b_count __u.__vi[3] 38#define _b_waiters2 __u.__vi[4] 39#define _b_inst __u.__p[3] 40 41/** 42 * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) 43 * @brief 创建线程 44 * 45 * @param res pthread指针 46 * @param attrp\tpthread属性 47 * @param entry\t入口地址 48 * @param arg\t入口属性 49 * @return\t创建结果 50 */ 51int pthread_create(pthread_t *restrict res, 52\tconst pthread_attr_t *restrict attrp, 53\tvoid *(*entry)(void *), 54 void *restrict arg) 55{ 56 int ret, c11 = (attrp == __ATTRP_C11_THREAD); 57\tsize_t size; 58 size_t guard; 59\tstruct pthread *self; 60 struct pthread *new; 61\tunsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; 62\tunsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND 63\t| CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS 64\t| CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; 65\t66 // 通过一定的规则将attrp--\u0026gt;attr 67 pthread_attr_t attr = { 0 }; 68\tsigset_t set; 69 70 /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ 71 attr._a_stacksize = __default_stacksize; 72\tattr._a_guardsize = __default_guardsize; 73 74 /* 填充pthread成员 */ 75 new = __copy_tls(tsd - libc.tls_size); 76\tnew-\u0026gt;map_base = map; 77\tnew-\u0026gt;map_size = size; 78\tnew-\u0026gt;stack = stack; 79\tnew-\u0026gt;stack_size = stack - stack_limit; 80\tnew-\u0026gt;guard_size = guard; 81\tnew-\u0026gt;self = new; 82\tnew-\u0026gt;tsd = (void *)tsd; 83\tnew-\u0026gt;locale = \u0026amp;libc.global_locale; 84\tif (attr._a_detach) { 85\tnew-\u0026gt;detach_state = DT_DETACHED; 86\t} else { 87\tnew-\u0026gt;detach_state = DT_JOINABLE; 88\t} 89\tnew-\u0026gt;robust_list.head = \u0026amp;new-\u0026gt;robust_list.head; 90\tnew-\u0026gt;canary = self-\u0026gt;canary; 91\tnew-\u0026gt;sysinfo = self-\u0026gt;sysinfo; 92 93 /* 移动stack指针,保存启动参数 */ 94 stack -= (uintptr_t)stack % sizeof(uintptr_t); 95\tstack -= sizeof(struct start_args); 96\t97 /* 设置启动参数 */ 98 struct start_args *args = (void *)stack; 99\targs-\u0026gt;start_func = entry; 100\targs-\u0026gt;start_arg = arg; 101\targs-\u0026gt;control = attr._a_sched ? 1 : 0; 102 103 /* 调用clone创建线程 */ 104 clone(start, stack, flags, args, \u0026amp;new-\u0026gt;tid, TP_ADJ(new), \u0026amp;__thread_list_lock); 105\t106 /* 设置调度器 */ 107 ret = __syscall(SYS_sched_setscheduler, new-\u0026gt;tid, attr._a_policy, \u0026amp;attr._a_prio); 108\tif (a_swap(\u0026amp;args-\u0026gt;control, ret ? 3 : 0)==2) 109\t__wake(\u0026amp;args-\u0026gt;control, 1, 1); 110\tif (ret) 111\t__wait(\u0026amp;args-\u0026gt;control, 0, 3, 0); 112 113 /* 初始化链表 */ 114 new-\u0026gt;next = self-\u0026gt;next; 115\tnew-\u0026gt;prev = self; 116\tnew-\u0026gt;next-\u0026gt;prev = new; 117\tnew-\u0026gt;prev-\u0026gt;next = new; 118 119 /* 返回new作为线程ID */ 120} 121 122void __pthread_exit(void *result) 123{ 124\tpthread_t self = __pthread_self(); 125\tsigset_t set; 126 127 /* 设置退出标志 */ 128 self-\u0026gt;canceldisable = 1; 129\tself-\u0026gt;cancelasync = 0; 130\tself-\u0026gt;result = result; 131\t132 /* 执行线程清理函数 */ 133\twhile (self-\u0026gt;cancelbuf) { 134\tvoid (*f)(void *) = self-\u0026gt;cancelbuf-\u0026gt;__f; 135\tvoid *x = self-\u0026gt;cancelbuf-\u0026gt;__x; 136\tself-\u0026gt;cancelbuf = self-\u0026gt;cancelbuf-\u0026gt;__next; 137\tf(x); 138\t} 139 140 int state = a_cas(\u0026amp;self-\u0026gt;detach_state, DT_JOINABLE, DT_EXITING); 141\t142 /* 如果线程分离状态,则代表需要自己手动释放内存 */ 143\tif (state==DT_DETACHED \u0026amp;\u0026amp; self-\u0026gt;map_base) { 144 __vm_wait(); 145\t} 146 147 volatile void *volatile *rp; 148\twhile ((rp=self-\u0026gt;robust_list.head) \u0026amp;\u0026amp; rp != \u0026amp;self-\u0026gt;robust_list.head) { 149\tpthread_mutex_t *m = (void *)((char *)rp 150\t- offsetof(pthread_mutex_t, _m_next)); 151\tint waiters = m-\u0026gt;_m_waiters; 152\tint priv = (m-\u0026gt;_m_type \u0026amp; 128) ^ 128; 153\tself-\u0026gt;robust_list.pending = rp; 154\tself-\u0026gt;robust_list.head = *rp; 155\tint cont = a_swap(\u0026amp;m-\u0026gt;_m_lock, 0x40000000); 156\tself-\u0026gt;robust_list.pending = 0; 157\tif (cont \u0026lt; 0 || waiters) 158\t__wake(\u0026amp;m-\u0026gt;_m_lock, 1, priv); 159\t} 160 161 self-\u0026gt;next-\u0026gt;prev = self-\u0026gt;prev; 162\tself-\u0026gt;prev-\u0026gt;next = self-\u0026gt;next; 163\tself-\u0026gt;prev = self-\u0026gt;next = self; 164 165\tif (state==DT_DETACHED \u0026amp;\u0026amp; self-\u0026gt;map_base) { 166\tif (self-\u0026gt;robust_list.off) { 167\t__syscall(SYS_set_robust_list, 0, 3*sizeof(long)); 168 } 169 170\t__unmapself(self-\u0026gt;map_base, self-\u0026gt;map_size); 171\t} 172 173 /* 设置线程为退出 */ 174 a_store(\u0026amp;self-\u0026gt;detach_state, DT_EXITED); 175\t176 /* 唤醒 */ 177 __wake(\u0026amp;self-\u0026gt;detach_state, 1, 1); 178 179 /* 清除线程ID */ 180\tself-\u0026gt;tid = 0; 181 182 /* 杀死线程 */ 183\tfor (;;) __syscall(SYS_exit, 0); 184} glibc实现的线程函数 1 2int pthread_create (pthread_t * thread, const pthread_attr_t * attr, 3\tvoid *(*start_routine) (void *), void *arg) 4{ 5\tstruct __pthread *pthread; 6\tconst struct __pthread_attr *setup; 7\tsigset_t sigset; 8\tsize_t stacksize; 9\tint err;\t10\t11\terr = __pthread_alloc (\u0026amp;pthread); // 申请pthread 12\t13\t/* 填充堆栈大小,优先级从上到下 */ 14\t15\t/* 1. 用户设定 */ 16\tstacksize = setup-\u0026gt;__stacksize; 17\t18\t/* 2. 系统限制 */ 19 __getrlimit (RLIMIT_STACK, \u0026amp;rlim); 20\tstacksize = rlim.rlim_cur; 21\t22\t/* 3. 默认大小8M */ 23\tstacksize = PTHREAD_STACK_DEFAULT; 24\t25\t/* 最后将结果回填 */ 26\tpthread-\u0026gt;stacksize = stacksize; 27\t28\t/* 确定PTHREAD_DETACHED/PTHREAD_JOINABLE */ 29\tpthread-\u0026gt;state = (setup-\u0026gt;__detachstate == PTHREAD_CREATE_DETACHED 30\t? PTHREAD_DETACHED : PTHREAD_JOINABLE); 31\t32\t/* 1. 填充堆栈:用户提供堆栈 */ 33\tpthread-\u0026gt;stackaddr = setup-\u0026gt;__stackaddr; 34\tpthread-\u0026gt;guardsize = 0; 35\tpthread-\u0026gt;stack = 0; 36 37\t/* 2. 用户没有提供堆栈 */ 38\t__pthread_stack_alloc (\u0026amp;pthread-\u0026gt;stackaddr, 39\t((setup-\u0026gt;__guardsize + __vm_page_size - 1) 40\t/ __vm_page_size) * __vm_page_size 41\t+ stacksize); 42\tpthread-\u0026gt;guardsize = setup-\u0026gt;__guardsize; 43\tpthread-\u0026gt;stack = 1; 44 45 /* 申请内核线程 */ 46 __pthread_thread_alloc (pthread); 47 48 /* 申请线程控制块 */ 49 pthread-\u0026gt;tcb = _dl_allocate_tls (NULL); 50 pthread-\u0026gt;tcb-\u0026gt;tcb = pthread-\u0026gt;tcb; 51 52 /* 设置入口地址等相关参数 */ 53\t__pthread_setup (pthread, entry_point, start_routine, arg); 54 55 /* 初始化信号 */ 56 __pthread_sigstate_init (pthread); 57 __pthread_sigstate (_pthread_self(), 0, 0, \u0026amp;pthread-\u0026gt;init_sigset, 0); 58 59 /* 增加计数 */ 60 atomic_increment (\u0026amp;__pthread_total); 61 __libc_rwlock_rdlock (GL (dl_pthread_threads_lock)); 62 GL (dl_pthread_threads)[pthread-\u0026gt;thread - 1] = pthread; 63 __libc_rwlock_unlock (GL (dl_pthread_threads_lock)); 64 65 /* 创建结束,返回线程ID */ 66\t*thread = pthread-\u0026gt;thread; 67 68 /* 启动调度 */ 69 __pthread_thread_start(pthread); 70} 将其中的函数拆解开进行分析\npthread管理单元申请与释放 全局free线程链表中获取 1// __pthread_alloc 2struct __pthread *__pthread_free_threads; 3pthread_mutex_t __pthread_free_threads_lock; 4 5__pthread_mutex_lock (\u0026amp;__pthread_free_threads_lock); 6for (new = __pthread_free_threads; new; new = new-\u0026gt;next) 7{ 8\t/* 此标志为1才代表完全退出 */ 9\tif (new-\u0026gt;terminated) 10\t{ 11\t__pthread_dequeue(new); 12\tbreak; 13\t} 14} 15__pthread_mutex_unlock(\u0026amp;__pthread_free_threads_lock); 16 17// __pthread_dealloc 18__pthread_mutex_lock (\u0026amp;__pthread_free_threads_lock); 19__pthread_enqueue (\u0026amp;__pthread_free_threads, pthread); 20__pthread_mutex_unlock (\u0026amp;__pthread_free_threads_lock); 21 22/* 添加和删除的操作较为简单,可自行阅读 */ 23__pthread_enqueue (struct __pthread **head, struct __pthread *thread); 24__pthread_dequeue (struct __pthread *thread); 25// 操作的成员分别是 prev/next 直接调用malloc进行申请 无论是复用还是 重新申请,最后需要调用initialize_pthread进行初始化,此函数初始化默认参数 内核线程创建 1int __pthread_thread_alloc (struct __pthread *thread) 2{ 3 /// 创建唤醒消息 4\tcreate_wakeupmsg(thread); 5 6 /// 创建内核线程 7 __thread_create(__mach_task_self(), \u0026amp;thread-\u0026gt;kernel_thread); 8} TLS创建 1void *_dl_allocate_tls (void *mem) 2{ 3 void *result = NULLL; 4 5 if (NULL == mem) 6 { 7 result = _dl_allocate_tls_storage(); 8 } 9 else 10 { 11 result = allocate_dtv(mem); 12 } 13 14 return _dl_allocate_tls_init(result); 15} 设置启动参数 1// 1. 线程实体 2// 2. 入口函数 entry_point --\u0026gt; start_routine(arg); 3// 3. 用户线程 4// 4. 用户参数 5int __pthread_setup (struct __pthread *thread, 6\tvoid (*entry_point) (struct __pthread *, void *(*)(void *), void *), 7\tvoid *(*start_routine) (void *), void *arg) 8{\t9 /* 设置线程上下文:此时应该思考一个问题，什么叫做上下文 */ 10 thread-\u0026gt;mcontext.pc = entry_point; 11 thread-\u0026gt;mcontext.sp = stack_setup (thread, start_routine, arg); 12} ptrhead进程属性机制 1 2int pthread_attr_init(pthread_attr_t *a); 3pthread_attr_t-\u0026gt;_a_stacksize = __default_stacksize; 4pthread_attr_t-\u0026gt;_a_guardsize = __default_guardsize; 5 6int pthread_attr_setdetachstate(pthread_attr_t *a, int state); 7pthread_attr_t-\u0026gt;_a_detach = state; 8 9int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); 10pthread_attr_t-\u0026gt;_a_guardsize = size; 11 12int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); 13pthread_attr_t-\u0026gt;_a_sched = inherit; 14 15int pthread_attr_setschedparam(pthread_attr_t *restrict a, 16const struct sched_param *restrict param); 17pthread_attr_t-\u0026gt;_a_prio = param-\u0026gt;sched_priority; 18 19int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); 20pthread_attr_t-\u0026gt;_a_policy = policy; 21 22int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); 23pthread_attr_t-\u0026gt;_a_stackaddr = (size_t)addr + size; 24pthread_attr_t-\u0026gt;_a_stacksize = size; 25 26int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); 27pthread_attr_t-\u0026gt;_a_stackaddr = 0; 28pthread_attr_t-\u0026gt;_a_stacksize = size; 自身线程ID 1// 在musl和glibc的实现上二者不太一样 2 3static inline uintptr_t __get_tp() 4{ 5\tuintptr_t tp; 6\t__asm__ ( \u0026#34;mrc p15,0,%0,c13,c0,3\u0026#34; : \u0026#34;=r\u0026#34;(tp) ); 7\treturn tp; 8} 9 10// 获取线程自身的方法 11#define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) 12 13// 二者实现不太一样 14/* Return the thread descriptor for the current thread. */ 15# define THREAD_SELF ((struct pthread *)__builtin_thread_pointer () - 1) 16pthread_t __pthread_self (void) 17{ 18 return (pthread_t) THREAD_SELF; 19} 线程清理函数 一句话:就是设置pthread-\u0026gt;cancelbuf成员函数\n1#define pthread_cleanup_push(f, x) \\ 2do { \\ 3\tstruct __ptcb __cb; \\ 4 _pthread_cleanup_push(\u0026amp;__cb, f, x); \\ 5 6#define pthread_cleanup_pop(r) \\ 7\t_pthread_cleanup_pop(\u0026amp;__cb, (r)); \\ 8} while(0) 9 10void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) 11{ 12\tcb-\u0026gt;__f = f; 13\tcb-\u0026gt;__x = x; 14\t__do_cleanup_push(cb); 15} 16 17void _pthread_cleanup_pop(struct __ptcb *cb, int run) 18{ 19\t__do_cleanup_pop(cb); 20\tif (run) cb-\u0026gt;__f(cb-\u0026gt;__x); 21} 22 23void __do_cleanup_push(struct __ptcb *cb) 24{ 25\tstruct pthread *self = __pthread_self(); 26\tcb-\u0026gt;__next = self-\u0026gt;cancelbuf; 27\tself-\u0026gt;cancelbuf = cb; 28} 29 30void __do_cleanup_pop(struct __ptcb *cb) 31{ 32\t__pthread_self()-\u0026gt;cancelbuf = cb-\u0026gt;__next; 33} cancle设置 1int __pthread_setcancelstate(int new, int *old); 2self-\u0026gt;canceldisable --\u0026gt; old; 3self-\u0026gt;canceldisable \u0026lt;-- new; 4 5int pthread_setcanceltype(int new, int *old); 6self-\u0026gt;cancelasync --\u0026gt; old; 7self-\u0026gt;cancelasync \u0026lt;-- new; 8// 同时还会执行__pthread_testcancel 9\t10int pthread_cancel(pthread_t t) 11{ 12\t// 自己的线程,直接退出 13\tpthread_exit(PTHREAD_CANCELED); 14\t15\t// 不是自己,发送退出信息 16\tpthread_kill(t, SIGCANCEL) 17} 18 19// 设置线程取消点 20__pthread_testcancel --\u0026gt; __testcancel --\u0026gt; __cancel() 21void __pthread_testcancel() 22{ 23\t__testcancel(); 24} 25 26void __testcancel() 27{ 28\tpthread_t self = __pthread_self(); 29\tif (self-\u0026gt;cancel \u0026amp;\u0026amp; !self-\u0026gt;canceldisable) 30\t__cancel(); 31} 32 33/* 允许进行cancle才可以 */ 34long __cancel() 35{ 36\tpthread_t self = __pthread_self(); 37\tif (self-\u0026gt;canceldisable == PTHREAD_CANCEL_ENABLE || 38 self-\u0026gt;cancelasync) 39\tpthread_exit(PTHREAD_CANCELED); 40\tself-\u0026gt;canceldisable = PTHREAD_CANCEL_DISABLE; 41\treturn -ECANCELED; 42} 43// 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么?\n因此需要分析一下pthread_kill发生了什么?\n1int pthread_kill(pthread_t t, int sig) 2{ 3\t__block_all_sigs(\u0026amp;set); 4\tLOCK(t-\u0026gt;killlock); 5 6 // 仅仅对线程发送了一个信号 7\t__syscall(SYS_tkill, t-\u0026gt;tid, sig); 8\t9 UNLOCK(t-\u0026gt;killlock); 10\t__restore_sigs(\u0026amp;set); 11} 12 13// 那么在此回到pthread_cancle函数 14static void init_cancellation() 15{ 16\tstruct sigaction sa = { 17\t.sa_flags = SA_SIGINFO | SA_RESTART, 18\t.sa_sigaction = cancel_handler 19\t}; 20\tmemset(\u0026amp;sa.sa_mask, -1, _NSIG/8); 21\t__libc_sigaction(SIGCANCEL, \u0026amp;sa, 0); 22} 23 24int pthread_cancel(pthread_t t) 25{ 26 /* 此处存在这一个初始化 */ 27\tstatic int init; 28\tif (!init) { 29\tinit_cancellation(); 30\tinit = 1; 31\t} 32} 33 34static void cancel_handler(int sig, siginfo_t *si, void *ctx) 35{ 36\tpthread_t self = __pthread_self(); 37\tucontext_t *uc = ctx; 38\tuintptr_t pc = uc-\u0026gt;uc_mcontext.MC_PC; 39 40\ta_barrier(); 41\tif (!self-\u0026gt;cancel || self-\u0026gt;canceldisable == PTHREAD_CANCEL_DISABLE) return; 42 43\t_sigaddset(\u0026amp;uc-\u0026gt;uc_sigmask, SIGCANCEL); 44 45\tif (self-\u0026gt;cancelasync || pc \u0026gt;= (uintptr_t)__cp_begin \u0026amp;\u0026amp; pc \u0026lt; (uintptr_t)__cp_end) { 46\tuc-\u0026gt;uc_mcontext.MC_PC = (uintptr_t)__cp_cancel; 47#ifdef CANCEL_GOT 48\tuc-\u0026gt;uc_mcontext.MC_GOT = CANCEL_GOT; 49#endif 50\treturn; 51\t} 52 53\t__syscall(SYS_tkill, self-\u0026gt;tid, SIGCANCEL); 54} 在musl中分析结束,现在分析一下glibc是如何实现的？\n1// 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 2void __pthread_testcancel (void) 3{ 4 struct __pthread *p = _pthread_self (); 5 int cancelled; 6 7 __pthread_mutex_lock (\u0026amp;p-\u0026gt;cancel_lock); 8 cancelled = (p-\u0026gt;cancel_state == PTHREAD_CANCEL_ENABLE) \u0026amp;\u0026amp; p-\u0026gt;cancel_pending; 9 __pthread_mutex_unlock (\u0026amp;p-\u0026gt;cancel_lock); 10 11 if (cancelled) 12 __pthread_exit (PTHREAD_CANCELED); 13} 14 15// 但是glibc没有什么特别的差别 线程分离 1// 线程分离 2int pthread_detach(pthread_t) 3--\u0026gt; __pthread_join(pthread_t, 0) 4--\u0026gt; __pthread_timedjoin_np(pthread_t, 0, 0) 5 6 7// 设置线程等待 8int pthread_join(pthread_t, void **); 9--\u0026gt;__pthread_timedjoin_np(pthread_t, res, 0) 10 11// 那么也就是说明都调用了相同的函数 12 13static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) 14{ 15\t/* 设置线程分离状态 */ 16} 原子操作 1/// 原子操作由汇编实现 自旋锁 1int pthread_spin_init(pthread_spinlock_t *s, int shared) 2{ 3\treturn *s = 0; 4} 5 6int pthread_spin_destroy(pthread_spinlock_t *s) 7{ 8\treturn 0; 9} 10 11int pthread_spin_lock(pthread_spinlock_t *s) 12{ 13\twhile (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin(); 14\treturn 0; 15} 16 17int pthread_spin_trylock(pthread_spinlock_t *s) 18{ 19\treturn a_cas(s, 0, EBUSY); 20} 21 22int pthread_spin_unlock(pthread_spinlock_t *s) 23{ 24\ta_store(s, 0); 25\treturn 0; 26} 内存屏障 1int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); 2int pthread_barrier_destroy(pthread_barrier_t *); 3int pthread_barrier_wait(pthread_barrier_t *); 互斥锁 互斥锁musl实现 在musl库上的互斥锁,但是我感觉musl的设计存在一些瑕疵,还是在去分析一下glibc的设计思路吧.\n1typedef struct { 2 union { 3 int __i[sizeof(long)==8?10:6]; 4 volatile int __vi[sizeof(long)==8?10:6]; 5 volatile void *volatile __p[sizeof(long)==8?5:6]; 6 } __u; 7} pthread_mutex_t; 8 9int pthread_mutex_init(pthread_mutex_t *restrict m, 10 const pthread_mutexattr_t *restrict a) 11{ 12\t*m = (pthread_mutex_t){0}; 13\tif (a) { 14 m-\u0026gt;_m_type = a-\u0026gt;__attr; 15 } 16\treturn 0; 17} 18 19int pthread_mutex_destroy(pthread_mutex_t *mutex) 20{ 21\tif (mutex-\u0026gt;_m_type \u0026gt; 128) { 22 __vm_wait(); 23 } 24\treturn 0; 25} 26 27int pthread_mutex_lock(pthread_mutex_t *m) 28{ 29\tif ((m-\u0026gt;_m_type \u0026amp;15) == PTHREAD_MUTEX_NORMAL 30\t\u0026amp;\u0026amp; !a_cas(\u0026amp;m-\u0026gt;_m_lock, 0, EBUSY)) 31\treturn 0; 32 33\treturn __pthread_mutex_timedlock(m, 0); 34} 35 36int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, 37\tconst struct timespec *restrict at) 38{ 39\t/* PTHREAD_MUTEX_NORMAL:死等 */ 40\tif ((m-\u0026gt;_m_type\u0026amp;15) == PTHREAD_MUTEX_NORMAL 41\t\u0026amp;\u0026amp; !a_cas(\u0026amp;m-\u0026gt;_m_lock, 0, EBUSY)) 42\treturn 0; 43 44\tint type = m-\u0026gt;_m_type; 45\tint r, t, priv = (type \u0026amp; 128) ^ 128; 46 47\t/* 尝试加锁 */ 48\tr = __pthread_mutex_trylock(m); 49\tif (r != EBUSY) { 50\treturn r; 51\t} 52 53\tif (type\u0026amp;8) return pthread_mutex_timedlock_pi(m, at); 54\t55\tint spins = 100; 56\twhile (spins-- \u0026amp;\u0026amp; m-\u0026gt;_m_lock \u0026amp;\u0026amp; !m-\u0026gt;_m_waiters) a_spin(); 57 58\twhile ((r=__pthread_mutex_trylock(m)) == EBUSY) { 59\tr = m-\u0026gt;_m_lock; 60\tint own = r \u0026amp; 0x3fffffff; 61\tif (!own \u0026amp;\u0026amp; (!r || (type\u0026amp;4))) 62\tcontinue; 63\tif ((type\u0026amp;3) == PTHREAD_MUTEX_ERRORCHECK 64\t\u0026amp;\u0026amp; own == __pthread_self()-\u0026gt;tid) 65\treturn EDEADLK; 66 67\ta_inc(\u0026amp;m-\u0026gt;_m_waiters); 68\tt = r | 0x80000000; 69\ta_cas(\u0026amp;m-\u0026gt;_m_lock, r, t); 70\tr = __timedwait(\u0026amp;m-\u0026gt;_m_lock, t, CLOCK_REALTIME, at, priv); 71\ta_dec(\u0026amp;m-\u0026gt;_m_waiters); 72\tif (r \u0026amp;\u0026amp; r != EINTR) break; 73\t} 74\treturn r; 75} 互斥锁glibc实现 musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex)\n互斥锁的定义 1struct __pthread_mutex_s 2{ 3\tint __lock; 4\tunsigned int __count; 5\tint __owner; 6\tint __kind; 7\tunion 8\t{ 9\tint __spins; 10\t__pthread_slist_t __list; 11\t}; 12}; 13 14typedef union 15{ 16 struct __pthread_mutex_s __data; 17 char __size[__SIZEOF_PTHREAD_MUTEX_T]; 18 long int __align; 19} pthread_mutex_t; 上锁的实现\n1int __pthread_mutex_lock (pthread_mutex_t *mtxp) 2{ 3\tstruct __pthread *self; 4\tint flags = mtxp-\u0026gt;__flags \u0026amp; GSYNC_SHARED; 5\tint ret = 0; 6 7\t// 根据不同的类型确定 8\t#define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED 9\t#define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) 10\t#define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) 11\tswitch (MTX_TYPE (mtxp)) 12\t{ 13\t/* 普通上锁方式 */ 14\tcase PT_MTX_NORMAL: 15\tlll_lock (mtxp-\u0026gt;__lock, flags); 16\tbreak; 17\t18\t/* 迭代锁 */ 19\tcase PT_MTX_RECURSIVE: 20\tself = _pthread_self (); 21\tif (mtx_owned_p (mtxp, self, flags)) 22\t{ 23\tif (__glibc_unlikely (mtxp-\u0026gt;__cnt + 1 == 0)) 24\treturn EAGAIN; 25 26\t++mtxp-\u0026gt;__cnt; 27\treturn ret; 28\t} 29 30\tlll_lock (mtxp-\u0026gt;__lock, flags); 31\tmtx_set_owner (mtxp, self, flags); 32\tmtxp-\u0026gt;__cnt = 1; 33\tbreak; 34 35\tcase PT_MTX_ERRORCHECK: 36\tself = _pthread_self (); 37\tif (mtx_owned_p (mtxp, self, flags)) 38\treturn EDEADLK; 39 40\tlll_lock (mtxp-\u0026gt;__lock, flags); 41\tmtx_set_owner (mtxp, self, flags); 42\tbreak; 43 44\tcase PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: 45\tcase PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: 46\tcase PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: 47\tself = _pthread_self (); 48\tROBUST_LOCK (self, mtxp, lll_robust_lock, flags); 49\tbreak; 50 51\tdefault: 52\tret = EINVAL; 53\tbreak; 54\t} 55 56 return ret; 57} 条件变量 读写锁 ","date":"1010-05-01","img":"","largeImg":"","permalink":"/posts/pthread/","series":null,"smallImg":"","tags":[],"title":"Pthread源码分析"},{"categories":[],"content":"ZONE ZONE类型 ZONE_DMA, ZONE_DMA32 ZONE_NORMAL ZONE_HIGHMEM ZONE_MOVABLE ZONE_DEVICE ","date":"13130-03-13","img":"","largeImg":"","permalink":"/posts/memory_management/","series":null,"smallImg":"","tags":[],"title":"内存管理"},{"categories":["rootfs"],"content":"下载buildroot 1git clone --depth=1 https://git.busybox.net/buildroot 2git branch -a [new branch] 3git checkout [new branch] 快速开始 可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026amp;\u0026amp; make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh 基础配置 使用自定义的内核 在defconfig文件中添加下面的配置\n1BR2_LINUX_KERNEL=y # 是否编译内核 2BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 3BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\u0026#34;git@github.com:mengdemao/kernel.git\u0026#34; # kernel的地址 4BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\u0026#34;master\u0026#34; # 版本 5BR2_LINUX_KERNEL_VERSION=\u0026#34;master\u0026#34; 6BR2_LINUX_KERNEL_USE_DEFCONFIG=y 7BR2_LINUX_KERNEL_DEFCONFIG=\u0026#34;debian\u0026#34; 8BR2_LINUX_KERNEL_ZIMAGE=y 9BR2_LINUX_KERNEL_GZIP=y ","date":"13130-03-13","img":"","largeImg":"","permalink":"/posts/buildroot/","series":null,"smallImg":"","tags":["rootfs"],"title":"Buildroot"},{"categories":["compiler"],"content":"C4实现 C4共实现了4个函数\n1void stmt(); 2void next(); 3void expr(int lev); 4int main(int argc, char **argv); 全局数据 全局变量 1char *p, *lp, // current position in source code 2 *data; // data/bss pointer 3 4int *e, *le, // current position in emitted code 5 *id, // currently parsed identifier 6 *sym, // symbol table (simple list of identifiers) 7 tk, // current token 8 ival, // current token value 9 ty, // current expression type 10 loc, // local variable offset 11 line, // current line number 12 src, // print source and assembly flag 13 debug; // print executed instructions 表达式描述 1// 符号描述 2enum { 3 Num = 128, Fun, Sys, Glo, Loc, Id, 4 Char, Else, Enum, If, Int, Return, Sizeof, While, 5 Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak 6}; 7 8// 操作符 9enum 10{ 11\tLEA , 12\tIMM , 13\tJMP , 14\tJSR , 15\tBZ , 16\tBNZ , 17\tENT , 18\tADJ , 19\tLEV , 20\tLI , 21\tLC , 22\tSI , 23\tSC , 24\tPSH , 25 OR , 26\tXOR , 27\tAND , 28\tEQ , 29\tNE , 30\tLT , 31\tGT , 32\tLE , 33\tGE , 34\tSHL , 35\tSHR , 36\tADD , 37\tSUB , 38\tMUL , 39\tDIV , 40\tMOD , 41 OPEN, 42\tREAD, 43\tCLOS, 44\tPRTF, 45\tMALC, 46\tFREE, 47\tMSET, 48\tMCMP, 49\tEXIT 50}; 51 52// 类型描述 53enum 54{ 55\tCHAR, 56\tINT, 57\tPTR 58}; 59 60// 表达式描述 61enum 62{ 63\tTk, 64\tHash, 65\tName, 66\tClass, 67\tType, 68\tVal, 69\tHClass, 70\tHType, 71\tHVal, 72\tIdsz 73}; 基本架构 1graph TD 2main--\u0026gt;stmt 3stmt--\u0026gt;stmt 4main--\u0026gt;next 5stmt--\u0026gt;next 6stmt--\u0026gt;expr 7expr--\u0026gt;expr 8expr--\u0026gt;next 词法分析(next) 提取下一个单词\n1 2tk, // current token 3ival, // current token value parse code generator stack based virtual machine pc sp bp 1 while (1) { 2 i = *pc++; ++cycle; 3 if (i == LEA) a = (int)(bp + *pc++); // load local address 4 else if (i == IMM) a = *pc++; // load global address or immediate 5 else if (i == JMP) pc = (int *)*pc; // jump 6 else if (i == JSR) { *--sp = (int)(pc + 1); pc = (int *)*pc; } // jump to subroutine 7 else if (i == BZ) pc = a ? pc + 1 : (int *)*pc; // branch if zero 8 else if (i == BNZ) pc = a ? (int *)*pc : pc + 1; // branch if not zero 9 else if (i == ENT) { *--sp = (int)bp; bp = sp; sp = sp - *pc++; } // enter subroutine 10 else if (i == ADJ) sp = sp + *pc++; // stack adjust 11 else if (i == LEV) { sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; } // leave subroutine 12 else if (i == LI) a = *(int *)a; // load int 13 else if (i == LC) a = *(char *)a; // load char 14 else if (i == SI) *(int *)*sp++ = a; // store int 15 else if (i == SC) a = *(char *)*sp++ = a; // store char 16 else if (i == PSH) *--sp = a; // push 17 18 else if (i == OR) a = *sp++ | a; 19 else if (i == XOR) a = *sp++ ^ a; 20 else if (i == AND) a = *sp++ \u0026amp; a; 21 else if (i == EQ) a = *sp++ == a; 22 else if (i == NE) a = *sp++ != a; 23 else if (i == LT) a = *sp++ \u0026lt; a; 24 else if (i == GT) a = *sp++ \u0026gt; a; 25 else if (i == LE) a = *sp++ \u0026lt;= a; 26 else if (i == GE) a = *sp++ \u0026gt;= a; 27 else if (i == SHL) a = *sp++ \u0026lt;\u0026lt; a; 28 else if (i == SHR) a = *sp++ \u0026gt;\u0026gt; a; 29 else if (i == ADD) a = *sp++ + a; 30 else if (i == SUB) a = *sp++ - a; 31 else if (i == MUL) a = *sp++ * a; 32 else if (i == DIV) a = *sp++ / a; 33 else if (i == MOD) a = *sp++ % a; 34 35 else if (i == OPEN) a = open((char *)sp[1], *sp); 36 else if (i == READ) a = read(sp[2], (char *)sp[1], *sp); 37 else if (i == CLOS) a = close(*sp); 38 else if (i == PRTF) { t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); } 39 else if (i == MALC) a = (int)malloc(*sp); 40 else if (i == FREE) free((void *)*sp); 41 else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp); 42 else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp); 43 else if (i == EXIT) { printf(\u0026#34;exit(%d) cycle = %d\\n\u0026#34;, *sp, cycle); return *sp; } 44 else { printf(\u0026#34;unknown instruction = %d! cycle = %d\\n\u0026#34;, i, cycle); return -1; } 45 } ","date":"16160-01-16","img":"","largeImg":"","permalink":"/posts/c4/","series":null,"smallImg":"","tags":["compiler"],"title":"C4"},{"categories":[],"content":"Lua源码分析 Lua运行结构\ngraph LR 编译器==\u003ePROTO==\u003e虚拟机 相关数据结构 全局状态机 描述Lua运行状态,同时可以产生一种面向对象的模拟\n1struct lua_State { 2 CommonHeader; 3 lu_byte status; 4 lu_byte allowhook; 5 unsigned short nci; /* number of items in \u0026#39;ci\u0026#39; list */ 6 StkId top; /* first free slot in the stack */ 7 global_State *l_G; 8 CallInfo *ci; /* call info for current function */ 9 StkId stack_last; /* end of stack (last element + 1) */ 10 StkId stack; /* stack base */ 11 UpVal *openupval; /* list of open upvalues in this stack */ 12 StkId tbclist; /* list of to-be-closed variables */ 13 GCObject *gclist; 14 struct lua_State *twups; /* list of threads with open upvalues */ 15 struct lua_longjmp *errorJmp; /* current error recover point */ 16 CallInfo base_ci; /* CallInfo for first level (C calling Lua) */ 17 volatile lua_Hook hook; 18 ptrdiff_t errfunc; /* current error handling function (stack index) */ 19 l_uint32 nCcalls; /* number of nested (non-yieldable | C) calls */ 20 int oldpc; /* last pc traced */ 21 int basehookcount; 22 int hookcount; 23 volatile l_signalT hookmask; 24}; Lua编译器 lua并没有直接运行源文件,而是将源文件编译成字节码，然后运行字节码 其中运行编译驱动文件名luac.c\n文件名 功能 入口函数 llex.c 词法分析 luaX_next lparser.c 语法解析 luaY_parser lcode.c 代码生成 luaK_finish ldump.c/lundump.c 字节码 luaU_dump/luaU_undump 词法分析 外部接口 1// 读取下一个单词 2void luaX_next (LexState *ls); 3 4// 预读下一个单词 5int luaX_lookahead (LexState *ls); 核心函数 1// 词法分析状态机 2typedef struct LexState { 3 int current; /* current character (charint) */ 4 int linenumber; /* input line counter */ 5 int lastline; /* line of last token \u0026#39;consumed\u0026#39; */ 6 Token t; /* current token */ 7 Token lookahead; /* look ahead token */ 8 struct FuncState *fs; /* current function (parser) */ 9 struct lua_State *L; 10 ZIO *z; /* input stream */ 11 Mbuffer *buff; /* buffer for tokens */ 12 Table *h; /* to avoid collection/reuse strings */ 13 struct Dyndata *dyd; /* dynamic structures used by the parser */ 14 TString *source; /* current source name */ 15 TString *envn; /* environment variable name */ 16} LexState; 17 18// 语义信息 19typedef union { 20 lua_Number r; 21 lua_Integer i; 22 TString *ts; 23} SemInfo; 24 25int llex (LexState *ls, SemInfo *seminfo); 语法分析 1typedef struct Proto { 2 CommonHeader; 3 lu_byte numparams; /* number of fixed (named) parameters */ 4 lu_byte is_vararg; 5 lu_byte maxstacksize; /* number of registers needed by this function */ 6 int sizeupvalues; /* size of \u0026#39;upvalues\u0026#39; */ 7 int sizek; /* size of \u0026#39;k\u0026#39; */ 8 int sizecode; 9 int sizelineinfo; 10 int sizep; /* size of \u0026#39;p\u0026#39; */ 11 int sizelocvars; 12 int sizeabslineinfo; /* size of \u0026#39;abslineinfo\u0026#39; */ 13 int linedefined; /* debug information */ 14 int lastlinedefined; /* debug information */ 15 TValue *k; /* constants used by the function */ 16 Instruction *code; /* opcodes */ 17 struct Proto **p; /* functions defined inside the function */ 18 Upvaldesc *upvalues; /* upvalue information */ 19 ls_byte *lineinfo; /* information about source lines (debug information) */ 20 AbsLineInfo *abslineinfo; /* idem */ 21 LocVar *locvars; /* information about local variables (debug information) */ 22 TString *source; /* used for debug information */ 23 GCObject *gclist; 24} Proto; 25typedef struct LClosure { 26 ClosureHeader; 27 struct Proto *p; 28 UpVal *upvals[1]; /* list of upvalues */ 29} LClosure; 30 31LClosure *luaY_parser ( 32 lua_State *L, 33 ZIO *z, 34 Mbuffer *buff, 35 Dyndata *dyd, 36 const char *name, 37 int firstchar); 代码生成 1void luaK_finish (FuncState *fs) { 2 int i; 3 Proto *p = fs-\u0026gt;f; 4 for (i = 0; i \u0026lt; fs-\u0026gt;pc; i++) { 5 Instruction *pc = \u0026amp;p-\u0026gt;code[i]; 6 lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc)); 7 switch (GET_OPCODE(*pc)) { 8 case OP_RETURN0: case OP_RETURN1: { 9 if (!(fs-\u0026gt;needclose || p-\u0026gt;is_vararg)) 10 break; /* no extra work */ 11 /* else use OP_RETURN to do the extra work */ 12 SET_OPCODE(*pc, OP_RETURN); 13 } /* FALLTHROUGH */ 14 case OP_RETURN: case OP_TAILCALL: { 15 if (fs-\u0026gt;needclose) 16 SETARG_k(*pc, 1); /* signal that it needs to close */ 17 if (p-\u0026gt;is_vararg) 18 SETARG_C(*pc, p-\u0026gt;numparams + 1); /* signal that it is vararg */ 19 break; 20 } 21 case OP_JMP: { 22 int target = finaltarget(p-\u0026gt;code, i); 23 fixjump(fs, i, target); 24 break; 25 } 26 default: break; 27 } 28 } 29} 字节码 1int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data, 2 int strip) { 3 DumpState D; 4 D.L = L; 5 D.writer = w; 6 D.data = data; 7 D.strip = strip; 8 D.status = 0; 9 dumpHeader(\u0026amp;D); 10 dumpByte(\u0026amp;D, f-\u0026gt;sizeupvalues); 11 dumpFunction(\u0026amp;D, f, NULL); 12 return D.status; 13} 14LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name) { 15 LoadState S; 16 LClosure *cl; 17 if (*name == \u0026#39;@\u0026#39; || *name == \u0026#39;=\u0026#39;) 18 S.name = name + 1; 19 else if (*name == LUA_SIGNATURE[0]) 20 S.name = \u0026#34;binary string\u0026#34;; 21 else 22 S.name = name; 23 S.L = L; 24 S.Z = Z; 25 checkHeader(\u0026amp;S); 26 cl = luaF_newLclosure(L, loadByte(\u0026amp;S)); 27 setclLvalue2s(L, L-\u0026gt;top, cl); 28 luaD_inctop(L); 29 cl-\u0026gt;p = luaF_newproto(L); 30 luaC_objbarrier(L, cl, cl-\u0026gt;p); 31 loadFunction(\u0026amp;S, cl-\u0026gt;p, NULL); 32 lua_assert(cl-\u0026gt;nupvalues == cl-\u0026gt;p-\u0026gt;sizeupvalues); 33 luai_verifycode(L, cl-\u0026gt;p); 34 return cl; 35} Lua虚拟机 接受编译器产生的字节码并且运行,执行的入口函数是luaV_execute\nLua指令分析 指令名 参数 描述 OP_MOVE A B R(A) := R(B) OP_LOADK A Bx R(A) := Kst(Bx) OP_LOADBOOL A B C R(A) := (Bool)B; if (C) pc++ OP_LOADNIL A B R(A) := ... := R(B) := nil OP_GETUPVAL A B R(A) := UpValue[B] OP_GETGLOBAL A Bx R(A) := Gbl[Kst(Bx)] OP_GETTABLE A B C R(A) := R(B)[RK(C)] OP_SETGLOBAL A Bx Gbl[Kst(Bx)] := R(A) OP_SETUPVAL A B UpValue[B] := R(A) OP_SETTABLE A B C `R(A)[RK(B)] := RK(C) OP_NEWTABLE A B C R(A) := {} (size = B,C) OP_SELF A B C R(A+1) := R(B); R(A) := R(B)[RK(C)] OP_ADD A B C R(A) := RK(B) + RK(C) OP_SUB A B C R(A) := RK(B) - RK(C) OP_MUL A B C R(A) := RK(B) * RK(C) OP_DIV A B C R(A) := RK(B) / RK(C) OP_MOD A B C R(A) := RK(B) % RK(C) OP_POW A B C R(A) := RK(B) ^ RK(C) OP_UNM A B R(A) := -R(B) OP_NOT A B R(A) := not R(B) OP_LEN A B R(A) := length of R(B) OP_CONCAT A B C R(A) := R(B).. ... ..R(C) OP_JMP sBx pc+=sBx OP_EQ A B C if ((RK(B) == RK(C)) ~= A) then pc++ OP_LT A B C if ((RK(B) \u0026lt; RK(C)) ~= A) then pc++ OP_LE A B C if ((RK(B) \u0026lt;= RK(C)) ~= A) then pc++ OP_TEST A C if not (R(A) \u0026lt;=\u0026gt; C) then pc++ OP_TESTSET A B C if (R(B) \u0026lt;=\u0026gt; C) then R(A) := R(B) else pc++ OP_CALL A B C R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) OP_TAILCALL A B C return R(A)(R(A+1), ... ,R(A+B-1)) OP_RETURN A B return R(A), ... ,R(A+B-2)\t(see note) OP_FORLOOP A sBx R(A)+=R(A+2); if R(A) \u0026lt;?= R(A+1) then { pc+=sBx; R(A+3)=R(A) } OP_FORPREP A sBx R(A)-=R(A+2); pc+=sBx OP_TFORLOOP A C R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++ OP_SETLIST A B C R(A)[(C-1)*FPF+i] := R(A+i), 1 \u0026lt;= i \u0026lt;= B OP_CLOSE A close all variables in the stack up to (\u0026gt;=) R(A) OP_CLOSURE A Bx R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n)) OP_VARARG A B R(A), R(A+1), ..., R(A+B-1) = vararg 指令解析 1lua_State *L;\t/* Lua状态机 */ 2LClosure *cl = \u0026amp;clvalue(L-\u0026gt;ci-\u0026gt;func)-\u0026gt;l;\t/* 当前函数执行环境 */ 3TValue *k = cl-\u0026gt;p-\u0026gt;k;\t/* 函数环境常量数组 */ 4const Instruction *pc = L-\u0026gt;savedpc; /* 当前函数指针 */ 5StkId base = L-\u0026gt;base;;\t/* 函数环境栈基地址 */ 1// R(A|B|C) 寄存器索引 2#define RA(i)\t(base+GETARG_A(i)) 3#define RB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) 4#define RC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) 5 6// RKB() 寄存器索引或者常量索引 7#define RKB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ 8\tISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) 9#define RKC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ 10\tISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) 11 12#define KBx(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 指令分发 1const Instruction i = *pc++; 2StkId ra = RA(i); 钩子函数处理 1// 不明白在处理什么 2if ((L-\u0026gt;hookmask \u0026amp; (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026amp;\u0026amp; 3 (--L-\u0026gt;hookcount == 0 || L-\u0026gt;hookmask \u0026amp; LUA_MASKLINE)) { 4 traceexec(L, pc); 5 if (L-\u0026gt;status == LUA_YIELD) { /* did hook yield? */ 6 L-\u0026gt;savedpc = pc - 1; 7 return; 8 } 9 base = L-\u0026gt;base; 10} OP_MOVE 1#define setobjs2s\tsetobj 2case OP_MOVE: { 3\tsetobjs2s(L, ra, RB(i)); 4 continue; 5} OP_LOADK 1#define setobj2s\tsetobj 2case OP_LOADK: { 3\tsetobj2s(L, ra, KBx(i)); 4 continue; 5} 统一调用此函数\n1// 拷贝lua_TValue,也只有两个成员 2void setobj(lua_State *L, const TValue *obj1, TValue *obj2) 3{ 4 const TValue *o2=(obj2); 5 TValue *o1=(obj1); 6 7 o1-\u0026gt;value = o2-\u0026gt;value; 8 o1-\u0026gt;tt=o2-\u0026gt;tt; 9 10 checkliveness(G(L),o1); 11} OP_LOADBOOL 1case OP_LOADBOOL: { 2\tsetbvalue(ra, GETARG_B(i)); 3\tif (GETARG_C(i)) 4\tpc++; /* skip next instruction (if C) */ 5\tcontinue; 6} OP_LOADNIL 1case OP_LOADNIL: { 2\tTValue *rb = RB(i); 3\tdo { 4\tsetnilvalue(rb--); 5\t} while (rb \u0026gt;= ra); 6\tcontinue; 7} OP_GETUPVAL 1case OP_GETUPVAL: { 2\tint b = GETARG_B(i); 3\tsetobj2s(L, ra, cl-\u0026gt;upvals[b]-\u0026gt;v); 4\tcontinue; 5} 1case OP_GETGLOBAL: { 2\tTValue g; 3\tTValue *rb = KBx(i); 4\tsethvalue(L, \u0026amp;g, cl-\u0026gt;env); 5\tlua_assert(ttisstring(rb)); 6\tProtect(luaV_gettable(L, \u0026amp;g, rb, ra)); 7\tcontinue; 8} 1case OP_GETTABLE: { 2\tProtect(luaV_gettable(L, RB(i), RKC(i), ra)); 3\tcontinue; 4} 1case OP_SETGLOBAL: { 2\tTValue g; 3\tsethvalue(L, \u0026amp;g, cl-\u0026gt;env); 4\tlua_assert(ttisstring(KBx(i))); 5\tProtect(luaV_settable(L, \u0026amp;g, KBx(i), ra)); 6\tcontinue; 7} 1case OP_SETUPVAL: { 2\tUpVal *uv = cl-\u0026gt;upvals[GETARG_B(i)]; 3\tsetobj(L, uv-\u0026gt;v, ra); 4\tluaC_barrier(L, uv, ra); 5\tcontinue; 6} 1case OP_SETTABLE: { 2\tProtect(luaV_settable(L, ra, RKB(i), RKC(i))); 3\tcontinue; 4} 算术指令 1case OP_ADD: { 2\tarith_op(luai_numadd, TM_ADD); 3\tcontinue; 4} 5case OP_SUB: { 6\tarith_op(luai_numsub, TM_SUB); 7\tcontinue; 8} 9case OP_MUL: { 10\tarith_op(luai_nummul, TM_MUL); 11\tcontinue; 12} 13case OP_DIV: { 14\tarith_op(luai_numdiv, TM_DIV); 15\tcontinue; 16} 17case OP_MOD: { 18\tarith_op(luai_nummod, TM_MOD); 19\tcontinue; 20} 21case OP_POW: { 22\tarith_op(luai_numpow, TM_POW); 23\tcontinue; 24} 统一调用arith_op,计算数据效果\n功能 第一参数 第二参数 加 #define luai_numadd(a,b)\t((a)+(b)) TM_ADD 减 #define luai_numsub(a,b)\t((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b)\t((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b)\t((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b)\t(pow(a,b)) TM_POW 1void arith_op(op,tm) 2{ 3\tTValue *rb = RKB(i);\t// 第二操作数 4\tTValue *rc = RKC(i);\t// 第三操作数 5 6\tif (ttisnumber(rb) \u0026amp;\u0026amp; // 校验数据 7 ttisnumber(rc)) {\t// 校验数据 8 9\tlua_Number nb = nvalue(rb);\t// 提取数据 10 lua_Number nc = nvalue(rc); // 提取数据 11 12\tsetnvalue(ra, op(nb, nc)); // 设置第一操作数 13\t} else { 14 Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 15 } 16} 17 18#define Protect(x)\t{ L-\u0026gt;savedpc = pc; {x;}; base = L-\u0026gt;base; } 19static void Arith (lua_State *L, StkId ra, const TValue *rb, 20 const TValue *rc, TMS op) { 21 TValue tempb, tempc; 22 const TValue *b, *c; 23 if ((b = luaV_tonumber(rb, \u0026amp;tempb)) != NULL \u0026amp;\u0026amp; 24 (c = luaV_tonumber(rc, \u0026amp;tempc)) != NULL) { 25 lua_Number nb = nvalue(b), nc = nvalue(c); 26 switch (op) { 27 case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; 28 case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; 29 case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; 30 case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; 31 case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break; 32 case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break; 33 case TM_UNM: setnvalue(ra, luai_numunm(nb)); break; 34 default: lua_assert(0); break; 35 } 36 } 37 else if (!call_binTM(L, rb, rc, ra, op)) 38 luaG_aritherror(L, rb, rc); 39} ","date":"2020-01-02","img":"","largeImg":"","permalink":"/posts/lua/","series":null,"smallImg":"","tags":[],"title":"Lua"},{"categories":[],"content":"","date":"11110-12-11","img":"","largeImg":"","permalink":"/posts/complete/","series":null,"smallImg":"","tags":["kernel"],"title":"Complete"},{"categories":[],"content":"优先级定义 内核优先级使用0-139确定内部优先级,0-99分配实时进程; [100, 139]分配非实时进程,nice的映射[-20, 19]与非实时优先级的相对应.\n相关数据结构 任务相关数据\n1struct task_struct { 2\t3\tint\tprio;\t// 动态优先级 4\tint\tstatic_prio;\t// 静态优先级 5\tint\tnormal_prio;\t// 普通优先级\t6\tunsigned int\trt_priority;\t// 实时优先级 7}; 计算静态优先级 1static int effective_prio(struct task_struct *p) 2{ 3\t/* 设置普通优先级 */ 4\tp-\u0026gt;normal_prio = normal_prio(p); 5 6\t/* 如果不是实时优先级,则返回普通优先级 */ 7\tif (!rt_prio(p-\u0026gt;prio)) 8\treturn p-\u0026gt;normal_prio; 9\t10\t/* 返回动态优先级 */ 11\treturn p-\u0026gt;prio; 12} 获取普通优先级 1static inline int __normal_prio(struct task_struct *p) 2{ 3\treturn p-\u0026gt;static_prio; 4} 5 6static inline int normal_prio(struct task_struct *p) 7{ 8\tint prio; 9 10\tif (task_has_dl_policy(p)) 11\tprio = MAX_DL_PRIO-1; 12\telse if (task_has_rt_policy(p)) 13\tprio = MAX_RT_PRIO-1 - p-\u0026gt;rt_priority; 14\telse 15\tprio = __normal_prio(p); 16\treturn prio; 17} 负载计算 1// 负载权重 2struct load_weight { 3\tunsigned long\tweight; 4\tu32\tinv_weight; 5}; 6 7// 调度实体 8struct sched_entity { 9\tstruct load_weight\tload; 10}; 11 12struct sched_rt_entity { 13\tstruct list_head\trun_list; 14\tunsigned long\ttimeout; 15\tunsigned long\twatchdog_stamp; 16\tunsigned int\ttime_slice; 17\tunsigned short\ton_rq; 18\tunsigned short\ton_list; 19 20\tstruct sched_rt_entity\t*back; 21#ifdef CONFIG_RT_GROUP_SCHED 22\tstruct sched_rt_entity\t*parent; 23\t/* rq on which this entity is (to be) queued: */ 24\tstruct rt_rq\t*rt_rq; 25\t/* rq \u0026#34;owned\u0026#34; by this entity/group: */ 26\tstruct rt_rq\t*my_q; 27#endif 28} __randomize_layout; 29 30struct sched_dl_entity { 31\tstruct rb_node\trb_node; 32 33\t/* 34\t* Original scheduling parameters. Copied here from sched_attr 35\t* during sched_setattr(), they will remain the same until 36\t* the next sched_setattr(). 37\t*/ 38\tu64\tdl_runtime;\t/* Maximum runtime for each instance\t*/ 39\tu64\tdl_deadline;\t/* Relative deadline of each instance\t*/ 40\tu64\tdl_period;\t/* Separation of two instances (period) */ 41\tu64\tdl_bw;\t/* dl_runtime / dl_period\t*/ 42\tu64\tdl_density;\t/* dl_runtime / dl_deadline\t*/ 43 44\t/* 45\t* Actual scheduling parameters. Initialized with the values above, 46\t* they are continously updated during task execution. Note that 47\t* the remaining runtime could be \u0026lt; 0 in case we are in overrun. 48\t*/ 49\ts64\truntime;\t/* Remaining runtime for this instance\t*/ 50\tu64\tdeadline;\t/* Absolute deadline for this instance\t*/ 51\tunsigned int\tflags;\t/* Specifying the scheduler behaviour\t*/ 52 53\t/* 54\t* Some bool flags: 55\t* 56\t* @dl_throttled tells if we exhausted the runtime. If so, the 57\t* task has to wait for a replenishment to be performed at the 58\t* next firing of dl_timer. 59\t* 60\t* @dl_boosted tells if we are boosted due to DI. If so we are 61\t* outside bandwidth enforcement mechanism (but only until we 62\t* exit the critical section); 63\t* 64\t* @dl_yielded tells if task gave up the CPU before consuming 65\t* all its available runtime during the last job. 66\t* 67\t* @dl_non_contending tells if the task is inactive while still 68\t* contributing to the active utilization. In other words, it 69\t* indicates if the inactive timer has been armed and its handler 70\t* has not been executed yet. This flag is useful to avoid race 71\t* conditions between the inactive timer handler and the wakeup 72\t* code. 73\t* 74\t* @dl_overrun tells if the task asked to be informed about runtime 75\t* overruns. 76\t*/ 77\tunsigned int\tdl_throttled : 1; 78\tunsigned int\tdl_boosted : 1; 79\tunsigned int\tdl_yielded : 1; 80\tunsigned int\tdl_non_contending : 1; 81\tunsigned int\tdl_overrun\t: 1; 82 83\t/* 84\t* Bandwidth enforcement timer. Each -deadline task has its 85\t* own bandwidth to be enforced, thus we need one timer per task. 86\t*/ 87\tstruct hrtimer\tdl_timer; 88 89\t/* 90\t* Inactive timer, responsible for decreasing the active utilization 91\t* at the \u0026#34;0-lag time\u0026#34;. When a -deadline task blocks, it contributes 92\t* to GRUB\u0026#39;s active utilization until the \u0026#34;0-lag time\u0026#34;, hence a 93\t* timer is needed to decrease the active utilization at the correct 94\t* time. 95\t*/ 96\tstruct hrtimer inactive_timer; 97}; 98 99// 调度结构体 100struct task_struct { 101\tstruct sched_entity\tse; // 调度实体 102\tstruct sched_rt_entity\trt; // 实时调度实体 103\tstruct sched_dl_entity\tdl;\t// 限期调度实体 104}; 设置负载权重 1const int sched_prio_to_weight[40] = { 2 /* -20 */ 88761, 71755, 56483, 46273, 36291, 3 /* -15 */ 29154, 23254, 18705, 14949, 11916, 4 /* -10 */ 9548, 7620, 6100, 4904, 3906, 5 /* -5 */ 3121, 2501, 1991, 1586, 1277, 6 /* 0 */ 1024, 820, 655, 526, 423, 7 /* 5 */ 335, 272, 215, 172, 137, 8 /* 10 */ 110, 87, 70, 56, 45, 9 /* 15 */ 36, 29, 23, 18, 15, 10}; 11 12const u32 sched_prio_to_wmult[40] = { 13 /* -20 */ 48388, 59856, 76040, 92818, 118348, 14 /* -15 */ 147320, 184698, 229616, 287308, 360437, 15 /* -10 */ 449829, 563644, 704093, 875809, 1099582, 16 /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, 17 /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, 18 /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, 19 /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, 20 /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, 21}; 22 23static void set_load_weight(struct task_struct *p, bool update_load) 24{ 25\tint prio = p-\u0026gt;static_prio - MAX_RT_PRIO; 26\tstruct load_weight *load = \u0026amp;p-\u0026gt;se.load; 27 28\t// SCHED_IDLE 拥有最低权重 29\tif (idle_policy(p-\u0026gt;policy)) { 30\tload-\u0026gt;weight = scale_load(WEIGHT_IDLEPRIO); 31\tload-\u0026gt;inv_weight = WMULT_IDLEPRIO; 32\treturn; 33\t} 34 35\tif (update_load \u0026amp;\u0026amp; p-\u0026gt;sched_class == \u0026amp;fair_sched_class) { 36\treweight_task(p, prio); 37\t} else { 38\tload-\u0026gt;weight = scale_load(sched_prio_to_weight[prio]); 39\tload-\u0026gt;inv_weight = sched_prio_to_wmult[prio]; 40\t} 41} 不需更新权重 1\tload-\u0026gt;weight = scale_load(sched_prio_to_weight[prio]); 2\tload-\u0026gt;inv_weight = sched_prio_to_wmult[prio]; 需要更新权重 1void reweight_task(struct task_struct *p, int prio) 2{ 3\tstruct sched_entity *se = \u0026amp;p-\u0026gt;se; 4\tstruct cfs_rq *cfs_rq = cfs_rq_of(se); 5\tstruct load_weight *load = \u0026amp;se-\u0026gt;load; 6\tunsigned long weight = scale_load(sched_prio_to_weight[prio]); 7 8\treweight_entity(cfs_rq, se, weight, weight); 9\tload-\u0026gt;inv_weight = sched_prio_to_wmult[prio]; 10} 11static void reweight_entity(struct cfs_rq *cfs_rq, 12\tstruct sched_entity *se, 13\tunsigned long weight, 14\tunsigned long runnable) 15{ 16\tif (se-\u0026gt;on_rq) { 17\t/* commit outstanding execution time */ 18\tif (cfs_rq-\u0026gt;curr == se) 19\tupdate_curr(cfs_rq); 20\taccount_entity_dequeue(cfs_rq, se); 21\tdequeue_runnable_load_avg(cfs_rq, se); 22\t} 23\tdequeue_load_avg(cfs_rq, se); 24 25\tse-\u0026gt;runnable_weight = runnable; 26\tupdate_load_set(\u0026amp;se-\u0026gt;load, weight); 27\tenqueue_load_avg(cfs_rq, se); 28\tif (se-\u0026gt;on_rq) { 29\taccount_entity_enqueue(cfs_rq, se); 30\tenqueue_runnable_load_avg(cfs_rq, se); 31\t} 32} ","date":"14140-11-14","img":"","largeImg":"","permalink":"/posts/schedulepriority/","series":null,"smallImg":"","tags":[],"title":"调度优先级"},{"categories":[],"content":"dwl桌面环境 编译流程 setup 1void 2setup(void) 3{ 4\t/* The Wayland display is managed by libwayland. It handles accepting 5\t* clients from the Unix socket, manging Wayland globals, and so on. */ 6\tdpy = wl_display_create(); 7 8\t/* Set up signal handlers */ 9\tsigchld(0); 10\tsignal(SIGINT, quitsignal); 11\tsignal(SIGTERM, quitsignal); 12 13\t/* The backend is a wlroots feature which abstracts the underlying input and 14\t* output hardware. The autocreate option will choose the most suitable 15\t* backend based on the current environment, such as opening an X11 window 16\t* if an X11 server is running. The NULL argument here optionally allows you 17\t* to pass in a custom renderer if wlr_renderer doesn\u0026#39;t meet your needs. The 18\t* backend uses the renderer, for example, to fall back to software cursors 19\t* if the backend does not support hardware cursors (some older GPUs 20\t* don\u0026#39;t). */ 21\tif (!(backend = wlr_backend_autocreate(dpy))) 22\tBARF(\u0026#34;couldn\u0026#39;t create backend\u0026#34;); 23 24\t/* If we don\u0026#39;t provide a renderer, autocreate makes a GLES2 renderer for us. 25\t* The renderer is responsible for defining the various pixel formats it 26\t* supports for shared memory, this configures that for clients. */ 27\tdrw = wlr_backend_get_renderer(backend); 28\twlr_renderer_init_wl_display(drw, dpy); 29 30\t/* This creates some hands-off wlroots interfaces. The compositor is 31\t* necessary for clients to allocate surfaces and the data device manager 32\t* handles the clipboard. Each of these wlroots interfaces has room for you 33\t* to dig your fingers in and play with their behavior if you want. Note that 34\t* the clients cannot set the selection directly without compositor approval, 35\t* see the setsel() function. */ 36\tcompositor = wlr_compositor_create(dpy, drw); 37\twlr_export_dmabuf_manager_v1_create(dpy); 38\twlr_screencopy_manager_v1_create(dpy); 39\twlr_data_control_manager_v1_create(dpy); 40\twlr_data_device_manager_create(dpy); 41\twlr_gamma_control_manager_v1_create(dpy); 42\twlr_primary_selection_v1_device_manager_create(dpy); 43\twlr_viewporter_create(dpy); 44 45\t/* Initializes the interface used to implement urgency hints */ 46\tactivation = wlr_xdg_activation_v1_create(dpy); 47\twl_signal_add(\u0026amp;activation-\u0026gt;events.request_activate, \u0026amp;request_activate); 48 49\t/* Creates an output layout, which a wlroots utility for working with an 50\t* arrangement of screens in a physical layout. */ 51\toutput_layout = wlr_output_layout_create(); 52\twl_signal_add(\u0026amp;output_layout-\u0026gt;events.change, \u0026amp;layout_change); 53\twlr_xdg_output_manager_v1_create(dpy, output_layout); 54 55\t/* Configure a listener to be notified when new outputs are available on the 56\t* backend. */ 57\twl_list_init(\u0026amp;mons); 58\twl_signal_add(\u0026amp;backend-\u0026gt;events.new_output, \u0026amp;new_output); 59 60\t/* Set up our client lists and the xdg-shell. The xdg-shell is a 61\t* Wayland protocol which is used for application windows. For more 62\t* detail on shells, refer to the article: 63\t* 64\t* https://drewdevault.com/2018/07/29/Wayland-shells.html 65\t*/ 66\twl_list_init(\u0026amp;clients); 67\twl_list_init(\u0026amp;fstack); 68\twl_list_init(\u0026amp;stack); 69\twl_list_init(\u0026amp;independents); 70 71\tidle = wlr_idle_create(dpy); 72 73\tlayer_shell = wlr_layer_shell_v1_create(dpy); 74\twl_signal_add(\u0026amp;layer_shell-\u0026gt;events.new_surface, \u0026amp;new_layer_shell_surface); 75 76\txdg_shell = wlr_xdg_shell_create(dpy); 77\twl_signal_add(\u0026amp;xdg_shell-\u0026gt;events.new_surface, \u0026amp;new_xdg_surface); 78 79\t/* Use decoration protocols to negotiate server-side decorations */ 80\twlr_server_decoration_manager_set_default_mode( 81\twlr_server_decoration_manager_create(dpy), 82\tWLR_SERVER_DECORATION_MANAGER_MODE_SERVER); 83\twlr_xdg_decoration_manager_v1_create(dpy); 84 85\t/* 86\t* Creates a cursor, which is a wlroots utility for tracking the cursor 87\t* image shown on screen. 88\t*/ 89\tcursor = wlr_cursor_create(); 90\twlr_cursor_attach_output_layout(cursor, output_layout); 91 92\t/* Creates an xcursor manager, another wlroots utility which loads up 93\t* Xcursor themes to source cursor images from and makes sure that cursor 94\t* images are available at all scale factors on the screen (necessary for 95\t* HiDPI support). Scaled cursors will be loaded with each output. */ 96\tcursor_mgr = wlr_xcursor_manager_create(NULL, 24); 97 98\t/* 99\t* wlr_cursor *only* displays an image on screen. It does not move around 100\t* when the pointer moves. However, we can attach input devices to it, and 101\t* it will generate aggregate events for all of them. In these events, we 102\t* can choose how we want to process them, forwarding them to clients and 103\t* moving the cursor around. More detail on this process is described in my 104\t* input handling blog post: 105\t* 106\t* https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html 107\t* 108\t* And more comments are sprinkled throughout the notify functions above. 109\t*/ 110\twl_signal_add(\u0026amp;cursor-\u0026gt;events.motion, \u0026amp;cursor_motion); 111\twl_signal_add(\u0026amp;cursor-\u0026gt;events.motion_absolute, \u0026amp;cursor_motion_absolute); 112\twl_signal_add(\u0026amp;cursor-\u0026gt;events.button, \u0026amp;cursor_button); 113\twl_signal_add(\u0026amp;cursor-\u0026gt;events.axis, \u0026amp;cursor_axis); 114\twl_signal_add(\u0026amp;cursor-\u0026gt;events.frame, \u0026amp;cursor_frame); 115 116\t/* 117\t* Configures a seat, which is a single \u0026#34;seat\u0026#34; at which a user sits and 118\t* operates the computer. This conceptually includes up to one keyboard, 119\t* pointer, touch, and drawing tablet device. We also rig up a listener to 120\t* let us know when new input devices are available on the backend. 121\t*/ 122\twl_list_init(\u0026amp;keyboards); 123\twl_signal_add(\u0026amp;backend-\u0026gt;events.new_input, \u0026amp;new_input); 124\tvirtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy); 125\twl_signal_add(\u0026amp;virtual_keyboard_mgr-\u0026gt;events.new_virtual_keyboard, 126\t\u0026amp;new_virtual_keyboard); 127\tseat = wlr_seat_create(dpy, \u0026#34;seat0\u0026#34;); 128\twl_signal_add(\u0026amp;seat-\u0026gt;events.request_set_cursor, 129\t\u0026amp;request_cursor); 130\twl_signal_add(\u0026amp;seat-\u0026gt;events.request_set_selection, 131\t\u0026amp;request_set_sel); 132\twl_signal_add(\u0026amp;seat-\u0026gt;events.request_set_primary_selection, 133\t\u0026amp;request_set_psel); 134 135\toutput_mgr = wlr_output_manager_v1_create(dpy); 136\twl_signal_add(\u0026amp;output_mgr-\u0026gt;events.apply, \u0026amp;output_mgr_apply); 137\twl_signal_add(\u0026amp;output_mgr-\u0026gt;events.test, \u0026amp;output_mgr_test); 138 139\tpresentation = wlr_presentation_create(dpy, backend); 140 141#ifdef XWAYLAND 142\t/* 143\t* Initialise the XWayland X server. 144\t* It will be started when the first X client is started. 145\t*/ 146\txwayland = wlr_xwayland_create(dpy, compositor, 1); 147\tif (xwayland) { 148\twl_signal_add(\u0026amp;xwayland-\u0026gt;events.ready, \u0026amp;xwayland_ready); 149\twl_signal_add(\u0026amp;xwayland-\u0026gt;events.new_surface, \u0026amp;new_xwayland_surface); 150 151\tsetenv(\u0026#34;DISPLAY\u0026#34;, xwayland-\u0026gt;display_name, 1); 152\t} else { 153\tfprintf(stderr, \u0026#34;failed to setup XWayland X server, continuing without it\\n\u0026#34;); 154\t} 155#endif 156} run 1void 2run(char *startup_cmd) 3{ 4\tpid_t startup_pid = -1; 5 6\t/* Add a Unix socket to the Wayland display. */ 7\tconst char *socket = wl_display_add_socket_auto(dpy); 8\tif (!socket) 9\tBARF(\u0026#34;startup: display_add_socket_auto\u0026#34;); 10\tsetenv(\u0026#34;WAYLAND_DISPLAY\u0026#34;, socket, 1); 11 12\t/* Now that the socket exists, run the startup command */ 13\tif (startup_cmd) { 14\tint piperw[2]; 15\tpipe(piperw); 16\tstartup_pid = fork(); 17\tif (startup_pid \u0026lt; 0) 18\tEBARF(\u0026#34;startup: fork\u0026#34;); 19\tif (startup_pid == 0) { 20\tdup2(piperw[0], STDIN_FILENO); 21\tclose(piperw[1]); 22\texecl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, startup_cmd, NULL); 23\tEBARF(\u0026#34;startup: execl\u0026#34;); 24\t} 25\tdup2(piperw[1], STDOUT_FILENO); 26\tclose(piperw[0]); 27\t} 28\t/* If nobody is reading the status output, don\u0026#39;t terminate */ 29\tsignal(SIGPIPE, SIG_IGN); 30\tprintstatus(); 31 32\t/* Start the backend. This will enumerate outputs and inputs, become the DRM 33\t* master, etc */ 34\tif (!wlr_backend_start(backend)) 35\tBARF(\u0026#34;startup: backend_start\u0026#34;); 36 37\t/* Now that outputs are initialized, choose initial selmon based on 38\t* cursor position, and set default cursor image */ 39\tselmon = xytomon(cursor-\u0026gt;x, cursor-\u0026gt;y); 40 41\t/* TODO hack to get cursor to display in its initial location (100, 100) 42\t* instead of (0, 0) and then jumping. still may not be fully 43\t* initialized, as the image/coordinates are not transformed for the 44\t* monitor when displayed here */ 45\twlr_cursor_warp_closest(cursor, NULL, cursor-\u0026gt;x, cursor-\u0026gt;y); 46\twlr_xcursor_manager_set_cursor_image(cursor_mgr, \u0026#34;left_ptr\u0026#34;, cursor); 47 48\t/* Run the Wayland event loop. This does not return until you exit the 49\t* compositor. Starting the backend rigged up all of the necessary event 50\t* loop configuration to listen to libinput events, DRM events, generate 51\t* frame events at the refresh rate, and so on. */ 52\twl_display_run(dpy); 53 54\tif (startup_cmd) { 55\tkill(startup_pid, SIGTERM); 56\twaitpid(startup_pid, NULL, 0); 57\t} 58} cleanup 1void cleanup(void) 2{ 3#ifdef XWAYLAND 4\twlr_xwayland_destroy(xwayland); 5#endif 6\twl_display_destroy_clients(dpy); 7 8\twlr_backend_destroy(backend); 9\twlr_xcursor_manager_destroy(cursor_mgr); 10\twlr_cursor_destroy(cursor); 11\twlr_output_layout_destroy(output_layout); 12\twlr_seat_destroy(seat); 13\twl_display_destroy(dpy); 14} ","date":"7070-11-07","img":"","largeImg":"","permalink":"/posts/dwl/","series":null,"smallImg":"","tags":[],"title":"Dwl"},{"categories":[],"content":"TinyCC TinyCC (aka TCC) is a small but hyper fast C compiler. Unlike other C compilers, it is meant to be self-relying: you do not need an external assembler or linker because TCC does that for you.\nTCC 执行概览 TCC组成代码\n文件名 解释 tcc.c/libtcc.c tcc运行代码 tccpp.c tccelf.c tcccoff.c tccasm.c tccrun.c tccgen.c x86_64-gen.c x86_64-link.c i386-asm.c 不同架构的生成器 TCC状态信息 1struct TCCState { 2 unsigned char verbose; /* if true, display some information during compilation */ 3 unsigned char nostdinc; /* if true, no standard headers are added */ 4 unsigned char nostdlib; /* if true, no standard libraries are added */ 5 unsigned char nocommon; /* if true, do not use common symbols for .bss data */ 6 unsigned char static_link; /* if true, static linking is performed */ 7 unsigned char rdynamic; /* if true, all symbols are exported */ 8 unsigned char symbolic; /* if true, resolve symbols in the current module first */ 9 unsigned char filetype; /* file type for compilation (NONE,C,ASM) */ 10 unsigned char optimize; /* only to #define __OPTIMIZE__ */ 11 unsigned char option_pthread; /* -pthread option */ 12 unsigned char enable_new_dtags; /* -Wl,--enable-new-dtags */ 13 unsigned int cversion; /* supported C ISO version, 199901 (the default), 201112, ... */ 14 15 /* C language options */ 16 unsigned char char_is_unsigned; 17 unsigned char leading_underscore; 18 unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */ 19 unsigned char dollars_in_identifiers; /* allows \u0026#39;$\u0026#39; char in identifiers */ 20 unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */ 21 22 /* warning switches */ 23 unsigned char warn_none; 24 unsigned char warn_all; 25 unsigned char warn_error; 26 unsigned char warn_write_strings; 27 unsigned char warn_unsupported; 28 unsigned char warn_implicit_function_declaration; 29 unsigned char warn_discarded_qualifiers; 30 #define WARN_ON 1 /* warning is on (-Woption) */ 31 unsigned char warn_num; /* temp var for tcc_warning_c() */ 32 33 unsigned char option_r; /* option -r */ 34 unsigned char do_bench; /* option -bench */ 35 unsigned char just_deps; /* option -M */ 36 unsigned char gen_deps; /* option -MD */ 37 unsigned char include_sys_deps; /* option -MD */ 38 39 /* compile with debug symbol (and use them if error during execution) */ 40 unsigned char do_debug; 41 unsigned char do_backtrace; 42#ifdef CONFIG_TCC_BCHECK 43 /* compile with built-in memory and bounds checker */ 44 unsigned char do_bounds_check; 45#endif 46 unsigned char test_coverage; /* generate test coverage code */ 47 48 /* use GNU C extensions */ 49 unsigned char gnu_ext; 50 /* use TinyCC extensions */ 51 unsigned char tcc_ext; 52 53 unsigned char dflag; /* -dX value */ 54 unsigned char Pflag; /* -P switch (LINE_MACRO_OUTPUT_FORMAT) */ 55 56#ifdef TCC_TARGET_X86_64 57 unsigned char nosse; /* For -mno-sse support. */ 58#endif 59#ifdef TCC_TARGET_ARM 60 unsigned char float_abi; /* float ABI of the generated code*/ 61#endif 62 63 unsigned char has_text_addr; 64 addr_t text_addr; /* address of text section */ 65 unsigned section_align; /* section alignment */ 66#ifdef TCC_TARGET_I386 67 int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */ 68#endif 69 70 char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */ 71 char *soname; /* as specified on the command line (-soname) */ 72 char *rpath; /* as specified on the command line (-Wl,-rpath=) */ 73 74 char *init_symbol; /* symbols to call at load-time (not used currently) */ 75 char *fini_symbol; /* symbols to call at unload-time (not used currently) */ 76 77 /* output type, see TCC_OUTPUT_XXX */ 78 int output_type; 79 /* output format, see TCC_OUTPUT_FORMAT_xxx */ 80 int output_format; 81 /* nth test to run with -dt -run */ 82 int run_test; 83 84 /* array of all loaded dlls (including those referenced by loaded dlls) */ 85 DLLReference **loaded_dlls; 86 int nb_loaded_dlls; 87 88 /* include paths */ 89 char **include_paths; 90 int nb_include_paths; 91 92 char **sysinclude_paths; 93 int nb_sysinclude_paths; 94 95 /* library paths */ 96 char **library_paths; 97 int nb_library_paths; 98 99 /* crt?.o object path */ 100 char **crt_paths; 101 int nb_crt_paths; 102 103 /* -D / -U options */ 104 CString cmdline_defs; 105 /* -include options */ 106 CString cmdline_incl; 107 108 /* error handling */ 109 void *error_opaque; 110 void (*error_func)(void *opaque, const char *msg); 111 int error_set_jmp_enabled; 112 jmp_buf error_jmp_buf; 113 int nb_errors; 114 115 /* output file for preprocessing (-E) */ 116 FILE *ppfp; 117 118 /* for -MD/-MF: collected dependencies for this compilation */ 119 char **target_deps; 120 int nb_target_deps; 121 122 /* compilation */ 123 BufferedFile *include_stack[INCLUDE_STACK_SIZE]; 124 BufferedFile **include_stack_ptr; 125 126 int ifdef_stack[IFDEF_STACK_SIZE]; 127 int *ifdef_stack_ptr; 128 129 /* included files enclosed with #ifndef MACRO */ 130 int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE]; 131 CachedInclude **cached_includes; 132 int nb_cached_includes; 133 134 /* #pragma pack stack */ 135 int pack_stack[PACK_STACK_SIZE]; 136 int *pack_stack_ptr; 137 char **pragma_libs; 138 int nb_pragma_libs; 139 140 /* inline functions are stored as token lists and compiled last 141 only if referenced */ 142 struct InlineFunc **inline_fns; 143 int nb_inline_fns; 144 145 /* sections */ 146 Section **sections; 147 int nb_sections; /* number of sections, including first dummy section */ 148 149 Section **priv_sections; 150 int nb_priv_sections; /* number of private sections */ 151 152 /* got \u0026amp; plt handling */ 153 Section *got; 154 Section *plt; 155 156 /* predefined sections */ 157 Section *text_section, *data_section, *rodata_section, *bss_section; 158 Section *common_section; 159 Section *cur_text_section; /* current section where function code is generated */ 160#ifdef CONFIG_TCC_BCHECK 161 /* bound check related sections */ 162 Section *bounds_section; /* contains global data bound description */ 163 Section *lbounds_section; /* contains local data bound description */ 164#endif 165 /* test coverage */ 166 Section *tcov_section; 167 /* symbol sections */ 168 Section *symtab_section; 169 /* debug sections */ 170 Section *stab_section; 171 /* Is there a new undefined sym since last new_undef_sym() */ 172 int new_undef_sym; 173 174 /* temporary dynamic symbol sections (for dll loading) */ 175 Section *dynsymtab_section; 176 /* exported dynamic symbol section */ 177 Section *dynsym; 178 /* copy of the global symtab_section variable */ 179 Section *symtab; 180 /* extra attributes (eg. GOT/PLT value) for symtab symbols */ 181 struct sym_attr *sym_attrs; 182 int nb_sym_attrs; 183 /* ptr to next reloc entry reused */ 184 ElfW_Rel *qrel; 185 #define qrel s1-\u0026gt;qrel 186 187#ifdef TCC_TARGET_RISCV64 188 struct pcrel_hi { addr_t addr, val; } last_hi; 189 #define last_hi s1-\u0026gt;last_hi 190#endif 191 192#ifdef TCC_TARGET_PE 193 /* PE info */ 194 int pe_subsystem; 195 unsigned pe_characteristics; 196 unsigned pe_file_align; 197 unsigned pe_stack_size; 198 addr_t pe_imagebase; 199# ifdef TCC_TARGET_X86_64 200 Section *uw_pdata; 201 int uw_sym; 202 unsigned uw_offs; 203# endif 204#endif 205 206#ifndef ELF_OBJ_ONLY 207 int nb_sym_versions; 208 struct sym_version *sym_versions; 209 int nb_sym_to_version; 210 int *sym_to_version; 211 int dt_verneednum; 212 Section *versym_section; 213 Section *verneed_section; 214#endif 215 216#ifdef TCC_IS_NATIVE 217 const char *runtime_main; 218 void **runtime_mem; 219 int nb_runtime_mem; 220#endif 221 222#ifdef CONFIG_TCC_BACKTRACE 223 int rt_num_callers; 224#endif 225 226 /* benchmark info */ 227 int total_idents; 228 int total_lines; 229 int total_bytes; 230 int total_output[4]; 231 232 /* option -dnum (for general development purposes) */ 233 int g_debug; 234 235 /* used by tcc_load_ldscript */ 236 int fd, cc; 237 238 /* for warnings/errors for object files */ 239 const char *current_filename; 240 241 /* used by main and tcc_parse_args only */ 242 struct filespec **files; /* files seen on command line */ 243 int nb_files; /* number thereof */ 244 int nb_libraries; /* number of libs thereof */ 245 char *outfile; /* output filename */ 246 char *deps_outfile; /* option -MF */ 247 int argc; 248 char **argv; 249}; 1LIBTCCAPI TCCState *tcc_new(void) 2{ 3 TCCState *s; 4 5 s = tcc_mallocz(sizeof(TCCState)); 6 if (!s) 7 return NULL; 8#ifdef MEM_DEBUG 9 ++nb_states; 10#endif 11 12#undef gnu_ext 13 14 s-\u0026gt;gnu_ext = 1; 15 s-\u0026gt;tcc_ext = 1; 16 s-\u0026gt;nocommon = 1; 17 s-\u0026gt;dollars_in_identifiers = 1; /*on by default like in gcc/clang*/ 18 s-\u0026gt;cversion = 199901; /* default unless -std=c11 is supplied */ 19 s-\u0026gt;warn_implicit_function_declaration = 1; 20 s-\u0026gt;warn_discarded_qualifiers = 1; 21 s-\u0026gt;ms_extensions = 1; 22 23#ifdef CHAR_IS_UNSIGNED 24 s-\u0026gt;char_is_unsigned = 1; 25#endif 26#ifdef TCC_TARGET_I386 27 s-\u0026gt;seg_size = 32; 28#endif 29 /* enable this if you want symbols with leading underscore on windows: */ 30#if defined TCC_TARGET_MACHO /* || defined TCC_TARGET_PE */ 31 s-\u0026gt;leading_underscore = 1; 32#endif 33#ifdef TCC_TARGET_ARM 34 s-\u0026gt;float_abi = ARM_FLOAT_ABI; 35#endif 36 37 s-\u0026gt;ppfp = stdout; 38 /* might be used in error() before preprocess_start() */ 39 s-\u0026gt;include_stack_ptr = s-\u0026gt;include_stack; 40 41 tccelf_new(s); 42 43 tcc_set_lib_path(s, CONFIG_TCCDIR); 44 return s; 45} 46 47LIBTCCAPI void tcc_delete(TCCState *s1) 48{ 49 /* free sections */ 50 tccelf_delete(s1); 51 52 /* free library paths */ 53 dynarray_reset(\u0026amp;s1-\u0026gt;library_paths, \u0026amp;s1-\u0026gt;nb_library_paths); 54 dynarray_reset(\u0026amp;s1-\u0026gt;crt_paths, \u0026amp;s1-\u0026gt;nb_crt_paths); 55 56 /* free include paths */ 57 dynarray_reset(\u0026amp;s1-\u0026gt;include_paths, \u0026amp;s1-\u0026gt;nb_include_paths); 58 dynarray_reset(\u0026amp;s1-\u0026gt;sysinclude_paths, \u0026amp;s1-\u0026gt;nb_sysinclude_paths); 59 60 tcc_free(s1-\u0026gt;tcc_lib_path); 61 tcc_free(s1-\u0026gt;soname); 62 tcc_free(s1-\u0026gt;rpath); 63 tcc_free(s1-\u0026gt;init_symbol); 64 tcc_free(s1-\u0026gt;fini_symbol); 65 tcc_free(s1-\u0026gt;outfile); 66 tcc_free(s1-\u0026gt;deps_outfile); 67 dynarray_reset(\u0026amp;s1-\u0026gt;files, \u0026amp;s1-\u0026gt;nb_files); 68 dynarray_reset(\u0026amp;s1-\u0026gt;target_deps, \u0026amp;s1-\u0026gt;nb_target_deps); 69 dynarray_reset(\u0026amp;s1-\u0026gt;pragma_libs, \u0026amp;s1-\u0026gt;nb_pragma_libs); 70 dynarray_reset(\u0026amp;s1-\u0026gt;argv, \u0026amp;s1-\u0026gt;argc); 71 cstr_free(\u0026amp;s1-\u0026gt;cmdline_defs); 72 cstr_free(\u0026amp;s1-\u0026gt;cmdline_incl); 73#ifdef TCC_IS_NATIVE 74 /* free runtime memory */ 75 tcc_run_free(s1); 76#endif 77 78 tcc_free(s1); 79#ifdef MEM_DEBUG 80 if (0 == --nb_states) 81 tcc_memcheck(); 82#endif 83} 文件读取 文件描述信息 1typedef struct BufferedFile { 2 uint8_t *buf_ptr; 3 uint8_t *buf_end; 4 int fd; 5 struct BufferedFile *prev; 6 int line_num; /* current line number - here to simplify code */ 7 int line_ref; /* tcc -E: last printed line */ 8 int ifndef_macro; /* #ifndef macro / #endif search */ 9 int ifndef_macro_saved; /* saved ifndef_macro */ 10 int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */ 11 int include_next_index; /* next search path */ 12 char filename[1024]; /* filename */ 13 char *true_filename; /* filename not modified by # line directive */ 14 unsigned char unget[4]; 15 unsigned char buffer[1]; /* extra size for CH_EOB char */ 16} BufferedFile; 文件相关操作 1static int _tcc_open(TCCState *s1, const char *filename) 2{ 3 int fd; 4 if (strcmp(filename, \u0026#34;-\u0026#34;) == 0) 5 fd = 0, filename = \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;; 6 else 7 fd = open(filename, O_RDONLY | O_BINARY); 8 if ((s1-\u0026gt;verbose == 2 \u0026amp;\u0026amp; fd \u0026gt;= 0) || s1-\u0026gt;verbose == 3) 9 printf(\u0026#34;%s %*s%s\\n\u0026#34;, fd \u0026lt; 0 ? \u0026#34;nf\u0026#34;:\u0026#34;-\u0026gt;\u0026#34;, 10 (int)(s1-\u0026gt;include_stack_ptr - s1-\u0026gt;include_stack), \u0026#34;\u0026#34;, filename); 11 return fd; 12} 13 14ST_FUNC int tcc_open(TCCState *s1, const char *filename) 15{ 16 int fd = _tcc_open(s1, filename); 17 if (fd \u0026lt; 0) 18 return -1; 19 tcc_open_bf(s1, filename, 0); 20 file-\u0026gt;fd = fd; 21 return 0; 22} 23 24ST_FUNC void tcc_close(void) 25{ 26 TCCState *s1 = tcc_state; 27 BufferedFile *bf = file; 28 if (bf-\u0026gt;fd \u0026gt; 0) { 29 close(bf-\u0026gt;fd); 30 total_lines += bf-\u0026gt;line_num; 31 } 32 if (bf-\u0026gt;true_filename != bf-\u0026gt;filename) 33 tcc_free(bf-\u0026gt;true_filename); 34 file = bf-\u0026gt;prev; 35 tcc_free(bf); 36} 词法分析 语法分析 类型检查 符号表 段机制 代码生成 ","date":"7070-11-07","img":"","largeImg":"","permalink":"/posts/tinycc/","series":null,"smallImg":"","tags":[],"title":"Tinycc"},{"categories":[],"content":"个人服务器安装记录 配置交换文件 1# 创建交换文件 2sudo fallocate -l 2G /swapfile 3 4# 修改权限只允许ROOT使用 5sudo chmod 600 /swapfile 6 7# 创建swapfile 8sudo mkswap /swapfile 9 10# 开启swapfile 11sudo swapon /swapfile 12 13# 写入fstab 14echo \u0026#39;/swapfile none swap sw 0 0\u0026#39; | sudo tee -a /etc/fstab jenkins安装 安装jdk 1sudo apt install default-jdk 安装jenkins 1wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - 2sudo sh -c \u0026#39;echo deb https://pkg.jenkins.io/debian-stable binary/ \u0026gt; /etc/apt/sources.list.d/jenkins.list\u0026#39; 3sudo apt-get update 4sudo apt-get install jenkins docker安装 安装依赖 1sudo apt install \\ 2 apt-transport-https \\ 3 ca-certificates \\ 4 curl \\ 5 gnupg-agent \\ 6 software-properties-common 安装公钥 1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 设置仓库 1sudo add-apt-repository \\ 2 \u0026#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\ 3 $(lsb_release -cs) \\ 4 stable\u0026#34; 安装Docker 1sudo apt update 2sudo apt install docker-ce docker-ce-cli containerd.io 添加root组 1sudo usermod -aG docker `whoami` docker辅助工具 docker-compose lazydocker 嵌入式开发工具链 arm编译工具链 1sudo apt install gcc-arm-linux-gnueabihf 2sudo apt install gcc-arm-linux-gnueabi 3sudo apt install gcc-arm-none-eabi 测试工具 1sudo apt install qemu 2sudo apt install qemu-system-arm 3sudo apt install qemu-user-static 4sudo apt install qemu-user 5sudo apt install qemu-user-binfmt 打包工具 1sudo apt install u-boot-tools ","date":"5050-11-05","img":"","largeImg":"","permalink":"/posts/server/","series":null,"smallImg":"","tags":[],"title":"Server"},{"categories":[],"content":"bsdiff bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u0026gt; sorting (specifically, Larsson and Sadakane\u0026rsquo;s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) \u0026ndash; 直接摘抄自官网\n详情可以查看bsdiff官网 ,存在这个详细描述.\n测试 新建立两个文件old.c与new.c,二者的差别是\n1// new.c 2#include \u0026lt;stdio.h\u0026gt; 3int main(void) 4{ 5\tprintf(\u0026#34;Hello World\\r\\n\u0026#34;); 6\treturn 0; 7} 1#include \u0026lt;stdio.h\u0026gt; 2int main(void) 3{ 4\treturn 0; 5} 测试的情况\n1# 执行编译 2gcc old.c -o old \u0026amp;\u0026amp; ./old 3gcc new.c -o new \u0026amp;\u0026amp; ./new 计算md5\n1md5sum old 2# d08fd167e74f279522fe8aa64d8e27dd old 3 4md5sum new 5# b0b4be993de61064a118d32a692bf795 new 6 7md5sum mid 8# b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试\n1# 生成diff 2bsdiff old new test.diff 3 4# 打入补丁--\u0026gt;mid 5bspatch old mid test.diff 分析 接口分析 1struct bsdiff_stream 2{ 3\tvoid* opaque;\t/* bzip文件 */ 4 5\tvoid* (*malloc)(size_t size);\t/* 内存申请接口 */ 6\tvoid (*free)(void* ptr);\t/* 内存释放接口 */ 7\tint (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ 8 const void* buffer, int size); 9}; 10 11struct bspatch_stream 12{ 13\tvoid* opaque;\t/* bzip文件 */ 14\tint (*read)(const struct bspatch_stream* stream, /* 读取文件接口 */ 15 void* buffer, int length); 16}; 17 18int bsdiff(const uint8_t* old, int64_t oldsize, 19 const uint8_t* new, int64_t newsize, 20 struct bsdiff_stream* stream); 21 22int bspatch(const uint8_t* old, int64_t oldsize, 23 uint8_t* new, int64_t newsize, 24 struct bspatch_stream* stream); diff算法核心 bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block\nHeader描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 Header的结构: start/bytes length/bytes content 0 8 \u0026ldquo;BSDIFF40\u0026rdquo; 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 \u0026ndash;\u0026gt; 147 0x313 \u0026ndash;\u0026gt; 787 0x3ED0 \u0026ndash;\u0026gt; 16080 可以匹配新生成的文件 代码分析 偏移信息与字符串信息相互转化 1/* 一般情况下,buf的长度为8个字节 */ 2static int64_t offtin(uint8_t *buf) 3{ 4\tint64_t y; 5 6\ty=buf[7]\u0026amp;0x7F; /* 提取绝对值 */ 7 8\ty=y*256;y+=buf[6]; 9\ty=y*256;y+=buf[5]; 10\ty=y*256;y+=buf[4]; 11\ty=y*256;y+=buf[3]; 12\ty=y*256;y+=buf[2]; 13\ty=y*256;y+=buf[1]; 14\ty=y*256;y+=buf[0]; 15 16 /* 根据最高位置确定正负 */ 17\tif (buf[7] \u0026amp; 0x80) { 18 y=-y; 19 } 20 21\treturn y; 22} 23static void offtout(int64_t x,uint8_t *buf) 24{ 25\tint64_t y; 26 27 /* 保证 y = |x| */ 28\tif (x \u0026lt; 0) { 29 y = -x; 30 } 31 else { 32 y = x; 33 } 34 35\tbuf[0]=y%256;y-=buf[0]; 36\ty=y/256;buf[1]=y%256;y-=buf[1]; 37\ty=y/256;buf[2]=y%256;y-=buf[2]; 38\ty=y/256;buf[3]=y%256;y-=buf[3]; 39\ty=y/256;buf[4]=y%256;y-=buf[4]; 40\ty=y/256;buf[5]=y%256;y-=buf[5]; 41\ty=y/256;buf[6]=y%256;y-=buf[6]; 42\ty=y/256;buf[7]=y%256; 43 44\tif(x\u0026lt;0) buf[7]|=0x80; 45} patch代码分析 总体的执行路径 1int bspatch(const uint8_t* old, int64_t oldsize, 2 uint8_t* new, int64_t newsize, 3 struct bspatch_stream* stream) 4{ 5\tuint8_t buf[8]; 6\tint64_t oldpos; 7 int64_t newpos; 8\tint64_t ctrl[3]; 9\tint64_t i; 10 11\toldpos=0; 12 newpos=0; 13\twhile (newpos \u0026lt; newsize) { 14\t/* Read control data 3*8个为一组,每次生成3个控制数据 */ 15\tfor(i=0;i\u0026lt;=2;i++) { 16\tif (stream-\u0026gt;read(stream, buf, 8)) 17\treturn -1; 18\tctrl[i]=offtin(buf); 19\t}; 20 21\t/* 健壮性检查 */ 22\tif (ctrl[0]\u0026lt;0 || ctrl[0]\u0026gt;INT_MAX || 23\tctrl[1]\u0026lt;0 || ctrl[1]\u0026gt;INT_MAX || 24\tnewpos+ctrl[0]\u0026gt;newsize) 25\treturn -1; 26 27\t/* Read diff string */ 28\tif (stream-\u0026gt;read(stream, new + newpos, ctrl[0])) 29\treturn -1; 30 31\t/* Add old data to diff string */ 32\tfor(i=0;i\u0026lt;ctrl[0];i++) 33\tif((oldpos+i\u0026gt;=0) \u0026amp;\u0026amp; (oldpos+i\u0026lt;oldsize)) 34\tnew[newpos+i]+=old[oldpos+i]; 35 36\t/* Adjust pointers */ 37\tnewpos+=ctrl[0]; 38\toldpos+=ctrl[0]; 39 40\t/* Sanity-check */ 41\tif(newpos+ctrl[1]\u0026gt;newsize) 42\treturn -1; 43 44\t/* Read extra string */ 45\tif (stream-\u0026gt;read(stream, new + newpos, ctrl[1])) 46\treturn -1; 47 48\t/* Adjust pointers */ 49\tnewpos+=ctrl[1]; 50\toldpos+=ctrl[2]; 51\t}; 52 53\treturn 0; 54} 主要函数的调用路线\nqsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解\n参数分析:\nI 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 1static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) 2{ 3\tint64_t buckets[256]; 4\tint64_t i,h,len; 5 6\tfor(i=0;i\u0026lt;256;i++) buckets[i]=0; 7\tfor(i=0;i\u0026lt;oldsize;i++) buckets[old[i]]++; 8\tfor(i=1;i\u0026lt;256;i++) buckets[i]+=buckets[i-1]; 9\tfor(i=255;i\u0026gt;0;i--) buckets[i]=buckets[i-1]; 10\tbuckets[0]=0; 11 12\tfor(i=0;i\u0026lt;oldsize;i++) I[++buckets[old[i]]]=i; 13\tI[0]=oldsize; 14\tfor(i=0;i\u0026lt;oldsize;i++) V[i]=buckets[old[i]]; 15\tV[oldsize]=0; 16\tfor(i=1;i\u0026lt;256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; 17\tI[0]=-1; 18 19\tfor(h=1;I[0]!=-(oldsize+1);h+=h) { 20\tlen=0; 21\tfor(i=0;i\u0026lt;oldsize+1;) { 22\tif(I[i]\u0026lt;0) { 23\tlen-=I[i]; 24\ti-=I[i]; 25\t} else { 26\tif(len) I[i-len]=-len; 27\tlen=V[I[i]]+1-i; 28\tsplit(I,V,i,len,h); 29\ti+=len; 30\tlen=0; 31\t}; 32\t}; 33\tif(len) I[i-len]=-len; 34\t}; 35 36\tfor(i=0;i\u0026lt;oldsize+1;i++) I[V[i]]=i; 37} 38 39static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) 40{ 41\tint64_t i,j,k,x,tmp,jj,kk; 42 43\tif(len\u0026lt;16) { 44\tfor(k=start;k\u0026lt;start+len;k+=j) { 45\tj=1;x=V[I[k]+h]; 46\tfor(i=1;k+i\u0026lt;start+len;i++) { 47\tif(V[I[k+i]+h]\u0026lt;x) { 48\tx=V[I[k+i]+h]; 49\tj=0; 50\t}; 51\tif(V[I[k+i]+h]==x) { 52\ttmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; 53\tj++; 54\t}; 55\t}; 56\tfor(i=0;i\u0026lt;j;i++) V[I[k+i]]=k+j-1; 57\tif(j==1) I[k]=-1; 58\t}; 59\treturn; 60\t}; 61 62\tx=V[I[start+len/2]+h]; 63\tjj=0;kk=0; 64\tfor(i=start;i\u0026lt;start+len;i++) { 65\tif(V[I[i]+h]\u0026lt;x) jj++; 66\tif(V[I[i]+h]==x) kk++; 67\t}; 68\tjj+=start;kk+=jj; 69 70\ti=start;j=0;k=0; 71\twhile(i\u0026lt;jj) { 72\tif(V[I[i]+h]\u0026lt;x) { 73\ti++; 74\t} else if(V[I[i]+h]==x) { 75\ttmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; 76\tj++; 77\t} else { 78\ttmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; 79\tk++; 80\t}; 81\t}; 82 83\twhile(jj+j\u0026lt;kk) { 84\tif(V[I[jj+j]+h]==x) { 85\tj++; 86\t} else { 87\ttmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; 88\tk++; 89\t}; 90\t}; 91 92\tif(jj\u0026gt;start) split(I,V,start,jj-start,h); 93 94\tfor(i=0;i\u0026lt;kk-jj;i++) V[I[jj+i]]=kk-1; 95\tif(jj==kk-1) I[jj]=-1; 96 97\tif(start+len\u0026gt;kk) split(I,V,kk,start+len-kk,h); 98} search 1static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) 2{ 3\tint64_t i; 4 5\tfor(i=0;(i\u0026lt;oldsize)\u0026amp;\u0026amp;(i\u0026lt;newsize);i++) 6\tif(old[i]!=new[i]) break; 7 8\treturn i; 9} 10static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, 11\tconst uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) 12{ 13\tint64_t x,y; 14 15\tif(en-st\u0026lt;2) { 16\tx=matchlen(old+I[st],oldsize-I[st],new,newsize); 17\ty=matchlen(old+I[en],oldsize-I[en],new,newsize); 18 19\tif(x\u0026gt;y) { 20\t*pos=I[st]; 21\treturn x; 22\t} else { 23\t*pos=I[en]; 24\treturn y; 25\t} 26\t}; 27 28\tx=st+(en-st)/2; 29\tif(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u0026lt;0) { 30\treturn search(I,old,oldsize,new,newsize,x,en,pos); 31\t} else { 32\treturn search(I,old,oldsize,new,newsize,st,x,pos); 33\t}; 34} writedata 1static int64_t writedata(struct bsdiff_stream* stream, 2\tconst void* buffer, int64_t length) 3{ 4\tint64_t result = 0; 5 6\twhile (length \u0026gt; 0) 7\t{ 8\tconst int smallsize = (int)MIN(length, INT_MAX); 9\tconst int writeresult = stream-\u0026gt;write(stream, buffer, smallsize); 10\tif (writeresult == -1) 11\t{ 12\treturn -1; 13\t} 14 15\tresult += writeresult; 16\tlength -= smallsize; 17\tbuffer = (uint8_t*)buffer + smallsize; 18\t} 19 20\treturn result; 21} diff文件生成核心代码 1struct bsdiff_request 2{ 3\tconst uint8_t* old; 4\tint64_t oldsize; 5\tconst uint8_t* new; 6\tint64_t newsize; 7\tstruct bsdiff_stream* stream; 8\tint64_t *I; 9\tuint8_t *buffer; 10}; 11 12static int bsdiff_internal(const struct bsdiff_request req) 13{ 14\tint64_t *I,*V; 15\tint64_t scan,pos,len; 16\tint64_t lastscan,lastpos,lastoffset; 17\tint64_t oldscore,scsc; 18\tint64_t s,Sf,lenf,Sb,lenb; 19\tint64_t overlap,Ss,lens; 20\tint64_t i; 21\tuint8_t *buffer; 22\tuint8_t buf[8 * 3]; 23 24\tif((V=req.stream-\u0026gt;malloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; 25\tI = req.I; 26 27\tqsufsort(I,V,req.old,req.oldsize); 28 29\treq.stream-\u0026gt;free(V); 30 31\tbuffer = req.buffer; 32 33\t/* Compute the differences, writing ctrl as we go */ 34\tscan=0;len=0;pos=0; 35\tlastscan=0;lastpos=0;lastoffset=0; 36\twhile(scan\u0026lt;req.newsize) { 37\toldscore=0; 38 39\tfor(scsc=scan+=len;scan\u0026lt;req.newsize;scan++) { 40\tlen=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 41\t0,req.oldsize,\u0026amp;pos); 42 43\tfor(;scsc\u0026lt;scan+len;scsc++) 44\tif((scsc+lastoffset\u0026lt;req.oldsize) \u0026amp;\u0026amp; 45\t(req.old[scsc+lastoffset] == req.new[scsc])) 46\toldscore++; 47 48\tif(((len==oldscore) \u0026amp;\u0026amp; (len!=0)) || 49\t(len\u0026gt;oldscore+8)) break; 50 51\tif((scan+lastoffset\u0026lt;req.oldsize) \u0026amp;\u0026amp; 52\t(req.old[scan+lastoffset] == req.new[scan])) 53\toldscore--; 54\t}; 55 56\tif((len!=oldscore) || (scan==req.newsize)) { 57\ts=0;Sf=0;lenf=0; 58\tfor(i=0;(lastscan+i\u0026lt;scan)\u0026amp;\u0026amp;(lastpos+i\u0026lt;req.oldsize);) { 59\tif(req.old[lastpos+i]==req.new[lastscan+i]) s++; 60\ti++; 61\tif(s*2-i\u0026gt;Sf*2-lenf) { Sf=s; lenf=i; }; 62\t}; 63 64\tlenb=0; 65\tif(scan\u0026lt;req.newsize) { 66\ts=0;Sb=0; 67\tfor(i=1;(scan\u0026gt;=lastscan+i)\u0026amp;\u0026amp;(pos\u0026gt;=i);i++) { 68\tif(req.old[pos-i]==req.new[scan-i]) s++; 69\tif(s*2-i\u0026gt;Sb*2-lenb) { Sb=s; lenb=i; }; 70\t}; 71\t}; 72 73\tif(lastscan+lenf\u0026gt;scan-lenb) { 74\toverlap=(lastscan+lenf)-(scan-lenb); 75\ts=0;Ss=0;lens=0; 76\tfor(i=0;i\u0026lt;overlap;i++) { 77\tif(req.new[lastscan+lenf-overlap+i]== 78\treq.old[lastpos+lenf-overlap+i]) s++; 79\tif(req.new[scan-lenb+i]== 80\treq.old[pos-lenb+i]) s--; 81\tif(s\u0026gt;Ss) { Ss=s; lens=i+1; }; 82\t}; 83 84\tlenf+=lens-overlap; 85\tlenb-=lens; 86\t}; 87 88\tofftout(lenf,buf); 89\tofftout((scan-lenb)-(lastscan+lenf),buf+8); 90\tofftout((pos-lenb)-(lastpos+lenf),buf+16); 91 92\t/* Write control data */ 93\tif (writedata(req.stream, buf, sizeof(buf))) 94\treturn -1; 95 96\t/* Write diff data */ 97\tfor(i=0;i\u0026lt;lenf;i++) 98\tbuffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; 99\tif (writedata(req.stream, buffer, lenf)) 100\treturn -1; 101 102\t/* Write extra data */ 103\tfor(i=0;i\u0026lt;(scan-lenb)-(lastscan+lenf);i++) 104\tbuffer[i]=req.new[lastscan+lenf+i]; 105\tif (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) 106\treturn -1; 107 108\tlastscan=scan-lenb; 109\tlastpos=pos-lenb; 110\tlastoffset=pos-scan; 111\t}; 112\t}; 113 114\treturn 0; 115} ","date":"30300-10-30","img":"","largeImg":"","permalink":"/posts/bsdiff/","series":null,"smallImg":"","tags":[],"title":"Bsdiff"},{"categories":[],"content":"ARM笔记 ARM体系结构 相关术语 流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE 工具链 文件名 详解 addr2line 把程序地址转化为文件名和行号 ar 建立、修改和提取归档文件 as 汇编编译器 ld 链接器 nm 列出文件的符号 objcopy 文件个数格式转换 objdump 反汇编 ranlib 产生索引,并且保存进入文件中 readelf 显示elf文件信息 size 列出文件大小 string 打印文件可打印字符串 strip 丢弃文件符号 交叉工具链测试\n1arm-none-linux-gnueabihf-addr2line arm-none-linux-gnueabihf-gdb 2arm-none-linux-gnueabihf-ar arm-none-linux-gnueabihf-gdb-add-index 3arm-none-linux-gnueabihf-as arm-none-linux-gnueabihf-gfortran 4arm-none-linux-gnueabihf-c++ arm-none-linux-gnueabihf-gprof 5arm-none-linux-gnueabihf-c++filt arm-none-linux-gnueabihf-ld 6arm-none-linux-gnueabihf-cpp arm-none-linux-gnueabihf-ld.bfd 7arm-none-linux-gnueabihf-dwp arm-none-linux-gnueabihf-ld.gold 8arm-none-linux-gnueabihf-elfedit arm-none-linux-gnueabihf-lto-dump 9arm-none-linux-gnueabihf-g++ arm-none-linux-gnueabihf-nm 10arm-none-linux-gnueabihf-gcc arm-none-linux-gnueabihf-objcopy 11arm-none-linux-gnueabihf-gcc-10.2.1 arm-none-linux-gnueabihf-objdump 12arm-none-linux-gnueabihf-gcc-ar arm-none-linux-gnueabihf-ranlib 13arm-none-linux-gnueabihf-gcc-nm arm-none-linux-gnueabihf-readelf 14arm-none-linux-gnueabihf-gcc-ranlib arm-none-linux-gnueabihf-size 15arm-none-linux-gnueabihf-gcov arm-none-linux-gnueabihf-strings 16arm-none-linux-gnueabihf-gcov-dump arm-none-linux-gnueabihf-strip 17arm-none-linux-gnueabihf-gcov-tool ARMv7处理器模式 模式 编码 功能 安全 优先级 User (USR) 10000 大多数运行的非特权模式 Both PL0 FIQ 10001 FIQ中断 Both PL1 IRQ 10010 IRQ中断 Both PL1 Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1 Monitor (MON) 10110 安全扩展实现 only PL1 Abort (ABT) 10111 内存权限异常 Both PL1 Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2 Undef (UND) 11011 未定义指令调用 Both PL1 System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1 不同的处理器模式上寄存器共享的情况\nARM指令集 翻译结果 统一汇编语言 分支指令 数据处理指令 指令 作用 LSL Logical Shift Left by 1-31 bits. LSR Logical Shift Right by 1-32 bits. ASR Arithmetic Shift Right by 1-32 bits. ROR Rotate Right by 1-31 bits. RRX Rotate Right with Extend. 状态寄存器访问指令 加载存储指令 加载存储多条指令 杂项指令 异常生成与处理指令 协处理器指令 SIMD指令 ","date":"30300-10-30","img":"","largeImg":"","permalink":"/posts/arm/","series":null,"smallImg":"","tags":[],"title":"Arm"},{"categories":["linux"],"content":"IDLE调度器类 1/* 2 * Generic entry points for the idle threads and 3 * implementation of the idle task scheduling class. 4 * 5 * (NOTE: these are not related to SCHED_IDLE batch scheduled 6 * tasks which are handled in sched/fair.c ) 7 */ 8#include \u0026#34;sched.h\u0026#34; 9 10#include \u0026lt;trace/events/power.h\u0026gt; 11 12/* Linker adds these: start and end of __cpuidle functions */ 13extern char __cpuidle_text_start[], __cpuidle_text_end[]; 14 15/** 16 * sched_idle_set_state - Record idle state for the current CPU. 17 * @idle_state: State to record. 18 */ 19void sched_idle_set_state(struct cpuidle_state *idle_state) 20{ 21\tidle_set_state(this_rq(), idle_state); 22} 23 24static int __read_mostly cpu_idle_force_poll; 25 26void cpu_idle_poll_ctrl(bool enable) 27{ 28\tif (enable) { 29\tcpu_idle_force_poll++; 30\t} else { 31\tcpu_idle_force_poll--; 32\tWARN_ON_ONCE(cpu_idle_force_poll \u0026lt; 0); 33\t} 34} 35 36#ifdef CONFIG_GENERIC_IDLE_POLL_SETUP 37static int __init cpu_idle_poll_setup(char *__unused) 38{ 39\tcpu_idle_force_poll = 1; 40 41\treturn 1; 42} 43__setup(\u0026#34;nohlt\u0026#34;, cpu_idle_poll_setup); 44 45static int __init cpu_idle_nopoll_setup(char *__unused) 46{ 47\tcpu_idle_force_poll = 0; 48 49\treturn 1; 50} 51__setup(\u0026#34;hlt\u0026#34;, cpu_idle_nopoll_setup); 52#endif 53 54static noinline int __cpuidle cpu_idle_poll(void) 55{ 56\trcu_idle_enter(); 57\ttrace_cpu_idle_rcuidle(0, smp_processor_id()); 58\tlocal_irq_enable(); 59\tstop_critical_timings(); 60 61\twhile (!tif_need_resched() \u0026amp;\u0026amp; 62\t(cpu_idle_force_poll || tick_check_broadcast_expired())) 63\tcpu_relax(); 64\tstart_critical_timings(); 65\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id()); 66\trcu_idle_exit(); 67 68\treturn 1; 69} 70 71/* Weak implementations for optional arch specific functions */ 72void __weak arch_cpu_idle_prepare(void) { } 73void __weak arch_cpu_idle_enter(void) { } 74void __weak arch_cpu_idle_exit(void) { } 75void __weak arch_cpu_idle_dead(void) { } 76void __weak arch_cpu_idle(void) 77{ 78\tcpu_idle_force_poll = 1; 79\tlocal_irq_enable(); 80} 81 82/** 83 * default_idle_call - Default CPU idle routine. 84 * 85 * To use when the cpuidle framework cannot be used. 86 */ 87void __cpuidle default_idle_call(void) 88{ 89\tif (current_clr_polling_and_test()) { 90\tlocal_irq_enable(); 91\t} else { 92\tstop_critical_timings(); 93\tarch_cpu_idle(); 94\tstart_critical_timings(); 95\t} 96} 97 98static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev, 99\tint next_state) 100{ 101\t/* 102\t* The idle task must be scheduled, it is pointless to go to idle, just 103\t* update no idle residency and return. 104\t*/ 105\tif (current_clr_polling_and_test()) { 106\tdev-\u0026gt;last_residency = 0; 107\tlocal_irq_enable(); 108\treturn -EBUSY; 109\t} 110 111\t/* 112\t* Enter the idle state previously returned by the governor decision. 113\t* This function will block until an interrupt occurs and will take 114\t* care of re-enabling the local interrupts 115\t*/ 116\treturn cpuidle_enter(drv, dev, next_state); 117} 118 119/** 120 * cpuidle_idle_call - the main idle function 121 * 122 * NOTE: no locks or semaphores should be used here 123 * 124 * On archs that support TIF_POLLING_NRFLAG, is called with polling 125 * set, and it returns with polling set. If it ever stops polling, it 126 * must clear the polling bit. 127 */ 128static void cpuidle_idle_call(void) 129{ 130\tstruct cpuidle_device *dev = cpuidle_get_device(); 131\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev); 132\tint next_state, entered_state; 133 134\t/* 135\t* Check if the idle task must be rescheduled. If it is the 136\t* case, exit the function after re-enabling the local irq. 137\t*/ 138\tif (need_resched()) { 139\tlocal_irq_enable(); 140\treturn; 141\t} 142 143\t/* 144\t* The RCU framework needs to be told that we are entering an idle 145\t* section, so no more rcu read side critical sections and one more 146\t* step to the grace period 147\t*/ 148 149\tif (cpuidle_not_available(drv, dev)) { 150\ttick_nohz_idle_stop_tick(); 151\trcu_idle_enter(); 152 153\tdefault_idle_call(); 154\tgoto exit_idle; 155\t} 156 157\t/* 158\t* Suspend-to-idle (\u0026#34;s2idle\u0026#34;) is a system state in which all user space 159\t* has been frozen, all I/O devices have been suspended and the only 160\t* activity happens here and in iterrupts (if any). In that case bypass 161\t* the cpuidle governor and go stratight for the deepest idle state 162\t* available. Possibly also suspend the local tick and the entire 163\t* timekeeping to prevent timer interrupts from kicking us out of idle 164\t* until a proper wakeup interrupt happens. 165\t*/ 166 167\tif (idle_should_enter_s2idle() || dev-\u0026gt;use_deepest_state) { 168\tif (idle_should_enter_s2idle()) { 169\trcu_idle_enter(); 170 171\tentered_state = cpuidle_enter_s2idle(drv, dev); 172\tif (entered_state \u0026gt; 0) { 173\tlocal_irq_enable(); 174\tgoto exit_idle; 175\t} 176 177\trcu_idle_exit(); 178\t} 179 180\ttick_nohz_idle_stop_tick(); 181\trcu_idle_enter(); 182 183\tnext_state = cpuidle_find_deepest_state(drv, dev); 184\tcall_cpuidle(drv, dev, next_state); 185\t} else { 186\tbool stop_tick = true; 187 188\t/* 189\t* Ask the cpuidle framework to choose a convenient idle state. 190\t*/ 191\tnext_state = cpuidle_select(drv, dev, \u0026amp;stop_tick); 192 193\tif (stop_tick || tick_nohz_tick_stopped()) 194\ttick_nohz_idle_stop_tick(); 195\telse 196\ttick_nohz_idle_retain_tick(); 197 198\trcu_idle_enter(); 199 200\tentered_state = call_cpuidle(drv, dev, next_state); 201\t/* 202\t* Give the governor an opportunity to reflect on the outcome 203\t*/ 204\tcpuidle_reflect(dev, entered_state); 205\t} 206 207exit_idle: 208\t__current_set_polling(); 209 210\t/* 211\t* It is up to the idle functions to reenable local interrupts 212\t*/ 213\tif (WARN_ON_ONCE(irqs_disabled())) 214\tlocal_irq_enable(); 215 216\trcu_idle_exit(); 217} 218 219/* 220 * Generic idle loop implementation 221 * 222 * Called with polling cleared. 223 */ 224static void do_idle(void) 225{ 226\tint cpu = smp_processor_id(); 227\t/* 228\t* If the arch has a polling bit, we maintain an invariant: 229\t* 230\t* Our polling bit is clear if we\u0026#39;re not scheduled (i.e. if rq-\u0026gt;curr != 231\t* rq-\u0026gt;idle). This means that, if rq-\u0026gt;idle has the polling bit set, 232\t* then setting need_resched is guaranteed to cause the CPU to 233\t* reschedule. 234\t*/ 235 236\t__current_set_polling(); 237\ttick_nohz_idle_enter(); 238 239\twhile (!need_resched()) { 240\tcheck_pgt_cache(); 241\trmb(); 242 243\tlocal_irq_disable(); 244 245\tif (cpu_is_offline(cpu)) { 246\ttick_nohz_idle_stop_tick(); 247\tcpuhp_report_idle_dead(); 248\tarch_cpu_idle_dead(); 249\t} 250 251\tarch_cpu_idle_enter(); 252 253\t/* 254\t* In poll mode we reenable interrupts and spin. Also if we 255\t* detected in the wakeup from idle path that the tick 256\t* broadcast device expired for us, we don\u0026#39;t want to go deep 257\t* idle as we know that the IPI is going to arrive right away. 258\t*/ 259\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) { 260\ttick_nohz_idle_restart_tick(); 261\tcpu_idle_poll(); 262\t} else { 263\tcpuidle_idle_call(); 264\t} 265\tarch_cpu_idle_exit(); 266\t} 267 268\t/* 269\t* Since we fell out of the loop above, we know TIF_NEED_RESCHED must 270\t* be set, propagate it into PREEMPT_NEED_RESCHED. 271\t* 272\t* This is required because for polling idle loops we will not have had 273\t* an IPI to fold the state for us. 274\t*/ 275\tpreempt_set_need_resched(); 276\ttick_nohz_idle_exit(); 277\t__current_clr_polling(); 278 279\t/* 280\t* We promise to call sched_ttwu_pending() and reschedule if 281\t* need_resched() is set while polling is set. That means that clearing 282\t* polling needs to be visible before doing these things. 283\t*/ 284\tsmp_mb__after_atomic(); 285 286\tsched_ttwu_pending(); 287\tschedule_idle(); 288 289\tif (unlikely(klp_patch_pending(current))) 290\tklp_update_patch_state(current); 291} 292 293bool cpu_in_idle(unsigned long pc) 294{ 295\treturn pc \u0026gt;= (unsigned long)__cpuidle_text_start \u0026amp;\u0026amp; 296\tpc \u0026lt; (unsigned long)__cpuidle_text_end; 297} 298 299struct idle_timer { 300\tstruct hrtimer timer; 301\tint done; 302}; 303 304static enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer) 305{ 306\tstruct idle_timer *it = container_of(timer, struct idle_timer, timer); 307 308\tWRITE_ONCE(it-\u0026gt;done, 1); 309\tset_tsk_need_resched(current); 310 311\treturn HRTIMER_NORESTART; 312} 313 314void play_idle(unsigned long duration_ms) 315{ 316\tstruct idle_timer it; 317 318\t/* 319\t* Only FIFO tasks can disable the tick since they don\u0026#39;t need the forced 320\t* preemption. 321\t*/ 322\tWARN_ON_ONCE(current-\u0026gt;policy != SCHED_FIFO); 323\tWARN_ON_ONCE(current-\u0026gt;nr_cpus_allowed != 1); 324\tWARN_ON_ONCE(!(current-\u0026gt;flags \u0026amp; PF_KTHREAD)); 325\tWARN_ON_ONCE(!(current-\u0026gt;flags \u0026amp; PF_NO_SETAFFINITY)); 326\tWARN_ON_ONCE(!duration_ms); 327 328\trcu_sleep_check(); 329\tpreempt_disable(); 330\tcurrent-\u0026gt;flags |= PF_IDLE; 331\tcpuidle_use_deepest_state(true); 332 333\tit.done = 0; 334\thrtimer_init_on_stack(\u0026amp;it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); 335\tit.timer.function = idle_inject_timer_fn; 336\thrtimer_start(\u0026amp;it.timer, ms_to_ktime(duration_ms), HRTIMER_MODE_REL_PINNED); 337 338\twhile (!READ_ONCE(it.done)) 339\tdo_idle(); 340 341\tcpuidle_use_deepest_state(false); 342\tcurrent-\u0026gt;flags \u0026amp;= ~PF_IDLE; 343 344\tpreempt_fold_need_resched(); 345\tpreempt_enable(); 346} 347EXPORT_SYMBOL_GPL(play_idle); 348 349void cpu_startup_entry(enum cpuhp_state state) 350{ 351\t/* 352\t* This #ifdef needs to die, but it\u0026#39;s too late in the cycle to 353\t* make this generic (ARM and SH have never invoked the canary 354\t* init for the non boot CPUs!). Will be fixed in 3.11 355\t*/ 356#ifdef CONFIG_X86 357\t/* 358\t* If we\u0026#39;re the non-boot CPU, nothing set the stack canary up 359\t* for us. The boot CPU already has it initialized but no harm 360\t* in doing it again. This is a good place for updating it, as 361\t* we wont ever return from this function (so the invalid 362\t* canaries already on the stack wont ever trigger). 363\t*/ 364\tboot_init_stack_canary(); 365#endif 366\tarch_cpu_idle_prepare(); 367\tcpuhp_online_idle(state); 368\twhile (1) 369\tdo_idle(); 370} 371 372/* 373 * idle-task scheduling class. 374 */ 375 376#ifdef CONFIG_SMP 377static int 378select_task_rq_idle(struct task_struct *p, int cpu, int sd_flag, int flags) 379{ 380\treturn task_cpu(p); /* IDLE tasks as never migrated */ 381} 382#endif 383 384/* 385 * Idle tasks are unconditionally rescheduled: 386 */ 387static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags) 388{ 389\tresched_curr(rq); 390} 391 392static struct task_struct * 393pick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) 394{ 395\tput_prev_task(rq, prev); 396\tupdate_idle_core(rq); 397\tschedstat_inc(rq-\u0026gt;sched_goidle); 398 399\treturn rq-\u0026gt;idle; 400} 401 402/* 403 * It is not legal to sleep in the idle task - print a warning 404 * message if some code attempts to do it: 405 */ 406static void 407dequeue_task_idle(struct rq *rq, struct task_struct *p, int flags) 408{ 409\traw_spin_unlock_irq(\u0026amp;rq-\u0026gt;lock); 410\tprintk(KERN_ERR \u0026#34;bad: scheduling from the idle thread!\\n\u0026#34;); 411\tdump_stack(); 412\traw_spin_lock_irq(\u0026amp;rq-\u0026gt;lock); 413} 414 415static void put_prev_task_idle(struct rq *rq, struct task_struct *prev) 416{ 417} 418 419/* 420 * scheduler tick hitting a task of our scheduling class. 421 * 422 * NOTE: This function can be called remotely by the tick offload that 423 * goes along full dynticks. Therefore no local assumption can be made 424 * and everything must be accessed through the @rq and @curr passed in 425 * parameters. 426 */ 427static void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued) 428{ 429} 430 431static void set_curr_task_idle(struct rq *rq) 432{ 433} 434 435static void switched_to_idle(struct rq *rq, struct task_struct *p) 436{ 437\tBUG(); 438} 439 440static void 441prio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio) 442{ 443\tBUG(); 444} 445 446static unsigned int get_rr_interval_idle(struct rq *rq, struct task_struct *task) 447{ 448\treturn 0; 449} 450 451static void update_curr_idle(struct rq *rq) 452{ 453} 454 455/* 456 * Simple, special scheduling class for the per-CPU idle tasks: 457 */ 458const struct sched_class idle_sched_class = { 459\t/* .next is NULL */ 460\t/* no enqueue/yield_task for idle tasks */ 461 462\t/* dequeue is not valid, we print a debug message there: */ 463\t.dequeue_task\t= dequeue_task_idle, 464 465\t.check_preempt_curr\t= check_preempt_curr_idle, 466 467\t.pick_next_task\t= pick_next_task_idle, 468\t.put_prev_task\t= put_prev_task_idle, 469 470#ifdef CONFIG_SMP 471\t.select_task_rq\t= select_task_rq_idle, 472\t.set_cpus_allowed\t= set_cpus_allowed_common, 473#endif 474 475\t.set_curr_task = set_curr_task_idle, 476\t.task_tick\t= task_tick_idle, 477 478\t.get_rr_interval\t= get_rr_interval_idle, 479 480\t.prio_changed\t= prio_changed_idle, 481\t.switched_to\t= switched_to_idle, 482\t.update_curr\t= update_curr_idle, 483}; ","date":"28280-10-28","img":"","largeImg":"","permalink":"/posts/idle/","series":null,"smallImg":"","tags":["kernel"],"title":"Idle"},{"categories":["linux"],"content":"完全公平调度器 1const struct sched_class fair_sched_class = { 2\t.next\t= \u0026amp;idle_sched_class, 3\t.enqueue_task\t= enqueue_task_fair, 4\t.dequeue_task\t= dequeue_task_fair, 5\t.yield_task\t= yield_task_fair, 6\t.yield_to_task\t= yield_to_task_fair, 7 8\t.check_preempt_curr\t= check_preempt_wakeup, 9 10\t.pick_next_task\t= pick_next_task_fair, 11\t.put_prev_task\t= put_prev_task_fair, 12 13#ifdef CONFIG_SMP 14\t.select_task_rq\t= select_task_rq_fair, 15\t.migrate_task_rq\t= migrate_task_rq_fair, 16 17\t.rq_online\t= rq_online_fair, 18\t.rq_offline\t= rq_offline_fair, 19 20\t.task_dead\t= task_dead_fair, 21\t.set_cpus_allowed\t= set_cpus_allowed_common, 22#endif 23 24\t.set_curr_task = set_curr_task_fair, 25\t.task_tick\t= task_tick_fair, 26\t.task_fork\t= task_fork_fair, 27 28\t.prio_changed\t= prio_changed_fair, 29\t.switched_from\t= switched_from_fair, 30\t.switched_to\t= switched_to_fair, 31 32\t.get_rr_interval\t= get_rr_interval_fair, 33 34\t.update_curr\t= update_curr_fair, 35 36#ifdef CONFIG_FAIR_GROUP_SCHED 37\t.task_change_group\t= task_change_group_fair, 38#endif 39}; 调度器类分析\n1struct sched_class { 2\tconst struct sched_class *next; 3 4\tvoid (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); 5\tvoid (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); 6\tvoid (*yield_task) (struct rq *rq); 7\tbool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); 8 9\tvoid (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); 10 11\t/* 12\t* It is the responsibility of the pick_next_task() method that will 13\t* return the next task to call put_prev_task() on the @prev task or 14\t* something equivalent. 15\t* 16\t* May return RETRY_TASK when it finds a higher prio class has runnable 17\t* tasks. 18\t*/ 19\tstruct task_struct * (*pick_next_task)(struct rq *rq, 20\tstruct task_struct *prev, 21\tstruct rq_flags *rf); 22\tvoid (*put_prev_task)(struct rq *rq, struct task_struct *p); 23 24#ifdef CONFIG_SMP 25\tint (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); 26\tvoid (*migrate_task_rq)(struct task_struct *p, int new_cpu); 27 28\tvoid (*task_woken)(struct rq *this_rq, struct task_struct *task); 29 30\tvoid (*set_cpus_allowed)(struct task_struct *p, 31\tconst struct cpumask *newmask); 32 33\tvoid (*rq_online)(struct rq *rq); 34\tvoid (*rq_offline)(struct rq *rq); 35#endif 36 37\tvoid (*set_curr_task)(struct rq *rq); 38\tvoid (*task_tick)(struct rq *rq, struct task_struct *p, int queued); 39\tvoid (*task_fork)(struct task_struct *p); 40\tvoid (*task_dead)(struct task_struct *p); 41 42\t/* 43\t* The switched_from() call is allowed to drop rq-\u0026gt;lock, therefore we 44\t* cannot assume the switched_from/switched_to pair is serliazed by 45\t* rq-\u0026gt;lock. They are however serialized by p-\u0026gt;pi_lock. 46\t*/ 47\tvoid (*switched_from)(struct rq *this_rq, struct task_struct *task); 48\tvoid (*switched_to) (struct rq *this_rq, struct task_struct *task); 49\tvoid (*prio_changed) (struct rq *this_rq, struct task_struct *task, 50\tint oldprio); 51 52\tunsigned int (*get_rr_interval)(struct rq *rq, 53\tstruct task_struct *task); 54 55\tvoid (*update_curr)(struct rq *rq); 56 57#define TASK_SET_GROUP\t0 58#define TASK_MOVE_GROUP\t1 59 60#ifdef CONFIG_FAIR_GROUP_SCHED 61\tvoid (*task_change_group)(struct task_struct *p, int type); 62#endif 63}; enqueue_task_fair 1static void 2enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) 3{ 4\tstruct cfs_rq *cfs_rq; 5\tstruct sched_entity *se = \u0026amp;p-\u0026gt;se; 6 7\t/* 8\t* The code below (indirectly) updates schedutil which looks at 9\t* the cfs_rq utilization to select a frequency. 10\t* Let\u0026#39;s add the task\u0026#39;s estimated utilization to the cfs_rq\u0026#39;s 11\t* estimated utilization, before we update schedutil. 12\t*/ 13\tutil_est_enqueue(\u0026amp;rq-\u0026gt;cfs, p); 14 15\t/* 16\t* If in_iowait is set, the code below may not trigger any cpufreq 17\t* utilization updates, so do it here explicitly with the IOWAIT flag 18\t* passed. 19\t*/ 20\tif (p-\u0026gt;in_iowait) 21\tcpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); 22 23\tfor_each_sched_entity(se) { 24\tif (se-\u0026gt;on_rq) 25\tbreak; 26\tcfs_rq = cfs_rq_of(se); 27\tenqueue_entity(cfs_rq, se, flags); 28 29\t/* 30\t* end evaluation on encountering a throttled cfs_rq 31\t* 32\t* note: in the case of encountering a throttled cfs_rq we will 33\t* post the final h_nr_running increment below. 34\t*/ 35\tif (cfs_rq_throttled(cfs_rq)) 36\tbreak; 37\tcfs_rq-\u0026gt;h_nr_running++; 38 39\tflags = ENQUEUE_WAKEUP; 40\t} 41 42\tfor_each_sched_entity(se) { 43\tcfs_rq = cfs_rq_of(se); 44\tcfs_rq-\u0026gt;h_nr_running++; 45 46\tif (cfs_rq_throttled(cfs_rq)) 47\tbreak; 48 49\tupdate_load_avg(cfs_rq, se, UPDATE_TG); 50\tupdate_cfs_group(se); 51\t} 52 53\tif (!se) 54\tadd_nr_running(rq, 1); 55 56\tif (cfs_bandwidth_used()) { 57\t/* 58\t* When bandwidth control is enabled; the cfs_rq_throttled() 59\t* breaks in the above iteration can result in incomplete 60\t* leaf list maintenance, resulting in triggering the assertion 61\t* below. 62\t*/ 63\tfor_each_sched_entity(se) { 64\tcfs_rq = cfs_rq_of(se); 65 66\tif (list_add_leaf_cfs_rq(cfs_rq)) 67\tbreak; 68\t} 69\t} 70 71\tassert_list_leaf_cfs_rq(rq); 72 73\thrtick_update(rq); 74} dequeue_task_fair 1static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) 2{ 3\tstruct cfs_rq *cfs_rq; 4\tstruct sched_entity *se = \u0026amp;p-\u0026gt;se; 5\tint task_sleep = flags \u0026amp; DEQUEUE_SLEEP; 6 7\tfor_each_sched_entity(se) { 8\tcfs_rq = cfs_rq_of(se); 9\tdequeue_entity(cfs_rq, se, flags); 10 11\t/* 12\t* end evaluation on encountering a throttled cfs_rq 13\t* 14\t* note: in the case of encountering a throttled cfs_rq we will 15\t* post the final h_nr_running decrement below. 16\t*/ 17\tif (cfs_rq_throttled(cfs_rq)) 18\tbreak; 19\tcfs_rq-\u0026gt;h_nr_running--; 20 21\t/* Don\u0026#39;t dequeue parent if it has other entities besides us */ 22\tif (cfs_rq-\u0026gt;load.weight) { 23\t/* Avoid re-evaluating load for this entity: */ 24\tse = parent_entity(se); 25\t/* 26\t* Bias pick_next to pick a task from this cfs_rq, as 27\t* p is sleeping when it is within its sched_slice. 28\t*/ 29\tif (task_sleep \u0026amp;\u0026amp; se \u0026amp;\u0026amp; !throttled_hierarchy(cfs_rq)) 30\tset_next_buddy(se); 31\tbreak; 32\t} 33\tflags |= DEQUEUE_SLEEP; 34\t} 35 36\tfor_each_sched_entity(se) { 37\tcfs_rq = cfs_rq_of(se); 38\tcfs_rq-\u0026gt;h_nr_running--; 39 40\tif (cfs_rq_throttled(cfs_rq)) 41\tbreak; 42 43\tupdate_load_avg(cfs_rq, se, UPDATE_TG); 44\tupdate_cfs_group(se); 45\t} 46 47\tif (!se) 48\tsub_nr_running(rq, 1); 49 50\tutil_est_dequeue(\u0026amp;rq-\u0026gt;cfs, p, task_sleep); 51\thrtick_update(rq); 52} yield_task_fair yield_to_task_fair ","date":"28280-10-28","img":"","largeImg":"","permalink":"/posts/fair/","series":null,"smallImg":"","tags":["kernel"],"title":"Fair"},{"categories":[],"content":"简述 驱动模型\n顶级kobject 解释 block 块设备链接\u0026ndash;\u0026gt;/sys/deives相关文件 bus 存放各种总线文件 class 各种设备类 dev 存放(字符/块)设备主副设备号链接文件\u0026ndash;\u0026gt;/sys/deives devices 设备的具体存放文件 firmware 固件存放 fs 文件类型 kernel kernel子系统 module 模块信息 power 能源管理 底层机制 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面\n数据结构 1struct kobject { 2\tconst char\t*name;\t/* 名字 */ 3\tstruct list_head\tentry;\t/* 链表:链接进入kset */ 4\tstruct kobject\t*parent;\t/* 指向父对象,建立层次结构 */ 5\tstruct kset\t*kset;\t/* 对象集合 */ 6\tstruct kobj_type\t*ktype;\t/* 对象类型 */ 7\tstruct kernfs_node\t*sd; /* sysfs directory entry */ 8\tstruct kref\tkref;\t/* 引用计数 */ 9 10 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE 11\tstruct delayed_work\trelease; 12\t#endif 13\t14 unsigned int state_initialized:1;\t/* 标志位:初始化 */ 15\tunsigned int state_in_sysfs:1;\t/* 标志位:在sysfs中 */ 16\tunsigned int state_add_uevent_sent:1;\t/* 标志位:发出KOBJ_ADD uevent */ 17\tunsigned int state_remove_uevent_sent:1;\t/* 标志位:发出KOBJ_REMOVE uevent */ 18\tunsigned int uevent_suppress:1;\t/* 标志位:禁止发出uevent */ 19}; 初始化 1/** 2 * kobject_init - initialize a kobject structure 3 * @kobj: pointer to the kobject to initialize 4 * @ktype: pointer to the ktype for this kobject. 5 * 6 * This function will properly initialize a kobject such that it can then 7 * be passed to the kobject_add() call. 8 * 9 * After this function is called, the kobject MUST be cleaned up by a call 10 * to kobject_put(), not by a call to kfree directly to ensure that all of 11 * the memory is cleaned up properly. 12 */ 13void kobject_init(struct kobject *kobj, struct kobj_type *ktype) 14{ 15\tchar *err_str;\t/** 错误信息 */ 16 17\t/** 校验参数NULL */ 18\tif (!kobj) { 19\terr_str = \u0026#34;invalid kobject pointer!\u0026#34;; 20\tgoto error; 21\t} 22\tif (!ktype) { 23\terr_str = \u0026#34;must have a ktype to be initialized properly!\\n\u0026#34;; 24\tgoto error; 25\t} 26 27\t/** kobject是否已经初始化 */ 28\tif (kobj-\u0026gt;state_initialized) { 29\t/* do not error out as sometimes we can recover */ 30\tpr_err(\u0026#34;kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\u0026#34;, 31\tkobj); 32\tdump_stack(); /** 回溯堆栈 */ 33\t} 34 35\t/** 调用具体初始化函数 */ 36\tkobject_init_internal(kobj); 37 38\t/* 设置类型 */ 39\tkobj-\u0026gt;ktype = ktype; 40\treturn; 41 42error: 43\tpr_err(\u0026#34;kobject (%p): %s\\n\u0026#34;, kobj, err_str); 44\tdump_stack(); 45} 46EXPORT_SYMBOL(kobject_init); 添加 1int kobject_add(struct kobject *kobj, /* 需要添加kobject */ 2\tstruct kobject *parent, /* 父指针 */ 3\tconst char *fmt, ...) /* 命名 */ 4{ 5\tva_list args; 6\tint retval; 7\t8\t/* 校验kobject */ 9\tif (!kobj) 10\treturn -EINVAL; 11\t12\t/* 是否已经初始化 */ 13\tif (!kobj-\u0026gt;state_initialized) { 14\tpr_err(\u0026#34;kobject \u0026#39;%s\u0026#39; (%p): tried to add an uninitialized object, something is seriously wrong.\\n\u0026#34;, 15\tkobject_name(kobj), kobj); 16\tdump_stack(); 17\treturn -EINVAL; 18\t} 19\tva_start(args, fmt); 20\t/* 设置名字并且将父指针添加到parent */ 21\tretval = kobject_add_varg(kobj, parent, fmt, args); 22\tva_end(args); 23\t24\treturn retval; 25} 最终调用添加函数\n1static int kobject_add_internal(struct kobject *kobj) 2{ 3\tint error = 0; 4\tstruct kobject *parent; 5\t6 /* 判断参数NULL */ 7\tif (!kobj) 8\treturn -ENOENT; 9\t10 /* 判断名字是否有效 */ 11\tif (!kobj-\u0026gt;name || !kobj-\u0026gt;name[0]) { 12\tWARN(1, 13\t\u0026#34;kobject: (%p): attempted to be registered with empty name!\\n\u0026#34;, 14\tkobj); 15\treturn -EINVAL; 16\t} 17\t18 /** 获取父指针 */ 19\tparent = kobject_get(kobj-\u0026gt;parent); 20 21\t/* join kset if set, use it as parent if we do not already have one */ 22\tif (kobj-\u0026gt;kset) {\t/* kset已经设置 */ 23\tif (!parent)\t/* 不存在父指针 */ 24\t/* kset的kobject作为父指针 */ 25 parent = kobject_get(\u0026amp;kobj-\u0026gt;kset-\u0026gt;kobj); 26\t/* 将kobject加入kset */ 27 kobj_kset_join(kobj); 28\t29 /* 保存父指针 */ 30 kobj-\u0026gt;parent = parent; 31\t} 32 33\tpr_debug(\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): %s: parent: \u0026#39;%s\u0026#39;, set: \u0026#39;%s\u0026#39;\\n\u0026#34;, 34\tkobject_name(kobj), kobj, __func__, 35\tparent ? kobject_name(parent) : \u0026#34;\u0026lt;NULL\u0026gt;\u0026#34;, 36\tkobj-\u0026gt;kset ? kobject_name(\u0026amp;kobj-\u0026gt;kset-\u0026gt;kobj) : \u0026#34;\u0026lt;NULL\u0026gt;\u0026#34;); 37\t38 /* 创建dir */ 39\terror = create_dir(kobj); 40\tif (error) { /* 出错,清理 */ 41\tkobj_kset_leave(kobj); 42\tkobject_put(parent); 43\tkobj-\u0026gt;parent = NULL; 44 45\t/* be noisy on error issues */ 46\tif (error == -EEXIST) 47\tpr_err(\u0026#34;%s failed for %s with -EEXIST, don\u0026#39;t try to register things with the same name in the same directory.\\n\u0026#34;, 48\t__func__, kobject_name(kobj)); 49\telse 50\tpr_err(\u0026#34;%s failed for %s (error: %d parent: %s)\\n\u0026#34;, 51\t__func__, kobject_name(kobj), error, 52\tparent ? kobject_name(parent) : \u0026#34;\u0026#39;none\u0026#39;\u0026#34;); 53\t} else 54\tkobj-\u0026gt;state_in_sysfs = 1; /* 添加到sysfs中 */ 55 56\treturn error; 57} sysfs文件夹生成 1static int create_dir(struct kobject *kobj) 2{ 3\tconst struct kobj_ns_type_operations *ops; 4\tint error; 5 6\terror = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); 7\tif (error) 8\treturn error; 9 10\terror = populate_dir(kobj); 11\tif (error) { 12\tsysfs_remove_dir(kobj); 13\treturn error; 14\t} 15 16\t/* 17\t* @kobj-\u0026gt;sd may be deleted by an ancestor going away. Hold an 18\t* extra reference so that it stays until @kobj is gone. 19\t*/ 20\tsysfs_get(kobj-\u0026gt;sd); 21 22\t/* 23\t* If @kobj has ns_ops, its children need to be filtered based on 24\t* their namespace tags. Enable namespace support on @kobj-\u0026gt;sd. 25\t*/ 26\tops = kobj_child_ns_ops(kobj); 27\tif (ops) { 28\tBUG_ON(ops-\u0026gt;type \u0026lt;= KOBJ_NS_TYPE_NONE); 29\tBUG_ON(ops-\u0026gt;type \u0026gt;= KOBJ_NS_TYPES); 30\tBUG_ON(!kobj_ns_type_registered(ops-\u0026gt;type)); 31 32\tsysfs_enable_ns(kobj-\u0026gt;sd); 33\t} 34 35\treturn 0; 36} 删除 1void kobject_del(struct kobject *kobj) 2{ 3\tstruct kernfs_node *sd; 4 5\tif (!kobj) 6\treturn; 7 8\tsd = kobj-\u0026gt;sd; 9\tsysfs_remove_dir(kobj); 10\tsysfs_put(sd); 11 12\tkobj-\u0026gt;state_in_sysfs = 0; 13\tkobj_kset_leave(kobj); 14\tkobject_put(kobj-\u0026gt;parent); 15\tkobj-\u0026gt;parent = NULL; 16} 引用计数 1struct kobject *kobject_get(struct kobject *kobj) 2{ 3\tif (kobj) { 4\tif (!kobj-\u0026gt;state_initialized) 5\tWARN(1, KERN_WARNING 6\t\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): is not initialized, yet kobject_get() is being called.\\n\u0026#34;, 7\tkobject_name(kobj), kobj); 8\tkref_get(\u0026amp;kobj-\u0026gt;kref); 9\t} 10\treturn kobj; 11} 12 13void kobject_put(struct kobject *kobj) 14{ 15\tif (kobj) { 16\tif (!kobj-\u0026gt;state_initialized) 17\tWARN(1, KERN_WARNING 18\t\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): is not initialized, yet kobject_put() is being called.\\n\u0026#34;, 19\tkobject_name(kobj), kobj); 20\tkref_put(\u0026amp;kobj-\u0026gt;kref, kobject_release); 21\t} 22} kset 数据结构 1struct kset { 2\tstruct list_head list; 3\tspinlock_t list_lock; 4\tstruct kobject kobj; 5\tconst struct kset_uevent_ops *uevent_ops; 6} __randomize_layout; ktype 数据结构 1struct kobj_type { 2\tvoid (*release)(struct kobject *kobj); 3\tconst struct sysfs_ops *sysfs_ops; 4\tstruct attribute **default_attrs; 5\tconst struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); 6\tconst void *(*namespace)(struct kobject *kobj); 7\tvoid (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); 8}; class 设备类描述\n1struct class { 2\tconst char\t*name; 3\tstruct module\t*owner; 4 5\tconst struct attribute_group\t**class_groups; 6\tconst struct attribute_group\t**dev_groups; 7\tstruct kobject\t*dev_kobj; 8 9\tint (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); 10\tchar *(*devnode)(struct device *dev, umode_t *mode); 11 12\tvoid (*class_release)(struct class *class); 13\tvoid (*dev_release)(struct device *dev); 14 15\tint (*shutdown_pre)(struct device *dev); 16 17\tconst struct kobj_ns_type_operations *ns_type; 18\tconst void *(*namespace)(struct device *dev); 19 20\tvoid (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid); 21 22\tconst struct dev_pm_ops *pm; 23 24\tstruct subsys_private *p; 25}; bus 设备总线描述\n总线类型 1# ls 2amba cpu nvmem platform virtio 3clockevents event_source pci scsi workqueue 4clocksource gpio pci_express serio 5container hid pcmcia spi 其中每一个总线具有如下信息\n1# ls 2devices drivers_autoprobe uevent 3drivers drivers_probe 1struct bus_type { 2\tconst char\t*name; 3\tconst char\t*dev_name; 4\tstruct device\t*dev_root; 5\tconst struct attribute_group **bus_groups; 6\tconst struct attribute_group **dev_groups; 7\tconst struct attribute_group **drv_groups; 8 9\tint (*match)(struct device *dev, struct device_driver *drv); 10\tint (*uevent)(struct device *dev, struct kobj_uevent_env *env); 11\tint (*probe)(struct device *dev); 12\tint (*remove)(struct device *dev); 13\tvoid (*shutdown)(struct device *dev); 14 15\tint (*online)(struct device *dev); 16\tint (*offline)(struct device *dev); 17 18\tint (*suspend)(struct device *dev, pm_message_t state); 19\tint (*resume)(struct device *dev); 20 21\tint (*num_vf)(struct device *dev); 22 23\tint (*dma_configure)(struct device *dev); 24 25\tconst struct dev_pm_ops *pm; 26 27\tconst struct iommu_ops *iommu_ops; 28 29\tstruct subsys_private *p; 30\tstruct lock_class_key lock_key; 31 32\tbool need_parent_lock; 33}; 设备总线注册 1int bus_register(struct bus_type *bus) 2{ 3\tint retval; 4\tstruct subsys_private *priv; 5\tstruct lock_class_key *key = \u0026amp;bus-\u0026gt;lock_key; 6 7\tpriv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); 8\tif (!priv) 9\treturn -ENOMEM; 10 11\tpriv-\u0026gt;bus = bus; 12\tbus-\u0026gt;p = priv; 13 14\tBLOCKING_INIT_NOTIFIER_HEAD(\u0026amp;priv-\u0026gt;bus_notifier); 15 16\tretval = kobject_set_name(\u0026amp;priv-\u0026gt;subsys.kobj, \u0026#34;%s\u0026#34;, bus-\u0026gt;name); 17\tif (retval) 18\tgoto out; 19 20\tpriv-\u0026gt;subsys.kobj.kset = bus_kset; 21\tpriv-\u0026gt;subsys.kobj.ktype = \u0026amp;bus_ktype; 22\tpriv-\u0026gt;drivers_autoprobe = 1; 23 24\tretval = kset_register(\u0026amp;priv-\u0026gt;subsys); 25\tif (retval) 26\tgoto out; 27 28\tretval = bus_create_file(bus, \u0026amp;bus_attr_uevent); 29\tif (retval) 30\tgoto bus_uevent_fail; 31 32\tpriv-\u0026gt;devices_kset = kset_create_and_add(\u0026#34;devices\u0026#34;, NULL, 33\t\u0026amp;priv-\u0026gt;subsys.kobj); 34\tif (!priv-\u0026gt;devices_kset) { 35\tretval = -ENOMEM; 36\tgoto bus_devices_fail; 37\t} 38 39\tpriv-\u0026gt;drivers_kset = kset_create_and_add(\u0026#34;drivers\u0026#34;, NULL, 40\t\u0026amp;priv-\u0026gt;subsys.kobj); 41\tif (!priv-\u0026gt;drivers_kset) { 42\tretval = -ENOMEM; 43\tgoto bus_drivers_fail; 44\t} 45 46\tINIT_LIST_HEAD(\u0026amp;priv-\u0026gt;interfaces); 47\t__mutex_init(\u0026amp;priv-\u0026gt;mutex, \u0026#34;subsys mutex\u0026#34;, key); 48\tklist_init(\u0026amp;priv-\u0026gt;klist_devices, klist_devices_get, klist_devices_put); 49\tklist_init(\u0026amp;priv-\u0026gt;klist_drivers, NULL, NULL); 50 51\tretval = add_probe_files(bus); 52\tif (retval) 53\tgoto bus_probe_files_fail; 54 55\tretval = bus_add_groups(bus, bus-\u0026gt;bus_groups); 56\tif (retval) 57\tgoto bus_groups_fail; 58 59\tpr_debug(\u0026#34;bus: \u0026#39;%s\u0026#39;: registered\\n\u0026#34;, bus-\u0026gt;name); 60\treturn 0; 61 62bus_groups_fail: 63\tremove_probe_files(bus); 64bus_probe_files_fail: 65\tkset_unregister(bus-\u0026gt;p-\u0026gt;drivers_kset); 66bus_drivers_fail: 67\tkset_unregister(bus-\u0026gt;p-\u0026gt;devices_kset); 68bus_devices_fail: 69\tbus_remove_file(bus, \u0026amp;bus_attr_uevent); 70bus_uevent_fail: 71\tkset_unregister(\u0026amp;bus-\u0026gt;p-\u0026gt;subsys); 72out: 73\tkfree(bus-\u0026gt;p); 74\tbus-\u0026gt;p = NULL; 75\treturn retval; 76} 设备总线卸载 1void bus_unregister(struct bus_type *bus) 2{ 3\tpr_debug(\u0026#34;bus: \u0026#39;%s\u0026#39;: unregistering\\n\u0026#34;, bus-\u0026gt;name); 4\tif (bus-\u0026gt;dev_root) 5\tdevice_unregister(bus-\u0026gt;dev_root); 6\tbus_remove_groups(bus, bus-\u0026gt;bus_groups); 7\tremove_probe_files(bus); 8\tkset_unregister(bus-\u0026gt;p-\u0026gt;drivers_kset); 9\tkset_unregister(bus-\u0026gt;p-\u0026gt;devices_kset); 10\tbus_remove_file(bus, \u0026amp;bus_attr_uevent); 11\tkset_unregister(\u0026amp;bus-\u0026gt;p-\u0026gt;subsys); 12} devices 设备文件具体描述: device(设备描述) device_driver(驱动描述) bus_type(总线信息)\n1|-- breakpoint 2|-- kprobe 3|-- platform 4|-- software 5|-- system 6|-- tracepoint 7|-- uprobe 8`-- virtual device 描述设备\n1struct device { 2\tstruct device\t*parent; 3 4\tstruct device_private\t*p; 5 6\tstruct kobject kobj; 7\tconst char\t*init_name; /* initial name of the device */ 8\tconst struct device_type *type; 9 10\tstruct mutex\tmutex;\t/* mutex to synchronize calls to 11\t* its driver. 12\t*/ 13 14\tstruct bus_type\t*bus;\t/* type of bus device is on */ 15\tstruct device_driver *driver;\t/* which driver has allocated this 16\tdevice */ 17\tvoid\t*platform_data;\t/* Platform specific data, device 18\tcore doesn\u0026#39;t touch it */ 19\tvoid\t*driver_data;\t/* Driver data, set and get with 20\tdev_set/get_drvdata */ 21\tstruct dev_links_info\tlinks; 22\tstruct dev_pm_info\tpower; 23\tstruct dev_pm_domain\t*pm_domain; 24 25#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN 26\tstruct irq_domain\t*msi_domain; 27#endif 28#ifdef CONFIG_PINCTRL 29\tstruct dev_pin_info\t*pins; 30#endif 31#ifdef CONFIG_GENERIC_MSI_IRQ 32\tstruct list_head\tmsi_list; 33#endif 34 35#ifdef CONFIG_NUMA 36\tint\tnuma_node;\t/* NUMA node this device is close to */ 37#endif 38\tconst struct dma_map_ops *dma_ops; 39\tu64\t*dma_mask;\t/* dma mask (if dma\u0026#39;able device) */ 40\tu64\tcoherent_dma_mask;/* Like dma_mask, but for 41\talloc_coherent mappings as 42\tnot all hardware supports 43\t64 bit addresses for consistent 44\tallocations such descriptors. */ 45\tu64\tbus_dma_mask;\t/* upstream dma_mask constraint */ 46\tunsigned long\tdma_pfn_offset; 47 48\tstruct device_dma_parameters *dma_parms; 49 50\tstruct list_head\tdma_pools;\t/* dma pools (if dma\u0026#39;ble) */ 51 52\tstruct dma_coherent_mem\t*dma_mem; /* internal for coherent mem 53\toverride */ 54#ifdef CONFIG_DMA_CMA 55\tstruct cma *cma_area;\t/* contiguous memory area for dma 56\tallocations */ 57#endif 58\t/* arch specific additions */ 59\tstruct dev_archdata\tarchdata; 60 61\tstruct device_node\t*of_node; /* associated device tree node */ 62\tstruct fwnode_handle\t*fwnode; /* firmware device node */ 63 64\tdev_t\tdevt;\t/* dev_t, creates the sysfs \u0026#34;dev\u0026#34; */ 65\tu32\tid;\t/* device instance */ 66 67\tspinlock_t\tdevres_lock; 68\tstruct list_head\tdevres_head; 69 70\tstruct klist_node\tknode_class; 71\tstruct class\t*class; 72\tconst struct attribute_group **groups;\t/* optional groups */ 73 74\tvoid\t(*release)(struct device *dev); 75\tstruct iommu_group\t*iommu_group; 76\tstruct iommu_fwspec\t*iommu_fwspec; 77 78\tbool\toffline_disabled:1; 79\tbool\toffline:1; 80\tbool\tof_node_reused:1; 81}; driver 描述驱动\n1struct device_driver { 2\tconst char\t*name; 3\tstruct bus_type\t*bus; 4 5\tstruct module\t*owner; 6\tconst char\t*mod_name;\t/* used for built-in modules */ 7 8\tbool suppress_bind_attrs;\t/* disables bind/unbind via sysfs */ 9\tenum probe_type probe_type; 10 11\tconst struct of_device_id\t*of_match_table; 12\tconst struct acpi_device_id\t*acpi_match_table; 13 14\tint (*probe) (struct device *dev); 15\tint (*remove) (struct device *dev); 16\tvoid (*shutdown) (struct device *dev); 17\tint (*suspend) (struct device *dev, pm_message_t state); 18\tint (*resume) (struct device *dev); 19\tconst struct attribute_group **groups; 20 21\tconst struct dev_pm_ops *pm; 22\tvoid (*coredump) (struct device *dev); 23 24\tstruct driver_private *p; 25}; kernel kernel子系统\nmodule 模块信息\n","date":"24240-10-24","img":"","largeImg":"","permalink":"/posts/drivermodel/","series":null,"smallImg":"","tags":["kernel"],"title":"驱动模型"},{"categories":["python"],"content":"python基础绘图\n","date":"16160-10-16","img":"","largeImg":"","permalink":"/posts/tkinter/","series":null,"smallImg":"","tags":[],"title":"Tkinter"},{"categories":[],"content":"","date":"7070-10-07","img":"","largeImg":"","permalink":"/posts/javascript/","series":null,"smallImg":"","tags":[],"title":"Javascript"},{"categories":[],"content":"CSS开始(层叠样式表) HTML + CSS + JavaScript 名词 + 形容词 + 动词 相当于对原始的HTML进行美化\n快速入门 CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画 什么是CSS 美化:字体, 颜色,高度,宽度, 背景图片\nCSS的优势: 内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件 CSS导入的方法 行内样式 1\u0026lt;h1 style=\u0026#34;color: red\u0026#34;\u0026gt;一级标题\u0026lt;/h1\u0026gt; style标签 1\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 外部样式 链接方式 1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; 导入式 1\u0026lt;style\u0026gt; 2\t@import url(\u0026#34;css/style.css\u0026#34;); 3\u0026lt;/style\u0026gt; 基本语法 1/* 注释语法 */ 2selector { 3\t/* 声明 */ 4\tattr:value; 5} 选择器 基本选择器 标签选择器\n类选择器\nID选择器\n标签选择器 1h1 { 2 color: red; 3} 4h2 { 5 color: black; 6} 7h3 { 8 color: yellow; 9} 10h4 { 11 color: red; 12} 类选择器 1\u0026lt;h1 class=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/h1\u0026gt; 此时,可以讲HTML选中\n1.test { 2 color: black; 3} ID选择器 1\u0026lt;h1 id=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/h1\u0026gt; 1#test { 2\tcolor: black; 3} ID唯一确定,不可以共享;\n层次选择器 ","date":"7070-10-07","img":"","largeImg":"","permalink":"/posts/css/","series":null,"smallImg":"","tags":[],"title":"Css"},{"categories":[],"content":"开始 网页基础结构\n1\u0026lt;!-- 告诉浏览器,需要使用的规范 --\u0026gt; 2\u0026lt;!DOCTYPE html\u0026gt; 3\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 4 5\u0026lt;!-- 网页标题 --\u0026gt; 6\u0026lt;head\u0026gt; 7 \u0026lt;!-- 描述标签 --\u0026gt; 8 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 9 10 \u0026lt;!-- 网页标题 --\u0026gt; 11 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 12\u0026lt;/head\u0026gt; 13 14\u0026lt;!-- 网页主体 --\u0026gt; 15\u0026lt;body\u0026gt; 16\u0026lt;/body\u0026gt; 17\u0026lt;/html\u0026gt; 网页基本标签 标题标签 1\u0026lt;h1\u0026gt;一级标签\u0026lt;/h1\u0026gt; 2\u0026lt;h2\u0026gt;二级标签\u0026lt;/h2\u0026gt; 3\u0026lt;h3\u0026gt;三级标签\u0026lt;/h3\u0026gt; 4\u0026lt;h4\u0026gt;四级标签\u0026lt;/h4\u0026gt; 5\u0026lt;h5\u0026gt;五级标签\u0026lt;/h5\u0026gt; 6\u0026lt;h6\u0026gt;六级标签\u0026lt;/h6\u0026gt; 段落标签 1\u0026lt;p\u0026gt;段落标签\u0026lt;/p\u0026gt; 换行标签 1\u0026lt;br/\u0026gt; 水平线标签 1\u0026lt;hr/\u0026gt; 字体样式标签 1\u0026lt;!-- 字体样式标签 --\u0026gt; 2\u0026lt;strong\u0026gt;粗体\u0026lt;/strong\u0026gt;\u0026lt;br/\u0026gt; 3\u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt;\u0026lt;br/\u0026gt; 图片标签 1\u0026lt;img src=\u0026#34;测试.png\u0026#34; alt=\u0026#34;测试\u0026#34; title=\u0026#34;测试\u0026#34;/\u0026gt; 链接 1\u0026lt;!-- 当前页打开 --\u0026gt; 2\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 3\u0026lt;!-- 新建页打开 --\u0026gt; 4\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 行内元素和块元素 列表标签 有序列表 1\u0026lt;ol\u0026gt; 2 \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; 3 \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; 4 \u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; 5\u0026lt;/ol\u0026gt; 无序列表 1\u0026lt;ul\u0026gt; 2 \u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; 3 \u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; 4 \u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; 5\u0026lt;/ul\u0026gt; 定义列表 1\u0026lt;dl\u0026gt; 2 \u0026lt;dt\u0026gt;前端\u0026lt;/dt\u0026gt; 3 \u0026lt;dd\u0026gt;html\u0026lt;/dd\u0026gt; 4 \u0026lt;dd\u0026gt;CSS\u0026lt;/dd\u0026gt; 5 \u0026lt;dd\u0026gt;JavaScript\u0026lt;/dd\u0026gt; 6\u0026lt;/dl\u0026gt; 表格 1\u0026lt;table border=\u0026#34;1px\u0026#34;\u0026gt; 2\t\u0026lt;tr\u0026gt; 3\t\u0026lt;td\u0026gt;1-1\u0026lt;/td\u0026gt; 4\t\u0026lt;td\u0026gt;1-2\u0026lt;/td\u0026gt; 5\t\u0026lt;/tr\u0026gt; 6\t\u0026lt;tr\u0026gt; 7\t\u0026lt;td\u0026gt;2-1\u0026lt;/td\u0026gt; 8\t\u0026lt;td\u0026gt;2-2\u0026lt;/td\u0026gt; 9\t\u0026lt;/tr\u0026gt; 10\u0026lt;/table\u0026gt; 页面结构分析 元素名 描述 header 标题头部区域 footer 标记尾部内容 section web页面中一块独立的区域 article 独立文章内容 aside 相关页面或者内容 nav 导航类辅助内容 iframe内联框架 1\u0026lt;iframe src=\u0026#34;path\u0026#34; name=\u0026#34;mainFrame\u0026#34;\u0026gt;\u0026lt;/frame\u0026gt; bilibili的例子\n1\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=55631961\u0026amp;bvid=BV1x4411V75C\u0026amp;cid=97257967\u0026amp;page=11\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 表单 表单form\n1\u0026lt;form action=\u0026#34;开始.html\u0026#34; method=\u0026#34;GET/POST\u0026#34;\u0026gt; 2 \u0026lt;p\u0026gt;名字: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 3 \u0026lt;p\u0026gt;密码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 4 \u0026lt;p\u0026gt; 5 \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; 6 \u0026lt;input type=\u0026#34;reset\u0026#34;\u0026gt; 7 \u0026lt;/p\u0026gt; 8\u0026lt;/form\u0026gt; 产生的效果\n1?name=111\u0026amp;password= ","date":"7070-10-07","img":"","largeImg":"","permalink":"/posts/html5/","series":null,"smallImg":"","tags":[],"title":"Html5"},{"categories":[],"content":" A C dynamic strings library C语言版本动态字符串库\nSDS SDS的类型就是\n1typedef char *sds; 可以明显的看到,sds就是普通的char类型\n下面是sds的数据类型 1+--------+-------------------------------+-----------+ 2| Header | Binary safe C alike string... | Null term | 3+--------+-------------------------------+-----------+ 4 | 5 -\u0026gt; Pointer returned to the user. 1#define SDS_HDR_VAR(T,s) \\ 2\tstruct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); 3#define SDS_HDR(T,s) \\ 4\t((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 5#define SDS_TYPE_5_LEN(f) ((f)\u0026gt;\u0026gt;SDS_TYPE_BITS) SDS 头 根据不同的标志计算不同的头部数据\n宏定义 标志 SDS_TYPE_5 sdshdr5 SDS_TYPE_8 sdshdr8 SDS_TYPE_16 sdshdr16 SDS_TYPE_32 sdshdr32 SDS_TYPE_64 sdshdr64 flag标志:\n1unsigned char flags = s[-1]; /* 最后一个头部数据 */ 1#define SDS_TYPE_5 0 2#define SDS_TYPE_8 1 3#define SDS_TYPE_16 2 4#define SDS_TYPE_32 3 5#define SDS_TYPE_64 4 1/* Note: sdshdr5 is never used, we just access the flags byte directly. 2 * However is here to document the layout of type 5 SDS strings. */ 3struct __attribute__ ((__packed__)) sdshdr5 { 4 unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ 5 char buf[]; 6}; 7struct __attribute__ ((__packed__)) sdshdr8 { 8 uint8_t len; /* used */ 9 uint8_t alloc; /* excluding the header and null terminator */ 10 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 11 char buf[]; 12}; 13struct __attribute__ ((__packed__)) sdshdr16 { 14 uint16_t len; /* used */ 15 uint16_t alloc; /* excluding the header and null terminator */ 16 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 17 char buf[]; 18}; 19struct __attribute__ ((__packed__)) sdshdr32 { 20 uint32_t len; /* used */ 21 uint32_t alloc; /* excluding the header and null terminator */ 22 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 23 char buf[]; 24}; 25struct __attribute__ ((__packed__)) sdshdr64 { 26 uint64_t len; /* used */ 27 uint64_t alloc; /* excluding the header and null terminator */ 28 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 29 char buf[]; 30}; 1#define SDS_TYPE_MASK 7 2#define SDS_TYPE_BITS 3 创建SDS 函数原型\n1sds sdsnewlen(const void *init, size_t initlen); 扩张字符串缓存区 1sds sdsMakeRoomFor(sds s, size_t addlen) 2{ 3 void *sh; 4 void *newsh; 5 size_t avail = sdsavail(s);\t/* 计算剩余的可以使用的大小 */ 6 size_t len; 7 size_t newlen; 8 char type, oldtype = s[-1] \u0026amp; SDS_TYPE_MASK; 9 int hdrlen; 10 11 if (avail \u0026gt;= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ 12 return s; 13 } 14 len = sdslen(s);\t/* 计算字符串大小 */ 15 sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ 16 17 /* 计算得到新的长度 */ 18 newlen = (len+addlen); 19 if (newlen \u0026lt; SDS_MAX_PREALLOC) 20 newlen *= 2; 21 else 22 newlen += SDS_MAX_PREALLOC; 23\t/* 重新生成类型 */ 24 type = sdsReqType(newlen); 25 26 /* Don\u0026#39;t use type 5: the user is appending to the string and type 5 is 27 * not able to remember empty space, so sdsMakeRoomFor() must be called 28 * at every appending operation. */ 29 if (type == SDS_TYPE_5) { 30 type = SDS_TYPE_8; 31\t} 32\t33 /* 计算头部大小 */ 34 hdrlen = sdsHdrSize(type); 35 36 if (oldtype == type) { 37 newsh = s_realloc(sh, hdrlen + newlen + 1); 38 if (newsh == NULL) { 39 return NULL; 40 } 41 s = (char*)newsh + hdrlen; 42 } else { 43 /* Since the header size changes, need to move the string forward, 44 * and can\u0026#39;t use realloc */ 45 newsh = s_malloc(hdrlen+newlen+1); 46 if (newsh == NULL) { 47 return NULL; 48 } 49 memcpy((char*)newsh+hdrlen, s, len+1); 50 s_free(sh); 51 52 s = (char*)newsh + hdrlen; 53 s[-1] = type; 54 55 sdssetlen(s, len); 56 } 57 58 sdssetalloc(s, newlen); 59 return s; 60} 追加字符串 1sds sdscatlen(sds s, const void *t, size_t len) 2{ 3 size_t curlen = sdslen(s);\t/* 计算字符串的长度 */ 4 5 s = sdsMakeRoomFor(s,len);\t/* 扩展字符串缓冲区长度 */ 6 if (s == NULL) { 7 return NULL; 8 } 9 memcpy(s+curlen, t, len);\t/* 添加字符串 */ 10 sdssetlen(s, curlen+len);\t/* 设置长度标志 */ 11 s[curlen+len] = \u0026#39;\\0\u0026#39;;\t/* 补全结束符 */ 12 return s; 13} ","date":"6060-10-06","img":"","largeImg":"","permalink":"/posts/sds/","series":null,"smallImg":"","tags":[],"title":"Sds"},{"categories":[],"content":" STL称为标准模板库(Standard Template Library) 广义上可以分为容器,算法,迭代器 容器和算法通过迭代器进行无缝连接 STL几乎所有的代码都采用了函数模版或者类模板\nSTL组件 序号 名称 解释 1 容器 各种数据结构 2 算法 各种常用的算法 3 迭代器 容器域算法的胶合 4 仿函数 行为类似函数 5 适配器 修饰容器或者仿函数迭代器 6 空间配置器 负责空间的配置和管理 容器算法和迭代器 vector vector使用 1/* 创建vector容器 */ 2vector\u0026lt;int\u0026gt; v; 3/* 插入数据 */ 4v.push_back(10); 5v.push_back(20); 6v.push_back(30); 7v.push_back(40); 迭代器使用 迭代器方案1 1vector\u0026lt;int\u0026gt;::iterator itBegin = v.begin(); 2vector\u0026lt;int\u0026gt;::iterator itEnd = v.end(); 3while (itBegin != itEnd) { 4\tcout \u0026lt;\u0026lt; *itBegin \u0026lt;\u0026lt; endl; 5\titBegin += 1; 6} 迭代器2 1for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 2{ 3\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; 4} 遍历算法 1template \u0026lt;class T\u0026gt; 2void myPrint(T val) 3{ 4\tcout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 5} 6 7/* 可惜回调函数不支持自动推导 */ 8for_each(v.begin(), v.end(), myPrint\u0026lt;int\u0026gt;); 容器自定义数据 容器嵌套容器 1vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;v; // 外部大容器 2vector\u0026lt;int\u0026gt; vx[10]; // 内部小容器 3 4/* 插入容器 */ 5for (int i = 0; i \u0026lt; 10; i++) 6{ 7\tfor (int j = 0; j \u0026lt; 30; j++) 8\t{ 9\tvx[i].push_back(i + j + 10); 10\t} 11\tv.push_back(vx[i]); 12} 13 14/* 遍历容器 */ 15for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 16{ 17\tfor (vector\u0026lt;int\u0026gt;::iterator vit = it-\u0026gt;begin(); vit != it-\u0026gt;end(); vit++) 18\t{ 19\tcout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 20\t} 21\tcout \u0026lt;\u0026lt; endl; 22} string string本质上是一个类,封装了char*,提供了许多的成员方法;\n构造函数 1string s1(str); 2string s2 = \u0026#34;Hello World\u0026#34;; 3string s3(s2); 赋值操作 重载操作符**=** 1string s1; 2s1 = \u0026#34;Hello World\u0026#34;; 成员函数assign 1string str; 2str.assign(\u0026#34;Hello World\u0026#34;); 追加操作 重载操作符**+=** 成员函数append 查找和替换 find replace 比较 compare 字符存取 [] at 插入和删除 insert earse 子串 substr array deque hashtable map list queue stack set rbtree ","date":"6060-10-06","img":"","largeImg":"","permalink":"/posts/stl/","series":null,"smallImg":"","tags":[],"title":"STL学习笔记"},{"categories":[],"content":"HelloWorld 1#!/bin/python3 2 3if __name__ == \u0026#39;__main__\u0026#39;: 4 print(\u0026#39;Hello World\u0026#39;) 数据类型 Numbers(数字) 1intA = 10 2print(intA) 布尔类型 1true 2false String(字符串) 1strB = \u0026#34;Hello\u0026#34; 2print(strB) List(列表) 1listC = [\u0026#34;12\u0026#34;, 3, 4] 2print(listC) Tuple(元组) 1tupleD = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) 2print(tupleD) Dictionary(字典) 1DictE = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;b\u0026#39;: \u0026#39;3\u0026#39;} 2print(DictE) 运算符 控制结构 条件语句 单执行语句 1if 判断条件： 2\t执行语句 3else： 4\t执行语句 多条件语句 1if 判断条件1: 2 执行语句1…… 3elif 判断条件2: 4 执行语句2…… 5elif 判断条件3: 6\t执行语句3…… 7else: 8 执行语句4…… while循环 1c = 0 2while (c \u0026lt; 10): 3 print(c) 4 c += 1 5print(\u0026#34;while Loop finish\u0026#34;) ###　for循环\n函数 面向对象 ","date":"5050-10-05","img":"","largeImg":"","permalink":"/posts/python/","series":null,"smallImg":"","tags":[],"title":"Python学习笔记"},{"categories":[],"content":"输入子设备分为三层\nhandle core device input的相关结构体 1 struct input_dev {\t/* 输入设备的描述 */ 2 const char *name;\t/* 设备名称 */ 3\tconst char *phys; 4\tconst char *uniq; 5\tstruct input_id id; 6 7\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; 8 9\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)]; 10\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; 11\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)]; 12\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; 13\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; 14\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; 15\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; 16\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; 17\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)]; 18 19\tunsigned int hint_events_per_packet; 20 21\tunsigned int keycodemax; 22\tunsigned int keycodesize; 23\tvoid *keycode; 24 25\tint (*setkeycode)(struct input_dev *dev, 26\tconst struct input_keymap_entry *ke, 27\tunsigned int *old_keycode); 28\tint (*getkeycode)(struct input_dev *dev, 29\tstruct input_keymap_entry *ke); 30 31\tstruct ff_device *ff; 32 33\tunsigned int repeat_key; 34\tstruct timer_list timer; 35 36\tint rep[REP_CNT]; 37 38\tstruct input_mt *mt; 39 40\tstruct input_absinfo *absinfo; 41 42\tunsigned long key[BITS_TO_LONGS(KEY_CNT)]; 43\tunsigned long led[BITS_TO_LONGS(LED_CNT)]; 44\tunsigned long snd[BITS_TO_LONGS(SND_CNT)]; 45\tunsigned long sw[BITS_TO_LONGS(SW_CNT)]; 46 47\tint (*open)(struct input_dev *dev); 48\tvoid (*close)(struct input_dev *dev); 49\tint (*flush)(struct input_dev *dev, struct file *file); 50\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); 51 52\tstruct input_handle __rcu *grab; 53 54\tspinlock_t event_lock; 55\tstruct mutex mutex; 56 57\tunsigned int users; 58\tbool going_away; 59 60\tstruct device dev; 61 62\tstruct list_head\th_list; 63\tstruct list_head\tnode; 64 65\tunsigned int num_vals; 66\tunsigned int max_vals; 67\tstruct input_value *vals; 68 69\tbool devres_managed; 70 }; 71#define to_input_dev(d) container_of(d, struct input_dev, dev) input子系统使用 input子系统分析 Makefile编写 1obj-$(CONFIG_INPUT)\t+= input-core.o 2input-core-y := input.o input-compat.o input-mt.o ff-core.o 开始判断下面的第一个文件 input.c 1subsys_initcall(input_init); 2module_exit(input_exit); 输入子系统的设备号\n1#define INPUT_MAJOR 13 安装驱动\n1 static int __init input_init(void) 2 { 3\tint err; 4\t/* 注册设备类 */ 5\terr = class_register(\u0026amp;input_class); 6\tif (err) { 7\tpr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 8\treturn err; 9\t} 10 11\t/* 注册proc文件系统 */ 12\terr = input_proc_init(); 13\tif (err) 14\tgoto fail1; 15\t/* 注册设备 */ 16\terr = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), 17\tINPUT_MAX_CHAR_DEVICES, \u0026#34;input\u0026#34;); 18\tif (err) { 19\tpr_err(\u0026#34;unable to register char major %d\u0026#34;, INPUT_MAJOR); 20\tgoto fail2; 21\t} 22 23\treturn 0; 24 25 fail2:\tinput_proc_exit(); 26 fail1:\tclass_unregister(\u0026amp;input_class); 27\treturn err; 28 } 卸载驱动\n1 static void __exit input_exit(void) 2 { 3\t/* 卸载proc文件系统 */ 4\tinput_proc_exit(); 5 6\t/* 注销设备号 */ 7\tunregister_chrdev_region(MKDEV(INPUT_MAJOR, 0), 8\tINPUT_MAX_CHAR_DEVICES); 9 10\t/* 注销CLass */ 11\tclass_unregister(\u0026amp;input_class); 12 } 设备类操作\n1\t/* 设备类型 */ 2\tstruct class input_class = { 3\t.name\t= \u0026#34;input\u0026#34;, 4\t.devnode\t= input_devnode, 5\t}; 6\tEXPORT_SYMBOL_GPL(input_class); 7 8\t/* 注册设备 */ 9\terr = class_register(\u0026amp;input_class); 10\tif (err) { 11\tpr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 12\treturn err; 13\t} 14 15\t/* 卸载设备 */ 16 class_unregister(\u0026amp;input_class); Proc文件系统操作\nProc文件系统添加\n1static int __init input_proc_init(void) 2{ 3\tstruct proc_dir_entry *entry; 4 5\tproc_bus_input_dir = proc_mkdir(\u0026#34;bus/input\u0026#34;, NULL); 6\tif (!proc_bus_input_dir) 7\treturn -ENOMEM; 8 9\tentry = proc_create(\u0026#34;devices\u0026#34;, 0, proc_bus_input_dir, 10\t\u0026amp;input_devices_fileops); 11\tif (!entry) 12\tgoto fail1; 13 14\tentry = proc_create(\u0026#34;handlers\u0026#34;, 0, proc_bus_input_dir, 15\t\u0026amp;input_handlers_fileops); 16\tif (!entry) 17\tgoto fail2; 18 19\treturn 0; 20 21 fail2:\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 22 fail1: remove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 23\treturn -ENOMEM; 24} Proc文件系统卸载\n1static void input_proc_exit(void) 2{ 3\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 4\tremove_proc_entry(\u0026#34;handlers\u0026#34;, proc_bus_input_dir); 5\tremove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 6} 接口部分 Handler操作 1/** 2 * 注册 input handler 3 * input_register_handler - register a new input handler 4 * @handler: handler to be registered 5 * 6 * This function registers a new input handler (interface) for input 7 * devices in the system and attaches it to all input devices that 8 * are compatible with the handler. 9 */ 10int input_register_handler(struct input_handler *handler) 11{ 12\tstruct input_dev *dev; 13\tint error; 14 15\terror = mutex_lock_interruptible(\u0026amp;input_mutex); 16\tif (error) 17\treturn error; 18 19\tINIT_LIST_HEAD(\u0026amp;handler-\u0026gt;h_list); 20 21\tlist_add_tail(\u0026amp;handler-\u0026gt;node, \u0026amp;input_handler_list); 22 23\tlist_for_each_entry(dev, \u0026amp;input_dev_list, node) 24\tinput_attach_handler(dev, handler); 25 26\tinput_wakeup_procfs_readers(); 27 28\tmutex_unlock(\u0026amp;input_mutex); 29\treturn 0; 30} 31EXPORT_SYMBOL(input_register_handler); 32 33/** 34 * 解除注册 input handler 35 * input_unregister_handler - unregisters an input handler 36 * @handler: handler to be unregistered 37 * 38 * This function disconnects a handler from its input devices and 39 * removes it from lists of known handlers. 40 */ 41void input_unregister_handler(struct input_handler *handler) 42{ 43\tstruct input_handle *handle, *next; 44 45\tmutex_lock(\u0026amp;input_mutex); 46 47\tlist_for_each_entry_safe(handle, next, \u0026amp;handler-\u0026gt;h_list, h_node) 48\thandler-\u0026gt;disconnect(handle); 49\tWARN_ON(!list_empty(\u0026amp;handler-\u0026gt;h_list)); 50 51\tlist_del_init(\u0026amp;handler-\u0026gt;node); 52 53\tinput_wakeup_procfs_readers(); 54 55\tmutex_unlock(\u0026amp;input_mutex); 56} 57EXPORT_SYMBOL(input_unregister_handler); 注册设备 1/** 2 * 注册一个设备 3 * input_register_device - register device with input core 4 * @dev: device to be registered 5 * 6 * This function registers device with input core. The device must be 7 * allocated with input_allocate_device() and all it\u0026#39;s capabilities 8 * set up before registering. 9 * If function fails the device must be freed with input_free_device(). 10 * Once device has been successfully registered it can be unregistered 11 * with input_unregister_device(); input_free_device() should not be 12 * called in this case. 13 * 14 * Note that this function is also used to register managed input devices 15 * (ones allocated with devm_input_allocate_device()). Such managed input 16 * devices need not be explicitly unregistered or freed, their tear down 17 * is controlled by the devres infrastructure. It is also worth noting 18 * that tear down of managed input devices is internally a 2-step process: 19 * registered managed input device is first unregistered, but stays in 20 * memory and can still handle input_event() calls (although events will 21 * not be delivered anywhere). The freeing of managed input device will 22 * happen later, when devres stack is unwound to the point where device 23 * allocation was made. 24 */ 25int input_register_device(struct input_dev *dev) 26{ 27\tstruct input_devres *devres = NULL; 28\tstruct input_handler *handler; 29\tunsigned int packet_size; 30\tconst char *path; 31\tint error; 32 33\tif (dev-\u0026gt;devres_managed) { 34\tdevres = devres_alloc(devm_input_device_unregister, 35\tsizeof(struct input_devres), GFP_KERNEL); 36\tif (!devres) 37\treturn -ENOMEM; 38 39\tdevres-\u0026gt;input = dev; 40\t} 41 42\t/* Every input device generates EV_SYN/SYN_REPORT events. */ 43\t__set_bit(EV_SYN, dev-\u0026gt;evbit); 44 45\t/* KEY_RESERVED is not supposed to be transmitted to userspace. */ 46\t__clear_bit(KEY_RESERVED, dev-\u0026gt;keybit); 47 48\t/* Make sure that bitmasks not mentioned in dev-\u0026gt;evbit are clean. */ 49\tinput_cleanse_bitmasks(dev); 50 51\tpacket_size = input_estimate_events_per_packet(dev); 52\tif (dev-\u0026gt;hint_events_per_packet \u0026lt; packet_size) 53\tdev-\u0026gt;hint_events_per_packet = packet_size; 54 55\tdev-\u0026gt;max_vals = dev-\u0026gt;hint_events_per_packet + 2; 56\tdev-\u0026gt;vals = kcalloc(dev-\u0026gt;max_vals, sizeof(*dev-\u0026gt;vals), GFP_KERNEL); 57\tif (!dev-\u0026gt;vals) { 58\terror = -ENOMEM; 59\tgoto err_devres_free; 60\t} 61 62\t/* 63\t* If delay and period are pre-set by the driver, then autorepeating 64\t* is handled by the driver itself and we don\u0026#39;t do it in input.c. 65\t*/ 66\tif (!dev-\u0026gt;rep[REP_DELAY] \u0026amp;\u0026amp; !dev-\u0026gt;rep[REP_PERIOD]) { 67\tdev-\u0026gt;timer.data = (long) dev; 68\tdev-\u0026gt;timer.function = input_repeat_key; 69\tdev-\u0026gt;rep[REP_DELAY] = 250; 70\tdev-\u0026gt;rep[REP_PERIOD] = 33; 71\t} 72 73\tif (!dev-\u0026gt;getkeycode) 74\tdev-\u0026gt;getkeycode = input_default_getkeycode; 75 76\tif (!dev-\u0026gt;setkeycode) 77\tdev-\u0026gt;setkeycode = input_default_setkeycode; 78 79\terror = device_add(\u0026amp;dev-\u0026gt;dev); 80\tif (error) 81\tgoto err_free_vals; 82 83\tpath = kobject_get_path(\u0026amp;dev-\u0026gt;dev.kobj, GFP_KERNEL); 84\tpr_info(\u0026#34;%s as %s\\n\u0026#34;, 85\tdev-\u0026gt;name ? dev-\u0026gt;name : \u0026#34;Unspecified device\u0026#34;, 86\tpath ? path : \u0026#34;N/A\u0026#34;); 87\tkfree(path); 88 89\terror = mutex_lock_interruptible(\u0026amp;input_mutex); 90\tif (error) 91\tgoto err_device_del; 92 93\tlist_add_tail(\u0026amp;dev-\u0026gt;node, \u0026amp;input_dev_list); 94 95\tlist_for_each_entry(handler, \u0026amp;input_handler_list, node) 96\tinput_attach_handler(dev, handler); 97 98\tinput_wakeup_procfs_readers(); 99 100\tmutex_unlock(\u0026amp;input_mutex); 101 102\tif (dev-\u0026gt;devres_managed) { 103\tdev_dbg(dev-\u0026gt;dev.parent, \u0026#34;%s: registering %s with devres.\\n\u0026#34;, 104\t__func__, dev_name(\u0026amp;dev-\u0026gt;dev)); 105\tdevres_add(dev-\u0026gt;dev.parent, devres); 106\t} 107\treturn 0; 108 109err_device_del: 110\tdevice_del(\u0026amp;dev-\u0026gt;dev); 111err_free_vals: 112\tkfree(dev-\u0026gt;vals); 113\tdev-\u0026gt;vals = NULL; 114err_devres_free: 115\tdevres_free(devres); 116\treturn error; 117} 118EXPORT_SYMBOL(input_register_device); 119 120/** 121 * 解除注册设备 122 * input_unregister_device - unregister previously registered device 123 * @dev: device to be unregistered 124 * 125 * This function unregisters an input device. Once device is unregistered 126 * the caller should not try to access it as it may get freed at any moment. 127 */ 128void input_unregister_device(struct input_dev *dev) 129{ 130\tif (dev-\u0026gt;devres_managed) { 131\tWARN_ON(devres_destroy(dev-\u0026gt;dev.parent, 132\tdevm_input_device_unregister, 133\tdevm_input_device_match, 134\tdev)); 135\t__input_unregister_device(dev); 136\t/* 137\t* We do not do input_put_device() here because it will be done 138\t* when 2nd devres fires up. 139\t*/ 140\t} else { 141\t__input_unregister_device(dev); 142\tinput_put_device(dev); 143\t} 144} 145EXPORT_SYMBOL(input_unregister_device); ","date":"5050-10-05","img":"","largeImg":"","permalink":"/posts/input_drive/","series":null,"smallImg":"","tags":[],"title":"输入子系统"},{"categories":[],"content":"","date":"4040-10-04","img":"","largeImg":"","permalink":"/posts/slab/","series":null,"smallImg":"","tags":[],"title":"Slab"},{"categories":[],"content":"MMU内存管理单元 ARM内存管理单元分析\n","date":"4040-10-04","img":"","largeImg":"","permalink":"/posts/mmu/","series":null,"smallImg":"","tags":[],"title":"Mmu"},{"categories":[],"content":"","date":"4040-10-04","img":"","largeImg":"","permalink":"/posts/page/","series":null,"smallImg":"","tags":[],"title":"Page"},{"categories":[],"content":"fork linux创建线程的函数 fork \u0026ndash;\u0026gt; do_fork\ndo_fork的执行线路 do_fork \u0026ndash;\u0026gt; copy_process \u0026ndash;\u0026gt; get_task_pid \u0026ndash;\u0026gt; wake_up_new_task \u0026ndash;\u0026gt; put_pid\ndo_fork函数原型\n1long _do_fork(unsigned long clone_flags, 2\tunsigned long stack_start, 3\tunsigned long stack_size, 4\tint __user *parent_tidptr, 5\tint __user *child_tidptr, 6\tunsigned long tls); clone_flags stack_start stack_size parent_tidptr child_tidptr tls copy_process get_task_pid wake_up_new_task ","date":"4040-10-04","img":"","largeImg":"","permalink":"/posts/fork/","series":null,"smallImg":"","tags":[],"title":"Fork"},{"categories":[],"content":"","date":"4040-10-04","img":"","largeImg":"","permalink":"/posts/task/","series":null,"smallImg":"","tags":[],"title":"任务管理"},{"categories":["linux"],"content":"系统调度 主调度器schedule 周期调度器scheduler_tick 周期调度器函数实现 1void scheduler_tick(void) 2{ 3\tint cpu = smp_processor_id();\t// CPUID 4\tstruct rq *rq = cpu_rq(cpu);\t// 提取消息队列 5\tstruct task_struct *curr = rq-\u0026gt;curr;\t// 提取正在运行的进程 6\tstruct rq_flags rf;\t// 7\tsched_clock_tick();\t// 8\trq_lock(rq, \u0026amp;rf);\t// 9\tupdate_rq_clock(rq);\t// 更新运行时钟 10\tcurr-\u0026gt;sched_class-\u0026gt;task_tick(rq, curr, 0);\t// 调用调度器类 11\tcpu_load_update_active(rq); 12\tcalc_global_load_tick(rq); 13\trq_unlock(rq, \u0026amp;rf); 14\tperf_event_task_tick(); 15} 主调度器函数实现 1static void __sched notrace __schedule(bool preempt) 2{ 3\tstruct task_struct *prev, *next; 4\tunsigned long *switch_count; 5\tstruct rq_flags rf; 6\tstruct rq *rq; 7\tint cpu; 8 9\tcpu = smp_processor_id(); 10\trq = cpu_rq(cpu); 11\tprev = rq-\u0026gt;curr; 12 13\tschedule_debug(prev); 14 15\tif (sched_feat(HRTICK)) 16\thrtick_clear(rq); 17 18\tlocal_irq_disable(); 19\trcu_note_context_switch(preempt); 20 21\trq_lock(rq, \u0026amp;rf); 22\tsmp_mb__after_spinlock(); 23 24\trq-\u0026gt;clock_update_flags \u0026lt;\u0026lt;= 1; 25\tupdate_rq_clock(rq); 26 27\tswitch_count = \u0026amp;prev-\u0026gt;nivcsw; 28\tif (!preempt \u0026amp;\u0026amp; prev-\u0026gt;state) { 29\tif (unlikely(signal_pending_state(prev-\u0026gt;state, prev))) { 30\tprev-\u0026gt;state = TASK_RUNNING; 31\t} else { 32\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK); 33\tprev-\u0026gt;on_rq = 0; 34 35\tif (prev-\u0026gt;in_iowait) { 36\tatomic_inc(\u0026amp;rq-\u0026gt;nr_iowait); 37\tdelayacct_blkio_start(); 38\t} 39\tif (prev-\u0026gt;flags \u0026amp; PF_WQ_WORKER) { 40\tstruct task_struct *to_wakeup; 41 42\tto_wakeup = wq_worker_sleeping(prev); 43\tif (to_wakeup) 44\ttry_to_wake_up_local(to_wakeup, \u0026amp;rf); 45\t} 46\t} 47\tswitch_count = \u0026amp;prev-\u0026gt;nvcsw; 48\t} 49 50\tnext = pick_next_task(rq, prev, \u0026amp;rf); 51\tclear_tsk_need_resched(prev); 52\tclear_preempt_need_resched(); 53 54\tif (likely(prev != next)) { 55\trq-\u0026gt;nr_switches++; 56\trq-\u0026gt;curr = next; 57\t++*switch_count; 58 59\ttrace_sched_switch(preempt, prev, next); 60\trq = context_switch(rq, prev, next, \u0026amp;rf); 61\t} else { 62\trq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); 63\trq_unlock_irq(rq, \u0026amp;rf); 64\t} 65 66\tbalance_callback(rq); 67} 寻找最高优先级任务 1/* 2 * 获取最高优先级的任务: 3 */ 4static inline struct task_struct 5*pick_next_task(struct rq *rq, 6\tstruct task_struct *prev, 7\tstruct rq_flags *rf) 8{ 9\tconst struct sched_class *class;\t// 调度器类 10\tstruct task_struct *p;\t// 任务实体 11 12\tif (likely((prev-\u0026gt;sched_class == \u0026amp;idle_sched_class || 13\tprev-\u0026gt;sched_class == \u0026amp;fair_sched_class) \u0026amp;\u0026amp; 14\trq-\u0026gt;nr_running == rq-\u0026gt;cfs.h_nr_running)) { 15 16\tp = fair_sched_class.pick_next_task(rq, prev, rf); 17\tif (unlikely(p == RETRY_TASK)) 18\tgoto again; 19 20\t/* Assumes fair_sched_class-\u0026gt;next == idle_sched_class */ 21\tif (unlikely(!p)) 22\tp = idle_sched_class.pick_next_task(rq, prev, rf); 23 24\treturn p; 25\t} 26 27again: 28\tfor_each_class(class) { 29\tp = class-\u0026gt;pick_next_task(rq, prev, rf); 30\tif (p) { 31\tif (unlikely(p == RETRY_TASK)) 32\tgoto again; 33\treturn p; 34\t} 35\t} 36 37\t/* IDLE线程不会退出 */ 38\tBUG(); 39} 任务切换 1static __always_inline struct rq * 2context_switch(struct rq *rq, struct task_struct *prev, 3\tstruct task_struct *next, struct rq_flags *rf) 4{ 5\tstruct mm_struct *mm, *oldmm; 6 7\tprepare_task_switch(rq, prev, next); 8 9\tmm = next-\u0026gt;mm; 10\toldmm = prev-\u0026gt;active_mm; 11\t/* 12\t* For paravirt, this is coupled with an exit in switch_to to 13\t* combine the page table reload and the switch backend into 14\t* one hypercall. 15\t*/ 16\tarch_start_context_switch(prev); 17 18\t/* 19\t* If mm is non-NULL, we pass through switch_mm(). If mm is 20\t* NULL, we will pass through mmdrop() in finish_task_switch(). 21\t* Both of these contain the full memory barrier required by 22\t* membarrier after storing to rq-\u0026gt;curr, before returning to 23\t* user-space. 24\t*/ 25\tif (!mm) { 26\tnext-\u0026gt;active_mm = oldmm; 27\tmmgrab(oldmm); 28\tenter_lazy_tlb(oldmm, next); 29\t} else 30\tswitch_mm_irqs_off(oldmm, mm, next); 31 32\tif (!prev-\u0026gt;mm) { 33\tprev-\u0026gt;active_mm = NULL; 34\trq-\u0026gt;prev_mm = oldmm; 35\t} 36 37\trq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); 38 39\tprepare_lock_switch(rq, next, rf); 40 41\t/* Here we just switch the register state and the stack. */ 42\tswitch_to(prev, next, prev); 43\tbarrier(); 44 45\treturn finish_task_switch(prev); 46} ","date":"4040-10-04","img":"","largeImg":"","permalink":"/posts/sched/","series":null,"smallImg":"","tags":["kernel"],"title":"系统调度"},{"categories":[],"content":"","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/rime/","series":null,"smallImg":"","tags":[],"title":"Rime"},{"categories":[],"content":"WASM笔记 ","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/wasm/","series":null,"smallImg":"","tags":[],"title":"Wasm"},{"categories":[],"content":"jupyter 安装 1conda install jupyter 基本配置 生成配置 1jupyter notebook --generate-config 自动生成配置文件 ~/.jupyter/jupyter_notebook_config.py\n设置密码 1jupyter notebook password ","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/jupyter/","series":null,"smallImg":"","tags":[],"title":"Jupyter"},{"categories":[],"content":"","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/conda/","series":null,"smallImg":"","tags":[],"title":"Conda"},{"categories":[],"content":"RUST学习笔记\n====\n安装 添加环境变量.bashrc/profile 1set RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 2set RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 安装工具链 1curl https://mirrors.ustc.edu.cn/rust-static/rustup/rustup-init.sh | sh 设置rust的环境变量.bashrc/profile 1source ~/.cargo/env 2set PATH=~/.cargo/bin;$PATH 入门基础 HelloWorld 创建工程 1cargo new hello_world 编译 1cargo build 运行 1cargo run 数据类型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 1// 创建变量 2let _xi32: i32 = 5; 3let _xu32: u32 = 5; 4let _xi64: i64 = 10; 5let _xu64: u64 = 10; 6let _xi128: i128 = 5; 7let _xu128: u128 = 5; 8let _xisize: isize = 10; 9let _xusize: usize = 10; 函数 1// 有返回值 2fn function_return() -\u0026gt; i32 { 3 println!(\u0026#34;Hello, World!\u0026#34;); 4 return 0; 5} 6 7// 无返回值 8fn function_noreturn() { 9 println!(\u0026#34;Hello, World!\u0026#34;); 10} 必须明确表示是否存在返回值 语法校验比较严格, 条件语句 1if \u0026lt;cond\u0026gt; { 2 do; 3} 1if \u0026lt;cond\u0026gt; { 2\tDo1; 3} else { 4\tDo2; 5} 1if \u0026lt;cond1\u0026gt; { 2\tDo1; 3} else if \u0026lt;cond2\u0026gt; { 4\tDo2; 5} else { 6 Do3; 7} ","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/rust/","series":null,"smallImg":"","tags":[],"title":"Rust"},{"categories":[],"content":"C++基础语法 第一个程序 1#include \u0026lt;iostream\u0026gt; 2 3using namespace std; 4 5int main(int argc, char *argv[]) 6{ 7\tcout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; 8\treturn 0; 9} 注释类型 单行注释 1// 这个是一个单行注释 多行注释 1/* 2\t这个里面是一个注释 3 */ 变量 变量的存在意义:方便我们管理内存\n变量创建的语法\n1数据类型 变量名 = 变量初始化; 常量 作用: 记录程序中不可以改变的数据\ndefine 宏常量(预编译期) const 修饰变量(编译期) 关键字 关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 标识符命名规则 标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写 数据类型 指定类型,分配内存\n整形 浮点型 单精度float 双精度double 字符型 转义字符 字符串 C风格 1char 变量名[] = \u0026#34;字符串值\u0026#34;; C++风格 1string 变量名 = \u0026#34;字符串值\u0026#34;; 布尔类型 1bool A = true; 2bool B = false; 运算符 基本运算符 取模运算 就是取余数\n自增自减运算 1a1++; 2a2--; 赋值运算 运算符 术语 示例 结果 = += -= *= /= %= 比较运算符 逻辑运算符 程序流程结构 顺序结构 if语句 三目运算符 1表达式1? 表达式2:表达式3 选择结构 1switch(condition) 2{ 3case 条件1: 4\tbreak; 5case 条件2: 6\tbreak; 7default: 8\tbreak; 9} 循环结构 while循环 1while(条件) 2{ 3\t循环体; 4} dowhile循环 1do { 2 3} while(条件) for循环 1for (起始表达式; 条件表达式; 末尾循环体) 2{ 3\t循环体; 4} 跳转语句 break continue goto 数组 函数定义 返回值类型 函数名 参数列表 函数体语句 return表达式 1返回值类型 函数名字(参数列表) 2{ 3\t函数体语句; 4\treturn 表达式; 5} 值传递 类似数值拷贝\n函数的常见样式 无参无返 有参无返 无参有反 有参有返 函数的声明 作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现;\n函数的分文件编写 指针 指针的定义和使用 指针所占用空间 空指针 含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的\n野指针 指针指向非法的内存空间\nconst与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 1const int *p = \u0026amp;a; 2 3int const *p = \u0026amp;a; 4 5const int *const p = \u0026amp;a; 指针与数组 指针与函数 结构体 结构体数组 结构体指针 结构体嵌套 C++核心编程 本阶段主要对面向对象进行详细讲解\nC++内存分区 c++程序在运行时,将内存分为4个区域\n代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放 new/delete操作符 C++利用new操作符在堆区开辟内存\n引用 作用: 给变量起别名 语法: 数据类型 \u0026amp;别名 = 原名;\n引用做参数 1#include \u0026lt;iostream\u0026gt; 2void swap(int \u0026amp;a, int \u0026amp;b) 3{ 4 int t; t = a;a = b;b = t; 5} 6int main(int argc, char *argv[]) 7{ 8 int a = 10;int b = 12; 9 std::cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 10 swap(a, b); 11 std::cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 12 return 0; 13} 执行结果\n引用做返回值 引用的本质 引用的本质是C++内部实现的一个指针常量\n常量引用 1const int \u0026amp;ref = 10; 函数提高 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) 1void test_default_param(int a = 0, int b = 0, int c = 0) 2{ 3 std::cout \u0026lt;\u0026lt; a + b + c \u0026lt;\u0026lt; std::endl; 4} 函数的占位参数 占位参数还可以有默认值\n1void test(int a, int = 10) { 2 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; 3} 函数重载 作用:函数名相同,提高复用性\n重载的条件:\n相同作用域\n函数名相同\n参数不同(类型, 个数,顺序)\n注意事项:\n引用作为重载条件 函数重载碰到默认参数 类和对象 类的访问属性\npublic: protected: private: class与struct的区别 class默认权限是private struct默认权限是public\n构造函数和析构函数 对象的初始化和清理\n构造函数有参数 析构函数没有参数 二者都没有返回值 拷贝构造函数 1class Person { 2public: 3 /* 构造函数 */ 4 Person(std::string name, int age) { 5 std::cout \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 6 } 7 /* 析构函数 */ 8 ~Person() { 9 std::cout \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; std::endl; 10 } 11 /* 拷贝构造函数 */ 12 Person(const Person \u0026amp;p) { 13 std::cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 14 } 15}; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 1Person testPerson();\t// 表面上是执行构造函数 2int func();\t// 类似函数声明 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 构造函数的调用规则 默认情况下:C++编译器至少给一个类添加3个函数\n默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下:\n用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 初始化列表 作用:C++提供了初始化列表语法,用来初始化属性;\n语法:\n1构造函数(): 属性1(值1),属性2(值2),属性3(值3) 2{ 3\t/* 函数体 */ 4} 类对象作为类成员 静态成员 静态成员就是在静态成员变量和成员函数前加上static,称为静态成员;\n静态成员变量 所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 1class Person { 2public: 3 static int age; 4 static void func() 5 { 6 std::cout \u0026lt;\u0026lt; \u0026#34;静态成员函数\u0026#34; \u0026lt;\u0026lt; std::endl; 7 } 8}; 9/* 通过对象访问 */ 10Person p; 11p.func(); 12/* 通过类访问 */ 13Person::func(); 成员变量和成员函数分开存储 非静态成员,\t属于类的对象 静态成员,\t不属于类的对象 非静态成员函数,\t不属于类的对象 静态成员函数, 不属于类的对象 空对象大小为1\nC++对象模型 this指针 this指针指向被调用成员函数所属的对象 this指针本质：指针常量\n空指针访问成员函数 C++空指针也是可以访问成员函数的,但是要注意的this指针;\nconst修饰成员函数 常函数:\n常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数 执行原理\n1this ==\u0026gt; Person * const this; 2后面新追加的const则会造成 3const Person * const this; 1class Person { 2public: 3 int m_A; 4 mutable int m_B; 5 void showPerson() const 6 { 7 m_A = 10; /* 错误,不可修改 */ 8 m_B = 10; /* 正确,可以修改 */ 9 } 10}; 友元 全局函数 全局类 成员函数 运算符重载 重载的原理:对已有的运算符进行重新定义,赋予新的功能含义;\n通过成员函数重载运算符 1class Person { 2public: 3 int m_A; 4 int m_B; 5 6 /* 使用成员函数实现 */ 7 Person PersonAddPerson(Person \u0026amp;p) 8 { 9 Person t; 10 t.m_A = this-\u0026gt;m_A + p.m_A; 11 t.m_B = this-\u0026gt;m_B + p.m_B; 12 return t; 13 } 14 15 /* 重载+ */ 16 Person operator+(Person \u0026amp;p) 17 { 18 Person t; 19 t.m_A = this-\u0026gt;m_A + p.m_A; 20 t.m_B = this-\u0026gt;m_B + p.m_B; 21 return t; 22 } 23}; 24 25int main(int argc, char *argv[]) 26{ 27 Person p1; 28 Person p2; 29 30 Person p3 = p1.PersonAddPerson(p2); 31 32 Person p4 = p1.operator+(p2); 33 34 Person p5 = p1 + p2; 35 36 return 0; 37} 通过全局函数重载 1Person operator+(Person \u0026amp;p1, Person \u0026amp;p2) 2{ 3 Person t; 4 t.m_A = p1.m_A + p2.m_A; 5 t.m_B = p2.m_B + p2.m_B; 6 return t; 7} 重载左移运算符 1std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Person \u0026amp;p) 2{ 3 cout \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; p.m_B; 4 return cout; 5} 递增重载++ 注意:\n前置递增 p++ 后置递增 ++p 重载例子(复数) 1#include \u0026lt;iostream\u0026gt; 2 3class Complex { 4 friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p); 5 6public: 7 Complex(int i, int j); 8 9 Complex(); 10 11 /* 重载+ */ 12 Complex operator+(Complex \u0026amp;p) 13 { 14 Complex t; 15 t.i = this-\u0026gt;i + p.i; 16 t.j = this-\u0026gt;j + p.j; 17 return t; 18 } 19 /* 重载前置++ */ 20 Complex\u0026amp; operator++() 21 { 22 this-\u0026gt;i++; 23 this-\u0026gt;j++; 24 return *this; 25 } 26 27 /* 重载后置++ */ 28 Complex operator++(int) 29 { 30 Complex t; 31 32 /* 记录 */ 33 t.i = this-\u0026gt;i; 34 t.j = this-\u0026gt;j; 35 36 /* 递增 */ 37 this-\u0026gt;i++; 38 this-\u0026gt;j++; 39 40 return t; 41 } 42 43 /* 重载= */ 44 Complex\u0026amp; operator=(Complex \u0026amp;p) 45 { 46 this-\u0026gt;i = p.i; 47 this-\u0026gt;j = p.j; 48 49 return *this; 50 } 51private: 52 int i; /* 实部 */ 53 int j; /* 虚部 */ 54}; 55 56/* 构造函数 */ 57Complex::Complex(int i, int j) 58{ 59 this-\u0026gt;i = i; 60 this-\u0026gt;j = j; 61} 62 63Complex::Complex() 64{ 65 this-\u0026gt;i = 0; 66 this-\u0026gt;j = 0; 67} 68 69std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p) 70{ 71 cout \u0026lt;\u0026lt; p.i \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; p.j \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; 72 return cout; 73} 74 75int main(int argc, char *argv[]) 76{ 77 Complex p1(1, 2); 78 Complex p2(3, 4); 79 80 std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; std::endl; 81 std::cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl; 82 std::cout \u0026lt;\u0026lt; p1 + p2 \u0026lt;\u0026lt; std::endl; 83 84 std::cout \u0026lt;\u0026lt; ++p1 \u0026lt;\u0026lt; std::endl; 85 std::cout \u0026lt;\u0026lt; p2++ \u0026lt;\u0026lt; std::endl; 86 87 Complex p3 = p2 = p1; 88 std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p3 \u0026lt;\u0026lt; std::endl; 89 90 return 0; 91} 继承 减少重复代码\n1class 子类 : 继承方式 父类 父类:基类 子类:派生类\n继承方式 公共继承 保护继承 私有继承 继承中的对象模型 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类\n继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 多重继承 C++允许一个类继承多个基类\n1class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名\n菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。\n多重继承数据会产生二义性 数据只需要一份即可 1/* 动物类 */ 2class Animal { 3public: 4 int m_age; 5}; 6class Sheep : public Animal {}; /* 羊类 */ 7class Camel : public Animal {}; /* 驼类 */ 8class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ 9int main(int argc, char *argv[]) 10{ 11 Alpaca a; 12 a.Sheep::m_age = 18; 13 a.Camel::m_age = 18; 14 return 0; 15} 虚继承\n1class Sheep : virtual public Animal {}; /* 羊类 */ 2class Camel : virtual public Animal {}; /* 驼类 */ 虚基类指针(vbptr) vbptr \u0026ndash;\u0026gt; vbtable\n多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数;\n有继承关系\n子类重写父类的虚函数 重写：函数完全一致\n纯虚函数 只要有一个纯虚函数，就称为抽象类\n抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 原理 虚析构和纯虚析构 C++提高编程 泛型编程/STL\n模版 建立通用的模板,提高复用；\nC++提供两种模版机制:函数模版和类模板\n函数模版 1template \u0026lt;typename T\u0026gt; 2函数声明和定义 template \u0026ndash; 声明创建模版 typename \u0026ndash; 表明后面的符号是数据类型可以用class代替 T \u0026ndash; 通用的数据类型 实例 1/* 两个数据交换 */ 2template \u0026lt;typename T\u0026gt; 3void swap(T \u0026amp;a, T \u0026amp;b) 4{ 5 T t= a; a = b; b = t; 6} 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数\n1template \u0026lt;typename T\u0026gt; 2T add(T a, T b) 3{ 4 return a + b; 5} 调用方法\n1/* 自动推导 */ 2std::cout \u0026lt;\u0026lt; add(10, 20) \u0026lt;\u0026lt; std::endl; 3/* 显示指定 */ 4std::cout \u0026lt;\u0026lt; add\u0026lt;int\u0026gt;(10, 3.14) \u0026lt;\u0026lt; std::endl; 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u0026lt;\u0026gt;(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 类模板 1template \u0026lt;class T\u0026gt; 2类 例子\n1template \u0026lt;class NameType, class AgeType\u0026gt; 2class Person { 3public: 4 Person(NameType Name, AgeType Age) 5 { 6 m_Name = Name; 7 m_Age = Age; 8 } 9 NameType m_Name; 10 AgeType m_Age; 11}; 调用\n1Person\u0026lt;std::string, int\u0026gt; p(\u0026#34;Hello\u0026#34;, 99); ","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/c++/","series":null,"smallImg":"","tags":[],"title":"C++笔记"},{"categories":[],"content":"doxygen教程 开始doxygen ","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/doxygen/","series":null,"smallImg":"","tags":[],"title":"Doxygen"},{"categories":[],"content":"","date":"3030-10-03","img":"","largeImg":"","permalink":"/posts/engineering_compiler/","series":null,"smallImg":"","tags":["compiler"],"title":"Engineering_compiler"},{"categories":null,"content":"LuaJIT Lua语法 基本语法 1\tprint(\u0026#34;Hello World\u0026#34;) 表(table) LuaJIT分析 LuaJIT主函数 1int main(int argc, char **argv) 2{ 3\tint status; /* 返回值 */ 4\tlua_State *L = lua_open(); /* 创建LUA状态机 */ 5\tif (L == NULL) { 6\tl_message(argv[0], \u0026#34;cannot create state: not enough memory\u0026#34;); 7\treturn EXIT_FAILURE; 8\t} 9\t10\t/* smain只存在三个参数,主要作用是向pmain传递数据 */ 11\tsmain.argc = argc; 12\tsmain.argv = argv; 13\t14\tstatus = lua_cpcall(L, pmain, NULL);\t/* 启动函数调用 */ 15\t16\treport(L, status); /* 提取报错参数 */ 17\t18\tlua_close(L);\t/* 销毁状态机 */ 19\t20\treturn (status || smain.status \u0026gt; 0) ? EXIT_FAILURE : EXIT_SUCCESS; 21} Lua状态机 1struct lua_State { 2\tGCObject*next; 3 4 lu_byte tt; 5 lu_byte marked; 6\tlu_byte status; 7\t8 StkId top; 9\tStkId base; 10\t11 global_State *l_G;\t/* 全局状态信息 */ 12\t13 CallInfo*ci; 14\t15 const Instruction*savedpc; 16\tStkId stack_last; 17\tStkId stack; 18\t19 CallInfo*end_ci; 20\tCallInfo*base_ci; 21\t22 int stacksize; 23\tint size_ci; 24\tunsigned short nCcalls; 25\tunsigned short baseCcalls; 26\t27 lu_byte hookmask; 28\tlu_byte allowhook; 29\t30 int basehookcount; 31\tint hookcount; 32\t33 lua_Hook hook; 34\t35 TValue l_gt; 36\tTValue env; 37\t38 GCObject*openupval; 39\tGCObject*gclist; 40\t41 struct lua_longjmp*errorJmp; 42\t43 ptrdiff_t errfunc; 44}; 创建状态 1/* 此函数实际不存在,程序内部使用的是宏定义 */ 2void lua_open(void); 3 4/* 实际调用位置 */ 5LUALIB_API lua_State *luaL_newstate(void); 6 7/* 根据编译期64位信息选择调用 */ 8#if LJ_64 \u0026amp;\u0026amp; !LJ_GC64 \u0026amp;\u0026amp; !(defined(LUAJIT_USE_VALGRIND) \u0026amp;\u0026amp; defined(LUAJIT_USE_SYSMALLOC)) 9lua_State *lj_state_newstate(lua_Alloc allocf, void *allocd); 10#else 11LUA_API lua_State *lua_newstate(lua_Alloc allocf, void *allocd); 12#endif 函数调用 1LUA_API int lua_cpcall(lua_State *L, lua_CFunction func, void *ud); 2LUA_API int lua_pcall(lua_State *L, int nargs, int nresults, int errfunc); 3LUA_API void lua_call(lua_State *L, int nargs, int nresults); lua_cpcall函数调用\n执行原理 FFI分析 ","date":"4040-09-04","img":"","largeImg":"","permalink":"/posts/luajit/","series":null,"smallImg":"","tags":null,"title":"LuaJIT"},{"categories":null,"content":"页面分配器 核心函数: __alloc_pages_nodemask\ngfp_mask : 分配掩码 order : 分配阶数 preferred_nid nodemask 核心函数 1struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) 2{ 3\tstruct page *page;\t// 分配变量 4\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\t// 分配标志 5\tgfp_t alloc_mask; // 真实分配掩码 6\tstruct alloc_context ac = { };\t// 保存相关参数 7 8\t/* 9\t* There are several places where we assume that the order value is sane 10\t* so bail out early if the request is out of bound. 11\t* 限制分配的大小 12\t*/ 13\tif (unlikely(order \u0026gt;= MAX_ORDER)) { 14\tWARN_ON_ONCE(!(gfp_mask \u0026amp; __GFP_NOWARN)); 15\treturn NULL; 16\t} 17 18\tgfp_mask \u0026amp;= gfp_allowed_mask; 19\talloc_mask = gfp_mask; 20\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026amp;ac, \u0026amp;alloc_mask, \u0026amp;alloc_flags)) 21\treturn NULL; 22 23\tfinalise_ac(gfp_mask, \u0026amp;ac); 24 25\t/* First allocation attempt */ 26\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026amp;ac); 27\tif (likely(page)) 28\tgoto out; 29 30\t/* 31\t* Apply scoped allocation constraints. This is mainly about GFP_NOFS 32\t* resp. GFP_NOIO which has to be inherited for all allocation requests 33\t* from a particular context which has been marked by 34\t* memalloc_no{fs,io}_{save,restore}. 35\t*/ 36\talloc_mask = current_gfp_context(gfp_mask); 37\tac.spread_dirty_pages = false; 38 39\t/* 40\t* Restore the original nodemask if it was potentially replaced with 41\t* \u0026amp;cpuset_current_mems_allowed to optimize the fast-path attempt. 42\t*/ 43\tif (unlikely(ac.nodemask != nodemask)) 44\tac.nodemask = nodemask; 45 46\tpage = __alloc_pages_slowpath(alloc_mask, order, \u0026amp;ac); 47 48out: 49\tif (memcg_kmem_enabled() \u0026amp;\u0026amp; (gfp_mask \u0026amp; __GFP_ACCOUNT) \u0026amp;\u0026amp; page \u0026amp;\u0026amp; 50\tunlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) { 51\t__free_pages(page, order); 52\tpage = NULL; 53\t} 54 55\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); 56 57\treturn page; 58} prepare_alloc_pages 1static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, 2\tint preferred_nid, nodemask_t *nodemask, 3\tstruct alloc_context *ac, gfp_t *alloc_mask, 4\tunsigned int *alloc_flags) 5{ 6\tac-\u0026gt;high_zoneidx = gfp_zone(gfp_mask); 7\tac-\u0026gt;zonelist = node_zonelist(preferred_nid, gfp_mask); 8\tac-\u0026gt;nodemask = nodemask; 9\tac-\u0026gt;migratetype = gfpflags_to_migratetype(gfp_mask); 10 11\tif (cpusets_enabled()) { 12\t*alloc_mask |= __GFP_HARDWALL; 13\tif (!ac-\u0026gt;nodemask) 14\tac-\u0026gt;nodemask = \u0026amp;cpuset_current_mems_allowed; 15\telse 16\t*alloc_flags |= ALLOC_CPUSET; 17\t} 18 19\tfs_reclaim_acquire(gfp_mask); 20\tfs_reclaim_release(gfp_mask); 21 22\tmight_sleep_if(gfp_mask \u0026amp; __GFP_DIRECT_RECLAIM); 23 24\tif (should_fail_alloc_page(gfp_mask, order)) 25\treturn false; 26 27\tif (IS_ENABLED(CONFIG_CMA) \u0026amp;\u0026amp; ac-\u0026gt;migratetype == MIGRATE_MOVABLE) 28\t*alloc_flags |= ALLOC_CMA; 29 30\treturn true; 31} get_page_from_freelist 1static struct page * 2get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, 3\tconst struct alloc_context *ac) 4{ 5\tstruct zoneref *z = ac-\u0026gt;preferred_zoneref; 6\tstruct zone *zone; 7\tstruct pglist_data *last_pgdat_dirty_limit = NULL; 8 9\t/* 10\t* Scan zonelist, looking for a zone with enough free. 11\t* See also __cpuset_node_allowed() comment in kernel/cpuset.c. 12\t*/ 13\tfor_next_zone_zonelist_nodemask(zone, z, ac-\u0026gt;zonelist, ac-\u0026gt;high_zoneidx, 14\tac-\u0026gt;nodemask) { 15\tstruct page *page; 16\tunsigned long mark; 17 18\tif (cpusets_enabled() \u0026amp;\u0026amp; 19\t(alloc_flags \u0026amp; ALLOC_CPUSET) \u0026amp;\u0026amp; 20\t!__cpuset_zone_allowed(zone, gfp_mask)) 21\tcontinue; 22\t/* 23\t* When allocating a page cache page for writing, we 24\t* want to get it from a node that is within its dirty 25\t* limit, such that no single node holds more than its 26\t* proportional share of globally allowed dirty pages. 27\t* The dirty limits take into account the node\u0026#39;s 28\t* lowmem reserves and high watermark so that kswapd 29\t* should be able to balance it without having to 30\t* write pages from its LRU list. 31\t* 32\t* XXX: For now, allow allocations to potentially 33\t* exceed the per-node dirty limit in the slowpath 34\t* (spread_dirty_pages unset) before going into reclaim, 35\t* which is important when on a NUMA setup the allowed 36\t* nodes are together not big enough to reach the 37\t* global limit. The proper fix for these situations 38\t* will require awareness of nodes in the 39\t* dirty-throttling and the flusher threads. 40\t*/ 41\tif (ac-\u0026gt;spread_dirty_pages) { 42\tif (last_pgdat_dirty_limit == zone-\u0026gt;zone_pgdat) 43\tcontinue; 44 45\tif (!node_dirty_ok(zone-\u0026gt;zone_pgdat)) { 46\tlast_pgdat_dirty_limit = zone-\u0026gt;zone_pgdat; 47\tcontinue; 48\t} 49\t} 50 51\tmark = zone-\u0026gt;watermark[alloc_flags \u0026amp; ALLOC_WMARK_MASK]; 52\tif (!zone_watermark_fast(zone, order, mark, 53\tac_classzone_idx(ac), alloc_flags)) { 54\tint ret; 55 56#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 57\t/* 58\t* Watermark failed for this zone, but see if we can 59\t* grow this zone if it contains deferred pages. 60\t*/ 61\tif (static_branch_unlikely(\u0026amp;deferred_pages)) { 62\tif (_deferred_grow_zone(zone, order)) 63\tgoto try_this_zone; 64\t} 65#endif 66\t/* Checked here to keep the fast path fast */ 67\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS \u0026lt; NR_WMARK); 68\tif (alloc_flags \u0026amp; ALLOC_NO_WATERMARKS) 69\tgoto try_this_zone; 70 71\tif (node_reclaim_mode == 0 || 72\t!zone_allows_reclaim(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone)) 73\tcontinue; 74 75\tret = node_reclaim(zone-\u0026gt;zone_pgdat, gfp_mask, order); 76\tswitch (ret) { 77\tcase NODE_RECLAIM_NOSCAN: 78\t/* did not scan */ 79\tcontinue; 80\tcase NODE_RECLAIM_FULL: 81\t/* scanned but unreclaimable */ 82\tcontinue; 83\tdefault: 84\t/* did we reclaim enough */ 85\tif (zone_watermark_ok(zone, order, mark, 86\tac_classzone_idx(ac), alloc_flags)) 87\tgoto try_this_zone; 88 89\tcontinue; 90\t} 91\t} 92 93try_this_zone: 94\tpage = rmqueue(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone, order, 95\tgfp_mask, alloc_flags, ac-\u0026gt;migratetype); 96\tif (page) { 97\tprep_new_page(page, order, gfp_mask, alloc_flags); 98 99\t/* 100\t* If this is a high-order atomic allocation then check 101\t* if the pageblock should be reserved for the future 102\t*/ 103\tif (unlikely(order \u0026amp;\u0026amp; (alloc_flags \u0026amp; ALLOC_HARDER))) 104\treserve_highatomic_pageblock(page, zone, order); 105 106\treturn page; 107\t} else { 108#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 109\t/* Try again if zone has deferred pages */ 110\tif (static_branch_unlikely(\u0026amp;deferred_pages)) { 111\tif (_deferred_grow_zone(zone, order)) 112\tgoto try_this_zone; 113\t} 114#endif 115\t} 116\t} 117 118\treturn NULL; 119} ","date":"9090-05-09","img":"","largeImg":"","permalink":"/posts/page_allocator/","series":null,"smallImg":"","tags":null,"title":"Page_allocator"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制\n使用 等待队列头 1struct __wait_queue_head { 2\twq_lock_t lock; 3\tstruct list_head task_list; 4}; 5typedef struct __wait_queue_head wait_queue_head_t; 等待队列实体 1struct __wait_queue { 2\tunsigned int flags; 3\tstruct task_struct * task; 4\tstruct list_head task_list; 5}; 6typedef struct __wait_queue wait_queue_t; 初始化等待队列头 1void __init_waitqueue_head(struct wait_queue_head *wq_head, 2\tconst char *name, struct lock_class_key *); 3void init_waitqueue_head(struct wait_queue_head *wq_head); 初始化等待队列 1#define __WAITQUEUE_INITIALIZER(name, tsk) \\ 2{\t\\ 3\t.private\t= tsk,\t\\ 4\t.func\t= default_wake_function,\t\\ 5\t.entry\t= { NULL, NULL }\t\\ 6} 7 8#define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) 9 10// 但是，一般直接 11DECLARE_WAITQUEUE(wait, current); 等待队列入口 等待的任务 等待队列操作 1void add_wait_queue(struct wait_queue_head *wq_head, 2\tstruct wait_queue_entry *wq_entry); 3void remove_wait_queue(struct wait_queue_head *wq_head, 4\tstruct wait_queue_entry *wq_entry); 等待队列头 等待队列实体 等待事件 1void wait_event(wq, condition); 2void wait_event_interruptible(wq, condition); 唤醒队列 wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync 例子 写端 1ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) 2{ 3\tDECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4\tint ret = -1; 5\tPTRACE; 6 7\tmutex_lock(\u0026amp;wait_device.mutex); 8\t/* 非阻塞模式直接写入 */ 9\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10\tpr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11\tgoto pure_write; 12\t} 13 14\tadd_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 15\twhile (wait_device.wait_flag == true) { 16\tpr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17\t__set_current_state(TASK_INTERRUPTIBLE); 18\tmutex_unlock(\u0026amp;wait_device.mutex); 19\tschedule(); 20\tif (signal_pending(current)) { 21\tret = -ERESTARTSYS; 22\tremove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 23\t__set_current_state(TASK_RUNNING); 24\tgoto out; 25\t} 26\t} 27\tremove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 28 29pure_write: 30\twait_device.wait_flag = true; 31\tpr_err(\u0026#34;Write Successful\u0026#34;); 32 33\twake_up_interruptible(\u0026amp;wait_device.wait_r); 34\tpr_err(\u0026#34;Wakeup Read\u0026#34;); 35\tgoto out; 36 37out: 38\tmutex_unlock(\u0026amp;wait_device.mutex); 39\treturn ret; 40} 读端 1 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) 2{ 3\tDECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4\tint ret = 0; 5\tPTRACE; 6 7\tmutex_lock(\u0026amp;wait_device.mutex); 8\t/* 非阻塞模式直接写入 */ 9\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10\tpr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11\tgoto pure_read; 12\t} 13 14\tadd_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 15\twhile (wait_device.wait_flag == false) { 16\tpr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17\t__set_current_state(TASK_INTERRUPTIBLE); 18\tmutex_unlock(\u0026amp;wait_device.mutex); 19\tschedule(); 20\tif (signal_pending(current)) { 21\tret = -ERESTARTSYS; 22\tremove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 23\t__set_current_state(TASK_RUNNING); 24\tgoto out; 25\t} 26\t} 27\tremove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 28 29pure_read: 30\twait_device.wait_flag = false; 31\tpr_err(\u0026#34;Read Successful\u0026#34;); 32 33\twake_up_interruptible(\u0026amp;wait_device.wait_w); 34\tpr_err(\u0026#34;Wakeup Write\u0026#34;); 35 36\tgoto out; 37 38out: 39\tmutex_unlock(\u0026amp;wait_device.mutex); 40\treturn 0; 41} 原理 ","date":"4040-05-04","img":"","largeImg":"","permalink":"/posts/wait_queue/","series":null,"smallImg":"","tags":null,"title":"Linux等待队列实现"},{"categories":null,"content":"简介 ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件.\n类似于flex/bison,根据描述文件，自动生成词法语法分析器\n安装说明 下载antlr 设置path和classpath 编写相关脚本 语法设计 错误处理 解析器 测试程序 antlr4编译器 1#!/bin/sh 2antlr4 Expr.g4 编译生成的java文件 1javac *.java 运行编译的结果 1grun Expr prog -tree 1(prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) 1grun Expr prog -gui\t1grun Expr prog -tokens 1[@0,0:0=\u0026#39;1\u0026#39;,\u0026lt;INT\u0026gt;,1:0] 2[@1,1:1=\u0026#39;+\u0026#39;,\u0026lt;\u0026#39;+\u0026#39;\u0026gt;,1:1] 3[@2,2:2=\u0026#39;2\u0026#39;,\u0026lt;INT\u0026gt;,1:2] 4[@3,3:3=\u0026#39;+\u0026#39;,\u0026lt;\u0026#39;+\u0026#39;\u0026gt;,1:3] 5[@4,4:4=\u0026#39;3\u0026#39;,\u0026lt;INT\u0026gt;,1:4] 6[@5,5:6=\u0026#39;\\r\\n\u0026#39;,\u0026lt;NEWLINE\u0026gt;,1:5] 7[@6,7:6=\u0026#39;\u0026lt;EOF\u0026gt;\u0026#39;,\u0026lt;EOF\u0026gt;,2:0] antlr语法详解 Hello 1// antlr4 Hello.g4 2// javac *.java 3// grun Hello r -gui 4grammar Hello; // 定义一个Hello的grammer 5r : \u0026#39;hello\u0026#39; ID ; // 开头是hello后面接着一个ID 6ID : [a-z]+ ; // ID由小写字母组成 7WS : [ \\t\\r\\n]+ -\u0026gt; skip ; // 控制符清除 ArrayInit 1// antlr4 ArrayInit.g4 2// javac *.java 3// grun ArrayInit init -gui 4grammar ArrayInit;\t// 定义一个ArrayInit的grammer 5init : \u0026#39;{\u0026#39; value (\u0026#39;,\u0026#39; value)* \u0026#39;}\u0026#39; ; // 6value : init\t// 嵌套定义 7 | INT\t// 定义整数 8 ; 9INT : [0-9]+ ; 10WS : [ \\t\\r\\n]+ -\u0026gt; skip ; ()* \u0026ndash;\u0026gt; 相当于扩展\nExpr 1// antlr4 Expr.g4 2// javac *.java 3// grun Expr prog -gui 4grammar Expr; 5 6prog : stat+; 7 8stat: expr NEWLINE # printExpr 9 | ID \u0026#39;=\u0026#39; expr NEWLINE # assign 10 | NEWLINE # blank 11 ; 12 13expr: expr op=(\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39;) expr # MulDiv 14 | expr op=(\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;) expr # AddSub 15 | INT # int 16 | ID # id 17 | \u0026#39;(\u0026#39;expr\u0026#39;)\u0026#39; # parens 18 ; 19 20MUL : \u0026#39;*\u0026#39; ; // assigns token name to \u0026#39;*\u0026#39; used above in grammar 21DIV : \u0026#39;/\u0026#39; ; 22ADD : \u0026#39;+\u0026#39; ; 23SUB : \u0026#39;-\u0026#39; ; 24ID : [a-zA-Z]+ ; 25INT : [0-9]+ ; 26NEWLINE :\u0026#39;\\r\u0026#39;? \u0026#39;\\n\u0026#39; ; 27WS : [ \\t]+ -\u0026gt; skip; json 在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础\n1grammar JSON;\t// 声明一个grammar 2 3json 4 : value\t// 一个value候选 5 ; 6 7obj\t// 对象类型 8 : \u0026#39;{\u0026#39; pair (\u0026#39;,\u0026#39; pair)* \u0026#39;}\u0026#39; 9 | \u0026#39;{\u0026#39; \u0026#39;}\u0026#39; 10 ; 11 12pair 13 : STRING \u0026#39;:\u0026#39; value 14 ; 15 16arr 17 : \u0026#39;[\u0026#39; value (\u0026#39;,\u0026#39; value)* \u0026#39;]\u0026#39; 18 | \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; 19 ; 20 21value 22 : STRING 23 | NUMBER 24 | obj 25 | arr 26 | \u0026#39;true\u0026#39; 27 | \u0026#39;false\u0026#39; 28 | \u0026#39;null\u0026#39; 29 ; 30 31 32STRING 33 : \u0026#39;\u0026#34;\u0026#39; (ESC | SAFECODEPOINT)* \u0026#39;\u0026#34;\u0026#39; 34 ; 35 36 37fragment ESC 38 : \u0026#39;\\\\\u0026#39; ([\u0026#34;\\\\/bfnrt] | UNICODE) 39 ; 40 41 42fragment UNICODE 43 : \u0026#39;u\u0026#39; HEX HEX HEX HEX 44 ; 45 46 47fragment HEX 48 : [0-9a-fA-F] 49 ; 50 51 52fragment SAFECODEPOINT 53 : ~ [\u0026#34;\\\\\\u0000-\\u001F] 54 ; 55 56 57NUMBER 58 : \u0026#39;-\u0026#39;? INT (\u0026#39;.\u0026#39; [0-9] +)? EXP? 59 ; 60 61 62fragment INT 63 : \u0026#39;0\u0026#39; | [1-9] [0-9]* 64 ; 65 66// no leading zeros 67 68fragment EXP 69 : [Ee] [+\\-]? INT 70 ; 71 72// \\- since - means \u0026#34;range\u0026#34; inside [...] 73 74WS 75 : [ \\t\\n\\r] + -\u0026gt; skip 76 ; 测试例子\n1{ 2 \u0026#34;glossary\u0026#34;: { 3 \u0026#34;title\u0026#34;: \u0026#34;example glossary\u0026#34;, 4\t\u0026#34;GlossDiv\u0026#34;: { 5 \u0026#34;title\u0026#34;: \u0026#34;S\u0026#34;, 6\t\u0026#34;GlossList\u0026#34;: { 7 \u0026#34;GlossEntry\u0026#34;: { 8 \u0026#34;ID\u0026#34;: \u0026#34;SGML\u0026#34;, 9\t\u0026#34;SortAs\u0026#34;: \u0026#34;SGML\u0026#34;, 10\t\u0026#34;GlossTerm\u0026#34;: \u0026#34;Standard Generalized Markup Language\u0026#34;, 11\t\u0026#34;Acronym\u0026#34;: \u0026#34;SGML\u0026#34;, 12\t\u0026#34;Abbrev\u0026#34;: \u0026#34;ISO 8879:1986\u0026#34;, 13\t\u0026#34;GlossDef\u0026#34;: { 14 \u0026#34;para\u0026#34;: \u0026#34;A meta-markup language\u0026#34;, 15\t\u0026#34;GlossSeeAlso\u0026#34;: [\u0026#34;GML\u0026#34;, \u0026#34;XML\u0026#34;] 16 }, 17\t\u0026#34;GlossSee\u0026#34;: \u0026#34;markup\u0026#34; 18 } 19 } 20 } 21 } 22} 显示结果：\nXML 孤岛语法:\ndot 1grammar DOT; 2 3graph 4 : STRICT? ( GRAPH | DIGRAPH ) id_? \u0026#39;{\u0026#39; stmt_list \u0026#39;}\u0026#39; 5 ; 6 7stmt_list 8 : ( stmt \u0026#39;;\u0026#39;? )* 9 ; 10 11stmt 12 : node_stmt | edge_stmt | attr_stmt | id_ \u0026#39;=\u0026#39; id_ | subgraph 13 ; 14 15attr_stmt 16 : ( GRAPH | NODE | EDGE ) attr_list 17 ; 18 19attr_list 20 : ( \u0026#39;[\u0026#39; a_list? \u0026#39;]\u0026#39; )+ 21 ; 22 23a_list 24 : ( id_ ( \u0026#39;=\u0026#39; id_ )? \u0026#39;,\u0026#39;? )+ 25 ; 26 27edge_stmt 28 : ( node_id | subgraph ) edgeRHS attr_list? 29 ; 30 31edgeRHS 32 : ( edgeop ( node_id | subgraph ) )+ 33 ; 34 35edgeop 36 : \u0026#39;-\u0026gt;\u0026#39; | \u0026#39;--\u0026#39; 37 ; 38 39node_stmt 40 : node_id attr_list? 41 ; 42 43node_id 44 : id_ port? 45 ; 46 47port 48 : \u0026#39;:\u0026#39; id_ ( \u0026#39;:\u0026#39; id_ )? 49 ; 50 51subgraph 52 : ( SUBGRAPH id_? )? \u0026#39;{\u0026#39; stmt_list \u0026#39;}\u0026#39; 53 ; 54 55id_ 56 : ID | STRING | HTML_STRING | NUMBER 57 ; 58 59// \u0026#34;The keywords node, edge, graph, digraph, subgraph, and strict are 60// case-independent\u0026#34; 61 62STRICT 63 : [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] 64 ; 65 66 67GRAPH 68 : [Gg] [Rr] [Aa] [Pp] [Hh] 69 ; 70 71 72DIGRAPH 73 : [Dd] [Ii] [Gg] [Rr] [Aa] [Pp] [Hh] 74 ; 75 76 77NODE 78 : [Nn] [Oo] [Dd] [Ee] 79 ; 80 81 82EDGE 83 : [Ee] [Dd] [Gg] [Ee] 84 ; 85 86 87SUBGRAPH 88 : [Ss] [Uu] [Bb] [Gg] [Rr] [Aa] [Pp] [Hh] 89 ; 90 91 92/** \u0026#34;a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\u0026#34; */ NUMBER 93 : \u0026#39;-\u0026#39;? ( \u0026#39;.\u0026#39; DIGIT+ | DIGIT+ ( \u0026#39;.\u0026#39; DIGIT* )? ) 94 ; 95 96 97fragment DIGIT 98 : [0-9] 99 ; 100 101 102/** \u0026#34;any double-quoted string (\u0026#34;...\u0026#34;) possibly containing escaped quotes\u0026#34; */ STRING 103 : \u0026#39;\u0026#34;\u0026#39; ( \u0026#39;\\\\\u0026#34;\u0026#39; | . )*? \u0026#39;\u0026#34;\u0026#39; 104 ; 105 106 107/** \u0026#34;Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores 108 * (\u0026#39;_\u0026#39;) or digits ([0-9]), not beginning with a digit\u0026#34; 109 */ ID 110 : LETTER ( LETTER | DIGIT )* 111 ; 112 113 114fragment LETTER 115 : [a-zA-Z\\u0080-\\u00FF_] 116 ; 117 118 119/** \u0026#34;HTML strings, angle brackets must occur in matched pairs, and 120 * unescaped newlines are allowed.\u0026#34; 121 */ HTML_STRING 122 : \u0026#39;\u0026lt;\u0026#39; ( TAG | ~ [\u0026lt;\u0026gt;] )* \u0026#39;\u0026gt;\u0026#39; 123 ; 124 125 126fragment TAG 127 : \u0026#39;\u0026lt;\u0026#39; .*? \u0026#39;\u0026gt;\u0026#39; 128 ; 129 130 131COMMENT 132 : \u0026#39;/*\u0026#39; .*? \u0026#39;*/\u0026#39; -\u0026gt; skip 133 ; 134 135 136LINE_COMMENT 137 : \u0026#39;//\u0026#39; .*? \u0026#39;\\r\u0026#39;? \u0026#39;\\n\u0026#39; -\u0026gt; skip 138 ; 139 140 141/** \u0026#34;a \u0026#39;#\u0026#39; character is considered a line output from a C preprocessor (e.g., 142 * # 34 to indicate line 34 ) and discarded\u0026#34; 143 */ PREPROC 144 : \u0026#39;#\u0026#39; ~[\\r\\n]* -\u0026gt; skip 145 ; 146 147 148WS 149 : [ \\t\\n\\r]+ -\u0026gt; skip 150 ; ","date":"4040-05-04","img":"","largeImg":"","permalink":"/posts/antlr/","series":null,"smallImg":"","tags":["编译原理"],"title":"Antlr教程"},{"categories":null,"content":"基本操作 安装hugo 在linux/windows上只能通过直接release 下载,\n创建网站 1hugo new site 路径 添加主题 将主题直接添加到theme文件下面 将主题作为一个submodule 创建文档 1hugo new posts/hugo.md 设置预览 1 hugo server -D --disableFastRender 文件结构 1. 2├── archetypes 3├── config 4├── content 5├── data 6├── layouts 7├── static 8├── themes 9├── static 10└── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。\narchetypes hugo模板,在创建文件时作为模板自动生成\nassets 存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录\nconfig Hugo配置目录\ncontent 此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分.\ndata 该目录用于存储 Hugo 在生成网站时可以使用的配置文件\nlayouts 以 .html文件的形式存储模板.\nstatic 存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制\n编写工具 typora 使用typora作为markdown编写工具\npicgo ","date":"4040-05-04","img":"","largeImg":"","permalink":"/posts/hugo/","series":null,"smallImg":"","tags":["技巧"],"title":"Hugo教程"},{"categories":null,"content":"nfs服务 安装 1sudo apt-get install nfs-kernel-server 设置导出 1/home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 开启服务 1sudo /etc/init.d/nfs-kernel-server restart 测试 1sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt 2ls /mnt ","date":"3030-05-03","img":"","largeImg":"","permalink":"/posts/nfs/","series":null,"smallImg":"","tags":["nfs"],"title":"Nfs"}]
[{"categories":["编程语言"],"content":"C++高级编程","date":"2022-06-18","objectID":"/cxx_template/","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/"},{"categories":["编程语言"],"content":" 1 相关知识gcc中typeof关键字用来检查变量类型,那么则可以用来判断魔板生成中的数据类型, 但是在C++中存在这另外的运算符typeid,但是我个人认为typeof更加优秀，但是二者并不相同, typeid返回类型对象,typeof只可以判断类型; 代码如下: #define __toStr(x) #x #define toStr(x) __toStr(x) #define check_type_item(_x, type) \\ if (typeid(_x) == typeid(type)) { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is \" \u003c\u003c toStr(type) \u003c\u003c std::endl; \\ } else #define check_type_tail(_x) \\ { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is unknow\" \u003c\u003c std::endl; \\ } #define check_type(_x) \\ ({ \\ check_type_item(_x, char) \\ check_type_item(_x, short) \\ check_type_item(_x, int) \\ check_type_item(_x, long) \\ check_type_item(_x, unsigned char) \\ check_type_item(_x, unsigned short) \\ check_type_item(_x, unsigned int) \\ check_type_item(_x, unsigned long) \\ check_type_item(_x, float) \\ check_type_item(_x, double) \\ check_type_tail(_x) \\ }) 另外从内核中学到的一种用来编译期间校验的宏函数,用来确定推导过程是否正确 #define BUILD_BUG_ON(cond) ((void)sizeof(int[1-2*(!!(cond))])) 那么就可以通过此工具来分析模板推导过程是否是正确的 ","date":"2022-06-18","objectID":"/cxx_template/:1:0","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#相关知识"},{"categories":["编程语言"],"content":" 2 模板基础 模板和宏定义区别:模板在编译期进行,宏在预编译期间进行 建立通用的模板,提高复用率 C++提供两种模版机制:函数模版和类模板 ","date":"2022-06-18","objectID":"/cxx_template/:2:0","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板基础"},{"categories":["编程语言"],"content":" 2.1 函数模版 template \u003ctypename T\u003e 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template \u003ctypename T\u003e void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template \u003ctypename T\u003e T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add\u003cint\u003e(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template\u003ctypename T\u003e T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max\u003cdouble\u003e(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template\u003ctypename T1, typename T2, typename RT = std::decay_t\u003cdecltype(true ? T1() : T2())\u003e \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template\u003ctypename T1, typename T2\u003e auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template\u003ctypename T1, typename T2\u003e std::common_type_t\u003cT1,T2\u003e max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template\u003ctypename T = std::string\u003e T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模版"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#实例"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#注意事项"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#普通函数和函数模版的区别"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#普通函数和模版函数调用规则"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段编译检查two-phase-translation"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类型推断中的类型转换"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#多模板参数调用"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#显式指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#返回值指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#自动推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#公共类型推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#默认模板参数"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板重载"},{"categories":["编程语言"],"content":" 2.2 类模板 template \u003cclass T\u003e 类 例子 template \u003cclass NameType, class AgeType\u003e class Person { public: Person(NameType Name, AgeType Age) { m_Name = Name; m_Age = Age; } NameType m_Name; AgeType m_Age; }; 实例化 Person\u003cstd::string, int\u003e p(\"Hello\", 99); ","date":"2022-06-18","objectID":"/cxx_template/:2:2","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类模板"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template\u003cint Val, typename T\u003e T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template\u003cdouble VAT\u003e // ERROR: floating-point values are not void process (double v){} template\u003cstd::string name\u003e // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template\u003ctypename T, auto Maxsize\u003e class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板非类型参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数的限制"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板-1"},{"categories":["编程语言"],"content":" 3 模板提高","date":"2022-06-18","objectID":"/cxx_template/:3:0","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板提高"},{"categories":["编程语言"],"content":" 3.1 移动语义和enable_if\u003c\u003e","date":"2022-06-18","objectID":"/cxx_template/:3:1","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#移动语义和enable_if"},{"categories":["编程语言"],"content":" 3.2 模板参数传递","date":"2022-06-18","objectID":"/cxx_template/:3:2","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板参数传递"},{"categories":["编程语言"],"content":" 3.3 编译期编程","date":"2022-06-18","objectID":"/cxx_template/:3:3","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#编译期编程"},{"categories":["编程语言"],"content":" 4 模板进阶","date":"2022-06-18","objectID":"/cxx_template/:4:0","series":null,"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板进阶"},{"categories":[],"content":" pthread源码分析 基于musl源码库与glibc库,其中musl提供分析的思路,glibc分析具体实现 ","date":"2022-05-01","objectID":"/pthread/:0:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#pthread源码分析"},{"categories":[],"content":" 1 pthread句柄 /// musl实现 struct pthread { struct pthread *self; #ifndef TLS_ABOVE_TP uintptr_t *dtv; #endif /* 线程链表项 */ struct pthread *prev, *next; /* non-ABI */ /* 系统信息 */ uintptr_t sysinfo; #ifndef TLS_ABOVE_TP #ifdef CANARY_PAD uintptr_t canary_pad; #endif uintptr_t canary; #endif /* TLS_ABOVE_TP */ int tid; // 线程ID int errno_val; volatile int detach_state; // 分离状态 volatile int cancel; // cancle启动标志 volatile unsigned char canceldisable; // cancle控制 volatile unsigned char cancelasync; // cancle同步标志 unsigned char tsd_used:1; unsigned char dlerror_flag:1; unsigned char *map_base; // mmap size_t map_size; void *stack; // 堆栈 size_t stack_size; size_t guard_size; void *result; // 返回结果, /* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ struct __ptcb *cancelbuf; void **tsd; struct { volatile void *volatile head; long off; volatile void *volatile pending; } robust_list; int h_errno_val; volatile int timer_id; locale_t locale; volatile int killlock[1]; // 退出锁 char *dlerror_buf; void *stdio_locks; #ifdef TLS_ABOVE_TP uintptr_t canary; uintptr_t *dtv; #endif }; // glibc实现 struct __pthread { /* 线程ID: typedef unsigned long int pthread_t; */ pthread_t thread; unsigned int nr_refs; /* Detached threads have a self reference only, while joinable threads have two references. These are used to keep the structure valid at thread destruction. Detaching/joining a thread drops a reference. */ /* Cancellation. */ pthread_mutex_t cancel_lock; /* Protect cancel_xxx members. */ void (*cancel_hook) (void *); /* Called to unblock a thread blocking in a cancellation point (namely, __pthread_cond_timedwait_internal). */ void *cancel_hook_arg; int cancel_state; int cancel_type; int cancel_pending; /* Thread stack. */ void *stackaddr; /* 堆栈地址 */ size_t stacksize; /* 堆栈大小 */ size_t guardsize; /* 预留用来保护堆栈大小的字节 */ int stack; /* Nonzero if the stack was allocated. */ /* Exit status. */ void *status; /* Thread state. */ enum pthread_state state; pthread_mutex_t state_lock; /* Locks the state. */ pthread_cond_t state_cond; /* Signalled when the state changes. */ bool terminated; /* Whether the kernel thread is over and we can reuse this structure. */ /* Resolver state. */ struct __res_state res_state; /* Indicates whether is a C11 thread created by thrd_creat. */ bool c11; /* Initial sigset for the thread. */ sigset_t init_sigset; /* Thread context. */ struct pthread_mcontext mcontext; PTHREAD_KEY_MEMBERS /* void **thread_specifics; // This is only resized by the thread, and always growing unsigned thread_specifics_size; // Number of entries in thread_specifics */ PTHREAD_SYSDEP_MEMBERS /* thread_t kernel_thread; mach_msg_header_t wakeupmsg; */ /* 线程控制块:与系统进行沟通 */ tcbhead_t *tcb; /* Queue links. Since PREVP is used to determine if a thread has been awaken, it must be protected by the queue lock. */ struct __pthread *next, **prevp; }; 但是在我们使用的时候发现与我们正常的使用不太一致,在用户层,我们一般认为pthread为线程ID，但是内部实现好像都是指针,因此出现了什么特殊的原因； 在musl中,直接抹掉了内部结构; // 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 #ifdef __cplusplus typedef unsigned long pthread_t; #else typedef struct __pthread* pthread_t; #endif 而在glibc中,线程ID仅仅是线程结构体中的一个成员,因此,glibc的处理更加安全, 下面分析一下id的实现, __pthread_create (pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine) (void *), void *arg) { int err; struct __pthread *pthread; err = __pthread_create_internal (\u0026pthread, attr, start_routine, arg); if (!err) *thread = pthread-\u003ethread; else if (err == ENOMEM) err = EAGAIN; return err; } /* 那么可以明白,线程ID */ int _dl_pthread_num_threads; struct __pthread **_dl_pthread_threads; __libc_rwlock_define_initialized (, _dl_pthread_threads_lock) /* 下面的代码实现线程ID的分配:只保留了成功的部分,没有考虑意外情况 */ __libc_rwlock_wrlock (GL(dl_pthread_threads_lock)); if (GL(dl_pthread_num_threads) \u003c __pthread_max_threads) { /* We have a free slot. Use the slot number plus one as the thread ID for the new thread. */ new-\u003ethread = 1 + GL(dl_pthread_num_threads)++; GL(dl_pthread_threads)[new-\u003ethread - 1] = NULL; __libc_rwlock_unlock (GL(dl_pthread_threads_lock)); *pthread = n","date":"2022-05-01","objectID":"/pthread/:1:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#pthread句柄"},{"categories":[],"content":" 2 所有的函数","date":"2022-05-01","objectID":"/pthread/:2:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#所有的函数"},{"categories":[],"content":" 2.1 线程基础 // 线程创建 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict); // 线程退出 void pthread_exit(void *); // 线程属性 int pthread_attr_init(pthread_attr_t *); int pthread_attr_destroy(pthread_attr_t *); int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setguardsize(pthread_attr_t *, size_t); int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setstacksize(pthread_attr_t *, size_t); int pthread_attr_getdetachstate(const pthread_attr_t *, int *); int pthread_attr_setdetachstate(pthread_attr_t *, int); int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); int pthread_attr_setstack(pthread_attr_t *, void *, size_t); int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setscope(pthread_attr_t *, int); int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setschedpolicy(pthread_attr_t *, int); int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setinheritsched(pthread_attr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程基础"},{"categories":[],"content":" 2.2 线程分离 // 线程分离 int pthread_detach(pthread_t); // 线程等待 int pthread_join(pthread_t, void **); // 获取线程自己的ID pthread_t pthread_self(void); // 判断线程是否相等 int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 ","date":"2022-05-01","objectID":"/pthread/:2:2","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程分离"},{"categories":[],"content":" 2.3 线程取消 int pthread_setcancelstate(int, int *); int pthread_setcanceltype(int, int *); void pthread_testcancel(void); int pthread_cancel(pthread_t); ","date":"2022-05-01","objectID":"/pthread/:2:3","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程取消"},{"categories":[],"content":" 2.4 调度相关 int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param); __syscall(SYS_sched_getparam, pthread_t-\u003etid, sched_param); __syscall(SYS_sched_getscheduler, pthread_t-\u003etid); int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param); __syscall(SYS_sched_setscheduler, pthread_t-\u003etid, policy, sched_param); // sched_param保存着优先级参数 int pthread_setschedprio(pthread_t t, int prio); __syscall(SYS_sched_setparam, pthread_t-\u003etid, \u0026prio); ","date":"2022-05-01","objectID":"/pthread/:2:4","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#调度相关"},{"categories":[],"content":" 2.5 线程同步 2.5.1 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 2.5.2 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 2.5.3 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 2.5.4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); 2.5.5 屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程同步"},{"categories":[],"content":" 2.5 线程同步 2.5.1 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 2.5.2 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 2.5.3 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 2.5.4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); 2.5.5 屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#互斥锁"},{"categories":[],"content":" 2.5 线程同步 2.5.1 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 2.5.2 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 2.5.3 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 2.5.4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); 2.5.5 屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#条件变量"},{"categories":[],"content":" 2.5 线程同步 2.5.1 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 2.5.2 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 2.5.3 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 2.5.4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); 2.5.5 屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#读写锁"},{"categories":[],"content":" 2.5 线程同步 2.5.1 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 2.5.2 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 2.5.3 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 2.5.4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); 2.5.5 屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#自旋锁"},{"categories":[],"content":" 2.5 线程同步 2.5.1 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 2.5.2 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 2.5.3 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 2.5.4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); 2.5.5 屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); ","date":"2022-05-01","objectID":"/pthread/:2:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#屏障"},{"categories":[],"content":" 2.6 线程资源 int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); void *pthread_getspecific(pthread_key_t); int pthread_setspecific(pthread_key_t, const void *); ","date":"2022-05-01","objectID":"/pthread/:2:6","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程资源"},{"categories":[],"content":" 3 补充知识","date":"2022-05-01","objectID":"/pthread/:3:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#补充知识"},{"categories":[],"content":" 3.1 Linux线程实现","date":"2022-05-01","objectID":"/pthread/:3:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#linux线程实现"},{"categories":[],"content":" 3.2 系统调用实现 #define __asm_syscall(...) do { __asm__ __volatile__ ( \"svc 0\" : \"=r\"(r0) : __VA_ARGS__ : \"memory\"); return r0; } while (0); #define R7_OPERAND \"r\"(r7) static inline long __syscall0(long n) { register long r7 __ASM____R7__ = n; //使用R7传递个数 register long r0 __asm__(\"r0\"); __asm_syscall(R7_OPERAND); } static inline long __syscall1(long n, long a) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; __asm_syscall(R7_OPERAND, \"0\"(r0)); } static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; register long r1 __asm__(\"r1\") = b; register long r2 __asm__(\"r2\") = c; register long r3 __asm__(\"r3\") = d; register long r4 __asm__(\"r4\") = e; register long r5 __asm__(\"r5\") = f; __asm_syscall(R7_OPERAND, \"0\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3), \"r\"(r4), \"r\"(r5)); } // 一个相当巧妙的宏定义的实现 #define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n #define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) // 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 // 拼装函数调用 #define __SYSCALL_CONCAT_X(a,b) a##b #define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) #define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) // __syscall_ret仅仅检查了系统调用号 #define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) #define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束 系统调用号实现 #ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H #define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 #define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) #define __NR_exit (__NR_SYSCALL_BASE + 1) #define __NR_fork (__NR_SYSCALL_BASE + 2) #define __NR_read (__NR_SYSCALL_BASE + 3) #define __NR_write (__NR_SYSCALL_BASE + 4) #define __NR_open (__NR_SYSCALL_BASE + 5) #define __NR_close (__NR_SYSCALL_BASE + 6) #define __NR_creat (__NR_SYSCALL_BASE + 8) ... #define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) #endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */ ","date":"2022-05-01","objectID":"/pthread/:3:2","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#系统调用实现"},{"categories":[],"content":" 3.3 glibc系统调用同样的道理,可以分析一下glibc的系统调用时如何进行 但是在一般的情况下此时就可以明白,与musl相同的调用方式时一样的 INLINE_SYSCALL_CALL --\u003e __INLINE_SYSCALL_DISP __INLINE_SYSCALL_DISP --\u003e __SYSCALL_CONCAT 生成一条调用指令的语言 # define INTERNAL_SYSCALL_RAW(name, nr, args...) \\ ({ \\ register int _a1 asm (\"r0\"), _nr asm (\"r7\"); \\ LOAD_ARGS_##nr (args) \\ _nr = name; \\ asm volatile (\"swi 0x0 @ syscall \" #name \\ : \"=r\" (_a1) \\ : \"r\" (_nr) ASM_ARGS_##nr \\ : \"memory\"); \\ _a1; }) ","date":"2022-05-01","objectID":"/pthread/:3:3","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#glibc系统调用"},{"categories":[],"content":" 3.4 clone系统调用 int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...); // 但是实现的地方却存在着异常 __clone: stmfd sp!,{r4,r5,r6,r7} mov r7,#120 mov r6,r3 mov r5,r0 mov r0,r2 and r1,r1,#-16 ldr r2,[sp,#16] ldr r3,[sp,#20] ldr r4,[sp,#24] svc 0 tst r0,r0 beq 1f ldmfd sp!,{r4,r5,r6,r7} bx lr ","date":"2022-05-01","objectID":"/pthread/:3:4","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#clone系统调用"},{"categories":[],"content":" 3.5 Futex设计与实现Futex 是Fast Userspace muTexes的缩写 但是我并没有搞明白futex实现的原理,造成我发继续分析, 因此只能分析别人的文档(注:不分析原理 ,只进行使用) 主要存在文件futex-internal.c/futex-internal.h,lowlevellock-futex.h,lowlevellock.c 另外lll-\u003elowlevellock缩写形式 其中futex提供的最重要的两个操作wait和wake 常用的锁都是通过futex实现的 mutex (互斥锁) rwlock (读写锁) cond (条件变量) #define lll_trylock(lock) 原子的(lock 0 --\u003e 1) // 不等待 #define lll_cond_trylock(lock) 原子的(lock 0 --\u003e 2) // 不等待 #define lll_lock(futex, private) 1. 原子的(futex 0 --\u003e 1) // 等待 2. __lll_lock_wait (futex, private) #define __lll_cond_lock(futex, private) 1. 原子的(futex 0 --\u003e 2) // 等待 2. __lll_lock_wait (futex, private) #define __lll_unlock(futex, private) 1. 原子的(futex ? --\u003e 0) // 等待 2. __lll_lock_wait (futex, private) void __lll_lock_wake_private (int *futex); void __lll_lock_wait_private (int *futex); void __lll_lock_wait (int *futex, int private); void __lll_lock_wake (int *futex, int private); int lll_futex_wake(int *futex, int nr, int private); int lll_futex_wait(int *futex, int val, int private); int futex_wait (unsigned int *futex_word, unsigned int expected, int private); void futex_wake (unsigned int* futex_word, int processes_to_wake, int private); // 进入系统调用阶段 int lll_futex_syscall(int nargs, int *futexp, int op, ...); 那么进入到最后可以得知,一般会进行一些原子操作,启动的操作都是INTERNAL_SYSCALL进行实现的,然后就是swi指令实现的原理 // 可以使用的op定义类型 #define FUTEX_WAIT 0 #define FUTEX_WAKE 1 #define FUTEX_REQUEUE 3 #define FUTEX_CMP_REQUEUE 4 #define FUTEX_WAKE_OP 5 #define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE ((4 \u003c\u003c 24) | 1) #define FUTEX_LOCK_PI 6 #define FUTEX_UNLOCK_PI 7 #define FUTEX_TRYLOCK_PI 8 #define FUTEX_WAIT_BITSET 9 #define FUTEX_WAKE_BITSET 10 #define FUTEX_WAIT_REQUEUE_PI 11 #define FUTEX_CMP_REQUEUE_PI 12 #define FUTEX_LOCK_PI2 13 #define FUTEX_PRIVATE_FLAG 128 #define FUTEX_CLOCK_REALTIME 256 ","date":"2022-05-01","objectID":"/pthread/:3:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#futex设计与实现"},{"categories":[],"content":" 4 线程基础","date":"2022-05-01","objectID":"/pthread/:4:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程基础-1"},{"categories":[],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-05-01","objectID":"/pthread/:4:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程创建"},{"categories":[],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-05-01","objectID":"/pthread/:4:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#glibc实现的线程函数"},{"categories":[],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-05-01","objectID":"/pthread/:4:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#pthread管理单元申请与释放"},{"categories":[],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-05-01","objectID":"/pthread/:4:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#内核线程创建"},{"categories":[],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-05-01","objectID":"/pthread/:4:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#tls创建"},{"categories":[],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-05-01","objectID":"/pthread/:4:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#设置启动参数"},{"categories":[],"content":" 4.2 ptrhead进程属性机制 int pthread_attr_init(pthread_attr_t *a); pthread_attr_t-\u003e_a_stacksize = __default_stacksize; pthread_attr_t-\u003e_a_guardsize = __default_guardsize; int pthread_attr_setdetachstate(pthread_attr_t *a, int state); pthread_attr_t-\u003e_a_detach = state; int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_guardsize = size; int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); pthread_attr_t-\u003e_a_sched = inherit; int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param); pthread_attr_t-\u003e_a_prio = param-\u003esched_priority; int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); pthread_attr_t-\u003e_a_policy = policy; int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); pthread_attr_t-\u003e_a_stackaddr = (size_t)addr + size; pthread_attr_t-\u003e_a_stacksize = size; int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_stackaddr = 0; pthread_attr_t-\u003e_a_stacksize = size; ","date":"2022-05-01","objectID":"/pthread/:4:2","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#ptrhead进程属性机制"},{"categories":[],"content":" 4.3 自身线程ID // 在musl和glibc的实现上二者不太一样 static inline uintptr_t __get_tp() { uintptr_t tp; __asm__ ( \"mrc p15,0,%0,c13,c0,3\" : \"=r\"(tp) ); return tp; } // 获取线程自身的方法 #define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) // 二者实现不太一样 /* Return the thread descriptor for the current thread. */ # define THREAD_SELF ((struct pthread *)__builtin_thread_pointer () - 1) pthread_t __pthread_self (void) { return (pthread_t) THREAD_SELF; } ","date":"2022-05-01","objectID":"/pthread/:4:3","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#自身线程id"},{"categories":[],"content":" 4.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 4.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-05-01","objectID":"/pthread/:4:4","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程清理函数"},{"categories":[],"content":" 4.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 4.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-05-01","objectID":"/pthread/:4:4","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#cancle设置"},{"categories":[],"content":" 4.5 线程分离 // 线程分离 int pthread_detach(pthread_t) --\u003e __pthread_join(pthread_t, 0) --\u003e __pthread_timedjoin_np(pthread_t, 0, 0) // 设置线程等待 int pthread_join(pthread_t, void **); --\u003e__pthread_timedjoin_np(pthread_t, res, 0) // 那么也就是说明都调用了相同的函数 static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { /* 设置线程分离状态 */ } ","date":"2022-05-01","objectID":"/pthread/:4:5","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#线程分离-1"},{"categories":[],"content":" 5 原子操作 /// 原子操作由汇编实现 ","date":"2022-05-01","objectID":"/pthread/:5:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#原子操作"},{"categories":[],"content":" 6 自旋锁 int pthread_spin_init(pthread_spinlock_t *s, int shared) { return *s = 0; } int pthread_spin_destroy(pthread_spinlock_t *s) { return 0; } int pthread_spin_lock(pthread_spinlock_t *s) { while (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin(); return 0; } int pthread_spin_trylock(pthread_spinlock_t *s) { return a_cas(s, 0, EBUSY); } int pthread_spin_unlock(pthread_spinlock_t *s) { a_store(s, 0); return 0; } ","date":"2022-05-01","objectID":"/pthread/:6:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#自旋锁-1"},{"categories":[],"content":" 7 内存屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); ","date":"2022-05-01","objectID":"/pthread/:7:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#内存屏障"},{"categories":[],"content":" 8 互斥锁","date":"2022-05-01","objectID":"/pthread/:8:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#互斥锁-1"},{"categories":[],"content":" 8.1 互斥锁musl实现在musl库上的互斥锁,但是我感觉musl的设计存在一些瑕疵,还是在去分析一下glibc的设计思路吧. typedef struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t; int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a) { *m = (pthread_mutex_t){0}; if (a) { m-\u003e_m_type = a-\u003e__attr; } return 0; } int pthread_mutex_destroy(pthread_mutex_t *mutex) { if (mutex-\u003e_m_type \u003e 128) { __vm_wait(); } return 0; } int pthread_mutex_lock(pthread_mutex_t *m) { if ((m-\u003e_m_type \u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; return __pthread_mutex_timedlock(m, 0); } int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at) { /* PTHREAD_MUTEX_NORMAL:死等 */ if ((m-\u003e_m_type\u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; int type = m-\u003e_m_type; int r, t, priv = (type \u0026 128) ^ 128; /* 尝试加锁 */ r = __pthread_mutex_trylock(m); if (r != EBUSY) { return r; } if (type\u00268) return pthread_mutex_timedlock_pi(m, at); int spins = 100; while (spins-- \u0026\u0026 m-\u003e_m_lock \u0026\u0026 !m-\u003e_m_waiters) a_spin(); while ((r=__pthread_mutex_trylock(m)) == EBUSY) { r = m-\u003e_m_lock; int own = r \u0026 0x3fffffff; if (!own \u0026\u0026 (!r || (type\u00264))) continue; if ((type\u00263) == PTHREAD_MUTEX_ERRORCHECK \u0026\u0026 own == __pthread_self()-\u003etid) return EDEADLK; a_inc(\u0026m-\u003e_m_waiters); t = r | 0x80000000; a_cas(\u0026m-\u003e_m_lock, r, t); r = __timedwait(\u0026m-\u003e_m_lock, t, CLOCK_REALTIME, at, priv); a_dec(\u0026m-\u003e_m_waiters); if (r \u0026\u0026 r != EINTR) break; } return r; } ","date":"2022-05-01","objectID":"/pthread/:8:1","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#互斥锁musl实现"},{"categories":[],"content":" 8.2 互斥锁glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) 8.2.1 互斥锁的定义 struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 int __pthread_mutex_lock (pthread_mutex_t *mtxp) { struct __pthread *self; int flags = mtxp-\u003e__flags \u0026 GSYNC_SHARED; int ret = 0; // 根据不同的类型确定 #define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED #define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) #define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) switch (MTX_TYPE (mtxp)) { /* 普通上锁方式 */ case PT_MTX_NORMAL: lll_lock (mtxp-\u003e__lock, flags); break; /* 迭代锁 */ case PT_MTX_RECURSIVE: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) { if (__glibc_unlikely (mtxp-\u003e__cnt + 1 == 0)) return EAGAIN; ++mtxp-\u003e__cnt; return ret; } lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); mtxp-\u003e__cnt = 1; break; case PT_MTX_ERRORCHECK: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) return EDEADLK; lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); break; case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: self = _pthread_self (); ROBUST_LOCK (self, mtxp, lll_robust_lock, flags); break; default: ret = EINVAL; break; } return ret; } ","date":"2022-05-01","objectID":"/pthread/:8:2","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#互斥锁glibc实现"},{"categories":[],"content":" 8.2 互斥锁glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) 8.2.1 互斥锁的定义 struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 int __pthread_mutex_lock (pthread_mutex_t *mtxp) { struct __pthread *self; int flags = mtxp-\u003e__flags \u0026 GSYNC_SHARED; int ret = 0; // 根据不同的类型确定 #define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED #define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) #define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) switch (MTX_TYPE (mtxp)) { /* 普通上锁方式 */ case PT_MTX_NORMAL: lll_lock (mtxp-\u003e__lock, flags); break; /* 迭代锁 */ case PT_MTX_RECURSIVE: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) { if (__glibc_unlikely (mtxp-\u003e__cnt + 1 == 0)) return EAGAIN; ++mtxp-\u003e__cnt; return ret; } lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); mtxp-\u003e__cnt = 1; break; case PT_MTX_ERRORCHECK: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) return EDEADLK; lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); break; case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: self = _pthread_self (); ROBUST_LOCK (self, mtxp, lll_robust_lock, flags); break; default: ret = EINVAL; break; } return ret; } ","date":"2022-05-01","objectID":"/pthread/:8:2","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#互斥锁的定义"},{"categories":[],"content":" 9 条件变量","date":"2022-05-01","objectID":"/pthread/:9:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#条件变量-1"},{"categories":[],"content":" 10 读写锁 ","date":"2022-05-01","objectID":"/pthread/:10:0","series":null,"tags":[],"title":"pthread源码分析","uri":"/pthread/#读写锁-1"},{"categories":[],"content":" 1 ZONE","date":"2022-03-13","objectID":"/memory_management/:1:0","series":null,"tags":[],"title":"内存管理","uri":"/memory_management/#zone"},{"categories":[],"content":" 1.1 ZONE类型 ZONE_DMA, ZONE_DMA32 ZONE_NORMAL ZONE_HIGHMEM ZONE_MOVABLE ZONE_DEVICE ","date":"2022-03-13","objectID":"/memory_management/:1:1","series":null,"tags":[],"title":"内存管理","uri":"/memory_management/#zone类型"},{"categories":["rootfs"],"content":" 1 下载buildroot git clone --depth=1 https://git.busybox.net/buildroot git branch -a [new branch] git checkout [new branch] ","date":"2022-03-13","objectID":"/buildroot/:1:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#下载buildroot"},{"categories":["rootfs"],"content":" 2 快速开始 可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026\u0026 make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh ","date":"2022-03-13","objectID":"/buildroot/:2:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#快速开始"},{"categories":["rootfs"],"content":" 3 基础配置","date":"2022-03-13","objectID":"/buildroot/:3:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#基础配置"},{"categories":["rootfs"],"content":" 3.1 使用自定义的内核在defconfig文件中添加下面的配置 BR2_LINUX_KERNEL=y # 是否编译内核 BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"git@github.com:mengdemao/kernel.git\" # kernel的地址 BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"master\" # 版本 BR2_LINUX_KERNEL_VERSION=\"master\" BR2_LINUX_KERNEL_USE_DEFCONFIG=y BR2_LINUX_KERNEL_DEFCONFIG=\"debian\" BR2_LINUX_KERNEL_ZIMAGE=y BR2_LINUX_KERNEL_GZIP=y ","date":"2022-03-13","objectID":"/buildroot/:3:1","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#使用自定义的内核"},{"categories":["compiler"],"content":"A simpile compiler","date":"2022-01-16","objectID":"/c4/","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/"},{"categories":["compiler"],"content":" 1 C4实现C4共实现了4个函数 void stmt(); void next(); void expr(int lev); int main(int argc, char **argv); ","date":"2022-01-16","objectID":"/c4/:1:0","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#c4实现"},{"categories":["compiler"],"content":" 1.1 全局数据 1.1.1 全局变量 char *p, *lp, // current position in source code *data; // data/bss pointer int *e, *le, // current position in emitted code *id, // currently parsed identifier *sym, // symbol table (simple list of identifiers) tk, // current token ival, // current token value ty, // current expression type loc, // local variable offset line, // current line number src, // print source and assembly flag debug; // print executed instructions 1.1.2 表达式描述 // 符号描述 enum { Num = 128, Fun, Sys, Glo, Loc, Id, Char, Else, Enum, If, Int, Return, Sizeof, While, Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak }; // 操作符 enum { LEA , IMM , JMP , JSR , BZ , BNZ , ENT , ADJ , LEV , LI , LC , SI , SC , PSH , OR , XOR , AND , EQ , NE , LT , GT , LE , GE , SHL , SHR , ADD , SUB , MUL , DIV , MOD , OPEN, READ, CLOS, PRTF, MALC, FREE, MSET, MCMP, EXIT }; // 类型描述 enum { CHAR, INT, PTR }; // 表达式描述 enum { Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz }; ","date":"2022-01-16","objectID":"/c4/:1:1","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#全局数据"},{"categories":["compiler"],"content":" 1.1 全局数据 1.1.1 全局变量 char *p, *lp, // current position in source code *data; // data/bss pointer int *e, *le, // current position in emitted code *id, // currently parsed identifier *sym, // symbol table (simple list of identifiers) tk, // current token ival, // current token value ty, // current expression type loc, // local variable offset line, // current line number src, // print source and assembly flag debug; // print executed instructions 1.1.2 表达式描述 // 符号描述 enum { Num = 128, Fun, Sys, Glo, Loc, Id, Char, Else, Enum, If, Int, Return, Sizeof, While, Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak }; // 操作符 enum { LEA , IMM , JMP , JSR , BZ , BNZ , ENT , ADJ , LEV , LI , LC , SI , SC , PSH , OR , XOR , AND , EQ , NE , LT , GT , LE , GE , SHL , SHR , ADD , SUB , MUL , DIV , MOD , OPEN, READ, CLOS, PRTF, MALC, FREE, MSET, MCMP, EXIT }; // 类型描述 enum { CHAR, INT, PTR }; // 表达式描述 enum { Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz }; ","date":"2022-01-16","objectID":"/c4/:1:1","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#全局变量"},{"categories":["compiler"],"content":" 1.1 全局数据 1.1.1 全局变量 char *p, *lp, // current position in source code *data; // data/bss pointer int *e, *le, // current position in emitted code *id, // currently parsed identifier *sym, // symbol table (simple list of identifiers) tk, // current token ival, // current token value ty, // current expression type loc, // local variable offset line, // current line number src, // print source and assembly flag debug; // print executed instructions 1.1.2 表达式描述 // 符号描述 enum { Num = 128, Fun, Sys, Glo, Loc, Id, Char, Else, Enum, If, Int, Return, Sizeof, While, Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak }; // 操作符 enum { LEA , IMM , JMP , JSR , BZ , BNZ , ENT , ADJ , LEV , LI , LC , SI , SC , PSH , OR , XOR , AND , EQ , NE , LT , GT , LE , GE , SHL , SHR , ADD , SUB , MUL , DIV , MOD , OPEN, READ, CLOS, PRTF, MALC, FREE, MSET, MCMP, EXIT }; // 类型描述 enum { CHAR, INT, PTR }; // 表达式描述 enum { Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz }; ","date":"2022-01-16","objectID":"/c4/:1:1","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#表达式描述"},{"categories":["compiler"],"content":" 1.2 基本架构","date":"2022-01-16","objectID":"/c4/:1:2","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#基本架构"},{"categories":["compiler"],"content":" 2 词法分析(next) 提取下一个单词 tk, // current token ival, // current token value ","date":"2022-01-16","objectID":"/c4/:2:0","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#词法分析next"},{"categories":["compiler"],"content":" 3 parse","date":"2022-01-16","objectID":"/c4/:3:0","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#parse"},{"categories":["compiler"],"content":" 4 code generator","date":"2022-01-16","objectID":"/c4/:4:0","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#code-generator"},{"categories":["compiler"],"content":" 5 stack based virtual machine pc sp bp while (1) { i = *pc++; ++cycle; if (i == LEA) a = (int)(bp + *pc++); // load local address else if (i == IMM) a = *pc++; // load global address or immediate else if (i == JMP) pc = (int *)*pc; // jump else if (i == JSR) { *--sp = (int)(pc + 1); pc = (int *)*pc; } // jump to subroutine else if (i == BZ) pc = a ? pc + 1 : (int *)*pc; // branch if zero else if (i == BNZ) pc = a ? (int *)*pc : pc + 1; // branch if not zero else if (i == ENT) { *--sp = (int)bp; bp = sp; sp = sp - *pc++; } // enter subroutine else if (i == ADJ) sp = sp + *pc++; // stack adjust else if (i == LEV) { sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; } // leave subroutine else if (i == LI) a = *(int *)a; // load int else if (i == LC) a = *(char *)a; // load char else if (i == SI) *(int *)*sp++ = a; // store int else if (i == SC) a = *(char *)*sp++ = a; // store char else if (i == PSH) *--sp = a; // push else if (i == OR) a = *sp++ | a; else if (i == XOR) a = *sp++ ^ a; else if (i == AND) a = *sp++ \u0026 a; else if (i == EQ) a = *sp++ == a; else if (i == NE) a = *sp++ != a; else if (i == LT) a = *sp++ \u003c a; else if (i == GT) a = *sp++ \u003e a; else if (i == LE) a = *sp++ \u003c= a; else if (i == GE) a = *sp++ \u003e= a; else if (i == SHL) a = *sp++ \u003c\u003c a; else if (i == SHR) a = *sp++ \u003e\u003e a; else if (i == ADD) a = *sp++ + a; else if (i == SUB) a = *sp++ - a; else if (i == MUL) a = *sp++ * a; else if (i == DIV) a = *sp++ / a; else if (i == MOD) a = *sp++ % a; else if (i == OPEN) a = open((char *)sp[1], *sp); else if (i == READ) a = read(sp[2], (char *)sp[1], *sp); else if (i == CLOS) a = close(*sp); else if (i == PRTF) { t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); } else if (i == MALC) a = (int)malloc(*sp); else if (i == FREE) free((void *)*sp); else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp); else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp); else if (i == EXIT) { printf(\"exit(%d) cycle = %d\\n\", *sp, cycle); return *sp; } else { printf(\"unknown instruction = %d! cycle = %d\\n\", i, cycle); return -1; } } ","date":"2022-01-16","objectID":"/c4/:5:0","series":null,"tags":["compiler"],"title":"C4","uri":"/c4/#stack-based-virtual-machine"},{"categories":[],"content":" Lua源码分析 Lua运行结构 ","date":"2022-01-02","objectID":"/lua/:0:0","series":null,"tags":[],"title":"Lua","uri":"/lua/#lua源码分析"},{"categories":[],"content":" 1 相关数据结构","date":"2022-01-02","objectID":"/lua/:1:0","series":null,"tags":[],"title":"Lua","uri":"/lua/#相关数据结构"},{"categories":[],"content":" 1.1 全局状态机 描述Lua运行状态,同时可以产生一种面向对象的模拟 struct lua_State { CommonHeader; lu_byte status; lu_byte allowhook; unsigned short nci; /* number of items in 'ci' list */ StkId top; /* first free slot in the stack */ global_State *l_G; CallInfo *ci; /* call info for current function */ StkId stack_last; /* end of stack (last element + 1) */ StkId stack; /* stack base */ UpVal *openupval; /* list of open upvalues in this stack */ StkId tbclist; /* list of to-be-closed variables */ GCObject *gclist; struct lua_State *twups; /* list of threads with open upvalues */ struct lua_longjmp *errorJmp; /* current error recover point */ CallInfo base_ci; /* CallInfo for first level (C calling Lua) */ volatile lua_Hook hook; ptrdiff_t errfunc; /* current error handling function (stack index) */ l_uint32 nCcalls; /* number of nested (non-yieldable | C) calls */ int oldpc; /* last pc traced */ int basehookcount; int hookcount; volatile l_signalT hookmask; }; ","date":"2022-01-02","objectID":"/lua/:1:1","series":null,"tags":[],"title":"Lua","uri":"/lua/#全局状态机"},{"categories":[],"content":" 2 Lua编译器 lua并没有直接运行源文件,而是将源文件编译成字节码，然后运行字节码 其中运行编译驱动文件名luac.c 文件名 功能 入口函数 llex.c 词法分析 luaX_next lparser.c 语法解析 luaY_parser lcode.c 代码生成 luaK_finish ldump.c/lundump.c 字节码 luaU_dump/luaU_undump ","date":"2022-01-02","objectID":"/lua/:2:0","series":null,"tags":[],"title":"Lua","uri":"/lua/#lua编译器"},{"categories":[],"content":" 2.1 词法分析 2.1.1 外部接口 // 读取下一个单词 void luaX_next (LexState *ls); // 预读下一个单词 int luaX_lookahead (LexState *ls); 2.1.2 核心函数 // 词法分析状态机 typedef struct LexState { int current; /* current character (charint) */ int linenumber; /* input line counter */ int lastline; /* line of last token 'consumed' */ Token t; /* current token */ Token lookahead; /* look ahead token */ struct FuncState *fs; /* current function (parser) */ struct lua_State *L; ZIO *z; /* input stream */ Mbuffer *buff; /* buffer for tokens */ Table *h; /* to avoid collection/reuse strings */ struct Dyndata *dyd; /* dynamic structures used by the parser */ TString *source; /* current source name */ TString *envn; /* environment variable name */ } LexState; // 语义信息 typedef union { lua_Number r; lua_Integer i; TString *ts; } SemInfo; int llex (LexState *ls, SemInfo *seminfo); ","date":"2022-01-02","objectID":"/lua/:2:1","series":null,"tags":[],"title":"Lua","uri":"/lua/#词法分析"},{"categories":[],"content":" 2.1 词法分析 2.1.1 外部接口 // 读取下一个单词 void luaX_next (LexState *ls); // 预读下一个单词 int luaX_lookahead (LexState *ls); 2.1.2 核心函数 // 词法分析状态机 typedef struct LexState { int current; /* current character (charint) */ int linenumber; /* input line counter */ int lastline; /* line of last token 'consumed' */ Token t; /* current token */ Token lookahead; /* look ahead token */ struct FuncState *fs; /* current function (parser) */ struct lua_State *L; ZIO *z; /* input stream */ Mbuffer *buff; /* buffer for tokens */ Table *h; /* to avoid collection/reuse strings */ struct Dyndata *dyd; /* dynamic structures used by the parser */ TString *source; /* current source name */ TString *envn; /* environment variable name */ } LexState; // 语义信息 typedef union { lua_Number r; lua_Integer i; TString *ts; } SemInfo; int llex (LexState *ls, SemInfo *seminfo); ","date":"2022-01-02","objectID":"/lua/:2:1","series":null,"tags":[],"title":"Lua","uri":"/lua/#外部接口"},{"categories":[],"content":" 2.1 词法分析 2.1.1 外部接口 // 读取下一个单词 void luaX_next (LexState *ls); // 预读下一个单词 int luaX_lookahead (LexState *ls); 2.1.2 核心函数 // 词法分析状态机 typedef struct LexState { int current; /* current character (charint) */ int linenumber; /* input line counter */ int lastline; /* line of last token 'consumed' */ Token t; /* current token */ Token lookahead; /* look ahead token */ struct FuncState *fs; /* current function (parser) */ struct lua_State *L; ZIO *z; /* input stream */ Mbuffer *buff; /* buffer for tokens */ Table *h; /* to avoid collection/reuse strings */ struct Dyndata *dyd; /* dynamic structures used by the parser */ TString *source; /* current source name */ TString *envn; /* environment variable name */ } LexState; // 语义信息 typedef union { lua_Number r; lua_Integer i; TString *ts; } SemInfo; int llex (LexState *ls, SemInfo *seminfo); ","date":"2022-01-02","objectID":"/lua/:2:1","series":null,"tags":[],"title":"Lua","uri":"/lua/#核心函数"},{"categories":[],"content":" 2.2 语法分析 typedef struct Proto { CommonHeader; lu_byte numparams; /* number of fixed (named) parameters */ lu_byte is_vararg; lu_byte maxstacksize; /* number of registers needed by this function */ int sizeupvalues; /* size of 'upvalues' */ int sizek; /* size of 'k' */ int sizecode; int sizelineinfo; int sizep; /* size of 'p' */ int sizelocvars; int sizeabslineinfo; /* size of 'abslineinfo' */ int linedefined; /* debug information */ int lastlinedefined; /* debug information */ TValue *k; /* constants used by the function */ Instruction *code; /* opcodes */ struct Proto **p; /* functions defined inside the function */ Upvaldesc *upvalues; /* upvalue information */ ls_byte *lineinfo; /* information about source lines (debug information) */ AbsLineInfo *abslineinfo; /* idem */ LocVar *locvars; /* information about local variables (debug information) */ TString *source; /* used for debug information */ GCObject *gclist; } Proto; typedef struct LClosure { ClosureHeader; struct Proto *p; UpVal *upvals[1]; /* list of upvalues */ } LClosure; LClosure *luaY_parser ( lua_State *L, ZIO *z, Mbuffer *buff, Dyndata *dyd, const char *name, int firstchar); ","date":"2022-01-02","objectID":"/lua/:2:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#语法分析"},{"categories":[],"content":" 2.3 代码生成 void luaK_finish (FuncState *fs) { int i; Proto *p = fs-\u003ef; for (i = 0; i \u003c fs-\u003epc; i++) { Instruction *pc = \u0026p-\u003ecode[i]; lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc)); switch (GET_OPCODE(*pc)) { case OP_RETURN0: case OP_RETURN1: { if (!(fs-\u003eneedclose || p-\u003eis_vararg)) break; /* no extra work */ /* else use OP_RETURN to do the extra work */ SET_OPCODE(*pc, OP_RETURN); } /* FALLTHROUGH */ case OP_RETURN: case OP_TAILCALL: { if (fs-\u003eneedclose) SETARG_k(*pc, 1); /* signal that it needs to close */ if (p-\u003eis_vararg) SETARG_C(*pc, p-\u003enumparams + 1); /* signal that it is vararg */ break; } case OP_JMP: { int target = finaltarget(p-\u003ecode, i); fixjump(fs, i, target); break; } default: break; } } } ","date":"2022-01-02","objectID":"/lua/:2:3","series":null,"tags":[],"title":"Lua","uri":"/lua/#代码生成"},{"categories":[],"content":" 2.4 字节码 int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data, int strip) { DumpState D; D.L = L; D.writer = w; D.data = data; D.strip = strip; D.status = 0; dumpHeader(\u0026D); dumpByte(\u0026D, f-\u003esizeupvalues); dumpFunction(\u0026D, f, NULL); return D.status; } LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name) { LoadState S; LClosure *cl; if (*name == '@' || *name == '=') S.name = name + 1; else if (*name == LUA_SIGNATURE[0]) S.name = \"binary string\"; else S.name = name; S.L = L; S.Z = Z; checkHeader(\u0026S); cl = luaF_newLclosure(L, loadByte(\u0026S)); setclLvalue2s(L, L-\u003etop, cl); luaD_inctop(L); cl-\u003ep = luaF_newproto(L); luaC_objbarrier(L, cl, cl-\u003ep); loadFunction(\u0026S, cl-\u003ep, NULL); lua_assert(cl-\u003enupvalues == cl-\u003ep-\u003esizeupvalues); luai_verifycode(L, cl-\u003ep); return cl; } ","date":"2022-01-02","objectID":"/lua/:2:4","series":null,"tags":[],"title":"Lua","uri":"/lua/#字节码"},{"categories":[],"content":" 3 Lua虚拟机 接受编译器产生的字节码并且运行,执行的入口函数是luaV_execute ","date":"2022-01-02","objectID":"/lua/:3:0","series":null,"tags":[],"title":"Lua","uri":"/lua/#lua虚拟机"},{"categories":[],"content":" 3.1 Lua指令分析 指令名 参数 描述 OP_MOVE A B R(A) := R(B) OP_LOADK A Bx R(A) := Kst(Bx) OP_LOADBOOL A B C R(A) := (Bool)B; if (C) pc++ OP_LOADNIL A B R(A) := ... := R(B) := nil OP_GETUPVAL A B R(A) := UpValue[B] OP_GETGLOBAL A Bx R(A) := Gbl[Kst(Bx)] OP_GETTABLE A B C R(A) := R(B)[RK(C)] OP_SETGLOBAL A Bx Gbl[Kst(Bx)] := R(A) OP_SETUPVAL A B UpValue[B] := R(A) OP_SETTABLE A B C `R(A)[RK(B)] := RK(C) OP_NEWTABLE A B C R(A) := {} (size = B,C) OP_SELF A B C R(A+1) := R(B); R(A) := R(B)[RK(C)] OP_ADD A B C R(A) := RK(B) + RK(C) OP_SUB A B C R(A) := RK(B) - RK(C) OP_MUL A B C R(A) := RK(B) * RK(C) OP_DIV A B C R(A) := RK(B) / RK(C) OP_MOD A B C R(A) := RK(B) % RK(C) OP_POW A B C R(A) := RK(B) ^ RK(C) OP_UNM A B R(A) := -R(B) OP_NOT A B R(A) := not R(B) OP_LEN A B R(A) := length of R(B) OP_CONCAT A B C R(A) := R(B).. ... ..R(C) OP_JMP sBx pc+=sBx OP_EQ A B C if ((RK(B) == RK(C)) ~= A) then pc++ OP_LT A B C if ((RK(B) \u003c RK(C)) ~= A) then pc++ OP_LE A B C if ((RK(B) \u003c= RK(C)) ~= A) then pc++ OP_TEST A C if not (R(A) \u003c=\u003e C) then pc++ OP_TESTSET A B C if (R(B) \u003c=\u003e C) then R(A) := R(B) else pc++ OP_CALL A B C R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) OP_TAILCALL A B C return R(A)(R(A+1), ... ,R(A+B-1)) OP_RETURN A B return R(A), ... ,R(A+B-2) (see note) OP_FORLOOP A sBx R(A)+=R(A+2); if R(A) \u003c?= R(A+1) then { pc+=sBx; R(A+3)=R(A) } OP_FORPREP A sBx R(A)-=R(A+2); pc+=sBx OP_TFORLOOP A C R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++ OP_SETLIST A B C R(A)[(C-1)*FPF+i] := R(A+i), 1 \u003c= i \u003c= B OP_CLOSE A close all variables in the stack up to (\u003e=) R(A) OP_CLOSURE A Bx R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n)) OP_VARARG A B R(A), R(A+1), ..., R(A+B-1) = vararg ","date":"2022-01-02","objectID":"/lua/:3:1","series":null,"tags":[],"title":"Lua","uri":"/lua/#lua指令分析"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#指令解析"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#指令分发"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#钩子函数处理"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#op_move"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#op_loadk"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#op_loadbool"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#op_loadnil"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#op_getupval"},{"categories":[],"content":" 3.2 指令解析 lua_State *L; /* Lua状态机 */ LClosure *cl = \u0026clvalue(L-\u003eci-\u003efunc)-\u003el; /* 当前函数执行环境 */ TValue *k = cl-\u003ep-\u003ek; /* 函数环境常量数组 */ const Instruction *pc = L-\u003esavedpc; /* 当前函数指针 */ StkId base = L-\u003ebase;; /* 函数环境栈基地址 */ // R(A|B|C) 寄存器索引 #define RA(i) (base+GETARG_A(i)) #define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) #define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) // RKB() 寄存器索引或者常量索引 #define RKB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) #define RKC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) #define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 3.2.1 指令分发 const Instruction i = *pc++; StkId ra = RA(i); 3.2.2 钩子函数处理 // 不明白在处理什么 if ((L-\u003ehookmask \u0026 (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026\u0026 (--L-\u003ehookcount == 0 || L-\u003ehookmask \u0026 LUA_MASKLINE)) { traceexec(L, pc); if (L-\u003estatus == LUA_YIELD) { /* did hook yield? */ L-\u003esavedpc = pc - 1; return; } base = L-\u003ebase; } 3.2.3 OP_MOVE #define setobjs2s setobj case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } 3.2.4 OP_LOADK #define setobj2s setobj case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } 统一调用此函数 // 拷贝lua_TValue,也只有两个成员 void setobj(lua_State *L, const TValue *obj1, TValue *obj2) { const TValue *o2=(obj2); TValue *o1=(obj1); o1-\u003evalue = o2-\u003evalue; o1-\u003ett=o2-\u003ett; checkliveness(G(L),o1); } 3.2.5 OP_LOADBOOL case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } 3.2.6 OP_LOADNIL case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb \u003e= ra); continue; } 3.2.7 OP_GETUPVAL case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-\u003eupvals[b]-\u003ev); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, \u0026g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, \u0026g, cl-\u003eenv); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, \u0026g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-\u003eupvals[GETARG_B(i)]; setobj(L, uv-\u003ev, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } 3.2.8 算术指令 case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } 统一调用arith_op,计算数据效果 功能 第一参数 第二参数 加 #define luai_numadd(a,b) ((a)+(b)) TM_ADD 减 #define luai_numsub(a,b) ((a)-(b)) TM_SUB 乘 #define luai_nummul(a,b) ((a)*(b)) TM_MUL 除 #define luai_numdiv(a,b) ((a)/(b)) TM_DIV 模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD 方 #define luai_numpow(a,b) (pow(a,b)) TM_POW void arith_op(op,tm) { TValue *rb = RKB(i); // 第二操作数 TValue *rc = RKC(i); // 第三操作数 if (ttisnumber(rb) \u0026\u0026 // 校验数据 ttisnumber(rc)) { // 校验数据 lua_Number nb = nvalue(rb); // 提取数据 lua_Number nc = nvalue(rc); // 提取数据 setnvalue(ra, op(nb, nc)); // 设置第一操作数 } else { Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 } } #define Protect(x) { L-\u003esavedpc = pc; {x;}; base = L-\u003ebase; } static void Arith (lua_State *L, StkId ra, const TValue *rb, const TValue *rc, TMS op) { TValue tempb, tempc; const TValue *b, *c; if ((b = luaV_tonumber(rb, \u0026tempb)) != NULL \u0026\u0026 (c = luaV_tonumber(rc, \u0026tempc)) != NULL) { lua_Number nb = nvalue(b), nc = nvalue(c); switch (op) { case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break","date":"2022-01-02","objectID":"/lua/:3:2","series":null,"tags":[],"title":"Lua","uri":"/lua/#算术指令"},{"categories":[],"content":" 1 优先级定义 内核优先级使用0-139确定内部优先级,0-99分配实时进程; [100, 139]分配非实时进程,nice的映射[-20, 19]与非实时优先级的相对应. ","date":"2021-11-14","objectID":"/schedulepriority/:1:0","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#优先级定义"},{"categories":[],"content":" 2 相关数据结构任务相关数据 struct task_struct { int prio; // 动态优先级 int static_prio; // 静态优先级 int normal_prio; // 普通优先级 unsigned int rt_priority; // 实时优先级 }; ","date":"2021-11-14","objectID":"/schedulepriority/:2:0","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#相关数据结构"},{"categories":[],"content":" 2.1 计算静态优先级 static int effective_prio(struct task_struct *p) { /* 设置普通优先级 */ p-\u003enormal_prio = normal_prio(p); /* 如果不是实时优先级,则返回普通优先级 */ if (!rt_prio(p-\u003eprio)) return p-\u003enormal_prio; /* 返回动态优先级 */ return p-\u003eprio; } ","date":"2021-11-14","objectID":"/schedulepriority/:2:1","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#计算静态优先级"},{"categories":[],"content":" 2.2 获取普通优先级 static inline int __normal_prio(struct task_struct *p) { return p-\u003estatic_prio; } static inline int normal_prio(struct task_struct *p) { int prio; if (task_has_dl_policy(p)) prio = MAX_DL_PRIO-1; else if (task_has_rt_policy(p)) prio = MAX_RT_PRIO-1 - p-\u003ert_priority; else prio = __normal_prio(p); return prio; } ","date":"2021-11-14","objectID":"/schedulepriority/:2:2","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#获取普通优先级"},{"categories":[],"content":" 3 负载计算 // 负载权重 struct load_weight { unsigned long weight; u32 inv_weight; }; // 调度实体 struct sched_entity { struct load_weight load; }; struct sched_rt_entity { struct list_head run_list; unsigned long timeout; unsigned long watchdog_stamp; unsigned int time_slice; unsigned short on_rq; unsigned short on_list; struct sched_rt_entity *back; #ifdef CONFIG_RT_GROUP_SCHED struct sched_rt_entity *parent; /* rq on which this entity is (to be) queued: */ struct rt_rq *rt_rq; /* rq \"owned\" by this entity/group: */ struct rt_rq *my_q; #endif } __randomize_layout; struct sched_dl_entity { struct rb_node rb_node; /* * Original scheduling parameters. Copied here from sched_attr * during sched_setattr(), they will remain the same until * the next sched_setattr(). */ u64 dl_runtime; /* Maximum runtime for each instance */ u64 dl_deadline; /* Relative deadline of each instance */ u64 dl_period; /* Separation of two instances (period) */ u64 dl_bw; /* dl_runtime / dl_period */ u64 dl_density; /* dl_runtime / dl_deadline */ /* * Actual scheduling parameters. Initialized with the values above, * they are continously updated during task execution. Note that * the remaining runtime could be \u003c 0 in case we are in overrun. */ s64 runtime; /* Remaining runtime for this instance */ u64 deadline; /* Absolute deadline for this instance */ unsigned int flags; /* Specifying the scheduler behaviour */ /* * Some bool flags: * * @dl_throttled tells if we exhausted the runtime. If so, the * task has to wait for a replenishment to be performed at the * next firing of dl_timer. * * @dl_boosted tells if we are boosted due to DI. If so we are * outside bandwidth enforcement mechanism (but only until we * exit the critical section); * * @dl_yielded tells if task gave up the CPU before consuming * all its available runtime during the last job. * * @dl_non_contending tells if the task is inactive while still * contributing to the active utilization. In other words, it * indicates if the inactive timer has been armed and its handler * has not been executed yet. This flag is useful to avoid race * conditions between the inactive timer handler and the wakeup * code. * * @dl_overrun tells if the task asked to be informed about runtime * overruns. */ unsigned int dl_throttled : 1; unsigned int dl_boosted : 1; unsigned int dl_yielded : 1; unsigned int dl_non_contending : 1; unsigned int dl_overrun : 1; /* * Bandwidth enforcement timer. Each -deadline task has its * own bandwidth to be enforced, thus we need one timer per task. */ struct hrtimer dl_timer; /* * Inactive timer, responsible for decreasing the active utilization * at the \"0-lag time\". When a -deadline task blocks, it contributes * to GRUB's active utilization until the \"0-lag time\", hence a * timer is needed to decrease the active utilization at the correct * time. */ struct hrtimer inactive_timer; }; // 调度结构体 struct task_struct { struct sched_entity se; // 调度实体 struct sched_rt_entity rt; // 实时调度实体 struct sched_dl_entity dl; // 限期调度实体 }; ","date":"2021-11-14","objectID":"/schedulepriority/:3:0","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#负载计算"},{"categories":[],"content":" 3.1 设置负载权重 const int sched_prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; const u32 sched_prio_to_wmult[40] = { /* -20 */ 48388, 59856, 76040, 92818, 118348, /* -15 */ 147320, 184698, 229616, 287308, 360437, /* -10 */ 449829, 563644, 704093, 875809, 1099582, /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, }; static void set_load_weight(struct task_struct *p, bool update_load) { int prio = p-\u003estatic_prio - MAX_RT_PRIO; struct load_weight *load = \u0026p-\u003ese.load; // SCHED_IDLE 拥有最低权重 if (idle_policy(p-\u003epolicy)) { load-\u003eweight = scale_load(WEIGHT_IDLEPRIO); load-\u003einv_weight = WMULT_IDLEPRIO; return; } if (update_load \u0026\u0026 p-\u003esched_class == \u0026fair_sched_class) { reweight_task(p, prio); } else { load-\u003eweight = scale_load(sched_prio_to_weight[prio]); load-\u003einv_weight = sched_prio_to_wmult[prio]; } } 3.1.1 不需更新权重 load-\u003eweight = scale_load(sched_prio_to_weight[prio]); load-\u003einv_weight = sched_prio_to_wmult[prio]; 3.1.2 需要更新权重 void reweight_task(struct task_struct *p, int prio) { struct sched_entity *se = \u0026p-\u003ese; struct cfs_rq *cfs_rq = cfs_rq_of(se); struct load_weight *load = \u0026se-\u003eload; unsigned long weight = scale_load(sched_prio_to_weight[prio]); reweight_entity(cfs_rq, se, weight, weight); load-\u003einv_weight = sched_prio_to_wmult[prio]; } static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, unsigned long weight, unsigned long runnable) { if (se-\u003eon_rq) { /* commit outstanding execution time */ if (cfs_rq-\u003ecurr == se) update_curr(cfs_rq); account_entity_dequeue(cfs_rq, se); dequeue_runnable_load_avg(cfs_rq, se); } dequeue_load_avg(cfs_rq, se); se-\u003erunnable_weight = runnable; update_load_set(\u0026se-\u003eload, weight); enqueue_load_avg(cfs_rq, se); if (se-\u003eon_rq) { account_entity_enqueue(cfs_rq, se); enqueue_runnable_load_avg(cfs_rq, se); } } ","date":"2021-11-14","objectID":"/schedulepriority/:3:1","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#设置负载权重"},{"categories":[],"content":" 3.1 设置负载权重 const int sched_prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; const u32 sched_prio_to_wmult[40] = { /* -20 */ 48388, 59856, 76040, 92818, 118348, /* -15 */ 147320, 184698, 229616, 287308, 360437, /* -10 */ 449829, 563644, 704093, 875809, 1099582, /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, }; static void set_load_weight(struct task_struct *p, bool update_load) { int prio = p-\u003estatic_prio - MAX_RT_PRIO; struct load_weight *load = \u0026p-\u003ese.load; // SCHED_IDLE 拥有最低权重 if (idle_policy(p-\u003epolicy)) { load-\u003eweight = scale_load(WEIGHT_IDLEPRIO); load-\u003einv_weight = WMULT_IDLEPRIO; return; } if (update_load \u0026\u0026 p-\u003esched_class == \u0026fair_sched_class) { reweight_task(p, prio); } else { load-\u003eweight = scale_load(sched_prio_to_weight[prio]); load-\u003einv_weight = sched_prio_to_wmult[prio]; } } 3.1.1 不需更新权重 load-\u003eweight = scale_load(sched_prio_to_weight[prio]); load-\u003einv_weight = sched_prio_to_wmult[prio]; 3.1.2 需要更新权重 void reweight_task(struct task_struct *p, int prio) { struct sched_entity *se = \u0026p-\u003ese; struct cfs_rq *cfs_rq = cfs_rq_of(se); struct load_weight *load = \u0026se-\u003eload; unsigned long weight = scale_load(sched_prio_to_weight[prio]); reweight_entity(cfs_rq, se, weight, weight); load-\u003einv_weight = sched_prio_to_wmult[prio]; } static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, unsigned long weight, unsigned long runnable) { if (se-\u003eon_rq) { /* commit outstanding execution time */ if (cfs_rq-\u003ecurr == se) update_curr(cfs_rq); account_entity_dequeue(cfs_rq, se); dequeue_runnable_load_avg(cfs_rq, se); } dequeue_load_avg(cfs_rq, se); se-\u003erunnable_weight = runnable; update_load_set(\u0026se-\u003eload, weight); enqueue_load_avg(cfs_rq, se); if (se-\u003eon_rq) { account_entity_enqueue(cfs_rq, se); enqueue_runnable_load_avg(cfs_rq, se); } } ","date":"2021-11-14","objectID":"/schedulepriority/:3:1","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#不需更新权重"},{"categories":[],"content":" 3.1 设置负载权重 const int sched_prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; const u32 sched_prio_to_wmult[40] = { /* -20 */ 48388, 59856, 76040, 92818, 118348, /* -15 */ 147320, 184698, 229616, 287308, 360437, /* -10 */ 449829, 563644, 704093, 875809, 1099582, /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, }; static void set_load_weight(struct task_struct *p, bool update_load) { int prio = p-\u003estatic_prio - MAX_RT_PRIO; struct load_weight *load = \u0026p-\u003ese.load; // SCHED_IDLE 拥有最低权重 if (idle_policy(p-\u003epolicy)) { load-\u003eweight = scale_load(WEIGHT_IDLEPRIO); load-\u003einv_weight = WMULT_IDLEPRIO; return; } if (update_load \u0026\u0026 p-\u003esched_class == \u0026fair_sched_class) { reweight_task(p, prio); } else { load-\u003eweight = scale_load(sched_prio_to_weight[prio]); load-\u003einv_weight = sched_prio_to_wmult[prio]; } } 3.1.1 不需更新权重 load-\u003eweight = scale_load(sched_prio_to_weight[prio]); load-\u003einv_weight = sched_prio_to_wmult[prio]; 3.1.2 需要更新权重 void reweight_task(struct task_struct *p, int prio) { struct sched_entity *se = \u0026p-\u003ese; struct cfs_rq *cfs_rq = cfs_rq_of(se); struct load_weight *load = \u0026se-\u003eload; unsigned long weight = scale_load(sched_prio_to_weight[prio]); reweight_entity(cfs_rq, se, weight, weight); load-\u003einv_weight = sched_prio_to_wmult[prio]; } static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, unsigned long weight, unsigned long runnable) { if (se-\u003eon_rq) { /* commit outstanding execution time */ if (cfs_rq-\u003ecurr == se) update_curr(cfs_rq); account_entity_dequeue(cfs_rq, se); dequeue_runnable_load_avg(cfs_rq, se); } dequeue_load_avg(cfs_rq, se); se-\u003erunnable_weight = runnable; update_load_set(\u0026se-\u003eload, weight); enqueue_load_avg(cfs_rq, se); if (se-\u003eon_rq) { account_entity_enqueue(cfs_rq, se); enqueue_runnable_load_avg(cfs_rq, se); } } ","date":"2021-11-14","objectID":"/schedulepriority/:3:1","series":null,"tags":[],"title":"调度优先级","uri":"/schedulepriority/#需要更新权重"},{"categories":[],"content":" dwl桌面环境","date":"2021-11-07","objectID":"/dwl/:0:0","series":null,"tags":[],"title":"dwl","uri":"/dwl/#dwl桌面环境"},{"categories":[],"content":" 1 编译流程 ","date":"2021-11-07","objectID":"/dwl/:1:0","series":null,"tags":[],"title":"dwl","uri":"/dwl/#编译流程"},{"categories":[],"content":" 2 setup void setup(void) { /* The Wayland display is managed by libwayland. It handles accepting * clients from the Unix socket, manging Wayland globals, and so on. */ dpy = wl_display_create(); /* Set up signal handlers */ sigchld(0); signal(SIGINT, quitsignal); signal(SIGTERM, quitsignal); /* The backend is a wlroots feature which abstracts the underlying input and * output hardware. The autocreate option will choose the most suitable * backend based on the current environment, such as opening an X11 window * if an X11 server is running. The NULL argument here optionally allows you * to pass in a custom renderer if wlr_renderer doesn't meet your needs. The * backend uses the renderer, for example, to fall back to software cursors * if the backend does not support hardware cursors (some older GPUs * don't). */ if (!(backend = wlr_backend_autocreate(dpy))) BARF(\"couldn't create backend\"); /* If we don't provide a renderer, autocreate makes a GLES2 renderer for us. * The renderer is responsible for defining the various pixel formats it * supports for shared memory, this configures that for clients. */ drw = wlr_backend_get_renderer(backend); wlr_renderer_init_wl_display(drw, dpy); /* This creates some hands-off wlroots interfaces. The compositor is * necessary for clients to allocate surfaces and the data device manager * handles the clipboard. Each of these wlroots interfaces has room for you * to dig your fingers in and play with their behavior if you want. Note that * the clients cannot set the selection directly without compositor approval, * see the setsel() function. */ compositor = wlr_compositor_create(dpy, drw); wlr_export_dmabuf_manager_v1_create(dpy); wlr_screencopy_manager_v1_create(dpy); wlr_data_control_manager_v1_create(dpy); wlr_data_device_manager_create(dpy); wlr_gamma_control_manager_v1_create(dpy); wlr_primary_selection_v1_device_manager_create(dpy); wlr_viewporter_create(dpy); /* Initializes the interface used to implement urgency hints */ activation = wlr_xdg_activation_v1_create(dpy); wl_signal_add(\u0026activation-\u003eevents.request_activate, \u0026request_activate); /* Creates an output layout, which a wlroots utility for working with an * arrangement of screens in a physical layout. */ output_layout = wlr_output_layout_create(); wl_signal_add(\u0026output_layout-\u003eevents.change, \u0026layout_change); wlr_xdg_output_manager_v1_create(dpy, output_layout); /* Configure a listener to be notified when new outputs are available on the * backend. */ wl_list_init(\u0026mons); wl_signal_add(\u0026backend-\u003eevents.new_output, \u0026new_output); /* Set up our client lists and the xdg-shell. The xdg-shell is a * Wayland protocol which is used for application windows. For more * detail on shells, refer to the article: * * https://drewdevault.com/2018/07/29/Wayland-shells.html */ wl_list_init(\u0026clients); wl_list_init(\u0026fstack); wl_list_init(\u0026stack); wl_list_init(\u0026independents); idle = wlr_idle_create(dpy); layer_shell = wlr_layer_shell_v1_create(dpy); wl_signal_add(\u0026layer_shell-\u003eevents.new_surface, \u0026new_layer_shell_surface); xdg_shell = wlr_xdg_shell_create(dpy); wl_signal_add(\u0026xdg_shell-\u003eevents.new_surface, \u0026new_xdg_surface); /* Use decoration protocols to negotiate server-side decorations */ wlr_server_decoration_manager_set_default_mode( wlr_server_decoration_manager_create(dpy), WLR_SERVER_DECORATION_MANAGER_MODE_SERVER); wlr_xdg_decoration_manager_v1_create(dpy); /* * Creates a cursor, which is a wlroots utility for tracking the cursor * image shown on screen. */ cursor = wlr_cursor_create(); wlr_cursor_attach_output_layout(cursor, output_layout); /* Creates an xcursor manager, another wlroots utility which loads up * Xcursor themes to source cursor images from and makes sure that cursor * images are available at all scale factors on the screen (necessary for * HiDPI support). Scaled cursors will be loaded with each output. */ cursor_mgr = wlr_xcursor_manager_create(NULL, 24); /* * wlr_cursor *only* displays an image on screen. It does not move around","date":"2021-11-07","objectID":"/dwl/:2:0","series":null,"tags":[],"title":"dwl","uri":"/dwl/#setup"},{"categories":[],"content":" 3 run void run(char *startup_cmd) { pid_t startup_pid = -1; /* Add a Unix socket to the Wayland display. */ const char *socket = wl_display_add_socket_auto(dpy); if (!socket) BARF(\"startup: display_add_socket_auto\"); setenv(\"WAYLAND_DISPLAY\", socket, 1); /* Now that the socket exists, run the startup command */ if (startup_cmd) { int piperw[2]; pipe(piperw); startup_pid = fork(); if (startup_pid \u003c 0) EBARF(\"startup: fork\"); if (startup_pid == 0) { dup2(piperw[0], STDIN_FILENO); close(piperw[1]); execl(\"/bin/sh\", \"/bin/sh\", \"-c\", startup_cmd, NULL); EBARF(\"startup: execl\"); } dup2(piperw[1], STDOUT_FILENO); close(piperw[0]); } /* If nobody is reading the status output, don't terminate */ signal(SIGPIPE, SIG_IGN); printstatus(); /* Start the backend. This will enumerate outputs and inputs, become the DRM * master, etc */ if (!wlr_backend_start(backend)) BARF(\"startup: backend_start\"); /* Now that outputs are initialized, choose initial selmon based on * cursor position, and set default cursor image */ selmon = xytomon(cursor-\u003ex, cursor-\u003ey); /* TODO hack to get cursor to display in its initial location (100, 100) * instead of (0, 0) and then jumping. still may not be fully * initialized, as the image/coordinates are not transformed for the * monitor when displayed here */ wlr_cursor_warp_closest(cursor, NULL, cursor-\u003ex, cursor-\u003ey); wlr_xcursor_manager_set_cursor_image(cursor_mgr, \"left_ptr\", cursor); /* Run the Wayland event loop. This does not return until you exit the * compositor. Starting the backend rigged up all of the necessary event * loop configuration to listen to libinput events, DRM events, generate * frame events at the refresh rate, and so on. */ wl_display_run(dpy); if (startup_cmd) { kill(startup_pid, SIGTERM); waitpid(startup_pid, NULL, 0); } } ","date":"2021-11-07","objectID":"/dwl/:3:0","series":null,"tags":[],"title":"dwl","uri":"/dwl/#run"},{"categories":[],"content":" 4 cleanup void cleanup(void) { #ifdef XWAYLAND wlr_xwayland_destroy(xwayland); #endif wl_display_destroy_clients(dpy); wlr_backend_destroy(backend); wlr_xcursor_manager_destroy(cursor_mgr); wlr_cursor_destroy(cursor); wlr_output_layout_destroy(output_layout); wlr_seat_destroy(seat); wl_display_destroy(dpy); } ","date":"2021-11-07","objectID":"/dwl/:4:0","series":null,"tags":[],"title":"dwl","uri":"/dwl/#cleanup"},{"categories":[],"content":" TinyCC TinyCC (aka TCC) is a small but hyper fast C compiler. Unlike other C compilers, it is meant to be self-relying: you do not need an external assembler or linker because TCC does that for you. ","date":"2021-11-07","objectID":"/tinycc/:0:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#tinycc"},{"categories":[],"content":" 1 TCC 执行概览TCC组成代码 文件名 解释 tcc.c/libtcc.c tcc运行代码 tccpp.c tccelf.c tcccoff.c tccasm.c tccrun.c tccgen.c x86_64-gen.c x86_64-link.c i386-asm.c 不同架构的生成器 ","date":"2021-11-07","objectID":"/tinycc/:1:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#tcc-执行概览"},{"categories":[],"content":" 2 TCC状态信息 struct TCCState { unsigned char verbose; /* if true, display some information during compilation */ unsigned char nostdinc; /* if true, no standard headers are added */ unsigned char nostdlib; /* if true, no standard libraries are added */ unsigned char nocommon; /* if true, do not use common symbols for .bss data */ unsigned char static_link; /* if true, static linking is performed */ unsigned char rdynamic; /* if true, all symbols are exported */ unsigned char symbolic; /* if true, resolve symbols in the current module first */ unsigned char filetype; /* file type for compilation (NONE,C,ASM) */ unsigned char optimize; /* only to #define __OPTIMIZE__ */ unsigned char option_pthread; /* -pthread option */ unsigned char enable_new_dtags; /* -Wl,--enable-new-dtags */ unsigned int cversion; /* supported C ISO version, 199901 (the default), 201112, ... */ /* C language options */ unsigned char char_is_unsigned; unsigned char leading_underscore; unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */ unsigned char dollars_in_identifiers; /* allows '$' char in identifiers */ unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */ /* warning switches */ unsigned char warn_none; unsigned char warn_all; unsigned char warn_error; unsigned char warn_write_strings; unsigned char warn_unsupported; unsigned char warn_implicit_function_declaration; unsigned char warn_discarded_qualifiers; #define WARN_ON 1 /* warning is on (-Woption) */ unsigned char warn_num; /* temp var for tcc_warning_c() */ unsigned char option_r; /* option -r */ unsigned char do_bench; /* option -bench */ unsigned char just_deps; /* option -M */ unsigned char gen_deps; /* option -MD */ unsigned char include_sys_deps; /* option -MD */ /* compile with debug symbol (and use them if error during execution) */ unsigned char do_debug; unsigned char do_backtrace; #ifdef CONFIG_TCC_BCHECK /* compile with built-in memory and bounds checker */ unsigned char do_bounds_check; #endif unsigned char test_coverage; /* generate test coverage code */ /* use GNU C extensions */ unsigned char gnu_ext; /* use TinyCC extensions */ unsigned char tcc_ext; unsigned char dflag; /* -dX value */ unsigned char Pflag; /* -P switch (LINE_MACRO_OUTPUT_FORMAT) */ #ifdef TCC_TARGET_X86_64 unsigned char nosse; /* For -mno-sse support. */ #endif #ifdef TCC_TARGET_ARM unsigned char float_abi; /* float ABI of the generated code*/ #endif unsigned char has_text_addr; addr_t text_addr; /* address of text section */ unsigned section_align; /* section alignment */ #ifdef TCC_TARGET_I386 int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */ #endif char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */ char *soname; /* as specified on the command line (-soname) */ char *rpath; /* as specified on the command line (-Wl,-rpath=) */ char *init_symbol; /* symbols to call at load-time (not used currently) */ char *fini_symbol; /* symbols to call at unload-time (not used currently) */ /* output type, see TCC_OUTPUT_XXX */ int output_type; /* output format, see TCC_OUTPUT_FORMAT_xxx */ int output_format; /* nth test to run with -dt -run */ int run_test; /* array of all loaded dlls (including those referenced by loaded dlls) */ DLLReference **loaded_dlls; int nb_loaded_dlls; /* include paths */ char **include_paths; int nb_include_paths; char **sysinclude_paths; int nb_sysinclude_paths; /* library paths */ char **library_paths; int nb_library_paths; /* crt?.o object path */ char **crt_paths; int nb_crt_paths; /* -D / -U options */ CString cmdline_defs; /* -include options */ CString cmdline_incl; /* error handling */ void *error_opaque; void (*error_func)(void *opaque, const char *msg); int error_set_jmp_enabled; jmp_buf error_jmp_buf; int nb_errors; /* output file for preprocessing (-E) */ FILE *ppfp; /* for -MD/-MF: collected dependencies for this compilation */ char **target_deps; int nb_target_deps; /* compilation */ BufferedFile","date":"2021-11-07","objectID":"/tinycc/:2:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#tcc状态信息"},{"categories":[],"content":" 3 文件读取","date":"2021-11-07","objectID":"/tinycc/:3:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#文件读取"},{"categories":[],"content":" 3.1 文件描述信息 typedef struct BufferedFile { uint8_t *buf_ptr; uint8_t *buf_end; int fd; struct BufferedFile *prev; int line_num; /* current line number - here to simplify code */ int line_ref; /* tcc -E: last printed line */ int ifndef_macro; /* #ifndef macro / #endif search */ int ifndef_macro_saved; /* saved ifndef_macro */ int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */ int include_next_index; /* next search path */ char filename[1024]; /* filename */ char *true_filename; /* filename not modified by # line directive */ unsigned char unget[4]; unsigned char buffer[1]; /* extra size for CH_EOB char */ } BufferedFile; ","date":"2021-11-07","objectID":"/tinycc/:3:1","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#文件描述信息"},{"categories":[],"content":" 3.2 文件相关操作 static int _tcc_open(TCCState *s1, const char *filename) { int fd; if (strcmp(filename, \"-\") == 0) fd = 0, filename = \"\u003cstdin\u003e\"; else fd = open(filename, O_RDONLY | O_BINARY); if ((s1-\u003everbose == 2 \u0026\u0026 fd \u003e= 0) || s1-\u003everbose == 3) printf(\"%s %*s%s\\n\", fd \u003c 0 ? \"nf\":\"-\u003e\", (int)(s1-\u003einclude_stack_ptr - s1-\u003einclude_stack), \"\", filename); return fd; } ST_FUNC int tcc_open(TCCState *s1, const char *filename) { int fd = _tcc_open(s1, filename); if (fd \u003c 0) return -1; tcc_open_bf(s1, filename, 0); file-\u003efd = fd; return 0; } ST_FUNC void tcc_close(void) { TCCState *s1 = tcc_state; BufferedFile *bf = file; if (bf-\u003efd \u003e 0) { close(bf-\u003efd); total_lines += bf-\u003eline_num; } if (bf-\u003etrue_filename != bf-\u003efilename) tcc_free(bf-\u003etrue_filename); file = bf-\u003eprev; tcc_free(bf); } ","date":"2021-11-07","objectID":"/tinycc/:3:2","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#文件相关操作"},{"categories":[],"content":" 4 词法分析","date":"2021-11-07","objectID":"/tinycc/:4:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#词法分析"},{"categories":[],"content":" 5 语法分析","date":"2021-11-07","objectID":"/tinycc/:5:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#语法分析"},{"categories":[],"content":" 6 类型检查","date":"2021-11-07","objectID":"/tinycc/:6:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#类型检查"},{"categories":[],"content":" 7 符号表","date":"2021-11-07","objectID":"/tinycc/:7:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#符号表"},{"categories":[],"content":" 8 段机制","date":"2021-11-07","objectID":"/tinycc/:8:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#段机制"},{"categories":[],"content":" 9 代码生成","date":"2021-11-07","objectID":"/tinycc/:9:0","series":null,"tags":[],"title":"Tinycc","uri":"/tinycc/#代码生成"},{"categories":[],"content":" 个人服务器安装记录","date":"2021-11-05","objectID":"/server/:0:0","series":null,"tags":[],"title":"Server","uri":"/server/#个人服务器安装记录"},{"categories":[],"content":" 1 配置交换文件 # 创建交换文件 sudo fallocate -l 2G /swapfile # 修改权限只允许ROOT使用 sudo chmod 600 /swapfile # 创建swapfile sudo mkswap /swapfile # 开启swapfile sudo swapon /swapfile # 写入fstab echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab ","date":"2021-11-05","objectID":"/server/:1:0","series":null,"tags":[],"title":"Server","uri":"/server/#配置交换文件"},{"categories":[],"content":" 2 jenkins安装","date":"2021-11-05","objectID":"/server/:2:0","series":null,"tags":[],"title":"Server","uri":"/server/#jenkins安装"},{"categories":[],"content":" 2.1 安装jdk sudo apt install default-jdk ","date":"2021-11-05","objectID":"/server/:2:1","series":null,"tags":[],"title":"Server","uri":"/server/#安装jdk"},{"categories":[],"content":" 2.2 安装jenkins wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - sudo sh -c 'echo deb https://pkg.jenkins.io/debian-stable binary/ \u003e /etc/apt/sources.list.d/jenkins.list' sudo apt-get update sudo apt-get install jenkins ","date":"2021-11-05","objectID":"/server/:2:2","series":null,"tags":[],"title":"Server","uri":"/server/#安装jenkins"},{"categories":[],"content":" 3 docker安装","date":"2021-11-05","objectID":"/server/:3:0","series":null,"tags":[],"title":"Server","uri":"/server/#docker安装"},{"categories":[],"content":" 3.1 安装依赖 sudo apt install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common ","date":"2021-11-05","objectID":"/server/:3:1","series":null,"tags":[],"title":"Server","uri":"/server/#安装依赖"},{"categories":[],"content":" 3.2 安装公钥 curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - ","date":"2021-11-05","objectID":"/server/:3:2","series":null,"tags":[],"title":"Server","uri":"/server/#安装公钥"},{"categories":[],"content":" 3.3 设置仓库 sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\ $(lsb_release -cs) \\ stable\" ","date":"2021-11-05","objectID":"/server/:3:3","series":null,"tags":[],"title":"Server","uri":"/server/#设置仓库"},{"categories":[],"content":" 3.4 安装Docker sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io ","date":"2021-11-05","objectID":"/server/:3:4","series":null,"tags":[],"title":"Server","uri":"/server/#安装docker"},{"categories":[],"content":" 3.5 添加root组 sudo usermod -aG docker `whoami` ","date":"2021-11-05","objectID":"/server/:3:5","series":null,"tags":[],"title":"Server","uri":"/server/#添加root组"},{"categories":[],"content":" 3.6 docker辅助工具 docker-compose lazydocker ","date":"2021-11-05","objectID":"/server/:3:6","series":null,"tags":[],"title":"Server","uri":"/server/#docker辅助工具"},{"categories":[],"content":" 4 嵌入式开发工具链","date":"2021-11-05","objectID":"/server/:4:0","series":null,"tags":[],"title":"Server","uri":"/server/#嵌入式开发工具链"},{"categories":[],"content":" 4.1 arm编译工具链 sudo apt install gcc-arm-linux-gnueabihf sudo apt install gcc-arm-linux-gnueabi sudo apt install gcc-arm-none-eabi ","date":"2021-11-05","objectID":"/server/:4:1","series":null,"tags":[],"title":"Server","uri":"/server/#arm编译工具链"},{"categories":[],"content":" 4.2 测试工具 sudo apt install qemu sudo apt install qemu-system-arm sudo apt install qemu-user-static sudo apt install qemu-user sudo apt install qemu-user-binfmt ","date":"2021-11-05","objectID":"/server/:4:2","series":null,"tags":[],"title":"Server","uri":"/server/#测试工具"},{"categories":[],"content":" 4.3 打包工具 sudo apt install u-boot-tools ","date":"2021-11-05","objectID":"/server/:4:3","series":null,"tags":[],"title":"Server","uri":"/server/#打包工具"},{"categories":[],"content":" bsdiff bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u003e sorting (specifically, Larsson and Sadakane’s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) – 直接摘抄自官网 详情可以查看bsdiff官网,存在这个详细描述. ","date":"2021-10-30","objectID":"/bsdiff/:0:0","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#bsdiff"},{"categories":[],"content":" 1 测试新建立两个文件old.c与new.c,二者的差别是 // new.c #include \u003cstdio.h\u003e int main(void) { printf(\"Hello World\\r\\n\"); return 0; } #include \u003cstdio.h\u003e int main(void) { return 0; } 测试的情况 # 执行编译 gcc old.c -o old \u0026\u0026 ./old gcc new.c -o new \u0026\u0026 ./new 计算md5 md5sum old # d08fd167e74f279522fe8aa64d8e27dd old md5sum new # b0b4be993de61064a118d32a692bf795 new md5sum mid # b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试 # 生成diff bsdiff old new test.diff # 打入补丁--\u003emid bspatch old mid test.diff ","date":"2021-10-30","objectID":"/bsdiff/:1:0","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#测试"},{"categories":[],"content":" 2 分析","date":"2021-10-30","objectID":"/bsdiff/:2:0","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#分析"},{"categories":[],"content":" 2.1 接口分析 struct bsdiff_stream { void* opaque; /* bzip文件 */ void* (*malloc)(size_t size); /* 内存申请接口 */ void (*free)(void* ptr); /* 内存释放接口 */ int (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ const void* buffer, int size); }; struct bspatch_stream { void* opaque; /* bzip文件 */ int (*read)(const struct bspatch_stream* stream, /* 读取文件接口 */ void* buffer, int length); }; int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream); int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream); ","date":"2021-10-30","objectID":"/bsdiff/:2:1","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#接口分析"},{"categories":[],"content":" 2.2 diff算法核心bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 2.2.1 Header的结构: start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2021-10-30","objectID":"/bsdiff/:2:2","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#diff算法核心"},{"categories":[],"content":" 2.2 diff算法核心bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 2.2.1 Header的结构: start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2021-10-30","objectID":"/bsdiff/:2:2","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#header的结构"},{"categories":[],"content":" 2.3 代码分析 2.3.1 偏移信息与字符串信息相互转化 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } static void offtout(int64_t x,uint8_t *buf) { int64_t y; /* 保证 y = |x| */ if (x \u003c 0) { y = -x; } else { y = x; } buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2021-10-30","objectID":"/bsdiff/:2:3","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#代码分析"},{"categories":[],"content":" 2.3 代码分析 2.3.1 偏移信息与字符串信息相互转化 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } static void offtout(int64_t x,uint8_t *buf) { int64_t y; /* 保证 y = |x| */ if (x \u003c 0) { y = -x; } else { y = x; } buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2021-10-30","objectID":"/bsdiff/:2:3","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#偏移信息与字符串信息相互转化"},{"categories":[],"content":" 2.4 patch代码分析总体的执行路径 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i\u003cctrl[0];i++) if((oldpos+i\u003e=0) \u0026\u0026 (oldpos+i\u003coldsize)) new[newpos+i]+=old[oldpos+i]; /* Adjust pointers */ newpos+=ctrl[0]; oldpos+=ctrl[0]; /* Sanity-check */ if(newpos+ctrl[1]\u003enewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } 主要函数的调用路线 2.4.1 qsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解 参数分析: I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; for(i=0;i\u003c256;i++) buckets[i]=0; for(i=0;i\u003coldsize;i++) buckets[old[i]]++; for(i=1;i\u003c256;i++) buckets[i]+=buckets[i-1]; for(i=255;i\u003e0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i\u003coldsize;i++) I[++buckets[old[i]]]=i; I[0]=oldsize; for(i=0;i\u003coldsize;i++) V[i]=buckets[old[i]]; V[oldsize]=0; for(i=1;i\u003c256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; I[0]=-1; for(h=1;I[0]!=-(oldsize+1);h+=h) { len=0; for(i=0;i\u003coldsize+1;) { if(I[i]\u003c0) { len-=I[i]; i-=I[i]; } else { if(len) I[i-len]=-len; len=V[I[i]]+1-i; split(I,V,i,len,h); i+=len; len=0; }; }; if(len) I[i-len]=-len; }; for(i=0;i\u003coldsize+1;i++) I[V[i]]=i; } static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k\u003cstart+len;k+=j) { j=1;x=V[I[k]+h]; for(i=1;k+i\u003cstart+len;i++) { if(V[I[k+i]+h]\u003cx) { x=V[I[k+i]+h]; j=0; }; if(V[I[k+i]+h]==x) { tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; j++; }; }; for(i=0;i\u003cj;i++) V[I[k+i]]=k+j-1; if(j==1) I[k]=-1; }; return; }; x=V[I[start+len/2]+h]; jj=0;kk=0; for(i=start;i\u003cstart+len;i++) { if(V[I[i]+h]\u003cx) jj++; if(V[I[i]+h]==x) kk++; }; jj+=start;kk+=jj; i=start;j=0;k=0; while(i\u003cjj) { if(V[I[i]+h]\u003cx) { i++; } else if(V[I[i]+h]==x) { tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; j++; } else { tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; k++; }; }; while(jj+j\u003ckk) { if(V[I[jj+j]+h]==x) { j++; } else { tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; k++; }; }; if(jj\u003estart) split(I,V,start,jj-start,h); for(i=0;i\u003ckk-jj;i++) V[I[jj+i]]=kk-1; if(jj==kk-1) I[jj]=-1; if(start+len\u003ekk) split(I,V,kk,start+len-kk,h); } 2.4.2 search static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i\u003coldsize)\u0026\u0026(i\u003cnewsize);i++) if(old[i]!=new[i]) break; return i; } static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, const uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) { int64_t x,y; if(en-st\u003c2) { x=matchlen(old+I[st],oldsize-I[st],new,newsize); y=matchlen(old+I[en],oldsize-I[en],new,newsize); if(x\u003ey) { *pos=I[st]; return x; } else { *pos=I[en]; return y; } }; x=st+(en-st)/2; if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u003c0) { return search(I,old,oldsize,new,newsize,x,en,pos); } else { return search(I,old,oldsize,new,newsize,st,x,pos); }; } ","date":"2021-10-30","objectID":"/bsdiff/:2:4","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#patch代码分析"},{"categories":[],"content":" 2.4 patch代码分析总体的执行路径 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } 主要函数的调用路线 2.4.1 qsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解 参数分析: I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; for(i=0;i\u003c256;i++) buckets[i]=0; for(i=0;i0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i","date":"2021-10-30","objectID":"/bsdiff/:2:4","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#qsufsort"},{"categories":[],"content":" 2.4 patch代码分析总体的执行路径 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } 主要函数的调用路线 2.4.1 qsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解 参数分析: I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; for(i=0;i\u003c256;i++) buckets[i]=0; for(i=0;i0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i","date":"2021-10-30","objectID":"/bsdiff/:2:4","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#search"},{"categories":[],"content":" 2.5 writedata static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { int64_t result = 0; while (length \u003e 0) { const int smallsize = (int)MIN(length, INT_MAX); const int writeresult = stream-\u003ewrite(stream, buffer, smallsize); if (writeresult == -1) { return -1; } result += writeresult; length -= smallsize; buffer = (uint8_t*)buffer + smallsize; } return result; } ","date":"2021-10-30","objectID":"/bsdiff/:2:5","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#writedata"},{"categories":[],"content":" 2.6 diff文件生成核心代码 struct bsdiff_request { const uint8_t* old; int64_t oldsize; const uint8_t* new; int64_t newsize; struct bsdiff_stream* stream; int64_t *I; uint8_t *buffer; }; static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I,V,req.old,req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan\u003creq.newsize) { oldscore=0; for(scsc=scan+=len;scan\u003creq.newsize;scan++) { len=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 0,req.oldsize,\u0026pos); for(;scsc\u003cscan+len;scsc++) if((scsc+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scsc+lastoffset] == req.new[scsc])) oldscore++; if(((len==oldscore) \u0026\u0026 (len!=0)) || (len\u003eoldscore+8)) break; if((scan+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scan+lastoffset] == req.new[scan])) oldscore--; }; if((len!=oldscore) || (scan==req.newsize)) { s=0;Sf=0;lenf=0; for(i=0;(lastscan+i\u003cscan)\u0026\u0026(lastpos+i\u003creq.oldsize);) { if(req.old[lastpos+i]==req.new[lastscan+i]) s++; i++; if(s*2-i\u003eSf*2-lenf) { Sf=s; lenf=i; }; }; lenb=0; if(scan\u003creq.newsize) { s=0;Sb=0; for(i=1;(scan\u003e=lastscan+i)\u0026\u0026(pos\u003e=i);i++) { if(req.old[pos-i]==req.new[scan-i]) s++; if(s*2-i\u003eSb*2-lenb) { Sb=s; lenb=i; }; }; }; if(lastscan+lenf\u003escan-lenb) { overlap=(lastscan+lenf)-(scan-lenb); s=0;Ss=0;lens=0; for(i=0;i\u003coverlap;i++) { if(req.new[lastscan+lenf-overlap+i]== req.old[lastpos+lenf-overlap+i]) s++; if(req.new[scan-lenb+i]== req.old[pos-lenb+i]) s--; if(s\u003eSs) { Ss=s; lens=i+1; }; }; lenf+=lens-overlap; lenb-=lens; }; offtout(lenf,buf); offtout((scan-lenb)-(lastscan+lenf),buf+8); offtout((pos-lenb)-(lastpos+lenf),buf+16); /* Write control data */ if (writedata(req.stream, buf, sizeof(buf))) return -1; /* Write diff data */ for(i=0;i\u003clenf;i++) buffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; if (writedata(req.stream, buffer, lenf)) return -1; /* Write extra data */ for(i=0;i\u003c(scan-lenb)-(lastscan+lenf);i++) buffer[i]=req.new[lastscan+lenf+i]; if (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) return -1; lastscan=scan-lenb; lastpos=pos-lenb; lastoffset=pos-scan; }; }; return 0; } ","date":"2021-10-30","objectID":"/bsdiff/:2:6","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#diff文件生成核心代码"},{"categories":[],"content":" ARM笔记","date":"2021-10-30","objectID":"/arm/:0:0","series":null,"tags":[],"title":"Arm","uri":"/arm/#arm笔记"},{"categories":[],"content":" 1 ARM体系结构","date":"2021-10-30","objectID":"/arm/:1:0","series":null,"tags":[],"title":"Arm","uri":"/arm/#arm体系结构"},{"categories":[],"content":" 1.1 相关术语 流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE ","date":"2021-10-30","objectID":"/arm/:1:1","series":null,"tags":[],"title":"Arm","uri":"/arm/#相关术语"},{"categories":[],"content":" 1.2 工具链 文件名 详解 addr2line 把程序地址转化为文件名和行号 ar 建立、修改和提取归档文件 as 汇编编译器 ld 链接器 nm 列出文件的符号 objcopy 文件个数格式转换 objdump 反汇编 ranlib 产生索引,并且保存进入文件中 readelf 显示elf文件信息 size 列出文件大小 string 打印文件可打印字符串 strip 丢弃文件符号 交叉工具链测试 arm-none-linux-gnueabihf-addr2line arm-none-linux-gnueabihf-gdb arm-none-linux-gnueabihf-ar arm-none-linux-gnueabihf-gdb-add-index arm-none-linux-gnueabihf-as arm-none-linux-gnueabihf-gfortran arm-none-linux-gnueabihf-c++ arm-none-linux-gnueabihf-gprof arm-none-linux-gnueabihf-c++filt arm-none-linux-gnueabihf-ld arm-none-linux-gnueabihf-cpp arm-none-linux-gnueabihf-ld.bfd arm-none-linux-gnueabihf-dwp arm-none-linux-gnueabihf-ld.gold arm-none-linux-gnueabihf-elfedit arm-none-linux-gnueabihf-lto-dump arm-none-linux-gnueabihf-g++ arm-none-linux-gnueabihf-nm arm-none-linux-gnueabihf-gcc arm-none-linux-gnueabihf-objcopy arm-none-linux-gnueabihf-gcc-10.2.1 arm-none-linux-gnueabihf-objdump arm-none-linux-gnueabihf-gcc-ar arm-none-linux-gnueabihf-ranlib arm-none-linux-gnueabihf-gcc-nm arm-none-linux-gnueabihf-readelf arm-none-linux-gnueabihf-gcc-ranlib arm-none-linux-gnueabihf-size arm-none-linux-gnueabihf-gcov arm-none-linux-gnueabihf-strings arm-none-linux-gnueabihf-gcov-dump arm-none-linux-gnueabihf-strip arm-none-linux-gnueabihf-gcov-tool ","date":"2021-10-30","objectID":"/arm/:1:2","series":null,"tags":[],"title":"Arm","uri":"/arm/#工具链"},{"categories":[],"content":" 1.3 ARMv7处理器模式 模式 编码 功能 安全 优先级 User (USR) 10000 大多数运行的非特权模式 Both PL0 FIQ 10001 FIQ中断 Both PL1 IRQ 10010 IRQ中断 Both PL1 Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1 Monitor (MON) 10110 安全扩展实现 only PL1 Abort (ABT) 10111 内存权限异常 Both PL1 Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2 Undef (UND) 11011 未定义指令调用 Both PL1 System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1 不同的处理器模式上寄存器共享的情况 ","date":"2021-10-30","objectID":"/arm/:1:3","series":null,"tags":[],"title":"Arm","uri":"/arm/#armv7处理器模式"},{"categories":[],"content":" 2 ARM指令集","date":"2021-10-30","objectID":"/arm/:2:0","series":null,"tags":[],"title":"Arm","uri":"/arm/#arm指令集"},{"categories":[],"content":" 3 翻译结果","date":"2021-10-30","objectID":"/arm/:3:0","series":null,"tags":[],"title":"Arm","uri":"/arm/#翻译结果"},{"categories":[],"content":" 3.1 统一汇编语言","date":"2021-10-30","objectID":"/arm/:3:1","series":null,"tags":[],"title":"Arm","uri":"/arm/#统一汇编语言"},{"categories":[],"content":" 3.2 分支指令","date":"2021-10-30","objectID":"/arm/:3:2","series":null,"tags":[],"title":"Arm","uri":"/arm/#分支指令"},{"categories":[],"content":" 3.3 数据处理指令 指令 作用 LSL Logical Shift Left by 1-31 bits. LSR Logical Shift Right by 1-32 bits. ASR Arithmetic Shift Right by 1-32 bits. ROR Rotate Right by 1-31 bits. RRX Rotate Right with Extend. ","date":"2021-10-30","objectID":"/arm/:3:3","series":null,"tags":[],"title":"Arm","uri":"/arm/#数据处理指令"},{"categories":[],"content":" 3.4 状态寄存器访问指令","date":"2021-10-30","objectID":"/arm/:3:4","series":null,"tags":[],"title":"Arm","uri":"/arm/#状态寄存器访问指令"},{"categories":[],"content":" 3.5 加载存储指令","date":"2021-10-30","objectID":"/arm/:3:5","series":null,"tags":[],"title":"Arm","uri":"/arm/#加载存储指令"},{"categories":[],"content":" 3.6 加载存储多条指令","date":"2021-10-30","objectID":"/arm/:3:6","series":null,"tags":[],"title":"Arm","uri":"/arm/#加载存储多条指令"},{"categories":[],"content":" 3.7 杂项指令","date":"2021-10-30","objectID":"/arm/:3:7","series":null,"tags":[],"title":"Arm","uri":"/arm/#杂项指令"},{"categories":[],"content":" 3.8 异常生成与处理指令","date":"2021-10-30","objectID":"/arm/:3:8","series":null,"tags":[],"title":"Arm","uri":"/arm/#异常生成与处理指令"},{"categories":[],"content":" 3.9 协处理器指令","date":"2021-10-30","objectID":"/arm/:3:9","series":null,"tags":[],"title":"Arm","uri":"/arm/#协处理器指令"},{"categories":[],"content":" 3.10 SIMD指令","date":"2021-10-30","objectID":"/arm/:3:10","series":null,"tags":[],"title":"Arm","uri":"/arm/#simd指令"},{"categories":["linux"],"content":" IDLE调度器类 /* * Generic entry points for the idle threads and * implementation of the idle task scheduling class. * * (NOTE: these are not related to SCHED_IDLE batch scheduled * tasks which are handled in sched/fair.c ) */ #include \"sched.h\" #include \u003ctrace/events/power.h\u003e /* Linker adds these: start and end of __cpuidle functions */ extern char __cpuidle_text_start[], __cpuidle_text_end[]; /** * sched_idle_set_state - Record idle state for the current CPU. * @idle_state: State to record. */ void sched_idle_set_state(struct cpuidle_state *idle_state) { idle_set_state(this_rq(), idle_state); } static int __read_mostly cpu_idle_force_poll; void cpu_idle_poll_ctrl(bool enable) { if (enable) { cpu_idle_force_poll++; } else { cpu_idle_force_poll--; WARN_ON_ONCE(cpu_idle_force_poll \u003c 0); } } #ifdef CONFIG_GENERIC_IDLE_POLL_SETUP static int __init cpu_idle_poll_setup(char *__unused) { cpu_idle_force_poll = 1; return 1; } __setup(\"nohlt\", cpu_idle_poll_setup); static int __init cpu_idle_nopoll_setup(char *__unused) { cpu_idle_force_poll = 0; return 1; } __setup(\"hlt\", cpu_idle_nopoll_setup); #endif static noinline int __cpuidle cpu_idle_poll(void) { rcu_idle_enter(); trace_cpu_idle_rcuidle(0, smp_processor_id()); local_irq_enable(); stop_critical_timings(); while (!tif_need_resched() \u0026\u0026 (cpu_idle_force_poll || tick_check_broadcast_expired())) cpu_relax(); start_critical_timings(); trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id()); rcu_idle_exit(); return 1; } /* Weak implementations for optional arch specific functions */ void __weak arch_cpu_idle_prepare(void) { } void __weak arch_cpu_idle_enter(void) { } void __weak arch_cpu_idle_exit(void) { } void __weak arch_cpu_idle_dead(void) { } void __weak arch_cpu_idle(void) { cpu_idle_force_poll = 1; local_irq_enable(); } /** * default_idle_call - Default CPU idle routine. * * To use when the cpuidle framework cannot be used. */ void __cpuidle default_idle_call(void) { if (current_clr_polling_and_test()) { local_irq_enable(); } else { stop_critical_timings(); arch_cpu_idle(); start_critical_timings(); } } static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev, int next_state) { /* * The idle task must be scheduled, it is pointless to go to idle, just * update no idle residency and return. */ if (current_clr_polling_and_test()) { dev-\u003elast_residency = 0; local_irq_enable(); return -EBUSY; } /* * Enter the idle state previously returned by the governor decision. * This function will block until an interrupt occurs and will take * care of re-enabling the local interrupts */ return cpuidle_enter(drv, dev, next_state); } /** * cpuidle_idle_call - the main idle function * * NOTE: no locks or semaphores should be used here * * On archs that support TIF_POLLING_NRFLAG, is called with polling * set, and it returns with polling set. If it ever stops polling, it * must clear the polling bit. */ static void cpuidle_idle_call(void) { struct cpuidle_device *dev = cpuidle_get_device(); struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev); int next_state, entered_state; /* * Check if the idle task must be rescheduled. If it is the * case, exit the function after re-enabling the local irq. */ if (need_resched()) { local_irq_enable(); return; } /* * The RCU framework needs to be told that we are entering an idle * section, so no more rcu read side critical sections and one more * step to the grace period */ if (cpuidle_not_available(drv, dev)) { tick_nohz_idle_stop_tick(); rcu_idle_enter(); default_idle_call(); goto exit_idle; } /* * Suspend-to-idle (\"s2idle\") is a system state in which all user space * has been frozen, all I/O devices have been suspended and the only * activity happens here and in iterrupts (if any). In that case bypass * the cpuidle governor and go stratight for the deepest idle state * available. Possibly also suspend the local tick and the entire * timekeeping to prevent timer interrupts from kicking us out of idle * until a proper wakeup interrupt ha","date":"2021-10-28","objectID":"/idle/:0:0","series":null,"tags":["kernel"],"title":"Idle","uri":"/idle/#idle调度器类"},{"categories":["linux"],"content":" 完全公平调度器 const struct sched_class fair_sched_class = { .next = \u0026idle_sched_class, .enqueue_task = enqueue_task_fair, .dequeue_task = dequeue_task_fair, .yield_task = yield_task_fair, .yield_to_task = yield_to_task_fair, .check_preempt_curr = check_preempt_wakeup, .pick_next_task = pick_next_task_fair, .put_prev_task = put_prev_task_fair, #ifdef CONFIG_SMP .select_task_rq = select_task_rq_fair, .migrate_task_rq = migrate_task_rq_fair, .rq_online = rq_online_fair, .rq_offline = rq_offline_fair, .task_dead = task_dead_fair, .set_cpus_allowed = set_cpus_allowed_common, #endif .set_curr_task = set_curr_task_fair, .task_tick = task_tick_fair, .task_fork = task_fork_fair, .prio_changed = prio_changed_fair, .switched_from = switched_from_fair, .switched_to = switched_to_fair, .get_rr_interval = get_rr_interval_fair, .update_curr = update_curr_fair, #ifdef CONFIG_FAIR_GROUP_SCHED .task_change_group = task_change_group_fair, #endif }; 调度器类分析 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf); void (*put_prev_task)(struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int new_cpu); void (*task_woken)(struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task)(struct rq *rq); void (*task_tick)(struct rq *rq, struct task_struct *p, int queued); void (*task_fork)(struct task_struct *p); void (*task_dead)(struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from)(struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval)(struct rq *rq, struct task_struct *task); void (*update_curr)(struct rq *rq); #define TASK_SET_GROUP 0 #define TASK_MOVE_GROUP 1 #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_change_group)(struct task_struct *p, int type); #endif }; ","date":"2021-10-28","objectID":"/fair/:0:0","series":null,"tags":["kernel"],"title":"Fair","uri":"/fair/#完全公平调度器"},{"categories":["linux"],"content":" 1 enqueue_task_fair static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; /* * The code below (indirectly) updates schedutil which looks at * the cfs_rq utilization to select a frequency. * Let's add the task's estimated utilization to the cfs_rq's * estimated utilization, before we update schedutil. */ util_est_enqueue(\u0026rq-\u003ecfs, p); /* * If in_iowait is set, the code below may not trigger any cpufreq * utilization updates, so do it here explicitly with the IOWAIT flag * passed. */ if (p-\u003ein_iowait) cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); for_each_sched_entity(se) { if (se-\u003eon_rq) break; cfs_rq = cfs_rq_of(se); enqueue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running increment below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running++; flags = ENQUEUE_WAKEUP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running++; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) add_nr_running(rq, 1); if (cfs_bandwidth_used()) { /* * When bandwidth control is enabled; the cfs_rq_throttled() * breaks in the above iteration can result in incomplete * leaf list maintenance, resulting in triggering the assertion * below. */ for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); if (list_add_leaf_cfs_rq(cfs_rq)) break; } } assert_list_leaf_cfs_rq(rq); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/fair/:1:0","series":null,"tags":["kernel"],"title":"Fair","uri":"/fair/#enqueue_task_fair"},{"categories":["linux"],"content":" 2 dequeue_task_fair static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; int task_sleep = flags \u0026 DEQUEUE_SLEEP; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); dequeue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running decrement below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running--; /* Don't dequeue parent if it has other entities besides us */ if (cfs_rq-\u003eload.weight) { /* Avoid re-evaluating load for this entity: */ se = parent_entity(se); /* * Bias pick_next to pick a task from this cfs_rq, as * p is sleeping when it is within its sched_slice. */ if (task_sleep \u0026\u0026 se \u0026\u0026 !throttled_hierarchy(cfs_rq)) set_next_buddy(se); break; } flags |= DEQUEUE_SLEEP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running--; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) sub_nr_running(rq, 1); util_est_dequeue(\u0026rq-\u003ecfs, p, task_sleep); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/fair/:2:0","series":null,"tags":["kernel"],"title":"Fair","uri":"/fair/#dequeue_task_fair"},{"categories":["linux"],"content":" 3 yield_task_fair","date":"2021-10-28","objectID":"/fair/:3:0","series":null,"tags":["kernel"],"title":"Fair","uri":"/fair/#yield_task_fair"},{"categories":["linux"],"content":" 4 yield_to_task_fair","date":"2021-10-28","objectID":"/fair/:4:0","series":null,"tags":["kernel"],"title":"Fair","uri":"/fair/#yield_to_task_fair"},{"categories":["python"],"content":"python基础绘图 ","date":"2021-10-16","objectID":"/tkinter/:0:0","series":null,"tags":[],"title":"Tkinter","uri":"/tkinter/#"},{"categories":["前端知识"],"content":"CSS3基础教程","date":"2021-10-07","objectID":"/css/","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/"},{"categories":["前端知识"],"content":" 1 基础知识 Cascading Style Sheets(层叠样式表) HTML + CSS + JavaScript =\u003e 名词 + 形容词 + 动词 CSS可以认为对原始的HTML进行美化 ","date":"2021-10-07","objectID":"/css/:1:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#基础知识"},{"categories":["前端知识"],"content":" 1.1 快速入门 CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画 ","date":"2021-10-07","objectID":"/css/:1:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#快速入门"},{"categories":["前端知识"],"content":" 1.2 什么是CSS美化:字体, 颜色,高度,宽度, 背景图片 ","date":"2021-10-07","objectID":"/css/:1:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#什么是css"},{"categories":["前端知识"],"content":" 1.3 CSS的优势 内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件 ","date":"2021-10-07","objectID":"/css/:1:3","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#css的优势"},{"categories":["前端知识"],"content":" 1.4 CSS导入的方法 行内样式 \u003ch1 style=\"color: red\"\u003e一级标题\u003c/h1\u003e style标签 \u003cstyle\u003e\u003c/style\u003e 外部样式 链接方式 \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e 导入式 \u003cstyle\u003e @import url(\"css/style.css\"); \u003c/style\u003e ","date":"2021-10-07","objectID":"/css/:1:4","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#css导入的方法"},{"categories":["前端知识"],"content":" 1.5 基本语法 /* 注释语法 */ selector { /* 声明 */ attr:value; } 下面的代码可以直接修改背景颜色 \u003cstyle\u003e body { background-color:gray; } \u003c/style\u003e CSS基本操作 选中元素(选择某一类或者某一个) 属性修改(修改一个或者多个) ","date":"2021-10-07","objectID":"/css/:1:5","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#基本语法"},{"categories":["前端知识"],"content":" 2 选择器 选择某一类或者某一个元素 ","date":"2021-10-07","objectID":"/css/:2:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 \u003ch1 class=\"test\"\u003e测试\u003c/h1\u003e 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 \u003ch1 id=\"test\"\u003e测试\u003c/h1\u003e #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#基本选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#标签选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#类选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#id选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 \u003cp class=\"active\"\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp id=\"test\"\u003ep3\u003c/p\u003e \u003cp\u003ep4\u003c/p\u003e \u003cstyle\u003e .active+p { color: red; } #test+p { color: blue; } \u003c/style\u003e 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 \u003cp\u003ep1\u003c/p\u003e \u003cp class=\"hello\"\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cstyle\u003e .hello~{ color: red; } \u003c/style\u003e p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp id=\"test\"\u003ep7\u003c/p\u003e \u003cp\u003ep8\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#高级选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#层次选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#后代选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#子选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#相邻兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#通用兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#结构伪类选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#属性选择器"},{"categories":["前端知识"],"content":" 3 CSS属性 选中元素开始设置属性 ","date":"2021-10-07","objectID":"/css/:3:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#css属性"},{"categories":["前端知识"],"content":" 3.1 属性基础 字体样式 文本样式 文本阴影 超链接 列表样式 背景 span标签强调,这是一个标签, div标签,分块 \u003c!-- 字体样式 --\u003e \u003cstyle\u003e body { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-style: oblique; } \u003c/style\u003e font-family; 字体设置 font-size 字体大小 font-style 字体风格 ","date":"2021-10-07","objectID":"/css/:3:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#属性基础"},{"categories":["前端知识"],"content":" 3.2 属性提高 盒子模型与边框 ","date":"2021-10-07","objectID":"/css/:3:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#属性提高"},{"categories":["前端知识"],"content":"html5基础教程","date":"2021-10-07","objectID":"/html5/","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/"},{"categories":["前端知识"],"content":" 1 网页结构 hugo中markdown可以直接渲染html,可以直接得到效果 但是网页基础结构却不可以编写,这样会破坏渲染过程 \u003c!-- 告诉浏览器,需要使用的规范 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 网页标题 --\u003e \u003chead\u003e \u003c!-- 描述标签 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页标题 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 网页主体 --\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e www规范\r注释的写法 \u003c!-- 注释 --\u003e html: 网页 head: 标题标签 meta: 网站信息 body: 网页主题 meta标签处于head区,对用户不可见,用于对网页进行描述,一般SEO优化 \u003chead\u003e \u003cmeta name=\"description\" content=\"前端基础\"\u003e \u003cmeta name=\"keywords\" content=\"HTML,CSS,JavaScript\"\u003e \u003cmeta name=\"author\" content=\"孟德茂\"\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c/head\u003e ","date":"2021-10-07","objectID":"/html5/:1:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#网页结构"},{"categories":["前端知识"],"content":" 2 基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号标签 ","date":"2021-10-07","objectID":"/html5/:2:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#基本标签"},{"categories":["前端知识"],"content":" 2.1 标题标签 \u003ch1\u003e一级标签\u003c/h1\u003e 一级标签\r\u003ch2\u003e二级标签\u003c/h2\u003e 二级标签\r\u003ch3\u003e三级标签\u003c/h3\u003e 三级标签\r\u003ch4\u003e四级标签\u003c/h4\u003e 四级标签\r\u003ch5\u003e五级标签\u003c/h5\u003e 五级标签\r\u003ch6\u003e六级标签\u003c/h6\u003e 六级标签\r","date":"2021-10-07","objectID":"/html5/:2:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#标题标签"},{"categories":["前端知识"],"content":" 2.2 段落标签 \u003cp\u003e段落标签\u003c/p\u003e 显示如下: 我是一个段落 我又是一个段落 ","date":"2021-10-07","objectID":"/html5/:2:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#段落标签"},{"categories":["前端知识"],"content":" 2.3 换行标签 \u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:2:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#换行标签"},{"categories":["前端知识"],"content":" 2.4 水平线标签 \u003chr/\u003e 我在水平线标签上方 我在水平线标签下方 ","date":"2021-10-07","objectID":"/html5/:2:4","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#水平线标签"},{"categories":["前端知识"],"content":" 2.5 字体样式标签 \u003c!-- 字体样式标签 --\u003e 普通文本\u003cspan\u003e无效果\u003c/span\u003e\u003c/br\u003e 普通文本\u003cb\u003e加粗\u003c/b\u003e\u003c/br\u003e 普通文本\u003cstrong\u003e粗体\u003c/strong\u003e\u003c/br\u003e 普通文本\u003ci\u003e斜体\u003c/i\u003e\u003c/br\u003e 普通文本\u003cem\u003e斜体\u003c/em\u003e\u003c/br\u003e 普通文本\u003cu\u003e下划线\u003c/u\u003e\u003c/br\u003e 普通文本\u003cins\u003e下划线\u003c/ins\u003e\u003c/br\u003e 普通文本\u003cs\u003e删除线\u003c/s\u003e\u003c/br\u003e 普通文本\u003cdel\u003e删除线\u003c/del\u003e\u003c/br\u003e 普通文本\u003csub\u003e下标文本\u003c/sub\u003e\u003c/br\u003e 普通文本\u003csup\u003e上标文本\u003c/sup\u003e\u003c/br\u003e 普通文本无效果 普通文本加粗 普通文本粗体 普通文本斜体 普通文本斜体 普通文本下划线 普通文本下划线 普通文本删除线 普通文本删除线 普通文本下标文本 普通文本上标文本 ","date":"2021-10-07","objectID":"/html5/:2:5","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#字体样式标签"},{"categories":["前端知识"],"content":" 3 图片标签 \u003cimg src=\"测试.png\" alt=\"测试\" title=\"测试\"/\u003e ","date":"2021-10-07","objectID":"/html5/:3:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#图片标签"},{"categories":["前端知识"],"content":" 4 链接 \u003c!-- 当前页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_self\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e \u003c!-- 新建页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:4:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#链接"},{"categories":["前端知识"],"content":" 5 行内元素和块元素","date":"2021-10-07","objectID":"/html5/:5:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#行内元素和块元素"},{"categories":["前端知识"],"content":" 6 列表标签","date":"2021-10-07","objectID":"/html5/:6:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#列表标签"},{"categories":["前端知识"],"content":" 6.1 有序列表 \u003col\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ol\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:6:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#有序列表"},{"categories":["前端知识"],"content":" 6.2 无序列表 \u003cul\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ul\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:6:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#无序列表"},{"categories":["前端知识"],"content":" 6.3 定义列表 \u003cdl\u003e \u003cdt\u003e前端\u003c/dt\u003e \u003cdd\u003ehtml\u003c/dd\u003e \u003cdd\u003eCSS\u003c/dd\u003e \u003cdd\u003eJavaScript\u003c/dd\u003e \u003c/dl\u003e 前端\rhtml\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:6:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#定义列表"},{"categories":["前端知识"],"content":" 7 表格 \u003ctable border=\"1px\"\u003e \u003ctr\u003e \u003ctd\u003e1-1\u003c/td\u003e \u003ctd\u003e1-2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2-1\u003c/td\u003e \u003ctd\u003e2-2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 1-1\r1-2\r2-1\r2-2\r","date":"2021-10-07","objectID":"/html5/:7:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表格"},{"categories":["前端知识"],"content":" 8 页面结构分析 元素名 描述 header 标题头部区域 footer 标记尾部内容 section web页面中一块独立的区域 article 独立文章内容 aside 相关页面或者内容 nav 导航类辅助内容 ","date":"2021-10-07","objectID":"/html5/:8:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#页面结构分析"},{"categories":["前端知识"],"content":" 9 iframe内联框架 \u003ciframe src=\"path\" name=\"mainFrame\"\u003e\u003c/frame\u003e bilibili的例子 \u003ciframe src=\"//player.bilibili.com/player.html?aid=55631961\u0026bvid=BV1x4411V75C\u0026cid=97257967\u0026page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e \u003c/iframe\u003e ","date":"2021-10-07","objectID":"/html5/:9:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#iframe内联框架"},{"categories":["前端知识"],"content":" 10 表单 \u003cform action=\"submit.html\" method=\"GET/POST\"\u003e \u003cp\u003e名字: \u003cinput type=\"text\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003e密码: \u003cinput type=\"password\" name=\"password\"\u003e\u003c/p\u003e \u003cp\u003e \u003cinput type=\"submit\"\u003e \u003cinput type=\"reset\"\u003e \u003c/p\u003e \u003c/form\u003e 出入账户和密码,点击按钮会触发相应的 动作http://url/html5/submit.html?name=mengdemao\u0026password=1234, 但是此时会显示失败,因为没有处理函数. 名字: 密码: ","date":"2021-10-07","objectID":"/html5/:10:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表单"},{"categories":[],"content":" A C dynamic strings library C语言版本动态字符串库 ","date":"2021-10-06","objectID":"/sds/:0:0","series":null,"tags":[],"title":"Sds","uri":"/sds/#"},{"categories":[],"content":" 1 SDSSDS的类型就是 typedef char *sds; 可以明显的看到,sds就是普通的char类型 ","date":"2021-10-06","objectID":"/sds/:1:0","series":null,"tags":[],"title":"Sds","uri":"/sds/#sds"},{"categories":[],"content":" 1.1 下面是sds的数据类型 +--------+-------------------------------+-----------+ | Header | Binary safe C alike string... | Null term | +--------+-------------------------------+-----------+ | -\u003e Pointer returned to the user. #define SDS_HDR_VAR(T,s) \\ struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); #define SDS_HDR(T,s) \\ ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) #define SDS_TYPE_5_LEN(f) ((f)\u003e\u003eSDS_TYPE_BITS) ","date":"2021-10-06","objectID":"/sds/:1:1","series":null,"tags":[],"title":"Sds","uri":"/sds/#下面是sds的数据类型"},{"categories":[],"content":" 1.2 SDS 头根据不同的标志计算不同的头部数据 宏定义 标志 SDS_TYPE_5 sdshdr5 SDS_TYPE_8 sdshdr8 SDS_TYPE_16 sdshdr16 SDS_TYPE_32 sdshdr32 SDS_TYPE_64 sdshdr64 flag标志: unsigned char flags = s[-1]; /* 最后一个头部数据 */ #define SDS_TYPE_5 0 #define SDS_TYPE_8 1 #define SDS_TYPE_16 2 #define SDS_TYPE_32 3 #define SDS_TYPE_64 4 /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; #define SDS_TYPE_MASK 7 #define SDS_TYPE_BITS 3 ","date":"2021-10-06","objectID":"/sds/:1:2","series":null,"tags":[],"title":"Sds","uri":"/sds/#sds-头"},{"categories":[],"content":" 2 创建SDS函数原型 sds sdsnewlen(const void *init, size_t initlen); ","date":"2021-10-06","objectID":"/sds/:2:0","series":null,"tags":[],"title":"Sds","uri":"/sds/#创建sds"},{"categories":[],"content":" 3 扩张字符串缓存区 sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh; void *newsh; size_t avail = sdsavail(s); /* 计算剩余的可以使用的大小 */ size_t len; size_t newlen; char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; int hdrlen; if (avail \u003e= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ return s; } len = sdslen(s); /* 计算字符串大小 */ sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ /* 计算得到新的长度 */ newlen = (len+addlen); if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; /* 重新生成类型 */ type = sdsReqType(newlen); /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) { type = SDS_TYPE_8; } /* 计算头部大小 */ hdrlen = sdsHdrSize(type); if (oldtype == type) { newsh = s_realloc(sh, hdrlen + newlen + 1); if (newsh == NULL) { return NULL; } s = (char*)newsh + hdrlen; } else { /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc(hdrlen+newlen+1); if (newsh == NULL) { return NULL; } memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); } sdssetalloc(s, newlen); return s; } ","date":"2021-10-06","objectID":"/sds/:3:0","series":null,"tags":[],"title":"Sds","uri":"/sds/#扩张字符串缓存区"},{"categories":[],"content":" 4 追加字符串 sds sdscatlen(sds s, const void *t, size_t len) { size_t curlen = sdslen(s); /* 计算字符串的长度 */ s = sdsMakeRoomFor(s,len); /* 扩展字符串缓冲区长度 */ if (s == NULL) { return NULL; } memcpy(s+curlen, t, len); /* 添加字符串 */ sdssetlen(s, curlen+len); /* 设置长度标志 */ s[curlen+len] = '\\0'; /* 补全结束符 */ return s; } ","date":"2021-10-06","objectID":"/sds/:4:0","series":null,"tags":[],"title":"Sds","uri":"/sds/#追加字符串"},{"categories":[],"content":" STL称为标准模板库(Standard Template Library) 广义上可以分为容器,算法,迭代器 容器和算法通过迭代器进行无缝连接 STL几乎所有的代码都采用了函数模版或者类模板 ","date":"2021-10-06","objectID":"/stl/:0:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#"},{"categories":[],"content":" 1 STL组件 序号 名称 解释 1 容器 各种数据结构 2 算法 各种常用的算法 3 迭代器 容器域算法的胶合 4 仿函数 行为类似函数 5 适配器 修饰容器或者仿函数迭代器 6 空间配置器 负责空间的配置和管理 ","date":"2021-10-06","objectID":"/stl/:1:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#stl组件"},{"categories":[],"content":" 2 容器算法和迭代器","date":"2021-10-06","objectID":"/stl/:2:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#容器算法和迭代器"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector\u003cint\u003e v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector\u003cint\u003e::iterator itBegin = v.begin(); vector\u003cint\u003e::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector\u003cint\u003e::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template \u003cclass T\u003e void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint\u003cint\u003e); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector\u003cvector\u003cint\u003e\u003ev; // 外部大容器 vector\u003cint\u003e vx[10]; // 内部小容器 /* 插入容器 */ for (int i = 0; i \u003c 10; i++) { for (int j = 0; j \u003c 30; j++) { vx[i].push_back(i + j + 10); } v.push_back(vx[i]); } /* 遍历容器 */ for (vector\u003cvector\u003cint\u003e\u003e::iterator it = v.begin(); it != v.end(); it++) { for (vector\u003cint\u003e::iterator vit = it-\u003ebegin(); vit != it-\u003eend(); vit++) { cout \u003c\u003c *vit \u003c\u003c \" \"; } cout \u003c\u003c endl; } ","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#vector"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#vector使用"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#迭代器使用"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#迭代器方案1"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#迭代器2"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#遍历算法"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#容器自定义数据"},{"categories":[],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#容器嵌套容器"},{"categories":[],"content":" 2.2 stringstring本质上是一个类,封装了char*,提供了许多的成员方法; 2.2.1 构造函数 string s1(str); string s2 = \"Hello World\"; string s3(s2); ","date":"2021-10-06","objectID":"/stl/:2:2","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#string"},{"categories":[],"content":" 2.2 stringstring本质上是一个类,封装了char*,提供了许多的成员方法; 2.2.1 构造函数 string s1(str); string s2 = \"Hello World\"; string s3(s2); ","date":"2021-10-06","objectID":"/stl/:2:2","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#构造函数"},{"categories":[],"content":" 2.3 赋值操作 重载操作符**=** string s1; s1 = \"Hello World\"; 成员函数assign string str; str.assign(\"Hello World\"); ","date":"2021-10-06","objectID":"/stl/:2:3","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#赋值操作"},{"categories":[],"content":" 2.4 追加操作 重载操作符**+=** 成员函数append ","date":"2021-10-06","objectID":"/stl/:2:4","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#追加操作"},{"categories":[],"content":" 2.5 查找和替换 2.5.1 find 2.5.2 replace","date":"2021-10-06","objectID":"/stl/:2:5","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#查找和替换"},{"categories":[],"content":" 2.5 查找和替换 2.5.1 find 2.5.2 replace","date":"2021-10-06","objectID":"/stl/:2:5","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#find"},{"categories":[],"content":" 2.5 查找和替换 2.5.1 find 2.5.2 replace","date":"2021-10-06","objectID":"/stl/:2:5","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#replace"},{"categories":[],"content":" 2.6 比较 2.6.1 compare","date":"2021-10-06","objectID":"/stl/:2:6","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#比较"},{"categories":[],"content":" 2.6 比较 2.6.1 compare","date":"2021-10-06","objectID":"/stl/:2:6","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#compare"},{"categories":[],"content":" 2.7 字符存取 [] at ","date":"2021-10-06","objectID":"/stl/:2:7","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#字符存取"},{"categories":[],"content":" 2.8 插入和删除 2.8.1 insert 2.8.2 earse","date":"2021-10-06","objectID":"/stl/:2:8","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#插入和删除"},{"categories":[],"content":" 2.8 插入和删除 2.8.1 insert 2.8.2 earse","date":"2021-10-06","objectID":"/stl/:2:8","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#insert"},{"categories":[],"content":" 2.8 插入和删除 2.8.1 insert 2.8.2 earse","date":"2021-10-06","objectID":"/stl/:2:8","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#earse"},{"categories":[],"content":" 2.9 子串 2.9.1 substr","date":"2021-10-06","objectID":"/stl/:2:9","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#子串"},{"categories":[],"content":" 2.9 子串 2.9.1 substr","date":"2021-10-06","objectID":"/stl/:2:9","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#substr"},{"categories":[],"content":" 3 array","date":"2021-10-06","objectID":"/stl/:3:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#array"},{"categories":[],"content":" 4 deque","date":"2021-10-06","objectID":"/stl/:4:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#deque"},{"categories":[],"content":" 5 hashtable","date":"2021-10-06","objectID":"/stl/:5:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#hashtable"},{"categories":[],"content":" 6 map","date":"2021-10-06","objectID":"/stl/:6:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#map"},{"categories":[],"content":" 7 list","date":"2021-10-06","objectID":"/stl/:7:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#list"},{"categories":[],"content":" 8 queue","date":"2021-10-06","objectID":"/stl/:8:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#queue"},{"categories":[],"content":" 9 stack","date":"2021-10-06","objectID":"/stl/:9:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#stack"},{"categories":[],"content":" 10 set","date":"2021-10-06","objectID":"/stl/:10:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#set"},{"categories":[],"content":" 11 rbtree","date":"2021-10-06","objectID":"/stl/:11:0","series":null,"tags":[],"title":"STL学习笔记","uri":"/stl/#rbtree"},{"categories":[],"content":" 1 HelloWorld #!/bin/python3 if __name__ == '__main__': print('Hello World') ","date":"2021-10-05","objectID":"/python/:1:0","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#helloworld"},{"categories":[],"content":" 2 数据类型","date":"2021-10-05","objectID":"/python/:2:0","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#数据类型"},{"categories":[],"content":" 2.1 Numbers(数字) intA = 10 print(intA) ","date":"2021-10-05","objectID":"/python/:2:1","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#numbers数字"},{"categories":[],"content":" 2.2 布尔类型 true false 2.2.1 String(字符串) strB = \"Hello\" print(strB) ","date":"2021-10-05","objectID":"/python/:2:2","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#布尔类型"},{"categories":[],"content":" 2.2 布尔类型 true false 2.2.1 String(字符串) strB = \"Hello\" print(strB) ","date":"2021-10-05","objectID":"/python/:2:2","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#string字符串"},{"categories":[],"content":" 2.3 List(列表) listC = [\"12\", 3, 4] print(listC) ","date":"2021-10-05","objectID":"/python/:2:3","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#list列表"},{"categories":[],"content":" 2.4 Tuple(元组) tupleD = ('physics', 'chemistry', 1997, 2000) print(tupleD) ","date":"2021-10-05","objectID":"/python/:2:4","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#tuple元组"},{"categories":[],"content":" 2.5 Dictionary(字典) DictE = {'a': 1, 'b': 2, 'b': '3'} print(DictE) ","date":"2021-10-05","objectID":"/python/:2:5","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#dictionary字典"},{"categories":[],"content":" 3 运算符","date":"2021-10-05","objectID":"/python/:3:0","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#运算符"},{"categories":[],"content":" 4 控制结构","date":"2021-10-05","objectID":"/python/:4:0","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#控制结构"},{"categories":[],"content":" 4.1 条件语句 4.1.1 单执行语句 if 判断条件： 执行语句 else： 执行语句 ","date":"2021-10-05","objectID":"/python/:4:1","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#条件语句"},{"categories":[],"content":" 4.1 条件语句 4.1.1 单执行语句 if 判断条件： 执行语句 else： 执行语句 ","date":"2021-10-05","objectID":"/python/:4:1","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#单执行语句"},{"categories":[],"content":" 4.2 多条件语句 if 判断条件1: 执行语句1…… elif 判断条件2: 执行语句2…… elif 判断条件3: 执行语句3…… else: 执行语句4…… ","date":"2021-10-05","objectID":"/python/:4:2","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#多条件语句"},{"categories":[],"content":" 4.3 while循环 c = 0 while (c \u003c 10): print(c) c += 1 print(\"while Loop finish\") ###　for循环 ","date":"2021-10-05","objectID":"/python/:4:3","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#while循环"},{"categories":[],"content":" 5 函数","date":"2021-10-05","objectID":"/python/:5:0","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#函数"},{"categories":[],"content":" 6 面向对象","date":"2021-10-05","objectID":"/python/:6:0","series":null,"tags":[],"title":"Python学习笔记","uri":"/python/#面向对象"},{"categories":[],"content":"输入子设备分为三层 handle core device ","date":"2021-10-05","objectID":"/input_drive/:0:0","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#"},{"categories":[],"content":" 1 input的相关结构体 struct input_dev { /* 输入设备的描述 */ const char *name; /* 设备名称 */ const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; unsigned int hint_events_per_packet; unsigned int keycodemax; unsigned int keycodesize; void *keycode; int (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode); int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke); struct ff_device *ff; unsigned int repeat_key; struct timer_list timer; int rep[REP_CNT]; struct input_mt *mt; struct input_absinfo *absinfo; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; unsigned long led[BITS_TO_LONGS(LED_CNT)]; unsigned long snd[BITS_TO_LONGS(SND_CNT)]; unsigned long sw[BITS_TO_LONGS(SW_CNT)]; int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle __rcu *grab; spinlock_t event_lock; struct mutex mutex; unsigned int users; bool going_away; struct device dev; struct list_head h_list; struct list_head node; unsigned int num_vals; unsigned int max_vals; struct input_value *vals; bool devres_managed; }; #define to_input_dev(d) container_of(d, struct input_dev, dev) ","date":"2021-10-05","objectID":"/input_drive/:1:0","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#input的相关结构体"},{"categories":[],"content":" 2 input子系统使用","date":"2021-10-05","objectID":"/input_drive/:2:0","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#input子系统使用"},{"categories":[],"content":" 3 input子系统分析 Makefile编写 obj-$(CONFIG_INPUT) += input-core.o input-core-y := input.o input-compat.o input-mt.o ff-core.o 开始判断下面的第一个文件 input.c subsys_initcall(input_init); module_exit(input_exit); 输入子系统的设备号 #define INPUT_MAJOR 13 安装驱动 static int __init input_init(void) { int err; /* 注册设备类 */ err = class_register(\u0026input_class); if (err) { pr_err(\"unable to register input_dev class\\n\"); return err; } /* 注册proc文件系统 */ err = input_proc_init(); if (err) goto fail1; /* 注册设备 */ err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES, \"input\"); if (err) { pr_err(\"unable to register char major %d\", INPUT_MAJOR); goto fail2; } return 0; fail2: input_proc_exit(); fail1: class_unregister(\u0026input_class); return err; } 卸载驱动 static void __exit input_exit(void) { /* 卸载proc文件系统 */ input_proc_exit(); /* 注销设备号 */ unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES); /* 注销CLass */ class_unregister(\u0026input_class); } 设备类操作 /* 设备类型 */ struct class input_class = { .name = \"input\", .devnode = input_devnode, }; EXPORT_SYMBOL_GPL(input_class); /* 注册设备 */ err = class_register(\u0026input_class); if (err) { pr_err(\"unable to register input_dev class\\n\"); return err; } /* 卸载设备 */ class_unregister(\u0026input_class); Proc文件系统操作 Proc文件系统添加 static int __init input_proc_init(void) { struct proc_dir_entry *entry; proc_bus_input_dir = proc_mkdir(\"bus/input\", NULL); if (!proc_bus_input_dir) return -ENOMEM; entry = proc_create(\"devices\", 0, proc_bus_input_dir, \u0026input_devices_fileops); if (!entry) goto fail1; entry = proc_create(\"handlers\", 0, proc_bus_input_dir, \u0026input_handlers_fileops); if (!entry) goto fail2; return 0; fail2: remove_proc_entry(\"devices\", proc_bus_input_dir); fail1: remove_proc_entry(\"bus/input\", NULL); return -ENOMEM; } Proc文件系统卸载 static void input_proc_exit(void) { remove_proc_entry(\"devices\", proc_bus_input_dir); remove_proc_entry(\"handlers\", proc_bus_input_dir); remove_proc_entry(\"bus/input\", NULL); } ","date":"2021-10-05","objectID":"/input_drive/:3:0","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#input子系统分析"},{"categories":[],"content":" 4 接口部分","date":"2021-10-05","objectID":"/input_drive/:4:0","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#接口部分"},{"categories":[],"content":" 4.1 Handler操作 /** * 注册 input handler * input_register_handler - register a new input handler * @handler: handler to be registered * * This function registers a new input handler (interface) for input * devices in the system and attaches it to all input devices that * are compatible with the handler. */ int input_register_handler(struct input_handler *handler) { struct input_dev *dev; int error; error = mutex_lock_interruptible(\u0026input_mutex); if (error) return error; INIT_LIST_HEAD(\u0026handler-\u003eh_list); list_add_tail(\u0026handler-\u003enode, \u0026input_handler_list); list_for_each_entry(dev, \u0026input_dev_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(\u0026input_mutex); return 0; } EXPORT_SYMBOL(input_register_handler); /** * 解除注册 input handler * input_unregister_handler - unregisters an input handler * @handler: handler to be unregistered * * This function disconnects a handler from its input devices and * removes it from lists of known handlers. */ void input_unregister_handler(struct input_handler *handler) { struct input_handle *handle, *next; mutex_lock(\u0026input_mutex); list_for_each_entry_safe(handle, next, \u0026handler-\u003eh_list, h_node) handler-\u003edisconnect(handle); WARN_ON(!list_empty(\u0026handler-\u003eh_list)); list_del_init(\u0026handler-\u003enode); input_wakeup_procfs_readers(); mutex_unlock(\u0026input_mutex); } EXPORT_SYMBOL(input_unregister_handler); ","date":"2021-10-05","objectID":"/input_drive/:4:1","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#handler操作"},{"categories":[],"content":" 4.2 注册设备 /** * 注册一个设备 * input_register_device - register device with input core * @dev: device to be registered * * This function registers device with input core. The device must be * allocated with input_allocate_device() and all it's capabilities * set up before registering. * If function fails the device must be freed with input_free_device(). * Once device has been successfully registered it can be unregistered * with input_unregister_device(); input_free_device() should not be * called in this case. * * Note that this function is also used to register managed input devices * (ones allocated with devm_input_allocate_device()). Such managed input * devices need not be explicitly unregistered or freed, their tear down * is controlled by the devres infrastructure. It is also worth noting * that tear down of managed input devices is internally a 2-step process: * registered managed input device is first unregistered, but stays in * memory and can still handle input_event() calls (although events will * not be delivered anywhere). The freeing of managed input device will * happen later, when devres stack is unwound to the point where device * allocation was made. */ int input_register_device(struct input_dev *dev) { struct input_devres *devres = NULL; struct input_handler *handler; unsigned int packet_size; const char *path; int error; if (dev-\u003edevres_managed) { devres = devres_alloc(devm_input_device_unregister, sizeof(struct input_devres), GFP_KERNEL); if (!devres) return -ENOMEM; devres-\u003einput = dev; } /* Every input device generates EV_SYN/SYN_REPORT events. */ __set_bit(EV_SYN, dev-\u003eevbit); /* KEY_RESERVED is not supposed to be transmitted to userspace. */ __clear_bit(KEY_RESERVED, dev-\u003ekeybit); /* Make sure that bitmasks not mentioned in dev-\u003eevbit are clean. */ input_cleanse_bitmasks(dev); packet_size = input_estimate_events_per_packet(dev); if (dev-\u003ehint_events_per_packet \u003c packet_size) dev-\u003ehint_events_per_packet = packet_size; dev-\u003emax_vals = dev-\u003ehint_events_per_packet + 2; dev-\u003evals = kcalloc(dev-\u003emax_vals, sizeof(*dev-\u003evals), GFP_KERNEL); if (!dev-\u003evals) { error = -ENOMEM; goto err_devres_free; } /* * If delay and period are pre-set by the driver, then autorepeating * is handled by the driver itself and we don't do it in input.c. */ if (!dev-\u003erep[REP_DELAY] \u0026\u0026 !dev-\u003erep[REP_PERIOD]) { dev-\u003etimer.data = (long) dev; dev-\u003etimer.function = input_repeat_key; dev-\u003erep[REP_DELAY] = 250; dev-\u003erep[REP_PERIOD] = 33; } if (!dev-\u003egetkeycode) dev-\u003egetkeycode = input_default_getkeycode; if (!dev-\u003esetkeycode) dev-\u003esetkeycode = input_default_setkeycode; error = device_add(\u0026dev-\u003edev); if (error) goto err_free_vals; path = kobject_get_path(\u0026dev-\u003edev.kobj, GFP_KERNEL); pr_info(\"%s as %s\\n\", dev-\u003ename ? dev-\u003ename : \"Unspecified device\", path ? path : \"N/A\"); kfree(path); error = mutex_lock_interruptible(\u0026input_mutex); if (error) goto err_device_del; list_add_tail(\u0026dev-\u003enode, \u0026input_dev_list); list_for_each_entry(handler, \u0026input_handler_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(\u0026input_mutex); if (dev-\u003edevres_managed) { dev_dbg(dev-\u003edev.parent, \"%s: registering %s with devres.\\n\", __func__, dev_name(\u0026dev-\u003edev)); devres_add(dev-\u003edev.parent, devres); } return 0; err_device_del: device_del(\u0026dev-\u003edev); err_free_vals: kfree(dev-\u003evals); dev-\u003evals = NULL; err_devres_free: devres_free(devres); return error; } EXPORT_SYMBOL(input_register_device); /** * 解除注册设备 * input_unregister_device - unregister previously registered device * @dev: device to be unregistered * * This function unregisters an input device. Once device is unregistered * the caller should not try to access it as it may get freed at any moment. */ void input_unregister_device(struct input_dev *dev) { if (dev-\u003edevres_managed) { WARN_ON(devres_destroy(dev-\u003edev.parent, devm_input_device_unregister, devm_input_device_match, dev)); __input_unregister_device(dev); /* * We do not do input_put_device() here because it will be done * when ","date":"2021-10-05","objectID":"/input_drive/:4:2","series":null,"tags":[],"title":"输入子系统","uri":"/input_drive/#注册设备"},{"categories":[],"content":" MMU内存管理单元 ARM内存管理单元分析 ","date":"2021-10-04","objectID":"/mmu/:0:0","series":null,"tags":[],"title":"Mmu","uri":"/mmu/#mmu内存管理单元"},{"categories":[],"content":" fork linux创建线程的函数 fork –\u003e do_fork do_fork的执行线路 do_fork –\u003e copy_process –\u003e get_task_pid –\u003e wake_up_new_task –\u003e put_pid do_fork函数原型 long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); clone_flags stack_start stack_size parent_tidptr child_tidptr tls ","date":"2021-10-04","objectID":"/fork/:0:0","series":null,"tags":[],"title":"Fork","uri":"/fork/#fork"},{"categories":[],"content":" 1 copy_process","date":"2021-10-04","objectID":"/fork/:1:0","series":null,"tags":[],"title":"Fork","uri":"/fork/#copy_process"},{"categories":[],"content":" 2 get_task_pid","date":"2021-10-04","objectID":"/fork/:2:0","series":null,"tags":[],"title":"Fork","uri":"/fork/#get_task_pid"},{"categories":[],"content":" 3 wake_up_new_task","date":"2021-10-04","objectID":"/fork/:3:0","series":null,"tags":[],"title":"Fork","uri":"/fork/#wake_up_new_task"},{"categories":["linux"],"content":" 系统调度 主调度器schedule 周期调度器scheduler_tick ","date":"2021-10-04","objectID":"/sched/:0:0","series":null,"tags":["kernel"],"title":"系统调度","uri":"/sched/#系统调度"},{"categories":["linux"],"content":" 1 周期调度器函数实现 void scheduler_tick(void) { int cpu = smp_processor_id(); // CPUID struct rq *rq = cpu_rq(cpu); // 提取消息队列 struct task_struct *curr = rq-\u003ecurr; // 提取正在运行的进程 struct rq_flags rf; // sched_clock_tick(); // rq_lock(rq, \u0026rf); // update_rq_clock(rq); // 更新运行时钟 curr-\u003esched_class-\u003etask_tick(rq, curr, 0); // 调用调度器类 cpu_load_update_active(rq); calc_global_load_tick(rq); rq_unlock(rq, \u0026rf); perf_event_task_tick(); } ","date":"2021-10-04","objectID":"/sched/:1:0","series":null,"tags":["kernel"],"title":"系统调度","uri":"/sched/#周期调度器函数实现"},{"categories":["linux"],"content":" 2 主调度器函数实现 static void __sched notrace __schedule(bool preempt) { struct task_struct *prev, *next; unsigned long *switch_count; struct rq_flags rf; struct rq *rq; int cpu; cpu = smp_processor_id(); rq = cpu_rq(cpu); prev = rq-\u003ecurr; schedule_debug(prev); if (sched_feat(HRTICK)) hrtick_clear(rq); local_irq_disable(); rcu_note_context_switch(preempt); rq_lock(rq, \u0026rf); smp_mb__after_spinlock(); rq-\u003eclock_update_flags \u003c\u003c= 1; update_rq_clock(rq); switch_count = \u0026prev-\u003enivcsw; if (!preempt \u0026\u0026 prev-\u003estate) { if (unlikely(signal_pending_state(prev-\u003estate, prev))) { prev-\u003estate = TASK_RUNNING; } else { deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK); prev-\u003eon_rq = 0; if (prev-\u003ein_iowait) { atomic_inc(\u0026rq-\u003enr_iowait); delayacct_blkio_start(); } if (prev-\u003eflags \u0026 PF_WQ_WORKER) { struct task_struct *to_wakeup; to_wakeup = wq_worker_sleeping(prev); if (to_wakeup) try_to_wake_up_local(to_wakeup, \u0026rf); } } switch_count = \u0026prev-\u003envcsw; } next = pick_next_task(rq, prev, \u0026rf); clear_tsk_need_resched(prev); clear_preempt_need_resched(); if (likely(prev != next)) { rq-\u003enr_switches++; rq-\u003ecurr = next; ++*switch_count; trace_sched_switch(preempt, prev, next); rq = context_switch(rq, prev, next, \u0026rf); } else { rq-\u003eclock_update_flags \u0026= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); rq_unlock_irq(rq, \u0026rf); } balance_callback(rq); } ","date":"2021-10-04","objectID":"/sched/:2:0","series":null,"tags":["kernel"],"title":"系统调度","uri":"/sched/#主调度器函数实现"},{"categories":["linux"],"content":" 2.1 寻找最高优先级任务 /* * 获取最高优先级的任务: */ static inline struct task_struct *pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) { const struct sched_class *class; // 调度器类 struct task_struct *p; // 任务实体 if (likely((prev-\u003esched_class == \u0026idle_sched_class || prev-\u003esched_class == \u0026fair_sched_class) \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev, rf); if (unlikely(p == RETRY_TASK)) goto again; /* Assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev, rf); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev, rf); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } /* IDLE线程不会退出 */ BUG(); } ","date":"2021-10-04","objectID":"/sched/:2:1","series":null,"tags":["kernel"],"title":"系统调度","uri":"/sched/#寻找最高优先级任务"},{"categories":["linux"],"content":" 2.2 任务切换 static __always_inline struct rq * context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next, struct rq_flags *rf) { struct mm_struct *mm, *oldmm; prepare_task_switch(rq, prev, next); mm = next-\u003emm; oldmm = prev-\u003eactive_mm; /* * For paravirt, this is coupled with an exit in switch_to to * combine the page table reload and the switch backend into * one hypercall. */ arch_start_context_switch(prev); /* * If mm is non-NULL, we pass through switch_mm(). If mm is * NULL, we will pass through mmdrop() in finish_task_switch(). * Both of these contain the full memory barrier required by * membarrier after storing to rq-\u003ecurr, before returning to * user-space. */ if (!mm) { next-\u003eactive_mm = oldmm; mmgrab(oldmm); enter_lazy_tlb(oldmm, next); } else switch_mm_irqs_off(oldmm, mm, next); if (!prev-\u003emm) { prev-\u003eactive_mm = NULL; rq-\u003eprev_mm = oldmm; } rq-\u003eclock_update_flags \u0026= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); prepare_lock_switch(rq, next, rf); /* Here we just switch the register state and the stack. */ switch_to(prev, next, prev); barrier(); return finish_task_switch(prev); } ","date":"2021-10-04","objectID":"/sched/:2:2","series":null,"tags":["kernel"],"title":"系统调度","uri":"/sched/#任务切换"},{"categories":[],"content":" WASM笔记","date":"2021-10-03","objectID":"/wasm/:0:0","series":null,"tags":[],"title":"Wasm","uri":"/wasm/#wasm笔记"},{"categories":[],"content":" jupyter","date":"2021-10-03","objectID":"/jupyter/:0:0","series":null,"tags":[],"title":"Jupyter","uri":"/jupyter/#jupyter"},{"categories":[],"content":" 1 安装 conda install jupyter ","date":"2021-10-03","objectID":"/jupyter/:1:0","series":null,"tags":[],"title":"Jupyter","uri":"/jupyter/#安装"},{"categories":[],"content":" 2 基本配置","date":"2021-10-03","objectID":"/jupyter/:2:0","series":null,"tags":[],"title":"Jupyter","uri":"/jupyter/#基本配置"},{"categories":[],"content":" 2.1 生成配置 jupyter notebook --generate-config 自动生成配置文件 ~/.jupyter/jupyter_notebook_config.py ","date":"2021-10-03","objectID":"/jupyter/:2:1","series":null,"tags":[],"title":"Jupyter","uri":"/jupyter/#生成配置"},{"categories":[],"content":" 2.2 设置密码 jupyter notebook password ","date":"2021-10-03","objectID":"/jupyter/:2:2","series":null,"tags":[],"title":"Jupyter","uri":"/jupyter/#设置密码"},{"categories":[],"content":" 2.3 ","date":"2021-10-03","objectID":"/jupyter/:2:3","series":null,"tags":[],"title":"Jupyter","uri":"/jupyter/#heading"},{"categories":[],"content":"RUST学习笔记 ==== ","date":"2021-10-03","objectID":"/rust/:0:0","series":null,"tags":[],"title":"Rust","uri":"/rust/#"},{"categories":[],"content":" 1 安装 添加环境变量.bashrc/profile set RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static set RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 安装工具链 curl https://mirrors.ustc.edu.cn/rust-static/rustup/rustup-init.sh | sh 设置rust的环境变量.bashrc/profile source ~/.cargo/env set PATH=~/.cargo/bin;$PATH ","date":"2021-10-03","objectID":"/rust/:1:0","series":null,"tags":[],"title":"Rust","uri":"/rust/#安装"},{"categories":[],"content":" 2 入门基础","date":"2021-10-03","objectID":"/rust/:2:0","series":null,"tags":[],"title":"Rust","uri":"/rust/#入门基础"},{"categories":[],"content":" 2.1 HelloWorld 创建工程 cargo new hello_world 编译 cargo build 运行 cargo run ","date":"2021-10-03","objectID":"/rust/:2:1","series":null,"tags":[],"title":"Rust","uri":"/rust/#helloworld"},{"categories":[],"content":" 2.2 数据类型 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize // 创建变量 let _xi32: i32 = 5; let _xu32: u32 = 5; let _xi64: i64 = 10; let _xu64: u64 = 10; let _xi128: i128 = 5; let _xu128: u128 = 5; let _xisize: isize = 10; let _xusize: usize = 10; ","date":"2021-10-03","objectID":"/rust/:2:2","series":null,"tags":[],"title":"Rust","uri":"/rust/#数据类型"},{"categories":[],"content":" 2.3 函数 // 有返回值 fn function_return() -\u003e i32 { println!(\"Hello, World!\"); return 0; } // 无返回值 fn function_noreturn() { println!(\"Hello, World!\"); } 必须明确表示是否存在返回值 语法校验比较严格, ","date":"2021-10-03","objectID":"/rust/:2:3","series":null,"tags":[],"title":"Rust","uri":"/rust/#函数"},{"categories":[],"content":" 2.4 条件语句 if \u003ccond\u003e { do; } if \u003ccond\u003e { Do1; } else { Do2; } if \u003ccond1\u003e { Do1; } else if \u003ccond2\u003e { Do2; } else { Do3; } ","date":"2021-10-03","objectID":"/rust/:2:4","series":null,"tags":[],"title":"Rust","uri":"/rust/#条件语句"},{"categories":["编程语言"],"content":"C++编程基础","date":"2021-10-03","objectID":"/cxx_basic/","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/"},{"categories":["编程语言"],"content":" 1 C++基础语法","date":"2021-10-03","objectID":"/cxx_basic/:1:0","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#c基础语法"},{"categories":["编程语言"],"content":" 1.1 第一个程序 #include \u003ciostream\u003e using namespace std; int main(int argc, char *argv[]) { cout \u003c\u003c \"Hello World\" \u003c\u003c endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:1:1","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#第一个程序"},{"categories":["编程语言"],"content":" 1.2 注释类型 单行注释 // 这个是一个单行注释 多行注释 /* 这个里面是一个注释 */ ","date":"2021-10-03","objectID":"/cxx_basic/:1:2","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#注释类型"},{"categories":["编程语言"],"content":" 1.3 变量变量的存在意义:方便我们管理内存 变量创建的语法 数据类型 变量名 = 变量初始化; ","date":"2021-10-03","objectID":"/cxx_basic/:1:3","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#变量"},{"categories":["编程语言"],"content":" 1.4 常量作用: 记录程序中不可以改变的数据 define 宏常量(预编译期) const 修饰变量(编译期) ","date":"2021-10-03","objectID":"/cxx_basic/:1:4","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#常量"},{"categories":["编程语言"],"content":" 1.5 关键字 关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template ","date":"2021-10-03","objectID":"/cxx_basic/:1:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#关键字"},{"categories":["编程语言"],"content":" 1.6 标识符命名规则 标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写 ","date":"2021-10-03","objectID":"/cxx_basic/:1:6","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#标识符命名规则"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#数据类型"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#整形"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#浮点型"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#字符型"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#转义字符"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#字符串"},{"categories":["编程语言"],"content":" 1.7 数据类型指定类型,分配内存 1.7.1 整形 1.7.2 浮点型 单精度float 双精度double 1.7.3 字符型 1.7.4 转义字符 1.7.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; 1.7.6 布尔类型 bool A = true; bool B = false; ","date":"2021-10-03","objectID":"/cxx_basic/:1:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#布尔类型"},{"categories":["编程语言"],"content":" 1.8 运算符 1.8.1 基本运算符 1.8.2 取模运算就是取余数 1.8.3 自增自减运算 a1++; a2--; ","date":"2021-10-03","objectID":"/cxx_basic/:1:8","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#运算符"},{"categories":["编程语言"],"content":" 1.8 运算符 1.8.1 基本运算符 1.8.2 取模运算就是取余数 1.8.3 自增自减运算 a1++; a2--; ","date":"2021-10-03","objectID":"/cxx_basic/:1:8","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#基本运算符"},{"categories":["编程语言"],"content":" 1.8 运算符 1.8.1 基本运算符 1.8.2 取模运算就是取余数 1.8.3 自增自减运算 a1++; a2--; ","date":"2021-10-03","objectID":"/cxx_basic/:1:8","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#取模运算"},{"categories":["编程语言"],"content":" 1.8 运算符 1.8.1 基本运算符 1.8.2 取模运算就是取余数 1.8.3 自增自减运算 a1++; a2--; ","date":"2021-10-03","objectID":"/cxx_basic/:1:8","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#自增自减运算"},{"categories":["编程语言"],"content":" 1.9 赋值运算 运算符 术语 示例 结果 = += -= *= /= %= ","date":"2021-10-03","objectID":"/cxx_basic/:1:9","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#赋值运算"},{"categories":["编程语言"],"content":" 1.10 比较运算符","date":"2021-10-03","objectID":"/cxx_basic/:1:10","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#比较运算符"},{"categories":["编程语言"],"content":" 1.11 逻辑运算符","date":"2021-10-03","objectID":"/cxx_basic/:1:11","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#逻辑运算符"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#程序流程结构"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#顺序结构"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#if语句"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#三目运算符"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#选择结构"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#循环结构"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#while循环"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#dowhile循环"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#for循环"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#跳转语句"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#break"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#continue"},{"categories":["编程语言"],"content":" 1.12 程序流程结构 1.12.1 顺序结构 1.12.1.1 if语句 1.12.1.2 三目运算符 表达式1? 表达式2:表达式3 1.12.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } 1.12.3 循环结构 1.12.4 while循环 while(条件) { 循环体; } 1.12.5 dowhile循环 do { } while(条件) 1.12.6 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } 1.12.7 跳转语句 1.12.7.1 break 1.12.7.2 continue 1.12.7.3 goto","date":"2021-10-03","objectID":"/cxx_basic/:1:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#goto"},{"categories":["编程语言"],"content":" 1.13 数组","date":"2021-10-03","objectID":"/cxx_basic/:1:13","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#数组"},{"categories":["编程语言"],"content":" 1.14 函数定义 返回值类型 函数名 参数列表 函数体语句 return表达式 返回值类型 函数名字(参数列表) { 函数体语句; return 表达式; } 1.14.1 值传递类似数值拷贝 ","date":"2021-10-03","objectID":"/cxx_basic/:1:14","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数定义"},{"categories":["编程语言"],"content":" 1.14 函数定义 返回值类型 函数名 参数列表 函数体语句 return表达式 返回值类型 函数名字(参数列表) { 函数体语句; return 表达式; } 1.14.1 值传递类似数值拷贝 ","date":"2021-10-03","objectID":"/cxx_basic/:1:14","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#值传递"},{"categories":["编程语言"],"content":" 1.15 函数的常见样式 无参无返 有参无返 无参有反 有参有返 ","date":"2021-10-03","objectID":"/cxx_basic/:1:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数的常见样式"},{"categories":["编程语言"],"content":" 1.16 函数的声明作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现; ","date":"2021-10-03","objectID":"/cxx_basic/:1:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数的声明"},{"categories":["编程语言"],"content":" 1.17 函数的分文件编写","date":"2021-10-03","objectID":"/cxx_basic/:1:17","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数的分文件编写"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#指针"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#指针的定义和使用"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#指针所占用空间"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#空指针"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#野指针"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#const与指针"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#指针与数组"},{"categories":["编程语言"],"content":" 1.18 指针 1.18.1 指针的定义和使用 1.18.2 指针所占用空间 1.18.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 1.18.4 野指针指针指向非法的内存空间 1.18.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 1.18.6 指针与数组 1.18.7 指针与函数","date":"2021-10-03","objectID":"/cxx_basic/:1:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#指针与函数"},{"categories":["编程语言"],"content":" 1.19 结构体 1.19.1 结构体数组 1.19.2 结构体指针 1.19.3 结构体嵌套","date":"2021-10-03","objectID":"/cxx_basic/:1:19","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#结构体"},{"categories":["编程语言"],"content":" 1.19 结构体 1.19.1 结构体数组 1.19.2 结构体指针 1.19.3 结构体嵌套","date":"2021-10-03","objectID":"/cxx_basic/:1:19","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#结构体数组"},{"categories":["编程语言"],"content":" 1.19 结构体 1.19.1 结构体数组 1.19.2 结构体指针 1.19.3 结构体嵌套","date":"2021-10-03","objectID":"/cxx_basic/:1:19","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#结构体指针"},{"categories":["编程语言"],"content":" 1.19 结构体 1.19.1 结构体数组 1.19.2 结构体指针 1.19.3 结构体嵌套","date":"2021-10-03","objectID":"/cxx_basic/:1:19","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#结构体嵌套"},{"categories":["编程语言"],"content":" 2 C++核心编程本阶段主要对面向对象进行详细讲解 ","date":"2021-10-03","objectID":"/cxx_basic/:2:0","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#c核心编程"},{"categories":["编程语言"],"content":" 2.1 C++内存分区c++程序在运行时,将内存分为4个区域 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放 ","date":"2021-10-03","objectID":"/cxx_basic/:2:1","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#c内存分区"},{"categories":["编程语言"],"content":" 2.2 new/delete操作符C++利用new操作符在堆区开辟内存 ","date":"2021-10-03","objectID":"/cxx_basic/:2:2","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#newdelete操作符"},{"categories":["编程语言"],"content":" 2.3 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; 2.3.1 引用做参数 #include \u003ciostream\u003e void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 2.3.2 引用做返回值 2.3.3 引用的本质引用的本质是C++内部实现的一个指针常量 2.3.4 常量引用 const int \u0026ref = 10; ","date":"2021-10-03","objectID":"/cxx_basic/:2:3","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#引用"},{"categories":["编程语言"],"content":" 2.3 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; 2.3.1 引用做参数 #include void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 2.3.2 引用做返回值 2.3.3 引用的本质引用的本质是C++内部实现的一个指针常量 2.3.4 常量引用 const int \u0026ref = 10; ","date":"2021-10-03","objectID":"/cxx_basic/:2:3","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#引用做参数"},{"categories":["编程语言"],"content":" 2.3 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; 2.3.1 引用做参数 #include void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 2.3.2 引用做返回值 2.3.3 引用的本质引用的本质是C++内部实现的一个指针常量 2.3.4 常量引用 const int \u0026ref = 10; ","date":"2021-10-03","objectID":"/cxx_basic/:2:3","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#引用做返回值"},{"categories":["编程语言"],"content":" 2.3 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; 2.3.1 引用做参数 #include void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 2.3.2 引用做返回值 2.3.3 引用的本质引用的本质是C++内部实现的一个指针常量 2.3.4 常量引用 const int \u0026ref = 10; ","date":"2021-10-03","objectID":"/cxx_basic/:2:3","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#引用的本质"},{"categories":["编程语言"],"content":" 2.3 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; 2.3.1 引用做参数 #include void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 2.3.2 引用做返回值 2.3.3 引用的本质引用的本质是C++内部实现的一个指针常量 2.3.4 常量引用 const int \u0026ref = 10; ","date":"2021-10-03","objectID":"/cxx_basic/:2:3","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#常量引用"},{"categories":["编程语言"],"content":" 2.4 函数提高 2.4.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } 2.4.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } 2.4.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2021-10-03","objectID":"/cxx_basic/:2:4","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数提高"},{"categories":["编程语言"],"content":" 2.4 函数提高 2.4.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } 2.4.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } 2.4.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2021-10-03","objectID":"/cxx_basic/:2:4","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数默认值"},{"categories":["编程语言"],"content":" 2.4 函数提高 2.4.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } 2.4.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } 2.4.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2021-10-03","objectID":"/cxx_basic/:2:4","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数的占位参数"},{"categories":["编程语言"],"content":" 2.4 函数提高 2.4.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } 2.4.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } 2.4.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2021-10-03","objectID":"/cxx_basic/:2:4","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#函数重载"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#类和对象"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#class与struct的区别"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#构造函数和析构函数"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#拷贝构造函数"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#拷贝构造函数的调用时机"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#构造函数的调用规则"},{"categories":["编程语言"],"content":" 2.5 类和对象类的访问属性 public: protected: private: 2.5.1 class与struct的区别class默认权限是private struct默认权限是public 2.5.2 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 2.5.3 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 2.5.4 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 2.5.5 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 2.5.6 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2021-10-03","objectID":"/cxx_basic/:2:5","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#深拷贝和浅拷贝"},{"categories":["编程语言"],"content":" 2.6 初始化列表作用:C++提供了初始化列表语法,用来初始化属性; 语法: 构造函数(): 属性1(值1),属性2(值2),属性3(值3) { /* 函数体 */ } ","date":"2021-10-03","objectID":"/cxx_basic/:2:6","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#初始化列表"},{"categories":["编程语言"],"content":" 2.7 类对象作为类成员","date":"2021-10-03","objectID":"/cxx_basic/:2:7","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#类对象作为类成员"},{"categories":["编程语言"],"content":" 2.8 静态成员静态成员就是在静态成员变量和成员函数前加上static,称为静态成员; 静态成员变量 所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 class Person { public: static int age; static void func() { std::cout \u003c\u003c \"静态成员函数\" \u003c\u003c std::endl; } }; /* 通过对象访问 */ Person p; p.func(); /* 通过类访问 */ Person::func(); ","date":"2021-10-03","objectID":"/cxx_basic/:2:8","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#静态成员"},{"categories":["编程语言"],"content":" 2.9 成员变量和成员函数分开存储 非静态成员, 属于类的对象 静态成员, 不属于类的对象 非静态成员函数, 不属于类的对象 静态成员函数, 不属于类的对象 空对象大小为1 ","date":"2021-10-03","objectID":"/cxx_basic/:2:9","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#成员变量和成员函数分开存储"},{"categories":["编程语言"],"content":" 2.10 C++对象模型","date":"2021-10-03","objectID":"/cxx_basic/:2:10","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#c对象模型"},{"categories":["编程语言"],"content":" 2.11 this指针this指针指向被调用成员函数所属的对象 this指针本质：指针常量 ","date":"2021-10-03","objectID":"/cxx_basic/:2:11","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#this指针"},{"categories":["编程语言"],"content":" 2.12 空指针访问成员函数C++空指针也是可以访问成员函数的,但是要注意的this指针; ","date":"2021-10-03","objectID":"/cxx_basic/:2:12","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#空指针访问成员函数"},{"categories":["编程语言"],"content":" 2.13 const修饰成员函数常函数: 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数 执行原理 this ==\u003e Person * const this; 后面新追加的const则会造成 const Person * const this; class Person { public: int m_A; mutable int m_B; void showPerson() const { m_A = 10; /* 错误,不可修改 */ m_B = 10; /* 正确,可以修改 */ } }; ","date":"2021-10-03","objectID":"/cxx_basic/:2:13","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#const修饰成员函数"},{"categories":["编程语言"],"content":" 2.14 友元 全局函数 全局类 成员函数 ","date":"2021-10-03","objectID":"/cxx_basic/:2:14","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#友元"},{"categories":["编程语言"],"content":" 2.15 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; 2.15.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } 2.15.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } 2.15.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } 2.15.4 递增重载++注意: 前置递增 p++ 后置递增 ++p 2.15.5 重载例子(复数) #include \u003ciostream\u003e class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:2:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#运算符重载"},{"categories":["编程语言"],"content":" 2.15 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; 2.15.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } 2.15.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } 2.15.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } 2.15.4 递增重载++注意: 前置递增 p++ 后置递增 ++p 2.15.5 重载例子(复数) #include class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:2:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#通过成员函数重载运算符"},{"categories":["编程语言"],"content":" 2.15 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; 2.15.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } 2.15.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } 2.15.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } 2.15.4 递增重载++注意: 前置递增 p++ 后置递增 ++p 2.15.5 重载例子(复数) #include class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:2:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#通过全局函数重载"},{"categories":["编程语言"],"content":" 2.15 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; 2.15.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } 2.15.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } 2.15.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } 2.15.4 递增重载++注意: 前置递增 p++ 后置递增 ++p 2.15.5 重载例子(复数) #include class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:2:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#重载左移运算符"},{"categories":["编程语言"],"content":" 2.15 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; 2.15.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } 2.15.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } 2.15.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } 2.15.4 递增重载++注意: 前置递增 p++ 后置递增 ++p 2.15.5 重载例子(复数) #include class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:2:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#递增重载"},{"categories":["编程语言"],"content":" 2.15 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; 2.15.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } 2.15.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } 2.15.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } 2.15.4 递增重载++注意: 前置递增 p++ 后置递增 ++p 2.15.5 重载例子(复数) #include class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2021-10-03","objectID":"/cxx_basic/:2:15","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#重载例子复数"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#继承"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#继承方式"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#继承中的对象模型"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#构造和析构的顺序"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#继承中同名成员处理"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#多重继承"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#菱形继承"},{"categories":["编程语言"],"content":" 2.16 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 2.16.1 继承方式 公共继承 保护继承 私有继承 2.16.2 继承中的对象模型 2.16.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 2.16.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A 2.16.5 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 2.16.6 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ 2.16.7 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2021-10-03","objectID":"/cxx_basic/:2:16","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#虚基类指针vbptr"},{"categories":["编程语言"],"content":" 2.17 多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数; 有继承关系 子类重写父类的虚函数 重写：函数完全一致 2.17.1 纯虚函数 只要有一个纯虚函数，就称为抽象类 抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 2.17.2 原理","date":"2021-10-03","objectID":"/cxx_basic/:2:17","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#多态"},{"categories":["编程语言"],"content":" 2.17 多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数; 有继承关系 子类重写父类的虚函数 重写：函数完全一致 2.17.1 纯虚函数 只要有一个纯虚函数，就称为抽象类 抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 2.17.2 原理","date":"2021-10-03","objectID":"/cxx_basic/:2:17","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#纯虚函数"},{"categories":["编程语言"],"content":" 2.17 多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数; 有继承关系 子类重写父类的虚函数 重写：函数完全一致 2.17.1 纯虚函数 只要有一个纯虚函数，就称为抽象类 抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 2.17.2 原理","date":"2021-10-03","objectID":"/cxx_basic/:2:17","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#原理"},{"categories":["编程语言"],"content":" 2.18 虚析构和纯虚析构","date":"2021-10-03","objectID":"/cxx_basic/:2:18","series":null,"tags":["C++"],"title":"C++笔记","uri":"/cxx_basic/#虚析构和纯虚析构"},{"categories":[],"content":" doxygen教程","date":"2021-10-03","objectID":"/doxygen/:0:0","series":null,"tags":[],"title":"Doxygen","uri":"/doxygen/#doxygen教程"},{"categories":[],"content":" 1 开始","date":"2021-10-03","objectID":"/doxygen/:1:0","series":null,"tags":[],"title":"Doxygen","uri":"/doxygen/#开始doxygenhttpsrawgithubusercontentcommengdemaopicturemasterdoxygenpng"},{"categories":[],"content":" 1 简述 驱动模型 顶级kobject 解释 block 块设备链接–\u003e/sys/deives相关文件 bus 存放各种总线文件 class 各种设备类 dev 存放(字符/块)设备主副设备号链接文件–\u003e/sys/deives devices 设备的具体存放文件 firmware 固件存放 fs 文件类型 kernel kernel子系统 module 模块信息 power 能源管理 ","date":"2021-10-01","objectID":"/drivermodel/:1:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#简述"},{"categories":[],"content":" 2 底层机制","date":"2021-10-01","objectID":"/drivermodel/:2:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#底层机制"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\u003cNULL\u003e\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\u003cNULL\u003e\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kobject"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#初始化"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#添加"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#sysfs文件夹生成"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#删除"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#引用计数"},{"categories":[],"content":" 2.2 kset 2.2.1 数据结构 struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; } __randomize_layout; ","date":"2021-10-01","objectID":"/drivermodel/:2:2","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kset"},{"categories":[],"content":" 2.2 kset 2.2.1 数据结构 struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; } __randomize_layout; ","date":"2021-10-01","objectID":"/drivermodel/:2:2","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构-1"},{"categories":[],"content":" 2.3 ktype 2.3.1 数据结构 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ","date":"2021-10-01","objectID":"/drivermodel/:2:3","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#ktype"},{"categories":[],"content":" 2.3 ktype 2.3.1 数据结构 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ","date":"2021-10-01","objectID":"/drivermodel/:2:3","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构-2"},{"categories":[],"content":" 3 class 设备类描述 struct class { const char *name; struct module *owner; const struct attribute_group **class_groups; const struct attribute_group **dev_groups; struct kobject *dev_kobj; int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); char *(*devnode)(struct device *dev, umode_t *mode); void (*class_release)(struct class *class); void (*dev_release)(struct device *dev); int (*shutdown_pre)(struct device *dev); const struct kobj_ns_type_operations *ns_type; const void *(*namespace)(struct device *dev); void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid); const struct dev_pm_ops *pm; struct subsys_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:3:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#class"},{"categories":[],"content":" 4 bus 设备总线描述 ","date":"2021-10-01","objectID":"/drivermodel/:4:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#bus"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#总线类型"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#设备总线注册"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#设备总线卸载"},{"categories":[],"content":" 5 devices 设备文件具体描述: device(设备描述) device_driver(驱动描述) bus_type(总线信息) |-- breakpoint |-- kprobe |-- platform |-- software |-- system |-- tracepoint |-- uprobe `-- virtual ","date":"2021-10-01","objectID":"/drivermodel/:5:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#devices"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#heading"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#device"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#driver"},{"categories":[],"content":" 6 kernel kernel子系统 ","date":"2021-10-01","objectID":"/drivermodel/:6:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kernel"},{"categories":[],"content":" 7 module 模块信息 ","date":"2021-10-01","objectID":"/drivermodel/:7:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#module"},{"categories":null,"content":" LuaJIT","date":"2021-09-04","objectID":"/luajit/:0:0","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#luajit"},{"categories":null,"content":" 1 Lua语法","date":"2021-09-04","objectID":"/luajit/:1:0","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#lua语法"},{"categories":null,"content":" 1.1 基本语法 print(\"Hello World\") ","date":"2021-09-04","objectID":"/luajit/:1:1","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#基本语法"},{"categories":null,"content":" 1.2 表(table)","date":"2021-09-04","objectID":"/luajit/:1:2","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#表table"},{"categories":null,"content":" 2 LuaJIT分析","date":"2021-09-04","objectID":"/luajit/:2:0","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#luajit分析"},{"categories":null,"content":" 2.1 LuaJIT主函数 int main(int argc, char **argv) { int status; /* 返回值 */ lua_State *L = lua_open(); /* 创建LUA状态机 */ if (L == NULL) { l_message(argv[0], \"cannot create state: not enough memory\"); return EXIT_FAILURE; } /* smain只存在三个参数,主要作用是向pmain传递数据 */ smain.argc = argc; smain.argv = argv; status = lua_cpcall(L, pmain, NULL); /* 启动函数调用 */ report(L, status); /* 提取报错参数 */ lua_close(L); /* 销毁状态机 */ return (status || smain.status \u003e 0) ? EXIT_FAILURE : EXIT_SUCCESS; } ","date":"2021-09-04","objectID":"/luajit/:2:1","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#luajit主函数"},{"categories":null,"content":" 2.2 Lua状态机 struct lua_State { GCObject*next; lu_byte tt; lu_byte marked; lu_byte status; StkId top; StkId base; global_State *l_G; /* 全局状态信息 */ CallInfo*ci; const Instruction*savedpc; StkId stack_last; StkId stack; CallInfo*end_ci; CallInfo*base_ci; int stacksize; int size_ci; unsigned short nCcalls; unsigned short baseCcalls; lu_byte hookmask; lu_byte allowhook; int basehookcount; int hookcount; lua_Hook hook; TValue l_gt; TValue env; GCObject*openupval; GCObject*gclist; struct lua_longjmp*errorJmp; ptrdiff_t errfunc; }; ","date":"2021-09-04","objectID":"/luajit/:2:2","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#lua状态机"},{"categories":null,"content":" 2.3 创建状态 /* 此函数实际不存在,程序内部使用的是宏定义 */ void lua_open(void); /* 实际调用位置 */ LUALIB_API lua_State *luaL_newstate(void); /* 根据编译期64位信息选择调用 */ #if LJ_64 \u0026\u0026 !LJ_GC64 \u0026\u0026 !(defined(LUAJIT_USE_VALGRIND) \u0026\u0026 defined(LUAJIT_USE_SYSMALLOC)) lua_State *lj_state_newstate(lua_Alloc allocf, void *allocd); #else LUA_API lua_State *lua_newstate(lua_Alloc allocf, void *allocd); #endif ","date":"2021-09-04","objectID":"/luajit/:2:3","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#创建状态"},{"categories":null,"content":" 2.4 函数调用 LUA_API int lua_cpcall(lua_State *L, lua_CFunction func, void *ud); LUA_API int lua_pcall(lua_State *L, int nargs, int nresults, int errfunc); LUA_API void lua_call(lua_State *L, int nargs, int nresults); lua_cpcall函数调用 ","date":"2021-09-04","objectID":"/luajit/:2:4","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#函数调用"},{"categories":null,"content":" 3 执行原理","date":"2021-09-04","objectID":"/luajit/:3:0","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#执行原理"},{"categories":null,"content":" 4 FFI分析","date":"2021-09-04","objectID":"/luajit/:4:0","series":null,"tags":null,"title":"LuaJIT","uri":"/luajit/#ffi分析"},{"categories":null,"content":" 页面分配器核心函数: __alloc_pages_nodemask gfp_mask : 分配掩码 order : 分配阶数 preferred_nid nodemask ","date":"2021-05-09","objectID":"/page_allocator/:0:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#页面分配器"},{"categories":null,"content":" 1 核心函数 struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) { struct page *page; // 分配变量 unsigned int alloc_flags = ALLOC_WMARK_LOW; // 分配标志 gfp_t alloc_mask; // 真实分配掩码 struct alloc_context ac = { }; // 保存相关参数 /* * There are several places where we assume that the order value is sane * so bail out early if the request is out of bound. * 限制分配的大小 */ if (unlikely(order \u003e= MAX_ORDER)) { WARN_ON_ONCE(!(gfp_mask \u0026 __GFP_NOWARN)); return NULL; } gfp_mask \u0026= gfp_allowed_mask; alloc_mask = gfp_mask; if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026ac, \u0026alloc_mask, \u0026alloc_flags)) return NULL; finalise_ac(gfp_mask, \u0026ac); /* First allocation attempt */ page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026ac); if (likely(page)) goto out; /* * Apply scoped allocation constraints. This is mainly about GFP_NOFS * resp. GFP_NOIO which has to be inherited for all allocation requests * from a particular context which has been marked by * memalloc_no{fs,io}_{save,restore}. */ alloc_mask = current_gfp_context(gfp_mask); ac.spread_dirty_pages = false; /* * Restore the original nodemask if it was potentially replaced with * \u0026cpuset_current_mems_allowed to optimize the fast-path attempt. */ if (unlikely(ac.nodemask != nodemask)) ac.nodemask = nodemask; page = __alloc_pages_slowpath(alloc_mask, order, \u0026ac); out: if (memcg_kmem_enabled() \u0026\u0026 (gfp_mask \u0026 __GFP_ACCOUNT) \u0026\u0026 page \u0026\u0026 unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) { __free_pages(page, order); page = NULL; } trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); return page; } ","date":"2021-05-09","objectID":"/page_allocator/:1:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#核心函数"},{"categories":null,"content":" 2 prepare_alloc_pages static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask, struct alloc_context *ac, gfp_t *alloc_mask, unsigned int *alloc_flags) { ac-\u003ehigh_zoneidx = gfp_zone(gfp_mask); ac-\u003ezonelist = node_zonelist(preferred_nid, gfp_mask); ac-\u003enodemask = nodemask; ac-\u003emigratetype = gfpflags_to_migratetype(gfp_mask); if (cpusets_enabled()) { *alloc_mask |= __GFP_HARDWALL; if (!ac-\u003enodemask) ac-\u003enodemask = \u0026cpuset_current_mems_allowed; else *alloc_flags |= ALLOC_CPUSET; } fs_reclaim_acquire(gfp_mask); fs_reclaim_release(gfp_mask); might_sleep_if(gfp_mask \u0026 __GFP_DIRECT_RECLAIM); if (should_fail_alloc_page(gfp_mask, order)) return false; if (IS_ENABLED(CONFIG_CMA) \u0026\u0026 ac-\u003emigratetype == MIGRATE_MOVABLE) *alloc_flags |= ALLOC_CMA; return true; } ","date":"2021-05-09","objectID":"/page_allocator/:2:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#prepare_alloc_pages"},{"categories":null,"content":" 3 get_page_from_freelist static struct page * get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, const struct alloc_context *ac) { struct zoneref *z = ac-\u003epreferred_zoneref; struct zone *zone; struct pglist_data *last_pgdat_dirty_limit = NULL; /* * Scan zonelist, looking for a zone with enough free. * See also __cpuset_node_allowed() comment in kernel/cpuset.c. */ for_next_zone_zonelist_nodemask(zone, z, ac-\u003ezonelist, ac-\u003ehigh_zoneidx, ac-\u003enodemask) { struct page *page; unsigned long mark; if (cpusets_enabled() \u0026\u0026 (alloc_flags \u0026 ALLOC_CPUSET) \u0026\u0026 !__cpuset_zone_allowed(zone, gfp_mask)) continue; /* * When allocating a page cache page for writing, we * want to get it from a node that is within its dirty * limit, such that no single node holds more than its * proportional share of globally allowed dirty pages. * The dirty limits take into account the node's * lowmem reserves and high watermark so that kswapd * should be able to balance it without having to * write pages from its LRU list. * * XXX: For now, allow allocations to potentially * exceed the per-node dirty limit in the slowpath * (spread_dirty_pages unset) before going into reclaim, * which is important when on a NUMA setup the allowed * nodes are together not big enough to reach the * global limit. The proper fix for these situations * will require awareness of nodes in the * dirty-throttling and the flusher threads. */ if (ac-\u003espread_dirty_pages) { if (last_pgdat_dirty_limit == zone-\u003ezone_pgdat) continue; if (!node_dirty_ok(zone-\u003ezone_pgdat)) { last_pgdat_dirty_limit = zone-\u003ezone_pgdat; continue; } } mark = zone-\u003ewatermark[alloc_flags \u0026 ALLOC_WMARK_MASK]; if (!zone_watermark_fast(zone, order, mark, ac_classzone_idx(ac), alloc_flags)) { int ret; #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT /* * Watermark failed for this zone, but see if we can * grow this zone if it contains deferred pages. */ if (static_branch_unlikely(\u0026deferred_pages)) { if (_deferred_grow_zone(zone, order)) goto try_this_zone; } #endif /* Checked here to keep the fast path fast */ BUILD_BUG_ON(ALLOC_NO_WATERMARKS \u003c NR_WMARK); if (alloc_flags \u0026 ALLOC_NO_WATERMARKS) goto try_this_zone; if (node_reclaim_mode == 0 || !zone_allows_reclaim(ac-\u003epreferred_zoneref-\u003ezone, zone)) continue; ret = node_reclaim(zone-\u003ezone_pgdat, gfp_mask, order); switch (ret) { case NODE_RECLAIM_NOSCAN: /* did not scan */ continue; case NODE_RECLAIM_FULL: /* scanned but unreclaimable */ continue; default: /* did we reclaim enough */ if (zone_watermark_ok(zone, order, mark, ac_classzone_idx(ac), alloc_flags)) goto try_this_zone; continue; } } try_this_zone: page = rmqueue(ac-\u003epreferred_zoneref-\u003ezone, zone, order, gfp_mask, alloc_flags, ac-\u003emigratetype); if (page) { prep_new_page(page, order, gfp_mask, alloc_flags); /* * If this is a high-order atomic allocation then check * if the pageblock should be reserved for the future */ if (unlikely(order \u0026\u0026 (alloc_flags \u0026 ALLOC_HARDER))) reserve_highatomic_pageblock(page, zone, order); return page; } else { #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT /* Try again if zone has deferred pages */ if (static_branch_unlikely(\u0026deferred_pages)) { if (_deferred_grow_zone(zone, order)) goto try_this_zone; } #endif } } return NULL; } ","date":"2021-05-09","objectID":"/page_allocator/:3:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#get_page_from_freelist"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制 ","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#"},{"categories":null,"content":" 使用","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#使用"},{"categories":null,"content":" 1 等待队列头 struct __wait_queue_head { wq_lock_t lock; struct list_head task_list; }; typedef struct __wait_queue_head wait_queue_head_t; ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列头"},{"categories":null,"content":" 2 等待队列实体 struct __wait_queue { unsigned int flags; struct task_struct * task; struct list_head task_list; }; typedef struct __wait_queue wait_queue_t; ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列实体"},{"categories":null,"content":" 3 初始化等待队列头 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *); void init_waitqueue_head(struct wait_queue_head *wq_head); ","date":"2021-05-04","objectID":"/wait_queue/:3:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列头"},{"categories":null,"content":" 4 初始化等待队列 #define __WAITQUEUE_INITIALIZER(name, tsk) \\ { \\ .private = tsk, \\ .func = default_wake_function, \\ .entry = { NULL, NULL } \\ } #define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) // 但是，一般直接 DECLARE_WAITQUEUE(wait, current); 等待队列入口 等待的任务 ","date":"2021-05-04","objectID":"/wait_queue/:4:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列"},{"categories":null,"content":" 5 等待队列操作 void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); 等待队列头 等待队列实体 ","date":"2021-05-04","objectID":"/wait_queue/:5:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列操作"},{"categories":null,"content":" 6 等待事件 void wait_event(wq, condition); void wait_event_interruptible(wq, condition); ","date":"2021-05-04","objectID":"/wait_queue/:6:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待事件"},{"categories":null,"content":" 7 唤醒队列 wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync ","date":"2021-05-04","objectID":"/wait_queue/:7:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#唤醒队列"},{"categories":null,"content":" 例子","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#例子"},{"categories":null,"content":" 1 写端 ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = -1; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_write; } add_wait_queue(\u0026wait_device.wait_w, \u0026wait); while (wait_device.wait_flag == true) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); pure_write: wait_device.wait_flag = true; pr_err(\"Write Successful\"); wake_up_interruptible(\u0026wait_device.wait_r); pr_err(\"Wakeup Read\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return ret; } ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#写端"},{"categories":null,"content":" 2 读端 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = 0; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_read; } add_wait_queue(\u0026wait_device.wait_r, \u0026wait); while (wait_device.wait_flag == false) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); pure_read: wait_device.wait_flag = false; pr_err(\"Read Successful\"); wake_up_interruptible(\u0026wait_device.wait_w); pr_err(\"Wakeup Write\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return 0; } ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#读端"},{"categories":null,"content":" 原理","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#原理"},{"categories":null,"content":" 1 简介 ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件. 类似于flex/bison,根据描述文件，自动生成词法语法分析器 ","date":"2021-05-04","objectID":"/antlr/:1:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#简介"},{"categories":null,"content":" 2 安装说明 下载antlr 设置path和classpath 编写相关脚本 ","date":"2021-05-04","objectID":"/antlr/:2:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#安装说明"},{"categories":null,"content":" 3 语法设计","date":"2021-05-04","objectID":"/antlr/:3:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#语法设计"},{"categories":null,"content":" 4 错误处理","date":"2021-05-04","objectID":"/antlr/:4:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#错误处理"},{"categories":null,"content":" 5 解析器","date":"2021-05-04","objectID":"/antlr/:5:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#解析器"},{"categories":null,"content":" 6 测试程序","date":"2021-05-04","objectID":"/antlr/:6:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#测试程序"},{"categories":null,"content":" 6.1 antlr4编译器 #!/bin/sh antlr4 Expr.g4 ","date":"2021-05-04","objectID":"/antlr/:6:1","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#antlr4编译器"},{"categories":null,"content":" 6.2 编译生成的java文件 javac *.java ","date":"2021-05-04","objectID":"/antlr/:6:2","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#编译生成的java文件"},{"categories":null,"content":" 6.3 运行编译的结果 grun Expr prog -tree (prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) grun Expr prog -gui grun Expr prog -tokens [@0,0:0='1',\u003cINT\u003e,1:0] [@1,1:1='+',\u003c'+'\u003e,1:1] [@2,2:2='2',\u003cINT\u003e,1:2] [@3,3:3='+',\u003c'+'\u003e,1:3] [@4,4:4='3',\u003cINT\u003e,1:4] [@5,5:6='\\r\\n',\u003cNEWLINE\u003e,1:5] [@6,7:6='\u003cEOF\u003e',\u003cEOF\u003e,2:0] ","date":"2021-05-04","objectID":"/antlr/:6:3","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#运行编译的结果"},{"categories":null,"content":" 7 antlr语法详解","date":"2021-05-04","objectID":"/antlr/:7:0","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#antlr语法详解"},{"categories":null,"content":" 7.1 Hello // antlr4 Hello.g4 // javac *.java // grun Hello r -gui grammar Hello; // 定义一个Hello的grammer r : 'hello' ID ; // 开头是hello后面接着一个ID ID : [a-z]+ ; // ID由小写字母组成 WS : [ \\t\\r\\n]+ -\u003e skip ; // 控制符清除 ","date":"2021-05-04","objectID":"/antlr/:7:1","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#hello"},{"categories":null,"content":" 7.2 ArrayInit // antlr4 ArrayInit.g4 // javac *.java // grun ArrayInit init -gui grammar ArrayInit; // 定义一个ArrayInit的grammer init : '{' value (',' value)* '}' ; // value : init // 嵌套定义 | INT // 定义整数 ; INT : [0-9]+ ; WS : [ \\t\\r\\n]+ -\u003e skip ; ()* –\u003e 相当于扩展 ","date":"2021-05-04","objectID":"/antlr/:7:2","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#arrayinit"},{"categories":null,"content":" 7.3 Expr // antlr4 Expr.g4 // javac *.java // grun Expr prog -gui grammar Expr; prog : stat+; stat: expr NEWLINE # printExpr | ID '=' expr NEWLINE # assign | NEWLINE # blank ; expr: expr op=('*'|'/') expr # MulDiv | expr op=('+'|'-') expr # AddSub | INT # int | ID # id | '('expr')' # parens ; MUL : '*' ; // assigns token name to '*' used above in grammar DIV : '/' ; ADD : '+' ; SUB : '-' ; ID : [a-zA-Z]+ ; INT : [0-9]+ ; NEWLINE :'\\r'? '\\n' ; WS : [ \\t]+ -\u003e skip; ","date":"2021-05-04","objectID":"/antlr/:7:3","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#expr"},{"categories":null,"content":" 7.4 json 在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础 grammar JSON; // 声明一个grammar json : value // 一个value候选 ; obj // 对象类型 : '{' pair (',' pair)* '}' | '{' '}' ; pair : STRING ':' value ; arr : '[' value (',' value)* ']' | '[' ']' ; value : STRING | NUMBER | obj | arr | 'true' | 'false' | 'null' ; STRING : '\"' (ESC | SAFECODEPOINT)* '\"' ; fragment ESC : '\\\\' ([\"\\\\/bfnrt] | UNICODE) ; fragment UNICODE : 'u' HEX HEX HEX HEX ; fragment HEX : [0-9a-fA-F] ; fragment SAFECODEPOINT : ~ [\"\\\\\\u0000-\\u001F] ; NUMBER : '-'? INT ('.' [0-9] +)? EXP? ; fragment INT : '0' | [1-9] [0-9]* ; // no leading zeros fragment EXP : [Ee] [+\\-]? INT ; // \\- since - means \"range\" inside [...] WS : [ \\t\\n\\r] + -\u003e skip ; 测试例子 { \"glossary\": { \"title\": \"example glossary\", \"GlossDiv\": { \"title\": \"S\", \"GlossList\": { \"GlossEntry\": { \"ID\": \"SGML\", \"SortAs\": \"SGML\", \"GlossTerm\": \"Standard Generalized Markup Language\", \"Acronym\": \"SGML\", \"Abbrev\": \"ISO 8879:1986\", \"GlossDef\": { \"para\": \"A meta-markup language\", \"GlossSeeAlso\": [\"GML\", \"XML\"] }, \"GlossSee\": \"markup\" } } } } } 显示结果： ","date":"2021-05-04","objectID":"/antlr/:7:4","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#json"},{"categories":null,"content":" 7.5 XML 孤岛语法: ","date":"2021-05-04","objectID":"/antlr/:7:5","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#xml"},{"categories":null,"content":" 7.6 dot grammar DOT; graph : STRICT? ( GRAPH | DIGRAPH ) id_? '{' stmt_list '}' ; stmt_list : ( stmt ';'? )* ; stmt : node_stmt | edge_stmt | attr_stmt | id_ '=' id_ | subgraph ; attr_stmt : ( GRAPH | NODE | EDGE ) attr_list ; attr_list : ( '[' a_list? ']' )+ ; a_list : ( id_ ( '=' id_ )? ','? )+ ; edge_stmt : ( node_id | subgraph ) edgeRHS attr_list? ; edgeRHS : ( edgeop ( node_id | subgraph ) )+ ; edgeop : '-\u003e' | '--' ; node_stmt : node_id attr_list? ; node_id : id_ port? ; port : ':' id_ ( ':' id_ )? ; subgraph : ( SUBGRAPH id_? )? '{' stmt_list '}' ; id_ : ID | STRING | HTML_STRING | NUMBER ; // \"The keywords node, edge, graph, digraph, subgraph, and strict are // case-independent\" STRICT : [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] ; GRAPH : [Gg] [Rr] [Aa] [Pp] [Hh] ; DIGRAPH : [Dd] [Ii] [Gg] [Rr] [Aa] [Pp] [Hh] ; NODE : [Nn] [Oo] [Dd] [Ee] ; EDGE : [Ee] [Dd] [Gg] [Ee] ; SUBGRAPH : [Ss] [Uu] [Bb] [Gg] [Rr] [Aa] [Pp] [Hh] ; /** \"a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\" */ NUMBER : '-'? ( '.' DIGIT+ | DIGIT+ ( '.' DIGIT* )? ) ; fragment DIGIT : [0-9] ; /** \"any double-quoted string (\"...\") possibly containing escaped quotes\" */ STRING : '\"' ( '\\\\\"' | . )*? '\"' ; /** \"Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores * ('_') or digits ([0-9]), not beginning with a digit\" */ ID : LETTER ( LETTER | DIGIT )* ; fragment LETTER : [a-zA-Z\\u0080-\\u00FF_] ; /** \"HTML strings, angle brackets must occur in matched pairs, and * unescaped newlines are allowed.\" */ HTML_STRING : '\u003c' ( TAG | ~ [\u003c\u003e] )* '\u003e' ; fragment TAG : '\u003c' .*? '\u003e' ; COMMENT : '/*' .*? '*/' -\u003e skip ; LINE_COMMENT : '//' .*? '\\r'? '\\n' -\u003e skip ; /** \"a '#' character is considered a line output from a C preprocessor (e.g., * # 34 to indicate line 34 ) and discarded\" */ PREPROC : '#' ~[\\r\\n]* -\u003e skip ; WS : [ \\t\\n\\r]+ -\u003e skip ; ","date":"2021-05-04","objectID":"/antlr/:7:6","series":null,"tags":["编译原理"],"title":"antlr教程","uri":"/antlr/#dot"},{"categories":null,"content":" 1 基本操作","date":"2021-05-04","objectID":"/hugo/:1:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#基本操作"},{"categories":null,"content":" 1.1 安装hugo在linux/windows上只能通过直接release下载, ","date":"2021-05-04","objectID":"/hugo/:1:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#安装hugo"},{"categories":null,"content":" 1.2 创建网站 hugo new site 路径 ","date":"2021-05-04","objectID":"/hugo/:1:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建网站"},{"categories":null,"content":" 1.3 添加主题 将主题直接添加到theme文件下面 将主题作为一个submodule ","date":"2021-05-04","objectID":"/hugo/:1:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#添加主题"},{"categories":null,"content":" 1.4 创建文档 hugo new posts/hugo.md ","date":"2021-05-04","objectID":"/hugo/:1:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建文档"},{"categories":null,"content":" 1.5 设置预览 hugo server -D --disableFastRender ","date":"2021-05-04","objectID":"/hugo/:1:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#设置预览"},{"categories":null,"content":" 2 文件结构 . ├── archetypes ├── config ├── content ├── data ├── layouts ├── static ├── themes ├── static └── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。 ","date":"2021-05-04","objectID":"/hugo/:2:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#文件结构"},{"categories":null,"content":" 2.1 archetypeshugo模板,在创建文件时作为模板自动生成 ","date":"2021-05-04","objectID":"/hugo/:2:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#archetypes"},{"categories":null,"content":" 2.2 assets存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录 ","date":"2021-05-04","objectID":"/hugo/:2:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#assets"},{"categories":null,"content":" 2.3 configHugo配置目录 ","date":"2021-05-04","objectID":"/hugo/:2:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#config"},{"categories":null,"content":" 2.4 content此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分. ","date":"2021-05-04","objectID":"/hugo/:2:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#content"},{"categories":null,"content":" 2.5 data该目录用于存储 Hugo 在生成网站时可以使用的配置文件 ","date":"2021-05-04","objectID":"/hugo/:2:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#data"},{"categories":null,"content":" 2.6 layouts以 .html文件的形式存储模板. ","date":"2021-05-04","objectID":"/hugo/:2:6","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#layouts"},{"categories":null,"content":" 2.7 static存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制 ","date":"2021-05-04","objectID":"/hugo/:2:7","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#static"},{"categories":null,"content":" 3 编写工具","date":"2021-05-04","objectID":"/hugo/:3:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#编写工具"},{"categories":null,"content":" 3.1 typora使用typora作为markdown编写工具 ","date":"2021-05-04","objectID":"/hugo/:3:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#typora"},{"categories":null,"content":" 3.2 picgo ","date":"2021-05-04","objectID":"/hugo/:3:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#picgo"},{"categories":null,"content":" nfs服务","date":"2021-05-03","objectID":"/nfs/:0:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#nfs服务"},{"categories":null,"content":" 1 安装 sudo apt-get install nfs-kernel-server ","date":"2021-05-03","objectID":"/nfs/:1:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#安装"},{"categories":null,"content":" 2 设置导出 /home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) ","date":"2021-05-03","objectID":"/nfs/:2:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#设置导出"},{"categories":null,"content":" 3 开启服务 sudo /etc/init.d/nfs-kernel-server restart ","date":"2021-05-03","objectID":"/nfs/:3:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#开启服务"},{"categories":null,"content":" 4 测试 sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt ls /mnt ","date":"2021-05-03","objectID":"/nfs/:4:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#测试"}]
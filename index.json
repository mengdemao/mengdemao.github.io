[{"categories":["Linux"],"content":"Uboot","date":"2023-03-12","objectID":"/uboot/","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/"},{"categories":["Linux"],"content":"u-boot源码阅读 ","date":"2023-03-12","objectID":"/uboot/:0:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#"},{"categories":["Linux"],"content":" 1 构建源码 # 下载源码 $ git clone git@github.com:Embedfire/ebf_6ull_uboot.git # 清理编译信息 $ make ARCH=arm clean # 配置信息 make ARCH=arm mx6ull_14x14_evk_emmc_defconfig make ARCH=arm mx6ull_14x14_evk_nand_defconfig # 执行编译 make -j4 ARCH=arm CROSS_COMPILE=arm-none-eabi- # 进入调试 qemu-system-arm -M vexpress-a9 -kernel u-boot --nographic -m 512M -S -s ","date":"2023-03-12","objectID":"/uboot/:1:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#构建源码"},{"categories":["Linux"],"content":" 2 启动前夕graph TD reset --\u003e _main _main --\u003e board_init_r board_init_r --\u003e initcall_run_list initcall_run_list --\u003e run_main_loop run_main_loop --\u003e main_loop [arch/arm/cpu/armv7/start.S] .globl reset .globl save_boot_params_ret reset: /* Allow the board to save important registers */ b save_boot_params save_boot_params_ret: /* * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode, * except if in HYP mode already */ mrs r0, cpsr and r1, r0, #0x1f @ mask mode bits teq r1, #0x1a @ test for HYP mode bicne r0, r0, #0x1f @ clear all mode bits orrne r0, r0, #0x13 @ set SVC mode orr r0, r0, #0xc0 @ disable FIQ and IRQ msr cpsr,r0 /* * Setup vector: * (OMAP4 spl TEXT_BASE is not 32 byte aligned. * Continue to use ROM code vector only in OMAP4 spl) */ #if !(defined(CONFIG_OMAP44XX) \u0026\u0026 defined(CONFIG_SPL_BUILD)) /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */ mrc p15, 0, r0, c1, c0, 0 @ Read CP15 SCTLR Register bic r0, #CR_V @ V = 0 mcr p15, 0, r0, c1, c0, 0 @ Write CP15 SCTLR Register /* Set vector address in CP15 VBAR register */ ldr r0, =_start mcr p15, 0, r0, c12, c0, 0 @Set VBAR #endif /* the mask ROM code should have PLL and others stable */ #ifndef CONFIG_SKIP_LOWLEVEL_INIT bl cpu_init_cp15 bl cpu_init_crit #endif bl _main [arch/arm/lib/crt0_64.S] ENTRY(_main) /* * Set up initial C runtime environment and call board_init_f(0). */ #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK) ldr sp, =(CONFIG_SPL_STACK) #else ldr sp, =(CONFIG_SYS_INIT_SP_ADDR) #endif #if defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination */ mov r3, sp bic r3, r3, #7 mov sp, r3 #else bic sp, sp, #7 /* 8-byte alignment for ABI compliance */ #endif mov r0, sp bl board_init_f_alloc_reserve mov sp, r0 /* set up gd here, outside any C code */ mov r9, r0 bl board_init_f_init_reserve mov r0, #0 bl board_init_f #if ! defined(CONFIG_SPL_BUILD) /* * Set up intermediate environment (new sp and gd) and call * relocate_code(addr_moni). Trick here is that we'll return * 'here' but relocated. */ ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-\u003estart_addr_sp */ #if defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination */ mov r3, sp bic r3, r3, #7 mov sp, r3 #else bic sp, sp, #7 /* 8-byte alignment for ABI compliance */ #endif ldr r9, [r9, #GD_BD] /* r9 = gd-\u003ebd */ sub r9, r9, #GD_SIZE /* new GD is below bd */ adr lr, here ldr r0, [r9, #GD_RELOC_OFF] /* r0 = gd-\u003ereloc_off */ add lr, lr, r0 #if defined(CONFIG_CPU_V7M) orr lr, #1 /* As required by Thumb-only */ #endif ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ b relocate_code here: /* * now relocate vectors */ bl relocate_vectors /* Set up final (full) environment */ bl c_runtime_cpu_setup /* we still call old routine here */ #endif #if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK) # ifdef CONFIG_SPL_BUILD /* Use a DRAM stack for the rest of SPL, if requested */ bl spl_relocate_stack_gd cmp r0, #0 movne sp, r0 movne r9, r0 # endif ldr r0, =__bss_start /* this is auto-relocated! */ #ifdef CONFIG_USE_ARCH_MEMSET ldr r3, =__bss_end /* this is auto-relocated! */ mov r1, #0x00000000 /* prepare zero to clear BSS */ subs r2, r3, r0 /* r2 = memset len */ bl memset #else ldr r1, =__bss_end /* this is auto-relocated! */ mov r2, #0x00000000 /* prepare zero to clear BSS */ clbss_l:cmp r0, r1 /* while not at end of BSS */ #if defined(CONFIG_CPU_V7M) itt lo #endif strlo r2, [r0] /* clear 32-bit BSS word */ addlo r0, r0, #4 /* move to next */ blo clbss_l #endif #if ! defined(CONFIG_SPL_BUILD) bl coloured_LED_init bl red_led_on #endif /* call board_init_r(gd_t *id, ulong dest_addr) */ mov r0, r9 /* gd_t */ ldr r1, [r9, #GD_RELOCADDR] /* dest_addr */ /* call board_init_r */ #if defined(CONFIG_SYS_THUMB_BUILD) ldr lr, =board_init_r /* this is auto-relocated! */ bx lr #else ldr pc, =board_init_r /* this is auto-relocated! */ #endif /* we should not return here. */ #endif ENDPROC(_main) [arch/arm/cpu/armv8/start.S] .globl _start _start: b reset reset: #ifdef CONFIG_S","date":"2023-03-12","objectID":"/uboot/:2:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#启动前夕"},{"categories":["Linux"],"content":" 3 启动实现","date":"2023-03-12","objectID":"/uboot/:3:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#启动实现"},{"categories":["Linux"],"content":" 3.1 main_loopgraph TD main_loop --\u003e bootstage_mark_name bootstage_mark_name --\u003e bootdelay_process bootdelay_process --\u003e autoboot_command autoboot_command --\u003e run_command_list ","date":"2023-03-12","objectID":"/uboot/:3:1","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#main_loop"},{"categories":["Linux"],"content":" 3.2 do_bootm int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) { #ifdef CONFIG_NEEDS_MANUAL_RELOC static int relocated = 0; if (!relocated) { int i; /* relocate names of sub-command table */ for (i = 0; i \u003c ARRAY_SIZE(cmd_bootm_sub); i++) cmd_bootm_sub[i].name += gd-\u003ereloc_off; relocated = 1; } #endif /* determine if we have a sub command */ argc--; argv++; if (argc \u003e 0) { char *endp; simple_strtoul(argv[0], \u0026endp, 16); /* endp pointing to NULL means that argv[0] was just a * valid number, pass it along to the normal bootm processing * * If endp is ':' or '#' assume a FIT identifier so pass * along for normal processing. * * Right now we assume the first arg should never be '-' */ if ((*endp != 0) \u0026\u0026 (*endp != ':') \u0026\u0026 (*endp != '#')) return do_bootm_subcommand(cmdtp, flag, argc, argv); } #ifdef CONFIG_SECURE_BOOT extern uint32_t authenticate_image( uint32_t ddr_start, uint32_t image_size); switch (genimg_get_format((const void *)load_addr)) { #if defined(CONFIG_IMAGE_FORMAT_LEGACY) case IMAGE_FORMAT_LEGACY: if (authenticate_image(load_addr, image_get_image_size((image_header_t *)load_addr)) == 0) { printf(\"Authenticate uImage Fail, Please check\\n\"); return 1; } break; #endif #ifdef CONFIG_ANDROID_BOOT_IMAGE case IMAGE_FORMAT_ANDROID: /* Do this authentication in boota command */ break; #endif default: printf(\"Not valid image format for Authentication, Please check\\n\"); return 1; } #endif return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START | BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER | BOOTM_STATE_LOADOS | #if defined(CONFIG_PPC) || defined(CONFIG_MIPS) BOOTM_STATE_OS_CMDLINE | #endif BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO, \u0026images, 1); } ","date":"2023-03-12","objectID":"/uboot/:3:2","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#do_bootm"},{"categories":["Linux"],"content":" 3.3 boot_jump_linux static void boot_jump_linux(bootm_headers_t *images, int flag) { #ifdef CONFIG_ARM64 void (*kernel_entry)(void *fdt_addr, void *res0, void *res1, void *res2); int fake = (flag \u0026 BOOTM_STATE_OS_FAKE_GO); kernel_entry = (void (*)(void *fdt_addr, void *res0, void *res1, void *res2))images-\u003eep; debug(\"## Transferring control to Linux (at address %lx)...\\n\", (ulong) kernel_entry); bootstage_mark(BOOTSTAGE_ID_RUN_OS); announce_and_cleanup(fake); if (!fake) { do_nonsec_virt_switch(); kernel_entry(images-\u003eft_addr, NULL, NULL, NULL); } #else unsigned long machid = gd-\u003ebd-\u003ebi_arch_number; char *s; void (*kernel_entry)(int zero, int arch, uint params); unsigned long r2; int fake = (flag \u0026 BOOTM_STATE_OS_FAKE_GO); kernel_entry = (void (*)(int, int, uint))images-\u003eep; s = getenv(\"machid\"); if (s) { if (strict_strtoul(s, 16, \u0026machid) \u003c 0) { debug(\"strict_strtoul failed!\\n\"); return; } printf(\"Using machid 0x%lx from environment\\n\", machid); } debug(\"## Transferring control to Linux (at address %08lx)\" \\ \"...\\n\", (ulong) kernel_entry); bootstage_mark(BOOTSTAGE_ID_RUN_OS); announce_and_cleanup(fake); if (IMAGE_ENABLE_OF_LIBFDT \u0026\u0026 images-\u003eft_len) r2 = (unsigned long)images-\u003eft_addr; else r2 = gd-\u003ebd-\u003ebi_boot_params; if (!fake) { #ifdef CONFIG_ARMV7_NONSEC if (armv7_boot_nonsec()) { armv7_init_nonsec(); secure_ram_addr(_do_nonsec_entry)(kernel_entry, 0, machid, r2); } else #endif kernel_entry(0, machid, r2); } #endif } ","date":"2023-03-12","objectID":"/uboot/:3:3","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#boot_jump_linux"},{"categories":["Linux"],"content":" 4 加载内核 static void do_nonsec_virt_switch(void) { smp_kick_all_cpus(); dcache_disable(); /* flush cache before swtiching to EL2 */ armv8_switch_to_el2(); #ifdef CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el1(); #endif } ENTRY(armv8_switch_to_el2) switch_el x0, 1f, 0f, 0f 0: ret 1: armv8_switch_to_el2_m x0 ENDPROC(armv8_switch_to_el2) ENTRY(armv8_switch_to_el1) switch_el x0, 0f, 1f, 0f 0: ret 1: armv8_switch_to_el1_m x0, x1 ENDPROC(armv8_switch_to_el1) .macro armv8_switch_to_el2_m, xreg1 /* 64bit EL2 | HCE | SMD | RES1 (Bits[5:4]) | Non-secure EL0/EL1 */ mov \\xreg1, #0x5b1 msr scr_el3, \\xreg1 msr cptr_el3, xzr /* Disable coprocessor traps to EL3 */ mov \\xreg1, #0x33ff msr cptr_el2, \\xreg1 /* Disable coprocessor traps to EL2 */ /* Initialize Generic Timers */ msr cntvoff_el2, xzr /* Initialize SCTLR_EL2 * * setting RES1 bits (29,28,23,22,18,16,11,5,4) to 1 * and RES0 bits (31,30,27,26,24,21,20,17,15-13,10-6) + * EE,WXN,I,SA,C,A,M to 0 */ mov \\xreg1, #0x0830 movk \\xreg1, #0x30C5, lsl #16 msr sctlr_el2, \\xreg1 /* Return to the EL2_SP2 mode from EL3 */ mov \\xreg1, sp msr sp_el2, \\xreg1 /* Migrate SP */ mrs \\xreg1, vbar_el3 msr vbar_el2, \\xreg1 /* Migrate VBAR */ mov \\xreg1, #0x3c9 msr spsr_el3, \\xreg1 /* EL2_SP2 | D | A | I | F */ msr elr_el3, lr eret .endm ","date":"2023-03-12","objectID":"/uboot/:4:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#加载内核"},{"categories":["Linux Kernel"],"content":"Linux内核源码阅读","date":"2023-02-12","objectID":"/read_linux/","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/"},{"categories":["Linux Kernel"],"content":"内核源码阅读 源码版本: Linux 4.0.0 参考书籍: « 奔跑吧Linux内核 » « 深度探索linux系统虚拟化:原理与实现 » ","date":"2023-02-12","objectID":"/read_linux/:0:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#"},{"categories":["Linux Kernel"],"content":" 1 建立环境","date":"2023-02-12","objectID":"/read_linux/:1:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#建立环境"},{"categories":["Linux Kernel"],"content":" 1.1 基础环境 安装软件 $ sudo apt install qemu $ sudo apt install gcc-arm-none-eabi 下载源码 $ git clone https://github.com/figozhang/runninglinuxkernel_4.0.git 构建运行 编译32位arm cd runninglinuxkernel_4.0 ./run_debian_arm32.sh build_kernel sudo ./run_debian_arm32.sh build_rootfs ./run_debian_arm32.sh build_run 编译64位arm cd runninglinuxkernel_4.0 ./run_debian_arm64.sh build_kernel sudo ./run_debian_arm64.sh build_rootfs ./run_debian_arm64.sh build_run 安装gdb-multiarch 参考资料:Archlinux gdb-multiarch构建 # 下载代码 git clone --branch gdb-13-branch https://sourceware.org/git/binutils-gdb.git # 执行构建 mkdir build \u0026\u0026 cd build ../configure \\ --enable-targets=all \\ --prefix=/build \\ --enable-languages=all \\ --enable-multilib \\ --enable-interwork \\ --with-system-readline \\ --disable-nls \\ --with-python=/usr/bin/python \\ --with-system-gdbinit=/etc/gdb/gdbinit make -j`nproc` make install # 修改文件名 mv /usr/bin/gdb /usr/bin/gdb-multiarch 运行gdb-multiarch # 加载执行文件 $ file vmlinux # 设置架构 $ set architecture arm # 远程连接 $ target remote localhost:1234 ","date":"2023-02-12","objectID":"/read_linux/:1:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#基础环境"},{"categories":["Linux Kernel"],"content":" 1.2 调试环境(eclipse) 安装eclipse 安装jdk $ sudo apt update $ sudo apt install default-jre 下载eclipse C/C++ 配置调试 ","date":"2023-02-12","objectID":"/read_linux/:1:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#调试环境eclipse"},{"categories":["Linux Kernel"],"content":" 1.3 调试环境(vscode)当然vscode也是相当好用的,作为调试程序 在当前工程中添加配置文件launch.json { \"configurations\": [ { \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"Linux Gdb Server\", \"program\": \"${workspaceRoot}/vmlinux\", \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb-multiarch\", \"miDebuggerServerAddress\": \"localhost:1234\", \"cwd\": \"${workspaceRoot}\", \"externalConsole\": false } ] } 安装调试器 yay -S gdb-multiarch 启动调试器 ","date":"2023-02-12","objectID":"/read_linux/:1:3","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#调试环境vscode"},{"categories":["Linux Kernel"],"content":" 1.4 调试环境(原始gdb) 安装gdbgui # 安装 pip install gdbgui # 设计 pip install --upgrade gdbgui # 卸载 $ pip uninstall gdbgui 运行gdbgui gdbgui -g arm-multiarch ","date":"2023-02-12","objectID":"/read_linux/:1:4","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#调试环境原始gdb"},{"categories":["Linux Kernel"],"content":" 2 系统构建镜像文件的整体过程 构建vmlinux,objcopy生成vmlinux.bin,然后将其压缩为vmlinux.bin.gz 添加操作,生成vmlinux.bin 构造setup.bin 将setup.bin与vmlinux.bin进行合成,生成bzImage ","date":"2023-02-12","objectID":"/read_linux/:2:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#系统构建"},{"categories":["Linux Kernel"],"content":" 2.1 vmlinux生成过程 # x86_64架构链接过程 ld -m elf_x86_64 --no-ld-generated-unwind-info -pie --no-dynamic-linker --orphan-handling=error -z noexecstack --no-warn-rwx-segments -T arch/x86/boot/compressed/vmlinux.lds arch/x86/boot/compressed/kernel_info.o arch/x86/boot/compressed/head_64.o arch/x86/boot/compressed/misc.o arch/x86/boot/compressed/string.o arch/x86/boot/compressed/cmdline.o arch/x86/boot/compressed/error.o arch/x86/boot/compressed/piggy.o arch/x86/boot/compressed/cpuflags.o arch/x86/boot/compressed/early_serial_console.o arch/x86/boot/compressed/kaslr.o arch/x86/boot/compressed/ident_map_64.o arch/x86/boot/compressed/idt_64.o arch/x86/boot/compressed/idt_handlers_64.o arch/x86/boot/compressed/pgtable_64.o arch/x86/boot/compressed/acpi.o arch/x86/boot/compressed/efi.o arch/x86/boot/compressed/efi_mixed.o drivers/firmware/efi/libstub/lib.a -o arch/x86/boot/compressed/vmlinux # arm32链接过程 ","date":"2023-02-12","objectID":"/read_linux/:2:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#vmlinux生成过程"},{"categories":["Linux Kernel"],"content":" 2.2 vmlinux.bin生成过程 objcopy -O binary -R .note -R .comment -S arch/x86/boot/compressed/vmlinux arch/x86/boot/vmlinux.bin ","date":"2023-02-12","objectID":"/read_linux/:2:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#vmlinuxbin生成过程"},{"categories":["Linux Kernel"],"content":" 2.3 header.o gcc -Wp,-MMD,arch/x86/boot/.header.o.d -nostdinc -I./arch/x86/include -I./arch/x86/include/generated -I./include -I./arch/x86/include/uapi -I./arch/x86/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/compiler-version.h -include ./include/linux/kconfig.h -D__KERNEL__ -Werror -fmacro-prefix-map=./= -m16 -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS -Wall -Wstrict-prototypes -march=i386 -mregparm=3 -fno-strict-aliasing -fomit-frame-pointer -fno-pic -mno-mmx -mno-sse -fcf-protection=none -ffreestanding -fno-stack-protector -Wno-address-of-packed-member -mpreferred-stack-boundary=2 -D_SETUP -D__ASSEMBLY__ -DSVGA_MODE=NORMAL_VGA -I./arch/x86/boot -c -o arch/x86/boot/header.o arch/x86/boot/header.S ","date":"2023-02-12","objectID":"/read_linux/:2:3","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#headero"},{"categories":["Linux Kernel"],"content":" 2.4 setup.bin生成过程 ld -m elf_x86_64 -z noexecstack --no-warn-rwx-segments -m elf_i386 -z noexecstack -T arch/x86/boot/setup.ld arch/x86/boot/a20.o arch/x86/boot/bioscall.o arch/x86/boot/cmdline.o arch/x86/boot/copy.o arch/x86/boot/cpu.o arch/x86/boot/cpuflags.o arch/x86/boot/cpucheck.o arch/x86/boot/early_serial_console.o arch/x86/boot/edd.o arch/x86/boot/header.o arch/x86/boot/main.o arch/x86/boot/memory.o arch/x86/boot/pm.o arch/x86/boot/pmjump.o arch/x86/boot/printf.o arch/x86/boot/regs.o arch/x86/boot/string.o arch/x86/boot/tty.o arch/x86/boot/video.o arch/x86/boot/video-mode.o arch/x86/boot/version.o arch/x86/boot/video-vga.o arch/x86/boot/video-vesa.o arch/x86/boot/video-bios.o -o arch/x86/boot/setup.elf objcopy -O binary arch/x86/boot/setup.elf arch/x86/boot/setup.bin ","date":"2023-02-12","objectID":"/read_linux/:2:4","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#setupbin生成过程"},{"categories":["Linux Kernel"],"content":" 2.5 最后生成 arch/x86/boot/tools/build arch/x86/boot/setup.bin arch/x86/boot/vmlinux.bin arch/x86/boot/zoffset.h arch/x86/boot/bzImag ","date":"2023-02-12","objectID":"/read_linux/:2:5","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#最后生成"},{"categories":["Linux Kernel"],"content":" 3 根文件系统linux系统在启动之后需要加载根文件系统 ","date":"2023-02-12","objectID":"/read_linux/:3:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#根文件系统"},{"categories":["Linux Kernel"],"content":" 3.1 编译busybox","date":"2023-02-12","objectID":"/read_linux/:3:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#编译busybox"},{"categories":["Linux Kernel"],"content":" 3.2 安装C库从交叉编译器中拷贝即可 ","date":"2023-02-12","objectID":"/read_linux/:3:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#安装c库"},{"categories":["Linux Kernel"],"content":" 4 initramfs","date":"2023-02-12","objectID":"/read_linux/:4:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#initramfs"},{"categories":["Linux Kernel"],"content":" 4.1 Hello initramfs #include \u003cstdio.h\u003e void main(int argc, char *argv[]) { printf(\"Hello initramfs\\n\"); fflush(stdout); while(1); } 执行构建 gcc -static -o init init.c echo init | cpio -o --format=newc \u003e initramfs 启动测试 qemu-system-x86_64 -kernel linux/arch/x86_64/boot/bzImage -initrd initramfs -append \"console=ttyS0 rdinit=init\" -nographic 然后就可以发现打印的数据 ","date":"2023-02-12","objectID":"/read_linux/:4:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#hello-initramfs"},{"categories":["Linux Kernel"],"content":" 5 启动分析一般情况下，我们都会讲断点打在start_kernel上,但是在进入C语言之前会存在一段汇编代码; 入口地址,我们可以通过链接脚本分析得到 链接头文件,那么真正的链接文件在**[arch/arm/kernel/vmlinux.lds]**,但是这个文件是生成的; 这个链接脚本用来描述vmlinux的生成 但是aarch64入口地址就是 graph LR stext --\u003e __mmap_switched __mmap_switched --\u003e start_kernel ","date":"2023-02-12","objectID":"/read_linux/:5:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#启动分析"},{"categories":["Linux Kernel"],"content":" 5.1 启动前夕启动前夕(ARM32) __mmap_switched: adr r3, __mmap_switched_data ldmia r3!, {r4, r5, r6, r7} cmp r4, r5 @ Copy data segment if needed 1: cmpne r5, r6 ldrne fp, [r4], #4 strne fp, [r5], #4 bne 1b mov fp, #0 @ Clear BSS (and zero fp) 1: cmp r6, r7 strcc fp, [r6],#4 bcc 1b ARM( ldmia r3, {r4, r5, r6, r7, sp}) THUMB( ldmia r3, {r4, r5, r6, r7} ) THUMB( ldr sp, [r3, #16] ) str r9, [r4] @ Save processor ID str r1, [r5] @ Save machine type str r2, [r6] @ Save atags pointer cmp r7, #0 strne r0, [r7] @ Save control register values b start_kernel ENDPROC(__mmap_switched) 启动前夕(ARM64) __mmap_switched: adr x3, __switch_data + 8 ldp x6, x7, [x3], #16 1: cmp x6, x7 b.hs 2f str xzr, [x6], #8 // Clear BSS b 1b 2: ldp x4, x5, [x3], #16 ldr x6, [x3], #8 ldr x16, [x3] mov sp, x16 str x22, [x4] // Save processor ID str x21, [x5] // Save FDT pointer str x24, [x6] // Save PHYS_OFFSET mov x29, #0 b start_kernel ENDPROC(__mmap_switched) .align 3 .type __switch_data, %object __switch_data: .quad __mmap_switched .quad __bss_start // x6 .quad __bss_stop // x7 .quad processor_id // x4 .quad __fdt_pointer // x5 .quad memstart_addr // x6 .quad init_thread_union + THREAD_START_SP // sp ENTRY(stext) mov x21, x0 // x21=FDT bl el2_setup // Drop to EL1, w20=cpu_boot_mode bl __calc_phys_offset // x24=PHYS_OFFSET, x28=PHYS_OFFSET-PAGE_OFFSET bl set_cpu_boot_mode_flag mrs x22, midr_el1 // x22=cpuid mov x0, x22 bl lookup_processor_type mov x23, x0 // x23=current cpu_table /* * __error_p may end up out of range for cbz if text areas are * aligned up to section sizes. */ cbnz x23, 1f // invalid processor (x23=0)? b __error_p 1: bl __vet_fdt bl __create_page_tables // x25=TTBR0, x26=TTBR1 /* * The following calls CPU specific code in a position independent * manner. See arch/arm64/mm/proc.S for details. x23 = base of * cpu_info structure selected by lookup_processor_type above. * On return, the CPU will be ready for the MMU to be turned on and * the TCR will have been set. */ ldr x27, __switch_data // address to jump to after // MMU has been enabled adrp lr, __enable_mmu // return (PIC) address add lr, lr, #:lo12:__enable_mmu ldr x12, [x23, #CPU_INFO_SETUP] add x12, x12, x28 // __virt_to_phys br x12 // initialise processor ENDPROC(stext) 上面的汇编函数都是由head.s跳入继续向下分析,谁开启了汇编,如何执行到这个函数vmlinux.lds决定，分析实现; 需要分析bootloader的实现; 下面我们开始分析 ","date":"2023-02-12","objectID":"/read_linux/:5:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#启动前夕"},{"categories":["Linux Kernel"],"content":" 5.2 start_kernel进入内核中第一个C语言启动函数;源码位置 asmlinkage __visible void __init start_kernel(void) { char *command_line; char *after_dashes; // 死锁检测 lockdep_init(); // 设置启动任务的结束磨数 set_task_stack_end_magic(\u0026init_task); // 设置smp id smp_setup_processor_id(); // debug debug_objects_early_init(); // 堆栈保护机制 boot_init_stack_canary(); // cgroup初始化 cgroup_init_early(); // irq中断停止，设置标志位 local_irq_disable(); early_boot_irqs_disabled = true; // 激活启动CPU boot_cpu_init(); // 单独章节分析 page_address_init(); pr_notice(\"%s\", linux_banner); // 设置架构 setup_arch(\u0026command_line); mm_init_cpumask(\u0026init_mm); setup_command_line(command_line); setup_nr_cpu_ids(); setup_per_cpu_areas(); smp_prepare_boot_cpu(); /* arch-specific boot-cpu hooks */ build_all_zonelists(NULL, NULL); page_alloc_init(); pr_notice(\"Kernel command line: %s\\n\", boot_command_line); parse_early_param(); after_dashes = parse_args(\"Booting kernel\", static_command_line, __start___param, __stop___param - __start___param, -1, -1, \u0026unknown_bootoption); if (!IS_ERR_OR_NULL(after_dashes)) parse_args(\"Setting init args\", after_dashes, NULL, 0, -1, -1, set_init_arg); jump_label_init(); /* * These use large bootmem allocations and must precede * kmem_cache_init() */ setup_log_buf(0); pidhash_init(); vfs_caches_init_early(); sort_main_extable(); trap_init(); mm_init(); /* * Set up the scheduler prior starting any interrupts (such as the * timer interrupt). Full topology setup happens at smp_init() * time - but meanwhile we still have a functioning scheduler. */ sched_init(); /* * Disable preemption - early bootup scheduling is extremely * fragile until we cpu_idle() for the first time. */ preempt_disable(); if (WARN(!irqs_disabled(), \"Interrupts were enabled *very* early, fixing it\\n\")) local_irq_disable(); idr_init_cache(); rcu_init(); /* trace_printk() and trace points may be used after this */ trace_init(); context_tracking_init(); radix_tree_init(); /* init some links before init_ISA_irqs() */ early_irq_init(); init_IRQ(); tick_init(); rcu_init_nohz(); init_timers(); hrtimers_init(); softirq_init(); timekeeping_init(); time_init(); sched_clock_postinit(); perf_event_init(); profile_init(); call_function_init(); WARN(!irqs_disabled(), \"Interrupts were enabled early\\n\"); early_boot_irqs_disabled = false; local_irq_enable(); kmem_cache_init_late(); /* * HACK ALERT! This is early. We're enabling the console before * we've done PCI setups etc, and console_init() must be aware of * this. But we do want output early, in case something goes wrong. */ console_init(); if (panic_later) panic(\"Too many boot %s vars at `%s'\", panic_later, panic_param); lockdep_info(); /* * Need to run this when irqs are enabled, because it wants * to self-test [hard/soft]-irqs on/off lock inversion bugs * too: */ locking_selftest(); #ifdef CONFIG_BLK_DEV_INITRD if (initrd_start \u0026\u0026 !initrd_below_start_ok \u0026\u0026 page_to_pfn(virt_to_page((void *)initrd_start)) \u003c min_low_pfn) { pr_crit(\"initrd overwritten (0x%08lx \u003c 0x%08lx) - disabling it.\\n\", page_to_pfn(virt_to_page((void *)initrd_start)), min_low_pfn); initrd_start = 0; } #endif page_ext_init(); debug_objects_mem_init(); kmemleak_init(); setup_per_cpu_pageset(); numa_policy_init(); if (late_time_init) late_time_init(); sched_clock_init(); calibrate_delay(); pidmap_init(); anon_vma_init(); acpi_early_init(); #ifdef CONFIG_X86 if (efi_enabled(EFI_RUNTIME_SERVICES)) efi_enter_virtual_mode(); #endif #ifdef CONFIG_X86_ESPFIX64 /* Should be run before the first non-init thread is created */ init_espfix_bsp(); #endif thread_info_cache_init(); cred_init(); fork_init(totalram_pages); proc_caches_init(); buffer_init(); key_init(); security_init(); dbg_late_init(); vfs_caches_init(totalram_pages); signals_init(); /* rootfs populating might need page-writeback */ page_writeback_init(); proc_root_init(); nsfs_init(); cgroup_init(); cpuset_init(); taskstats_init_early(); delayacct_init(); check_bugs(); sfi_init_late(); if (efi_enabled(EFI_RUNTIME_SERVICES)) { efi_late_init(); efi_free_boot_services(); ","date":"2023-02-12","objectID":"/read_linux/:5:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#start_kernel"},{"categories":["Linux Kernel"],"content":" 5.3 reset_init这个是系统调用的最后一个函数,调用结束后不会返回 static noinline void __init_refok rest_init(void) { int pid; rcu_scheduler_starting(); /* * We need to spawn init first so that it obtains pid 1, however * the init task will end up wanting to create kthreads, which, if * we schedule it before we create kthreadd, will OOPS. */ kernel_thread(kernel_init, NULL, CLONE_FS); numa_default_policy(); pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); rcu_read_lock(); kthreadd_task = find_task_by_pid_ns(pid, \u0026init_pid_ns); rcu_read_unlock(); complete(\u0026kthreadd_done); /* * The boot idle thread must execute schedule() * at least once to get things moving: */ init_idle_bootup_task(current); schedule_preempt_disabled(); /* Call into cpu_idle with preempt disabled */ cpu_startup_entry(CPUHP_ONLINE); } ","date":"2023-02-12","objectID":"/read_linux/:5:3","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#reset_init"},{"categories":["Linux Kernel"],"content":" 5.4 设置init任务堆栈 set_task_stack_end_magic(\u0026init_task); void set_task_stack_end_magic(struct task_struct *tsk) { unsigned long *stackend; stackend = end_of_stack(tsk); *stackend = STACK_END_MAGIC; /* for overflow detection */ } 此处可以得知: static inline unsigned long *end_of_stack(struct task_struct *p) { #ifdef CONFIG_STACK_GROWSUP return (unsigned long *)((unsigned long)task_thread_info(p) + THREAD_SIZE) - 1; #else return (unsigned long *)(task_thread_info(p) + 1); #endif } ","date":"2023-02-12","objectID":"/read_linux/:5:4","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置init任务堆栈"},{"categories":["Linux Kernel"],"content":" 5.5 设置smp的CPU ID int nr_cpu_ids __read_mostly = NR_CPUS; // 此参数通过配置文件得到 EXPORT_SYMBOL(nr_cpu_ids); u32 __cpu_logical_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID }; #define cpu_logical_map(cpu) __cpu_logical_map[cpu] // 1. 设置cpu_logical_map // 2. 设置线程ID // 3. 打印日志 void __init smp_setup_processor_id(void) { int i; u32 mpidr = is_smp() ? read_cpuid_mpidr() \u0026 MPIDR_HWID_BITMASK : 0; u32 cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0); cpu_logical_map(0) = cpu; for (i = 1; i \u003c nr_cpu_ids; ++i) cpu_logical_map(i) = i == cpu ? 0 : i; /* * clear __my_cpu_offset on boot CPU to avoid hang caused by * using percpu variable early, for example, lockdep will * access percpu variable inside lock_release */ set_my_cpu_offset(0); pr_info(\"Booting Linux on physical CPU 0x%x\\n\", mpidr); } // 设置线程ID static inline void set_my_cpu_offset(unsigned long off) { /* Set TPIDRPRW */ // off=0x0 asm volatile(\"mcr p15, 0, %0, c13, c0, 4\" : : \"r\" (off) : \"memory\"); } ","date":"2023-02-12","objectID":"/read_linux/:5:5","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置smp的cpu-id"},{"categories":["Linux Kernel"],"content":" 5.6 激活启动CPU static void __init boot_cpu_init(void) { int cpu = smp_processor_id(); /* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */ set_cpu_online(cpu, true); set_cpu_active(cpu, true); set_cpu_present(cpu, true); set_cpu_possible(cpu, true); } ","date":"2023-02-12","objectID":"/read_linux/:5:6","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#激活启动cpu"},{"categories":["Linux Kernel"],"content":" 5.7 设置架构读取配置文件(设置树),设置内存信息 在设备树一章节中会详细分析 void __init setup_arch(char **cmdline_p) { // 机器描述符 const struct machine_desc *mdesc; // 设置处理器相关信息 setup_processor(); // 读取设备树信息 mdesc = setup_machine_fdt(__atags_pointer); if (!mdesc) mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type); // 设置到全局变量 machine_desc = mdesc; machine_name = mdesc-\u003ename; dump_stack_set_arch_desc(\"%s\", mdesc-\u003ename); if (mdesc-\u003ereboot_mode != REBOOT_HARD) reboot_mode = mdesc-\u003ereboot_mode; // 设置init任务 init_mm.start_code = (unsigned long) _text; init_mm.end_code = (unsigned long) _etext; init_mm.end_data = (unsigned long) _edata; init_mm.brk = (unsigned long) _end; /* populate cmd_line too for later use, preserving boot_command_line */ strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE); *cmdline_p = cmd_line; parse_early_param(); // 读取设备树 early_paging_init(mdesc, lookup_processor_type(read_cpuid_id())); setup_dma_zone(mdesc); sanity_check_meminfo(); arm_memblock_init(mdesc); paging_init(mdesc); request_standard_resources(mdesc); if (mdesc-\u003erestart) arm_pm_restart = mdesc-\u003erestart; unflatten_device_tree(); arm_dt_init_cpu_maps(); psci_init(); #ifdef CONFIG_SMP if (is_smp()) { if (!mdesc-\u003esmp_init || !mdesc-\u003esmp_init()) { if (psci_smp_available()) smp_set_ops(\u0026psci_smp_ops); else if (mdesc-\u003esmp) smp_set_ops(mdesc-\u003esmp); } smp_init_cpus(); smp_build_mpidr_hash(); } #endif if (!is_smp()) hyp_mode_check(); reserve_crashkernel(); #ifdef CONFIG_MULTI_IRQ_HANDLER handle_arch_irq = mdesc-\u003ehandle_irq; #endif #ifdef CONFIG_VT #if defined(CONFIG_VGA_CONSOLE) conswitchp = \u0026vga_con; #elif defined(CONFIG_DUMMY_CONSOLE) conswitchp = \u0026dummy_con; #endif #endif if (mdesc-\u003einit_early) mdesc-\u003einit_early(); } ","date":"2023-02-12","objectID":"/read_linux/:5:7","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置架构"},{"categories":["Linux Kernel"],"content":" 5.8 mm_init_cpumask清理内存管理系统的init_mm-\u003ecpu_vm_mask_var static inline void mm_init_cpumask(struct mm_struct *mm) { #ifdef CONFIG_CPUMASK_OFFSTACK mm-\u003ecpu_vm_mask_var = \u0026mm-\u003ecpumask_allocation; #endif cpumask_clear(mm-\u003ecpu_vm_mask_var); } ","date":"2023-02-12","objectID":"/read_linux/:5:8","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#mm_init_cpumask"},{"categories":["Linux Kernel"],"content":" 5.9 设置命令行command_line申请内存， 保存命令行参数 /* Untouched saved command line (eg. for /proc) */ char *saved_command_line; /* Command line for parameter parsing */ static char *static_command_line; /* Command line for per-initcall parameter parsing */ static char *initcall_command_line; static void __init setup_command_line(char *command_line) { saved_command_line = memblock_virt_alloc(strlen(boot_command_line) + 1, 0); initcall_command_line = memblock_virt_alloc(strlen(boot_command_line) + 1, 0); static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0); strcpy(saved_command_line, boot_command_line); strcpy(static_command_line, command_line); } ","date":"2023-02-12","objectID":"/read_linux/:5:9","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置命令行command_line"},{"categories":["Linux Kernel"],"content":" 5.10 设置CPU setup_nr_cpu_ids setup_per_cpu_areas /* Setup number of possible processor ids */ int nr_cpu_ids __read_mostly = NR_CPUS; EXPORT_SYMBOL(nr_cpu_ids); /* An arch may set nr_cpu_ids earlier if needed, so this would be redundant */ void __init setup_nr_cpu_ids(void) { nr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1; } ","date":"2023-02-12","objectID":"/read_linux/:5:10","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置cpu"},{"categories":["Linux Kernel"],"content":" 5.11 smp_prepare_boot_cpu static inline void set_my_cpu_offset(unsigned long off) { /* Set TPIDRPRW */ asm volatile(\"mcr p15, 0, %0, c13, c0, 4\" : : \"r\" (off) : \"memory\"); } void __init smp_prepare_boot_cpu(void) { set_my_cpu_offset(per_cpu_offset(smp_processor_id())); } ","date":"2023-02-12","objectID":"/read_linux/:5:11","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#smp_prepare_boot_cpu"},{"categories":["Linux Kernel"],"content":" 5.12 build_all_zonelists启动期间构建zone, [build_all_zonelists –\u003e build_all_zonelists_init] /* * zonelist_order: * 0 = automatic detection of better ordering. * 1 = order by ([node] distance, -zonetype) * 2 = order by (-zonetype, [node] distance) * * If not NUMA, ZONELIST_ORDER_ZONE and ZONELIST_ORDER_NODE will create * the same zonelist. So only NUMA can configure this param. */ #define ZONELIST_ORDER_DEFAULT 0 #define ZONELIST_ORDER_NODE 1 #define ZONELIST_ORDER_ZONE 2 /* zonelist order in the kernel. * set_zonelist_order() will set this to NODE or ZONE. */ static int current_zonelist_order = ZONELIST_ORDER_DEFAULT; static char zonelist_order_name[3][8] = {\"Default\", \"Node\", \"Zone\"}; static void set_zonelist_order(void) { current_zonelist_order = ZONELIST_ORDER_ZONE; } 最终调用到build_all_zonelists_init static noinline void __init build_all_zonelists_init(void) { __build_all_zonelists(NULL); mminit_verify_zonelist(); cpuset_init_current_mems_allowed(); } ","date":"2023-02-12","objectID":"/read_linux/:5:12","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#build_all_zonelists"},{"categories":["Linux Kernel"],"content":" 5.13 page_alloc_init void __init page_alloc_init(void) { hotcpu_notifier(page_alloc_cpu_notify, 0); } ","date":"2023-02-12","objectID":"/read_linux/:5:13","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#page_alloc_init"},{"categories":["Linux Kernel"],"content":" 5.14 jump_label_init /* * Used to generate warnings if static_key manipulation functions are used * before jump_label_init is called. */ bool static_key_initialized __read_mostly; EXPORT_SYMBOL_GPL(static_key_initialized); static __always_inline void jump_label_init(void) { static_key_initialized = true; } ","date":"2023-02-12","objectID":"/read_linux/:5:14","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#jump_label_init"},{"categories":["Linux Kernel"],"content":" 5.15 setup_log_buf设置日志buf ","date":"2023-02-12","objectID":"/read_linux/:5:15","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#setup_log_buf"},{"categories":["Linux Kernel"],"content":" 5.16 pidhash_init struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; }; static struct hlist_head *pid_hash; static unsigned int pidhash_shift = 4; void __init pidhash_init(void) { unsigned int i, pidhash_size; pid_hash = alloc_large_system_hash(\"PID\", sizeof(*pid_hash), 0, 18, HASH_EARLY | HASH_SMALL, \u0026pidhash_shift, NULL, 0, 4096); pidhash_size = 1U \u003c\u003c pidhash_shift; for (i = 0; i \u003c pidhash_size; i++) INIT_HLIST_HEAD(\u0026pid_hash[i]); } ","date":"2023-02-12","objectID":"/read_linux/:5:16","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#pidhash_init"},{"categories":["前端知识"],"content":"nodejs基础教程","date":"2023-01-02","objectID":"/nodejs/","series":null,"tags":["前端知识"],"title":"Nodejs笔记","uri":"/nodejs/"},{"categories":["前端知识"],"content":" 1 Nodejs安装","date":"2023-01-02","objectID":"/nodejs/:1:0","series":null,"tags":["前端知识"],"title":"Nodejs笔记","uri":"/nodejs/#nodejs安装"},{"categories":["前端知识"],"content":" 2 Nodejs教程","date":"2023-01-02","objectID":"/nodejs/:2:0","series":null,"tags":["前端知识"],"title":"Nodejs笔记","uri":"/nodejs/#nodejs教程"},{"categories":["RTOS"],"content":"RTOS","date":"2022-10-30","objectID":"/freertos/","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/"},{"categories":["RTOS"],"content":" 1 基本概念","date":"2022-10-30","objectID":"/freertos/:1:0","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#基本概念"},{"categories":["RTOS"],"content":" 1.1 任务 一个死循环的函数运行(在RTOS中) ","date":"2022-10-30","objectID":"/freertos/:1:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务"},{"categories":["RTOS"],"content":" 1.2 函数运行环境(context) 寄存器 堆栈信息 ","date":"2022-10-30","objectID":"/freertos/:1:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#函数运行环境context"},{"categories":["RTOS"],"content":" 1.3 函数执行原理 pc/lr push/pop 下面写一个简单的函数,测试一下 函数是如何尽心调用的; int test(int a, int b) { return 0; } void main(void) { test(1, 2); } main –\u003e test 下面是程序编译后得到的汇编源码 test: push {r7} @ r7 --\u003e stack sub sp, sp, #12 @ sp = sp + 12 // 三个局部变量 add r7, sp, #0 @ r7 = sp str r0, [r7, #4] @ 保存第一个变量 str r1, [r7] @ 保存第二个变量 movs r3, #0 @ r3 = 0 mov r0, r3 @ r0 = r3 adds r7, r7, #12 @ r7 = r7 + 12 mov sp, r7 @ sp = r7 (销毁堆栈) ldr r7, [sp], #4 @ 恢复r7 bx lr @ 执行返回 main: push {r7, lr} @ 保存r7, lr add r7, sp, #0 @ r7 = sp movs r1, #2 @ r1 = 2 movs r0, #1 @ r0 = 1 bl test @ call test nop @ nop pop {r7, pc} @ lr_r = pc_v @ r7_r = r7_v ","date":"2022-10-30","objectID":"/freertos/:1:3","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#函数执行原理"},{"categories":["RTOS"],"content":" 1.4 总结那么,多任务就可以任务是从一个函数切换到另外一个函数; 但是此种切换对于任务来说是不可见的; 任务切换需要特权(定时器中断) 任务切换需要时停(开关中断) ","date":"2022-10-30","objectID":"/freertos/:1:4","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#总结"},{"categories":["RTOS"],"content":" 2 任务","date":"2022-10-30","objectID":"/freertos/:2:0","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务-1"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务创建"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#分配tcb结构体"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#初始化tcb成员变量"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#加入就绪列表"},{"categories":["RTOS"],"content":" 2.2 任务调度 任务调度的基础 可调用中断(可选) 定时器中断 2.2.1 调度器核心 void vTaskSwitchContext(void) { if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) { /* The scheduler is currently suspended - do not allow a context * switch. */ xYieldPending = pdTRUE; } else { xYieldPending = pdFALSE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations - which * are provided by the application, not the kernel. */ if( ulTotalRunTime \u003e ulTaskSwitchedInTime ) { pxCurrentTCB-\u003eulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime ); } else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime = ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskCHECK_FOR_STACK_OVERFLOW(); /* Before the currently running task is switched out, save its errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { pxCurrentTCB-\u003eiTaskErrno = FreeRTOS_errno; } #endif /* Select a new task to run using either the generic C or port * optimised asm code. */ taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ traceTASK_SWITCHED_IN(); /* After the new task is switched in, update the global errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { FreeRTOS_errno = pxCurrentTCB-\u003eiTaskErrno; } #endif #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) { /* Switch C-Runtime's TLS Block to point to the TLS * Block specific to this task. */ configSET_TLS_BLOCK( pxCurrentTCB-\u003exTLSBlock ); } #endif } } 分析M3的调度实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } 分析A9实现 vTaskSwitchContextConst: .word vTaskSwitchContext .macro portSAVE_CONTEXT /* Save the LR and SPSR onto the system mode stack before switching to system mode to save the remaining system mode registers. */ SRSDB sp!, #SYS_MODE CPS #SYS_MODE PUSH {R0-R12, R14} /* Push the critical nesting count. */ LDR R2, ulCriticalNestingConst LDR R1, [R2] PUSH {R1} /* Does the task have a floating point context that needs saving? If ulPortTaskHasFPUContext is 0 then no. */ LDR R2, ulPortTaskHasFPUContextConst LDR R3, [R2] CMP R3, #0 /* Save the floating point context, if any. */ FMRXNE R1, FPSCR VPUSHNE {D0-D15} VPUSHNE {D16-D31} PUSHNE {R1} /* Save ulPortTaskHasFPUContext itself. */ PUSH {R3} /* Save the stack pointer in the TCB. */ LDR R0, pxCurrentTCBConst LDR R1, [R0] STR SP, [R1] .endm ; /**********************************************************************/ .macro portRESTORE_CONTEXT /* Set the SP to point to the stack of the task being","date":"2022-10-30","objectID":"/freertos/:2:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务调度"},{"categories":["RTOS"],"content":" 2.2 任务调度 任务调度的基础 可调用中断(可选) 定时器中断 2.2.1 调度器核心 void vTaskSwitchContext(void) { if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) { /* The scheduler is currently suspended - do not allow a context * switch. */ xYieldPending = pdTRUE; } else { xYieldPending = pdFALSE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations - which * are provided by the application, not the kernel. */ if( ulTotalRunTime \u003e ulTaskSwitchedInTime ) { pxCurrentTCB-\u003eulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime ); } else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime = ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskCHECK_FOR_STACK_OVERFLOW(); /* Before the currently running task is switched out, save its errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { pxCurrentTCB-\u003eiTaskErrno = FreeRTOS_errno; } #endif /* Select a new task to run using either the generic C or port * optimised asm code. */ taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ traceTASK_SWITCHED_IN(); /* After the new task is switched in, update the global errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { FreeRTOS_errno = pxCurrentTCB-\u003eiTaskErrno; } #endif #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) { /* Switch C-Runtime's TLS Block to point to the TLS * Block specific to this task. */ configSET_TLS_BLOCK( pxCurrentTCB-\u003exTLSBlock ); } #endif } } 分析M3的调度实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } 分析A9实现 vTaskSwitchContextConst: .word vTaskSwitchContext .macro portSAVE_CONTEXT /* Save the LR and SPSR onto the system mode stack before switching to system mode to save the remaining system mode registers. */ SRSDB sp!, #SYS_MODE CPS #SYS_MODE PUSH {R0-R12, R14} /* Push the critical nesting count. */ LDR R2, ulCriticalNestingConst LDR R1, [R2] PUSH {R1} /* Does the task have a floating point context that needs saving? If ulPortTaskHasFPUContext is 0 then no. */ LDR R2, ulPortTaskHasFPUContextConst LDR R3, [R2] CMP R3, #0 /* Save the floating point context, if any. */ FMRXNE R1, FPSCR VPUSHNE {D0-D15} VPUSHNE {D16-D31} PUSHNE {R1} /* Save ulPortTaskHasFPUContext itself. */ PUSH {R3} /* Save the stack pointer in the TCB. */ LDR R0, pxCurrentTCBConst LDR R1, [R0] STR SP, [R1] .endm ; /**********************************************************************/ .macro portRESTORE_CONTEXT /* Set the SP to point to the stack of the task being","date":"2022-10-30","objectID":"/freertos/:2:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#调度器核心"},{"categories":["RTOS"],"content":" 2.3 任务状态 心跳实现 M3实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } A9实现 .align 4 .type FreeRTOS_IRQ_Handler, %function FreeRTOS_IRQ_Handler: /* Return to the interrupted instruction. */ SUB lr, lr, #4 /* Push the return address and SPSR. */ PUSH {lr} MRS lr, SPSR PUSH {lr} /* Change to supervisor mode to allow reentry. */ CPS #SVC_MODE /* Push used registers. */ PUSH {r0-r4, r12} /* Increment nesting count. r3 holds the address of ulPortInterruptNesting for future use. r1 holds the original ulPortInterruptNesting value for future use. */ LDR r3, ulPortInterruptNestingConst LDR r1, [r3] ADD r4, r1, #1 STR r4, [r3] /* Read value from the interrupt acknowledge register, which is stored in r0 for future parameter and interrupt clearing use. */ LDR r2, ulICCIARConst LDR r2, [r2] LDR r0, [r2] /* Ensure bit 2 of the stack pointer is clear. r2 holds the bit 2 value for future use. _RB_ Does this ever actually need to be done provided the start of the stack is 8-byte aligned? */ MOV r2, sp AND r2, r2, #4 SUB sp, sp, r2 /* Call the interrupt handler. r4 pushed to maintain alignment. */ PUSH {r0-r4, lr} LDR r1, vApplicationIRQHandlerConst BLX r1 POP {r0-r4, lr} ADD sp, sp, r2 CPSID i DSB ISB /* Write the value read from ICCIAR to ICCEOIR. */ LDR r4, ulICCEOIRConst LDR r4, [r4] STR r0, [r4] /* Restore the old nesting count. */ STR r1, [r3] /* A context switch is never performed if the nesting count is not 0. */ CMP r1, #0 BNE exit_without_switch /* Did the interrupt request a context switch? r1 holds the address of ulPortYieldRequired and r0 the value of ulPortYieldRequired for future use. */ LDR r1, =ulPortYieldRequired LDR r0, [r1] CMP r0, #0 BNE switch_before_exit exit_without_switch: /* No context switch. Restore used registers, LR_irq and SPSR before returning. */ POP {r0-r4, r12} CPS #IRQ_MODE POP {LR} MSR SPSR_cxsf, LR POP {LR} MOVS PC, LR switch_before_exit: /* A context swtich is to be performed. Clear the context switch pending flag. */ MOV r0, #0 STR r0, [r1] /* Restore used registers, LR-irq and SPSR before saving the context to the task stack. */ POP {r0-r4, r12} CPS #IRQ_MODE POP {LR} MSR SPSR_cxsf, LR POP {LR} portSAVE_CONTEXT /* Call the function that selects the new task to execute. vTaskSwitchContext() if vTaskSwitchContext() uses LDRD or STRD instructions, or 8 byte aligned stack allocated data. LR does not need saving as a new LR will be loaded by portRESTORE_CONTEXT anyway. */ LDR R0, vTaskSwitchContextConst BLX R0 /* Restore the context of, and branch to, the task selected to execute next. */ portRESTORE_CONTEXT ","date":"2022-10-30","objectID":"/freertos/:2:3","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务状态"},{"categories":["arm"],"content":"arm汇编","date":"2022-09-24","objectID":"/arm/","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/"},{"categories":["arm"],"content":" 1 体系结构参考文件 arm指令手册1 arm指令手册2 arm指令手册3 ","date":"2022-09-24","objectID":"/arm/:1:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#体系结构"},{"categories":["arm"],"content":" 1.1 相关术语 流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE ","date":"2022-09-24","objectID":"/arm/:1:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#相关术语"},{"categories":["arm"],"content":" 1.2 工具链 文件名 详解 addr2line 把程序地址转化为文件名和行号 ar 建立、修改和提取归档文件 as 汇编编译器 ld 链接器 nm 列出文件的符号 objcopy 文件个数格式转换 objdump 反汇编 ranlib 产生索引,并且保存进入文件中 readelf 显示elf文件信息 size 列出文件大小 string 打印文件可打印字符串 strip 丢弃文件符号 交叉工具链测试 arm-none-eabi-addr2line arm-none-eabi-gdb arm-none-eabi-ar arm-none-eabi-gdb-add-index arm-none-eabi-as arm-none-eabi-gfortran arm-none-eabi-c++ arm-none-eabi-gprof arm-none-eabi-c++filt arm-none-eabi-ld arm-none-eabi-cpp arm-none-eabi-ld.bfd arm-none-eabi-dwp arm-none-eabi-ld.gold arm-none-eabi-elfedit arm-none-eabi-lto-dump arm-none-eabi-g++ arm-none-eabi-nm arm-none-eabi-gcc arm-none-eabi-objcopy arm-none-eabi-gcc-10.2.1 arm-none-eabi-objdump arm-none-eabi-gcc-ar arm-none-eabi-ranlib arm-none-eabi-gcc-nm arm-none-eabi-readelf arm-none-eabi-gcc-ranlib arm-none-eabi-size arm-none-eabi-gcov arm-none-eabi-strings arm-none-eabi-gcov-dump arm-none-eabi-strip arm-none-eabi-gcov-tool ","date":"2022-09-24","objectID":"/arm/:1:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#工具链"},{"categories":["arm"],"content":" 1.3 ARMv7处理器模式 模式 编码 功能 安全 优先级 User (USR) 10000 大多数运行的非特权模式 Both PL0 FIQ 10001 FIQ中断 Both PL1 IRQ 10010 IRQ中断 Both PL1 Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1 Monitor (MON) 10110 安全扩展实现 only PL1 Abort (ABT) 10111 内存权限异常 Both PL1 Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2 Undef (UND) 11011 未定义指令调用 Both PL1 System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1 不同的处理器模式上寄存器共享的情况 ","date":"2022-09-24","objectID":"/arm/:1:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#armv7处理器模式"},{"categories":["arm"],"content":" 1.4 指令条件码指令条件码由CPSR/SPSR同时确定 ","date":"2022-09-24","objectID":"/arm/:1:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#指令条件码"},{"categories":["arm"],"content":" 2 寻址方式 立即数寻址 寄存器寻址 寄存器间接寻址 寄存器偏移寻址 寄存器基址变址寻址 批量寄存器寻址 相对寻址 堆栈寻址 块拷贝寻址 ","date":"2022-09-24","objectID":"/arm/:2:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寻址方式"},{"categories":["arm"],"content":" 2.1 立即数寻址立即数为操作数,其中立即数前面加上# ;; 立即数寻址 mov r0, #0 ; r0 = 0 mov r1, #64 ; r1 = 64 ","date":"2022-09-24","objectID":"/arm/:2:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#立即数寻址"},{"categories":["arm"],"content":" 2.2 寄存器寻址","date":"2022-09-24","objectID":"/arm/:2:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器寻址"},{"categories":["arm"],"content":" 2.3 寄存器偏移寻址寄存器寻址就是直接将寄存器中的数值作为操作数 指令 作用 LSL Logical Shift Left by 1-31 bits. LSR Logical Shift Right by 1-32 bits. ASR Arithmetic Shift Right by 1-32 bits. ROR Rotate Right by 1-31 bits. RRX Rotate Right with Extend. mov r0, r1 ; r0 = r1 mov r1, #12 ; r1 = 12; mov r0, r1, LSL #3 ; r0 = r1 \u003c\u003c 3 = 512 mov r0, r1, LSR #3 ; r0 = r1 \u003e\u003e 3 = 8 mov r0, r1, ASR #3 ; r0 = r1 \u003e\u003e 3 = 8 不改写符号位 mov r0, r1, ROR #3 ; r1 = 0x80000001 mov r0, r1, RRX ; r0 = r1 \u003e\u003e 1 | 空位 = C ","date":"2022-09-24","objectID":"/arm/:2:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器偏移寻址"},{"categories":["arm"],"content":" 2.4 寄存器间接寻址获取内存地址中的数据,需要使用LDR/STR操作符; 首先确定,RAM的地址范围; 打开simulator-\u003eMemory Configuration 可以得到RAM的地址0x00900000 –\u003e 0x0097FFFF, ldr r0, =0x123 ;; r0 = 0x123 ldr r1, =0x900000 ;; r1 = 0x900000 str r0, [r1] ;; *((unsigned long *)r1) = r0; mov r0, 0 ;; r0 = 0 ldr r0, [r1] ;; r0 = *((unsigned long *)r1) 但是此时只能得到一些奇怪的数据,那如何确定程序是运行正常的? ;; 读取异常地址,看看是否会崩溃 ;; 如果获取一个异常的地址, ;; 看看会发生什么? ldr r1, =0x00980000 ldr r0, [r1] 程序立即崩溃, 我们的测试是正确的; ","date":"2022-09-24","objectID":"/arm/:2:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器间接寻址"},{"categories":["arm"],"content":" 2.5 寄存器基址变址寻址 LDR R0, [R1,#0X0F] ;; R0 = *(unsigned long *)(R1 + 0x0f) LDR R0, [R1],#4 ;; R0 = *(unsigned long *)(R1 + 0x04) LDR R0, [R1,R2] ;; R0 = *(unsigned long *)(R1 + R2) ","date":"2022-09-24","objectID":"/arm/:2:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器基址变址寻址"},{"categories":["arm"],"content":" 2.6 批量寄存器寻址批量寻址来自于批量操作符STM/LDM, LDMIA R0,{R1,R2,R3,R4} STMIA R0,{R3-R5,R10} ","date":"2022-09-24","objectID":"/arm/:2:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#批量寄存器寻址"},{"categories":["arm"],"content":" 2.7 堆栈寻址 LDMFD SP!,{R1-R7,LR} STMFD SP!,{R1-R7,LR} ","date":"2022-09-24","objectID":"/arm/:2:7","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#堆栈寻址"},{"categories":["arm"],"content":" 3 指令集","date":"2022-09-24","objectID":"/arm/:3:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#指令集"},{"categories":["arm"],"content":" 3.1 跳转指令 跳转指令可以向前后32M地址跳转 跳转为24位长有符号数据 B: 绝对跳转 BL: 带返回的跳转 BLX: 带返回和状态切换的跳转 BX: 状态切换的跳转 B(跳转) L(设置链接寄存器) X(切换arm/thumb状态) 跳转指令的详细解释: add pc, pc, #跳转地址 ;; 跳转指令 B label_jump_B label_jump_B: mov pc, lr ;; 但是此时编译会报错,需要状态切换 BX label_jump_BX label_jump_BX: BL label_jump_BL label_jump_BL: BLX label_jump_BLX label_jump_BLX: ","date":"2022-09-24","objectID":"/arm/:3:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#跳转指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据处理指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据传送指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#比较指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#加减法"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#逻辑运算"},{"categories":["arm"],"content":" 3.3 乘法指令 mul mla smull umull umlal ","date":"2022-09-24","objectID":"/arm/:3:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#乘法指令"},{"categories":["arm"],"content":" 3.4 杂项算数指令 clz ","date":"2022-09-24","objectID":"/arm/:3:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#杂项算数指令"},{"categories":["arm"],"content":" 3.5 状态寄存器 mrs: 状态寄存器到通用寄存器 msr: 通用寄存器到状态寄存器 ","date":"2022-09-24","objectID":"/arm/:3:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#状态寄存器"},{"categories":["arm"],"content":" 3.6 内存操作指令 ldr/str ldm/stm ","date":"2022-09-24","objectID":"/arm/:3:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#内存操作指令"},{"categories":["arm"],"content":" 3.7 信号量操作指令 原子操作指令 swp swpb ","date":"2022-09-24","objectID":"/arm/:3:7","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#信号量操作指令"},{"categories":["arm"],"content":" 3.8 异常与中端指令 swi bkpt ","date":"2022-09-24","objectID":"/arm/:3:8","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#异常与中端指令"},{"categories":["arm"],"content":" 3.9 协处理器指令 cdp ldc stc mcr mrc ","date":"2022-09-24","objectID":"/arm/:3:9","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#协处理器指令"},{"categories":["arm"],"content":" 3.10 NEON指令 16个NEON寄存器(128bit), Q0-Q15(同时也可以被视为32个64bit的寄存器,D0-D31) ","date":"2022-09-24","objectID":"/arm/:3:10","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#neon指令"},{"categories":["arm"],"content":" 3.11 VFP指令 16个VFP寄存器(32bit),S0-S15 ","date":"2022-09-24","objectID":"/arm/:3:11","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#vfp指令"},{"categories":["arm"],"content":" 4 伪指令","date":"2022-09-24","objectID":"/arm/:4:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#伪指令"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#启动符号"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#符号定义"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-1"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-1"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据定义"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-2"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-2"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#汇编控制"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-3"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-3"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#段定义"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-4"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-4"},{"categories":["arm"],"content":" 4.6 杂项指令 GCC armasm 描述信息 @ ; Comment #\u0026 #0x An immediate hex value .if IFDEF, IF 条件编译 .else ELSE .elseif ELSEIF .endif ENDIF .ltorg LTORG ` ` :OR: \u0026 :AND: AND « :SHL: Shift Left » :SHR: Shift Right .macro MACRO Start macro definition .endm ENDM End macro definition .include INCLUDE GNU Assembler requires “filename” .word DCD A data word .short DCW .long DCD .byte DCB .req RN .global IMPORT, EXPORT .equ EQU ","date":"2022-09-24","objectID":"/arm/:4:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#杂项指令"},{"categories":["arm"],"content":" 5 程序设计","date":"2022-09-24","objectID":"/arm/:5:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#程序设计"},{"categories":["arm"],"content":" 5.1 条件语句","date":"2022-09-24","objectID":"/arm/:5:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#条件语句"},{"categories":["arm"],"content":" 5.2 循环语句","date":"2022-09-24","objectID":"/arm/:5:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#循环语句"},{"categories":["arm"],"content":" 5.3 函数定义","date":"2022-09-24","objectID":"/arm/:5:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#函数定义"},{"categories":["arm"],"content":" 6 混合编程","date":"2022-09-24","objectID":"/arm/:6:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#混合编程"},{"categories":["arm"],"content":" 6.1 C与汇编","date":"2022-09-24","objectID":"/arm/:6:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#c与汇编"},{"categories":["arm"],"content":" 6.2 C与thumb","date":"2022-09-24","objectID":"/arm/:6:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#c与thumb"},{"categories":["arm"],"content":" 7 存储系统","date":"2022-09-24","objectID":"/arm/:7:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#存储系统"},{"categories":["arm"],"content":" 7.1 MMU","date":"2022-09-24","objectID":"/arm/:7:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#mmu"},{"categories":["arm"],"content":" 7.2 cache","date":"2022-09-24","objectID":"/arm/:7:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#cache"},{"categories":["arm"],"content":" 8 仿真工具","date":"2022-09-24","objectID":"/arm/:8:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#仿真工具"},{"categories":["arm"],"content":" 8.1 IAR仿真设置新建工程 设置仿真 构建仿真 ","date":"2022-09-24","objectID":"/arm/:8:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar仿真设置"},{"categories":["arm"],"content":" 8.2 eclipse仿真设置 arm-none-eabi-gcc: 编译器 openocd: 调试器 qemu: 仿真器 ","date":"2022-09-24","objectID":"/arm/:8:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#eclipse仿真设置"},{"categories":["Bsdiff"],"content":"Bsdiff","date":"2022-08-17","objectID":"/bsdiff/","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/"},{"categories":["Bsdiff"],"content":" 1 引言 bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u003e sorting (specifically, Larsson and Sadakane’s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) – 直接摘抄自官网 详情可以查看bsdiff官网,存在这个详细描述. bsdiff基本原理： 存在差异的数据: diff 不存在的数据: extra 最后生成的文件 = diff + extra; ","date":"2022-08-17","objectID":"/bsdiff/:1:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#引言"},{"categories":["Bsdiff"],"content":" 2 测试新建立两个文件old.c与new.c,二者的差别是 // new.c #include \u003cstdio.h\u003e int main(void) { printf(\"Hello World\\r\\n\"); return 0; } // old.c #include \u003cstdio.h\u003e int main(void) { return 0; } 测试的情况 # 执行编译 gcc old.c -o old \u0026\u0026 ./old gcc new.c -o new \u0026\u0026 ./new 计算md5 md5sum old # d08fd167e74f279522fe8aa64d8e27dd old md5sum new # b0b4be993de61064a118d32a692bf795 new md5sum mid # b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试 # 生成diff bsdiff old new test.diff # 打入补丁--\u003emid bspatch old mid test.diff ","date":"2022-08-17","objectID":"/bsdiff/:2:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#测试"},{"categories":["Bsdiff"],"content":" 3 原理 后缀数组实现 ","date":"2022-08-17","objectID":"/bsdiff/:3:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#原理"},{"categories":["Bsdiff"],"content":" 3.1 后缀数组定义","date":"2022-08-17","objectID":"/bsdiff/:3:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#后缀数组定义"},{"categories":["Bsdiff"],"content":" 3.2 后缀数组计算 倍增法和桶排序 倍增法的时间复杂度是O(NlogN)的,程序简单,算法过程易于理解. 桶排序时间复杂度是O(N),数据量大的时候,效率比倍增算法有显著提升,但是缺点在于DC3算法原理较难理解,代码冗长. ","date":"2022-08-17","objectID":"/bsdiff/:3:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#后缀数组计算"},{"categories":["Bsdiff"],"content":" 4 补丁文件bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2022-08-17","objectID":"/bsdiff/:4:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#补丁文件"},{"categories":["Bsdiff"],"content":" 5 生成补丁 bsdiff bspatch ","date":"2022-08-17","objectID":"/bsdiff/:5:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#生成补丁"},{"categories":["Bsdiff"],"content":" 5.1 数据结构 struct bsdiff_stream { void* opaque; /* bzip文件 */ void* (*malloc)(size_t size); /* 内存申请接口 */ void (*free)(void* ptr); /* 内存释放接口 */ int (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ const void* buffer, int size); }; struct bsdiff_request { const uint8_t* old; int64_t oldsize; const uint8_t* new; int64_t newsize; struct bsdiff_stream* stream; int64_t *I; uint8_t *buffer; }; ","date":"2022-08-17","objectID":"/bsdiff/:5:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#数据结构"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行graph LR bsdiff --\u003e bsdiff_internal 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#接口分析"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行graph LR bsdiff --\u003e bsdiff_internal 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行graph LR bsdiff --\u003e bsdiff_internal 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行graph LR bsdiff --\u003e bsdiff_internal bsdiff_internal --\u003e offout bsdiff_internal --\u003e qsufsort bsdiff_internal --\u003e search bsdiff_internal --\u003e writedata qsufsort --\u003e split search --\u003e matchlen 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan\u003creq.newsize) { oldscore=0; for(scsc=scan+=len;scan\u003creq.newsize;scan++) { len=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 0,req.oldsize,\u0026pos); for(;scsc\u003cscan+len;scsc++) if((scsc+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scsc+lastoffset] == req.new[scsc])) oldscore++; if(((len==oldscore) \u0026\u0026 (len!=0)) || (len\u003eoldscore+8)) break; if((scan+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scan+lastoffset] == req.new[scan])) oldscore--; }; if((len!=oldscore) || (scan==req.newsize)) { s=0;Sf=0;lenf=0; for(i=0;(lastscan+i\u003cscan)\u0026\u0026(lastpos+i\u003creq.oldsize);) { if(req.old[lastpos+i]==req.new[lastscan+i]) s++; i++; if(s*2-i\u003eSf*2-lenf) { Sf=s; lenf=i; }; }; lenb=0; if(scan\u003creq.newsize) { s=0;Sb=0; for(i=1;(scan\u003e=lastscan+i)\u0026\u0026(pos\u003e=i);i++) { if(req.old[pos-i]==req.new[scan-i]) s++; if(s*2-i\u003eSb*2-lenb) { Sb=s; lenb=i; }; }; }; if(lastscan+lenf\u003escan-lenb) { overlap=(lastscan+lenf)-(scan-lenb); s=0;Ss=0;lens=0; for(i=0;i\u003coverlap;i++) { if(req.new[lastscan+lenf-overlap+i]== req.old[lastpos+lenf-overlap+i]) s++; if(req.new[scan-lenb+i]== req.old[pos-lenb+i]) s--; if(s\u003eSs) { Ss=s; lens=i+1; }; }; lenf+=lens-overlap; lenb-=lens; }; offtout(lenf,buf); offtout((scan-lenb)-(lastscan+lenf),buf+8); offtout((pos-lenb)-(lastpos+lenf),buf+16); /* Write control data */ if (writedata(req.stream, buf, sizeof(buf))) return -1; /* Write diff data */ for(i=0;i\u003clenf;i++) buffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; if (writedata(req.stream, buffer, lenf)) return -1; /* Write extra data */ for(i=0;i\u003c(scan-lenb)-(lastscan+lenf);i++) buffer[i]=req.new[lastscan+lenf+i]; if (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) return -1; lastscan=scan-lenb; lastpos=pos-lenb; lastoffset=pos-scan; }; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#核心处理"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行graph LR bsdiff --\u003e bsdiff_internal bsdiff_internal --\u003e offout bsdiff_internal --\u003e qsufsort bsdiff_internal --\u003e search bsdiff_internal --\u003e writedata qsufsort --\u003e split search --\u003e matchlen 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-1"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行graph LR bsdiff --\u003e bsdiff_internal bsdiff_internal --\u003e offout bsdiff_internal --\u003e qsufsort bsdiff_internal --\u003e search bsdiff_internal --\u003e writedata qsufsort --\u003e split search --\u003e matchlen 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-1"},{"categories":["Bsdiff"],"content":" 5.4 偏移转缓存 偏移转缓存 缓存转偏移 static void offtout(int64_t x, uint8_t *buf) { int64_t y; if(x\u003c0) y=-x; else y=x; buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2022-08-17","objectID":"/bsdiff/:5:4","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#偏移转缓存"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行graph LR search --\u003e matchlen search --\u003e search 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i\u003coldsize)\u0026\u0026(i\u003cnewsize);i++) if(old[i]!=new[i]) break; return i; } static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, const uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) { int64_t x,y; if(en-st\u003c2) { x=matchlen(old+I[st],oldsize-I[st],new,newsize); y=matchlen(old+I[en],oldsize-I[en],new,newsize); if(x\u003ey) { *pos=I[st]; return x; } else { *pos=I[en]; return y; } }; x=st+(en-st)/2; if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u003c0) { return search(I,old,oldsize,new,newsize,x,en,pos); } else { return search(I,old,oldsize,new,newsize,st,x,pos); }; } ","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#搜索"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行graph LR search --\u003e matchlen search --\u003e search 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-2"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行graph LR search --\u003e matchlen search --\u003e search 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-2"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行graph LR qsufsort --\u003e split split --\u003e split 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k\u003cstart+len;k+=j) { j=1;x=V[I[k]+h]; for(i=1;k+i\u003cstart+len;i++) { if(V[I[k+i]+h]\u003cx) { x=V[I[k+i]+h]; j=0; }; if(V[I[k+i]+h]==x) { tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; j++; }; }; for(i=0;i\u003cj;i++) V[I[k+i]]=k+j-1; if(j==1) I[k]=-1; }; return; }; x=V[I[start+len/2]+h]; jj=0;kk=0; for(i=start;i\u003cstart+len;i++) { if(V[I[i]+h]\u003cx) jj++; if(V[I[i]+h]==x) kk++; }; jj+=start;kk+=jj; i=start;j=0;k=0; while(i\u003cjj) { if(V[I[i]+h]\u003cx) { i++; } else if(V[I[i]+h]==x) { tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; j++; } else { tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; k++; }; }; while(jj+j\u003ckk) { if(V[I[jj+j]+h]==x) { j++; } else { tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; k++; }; }; if(jj\u003estart) split(I,V,start,jj-start,h); for(i=0;i\u003ckk-jj;i++) V[I[jj+i]]=kk-1; if(jj==kk-1) I[jj]=-1; if(start+len\u003ekk) split(I,V,kk,start+len-kk,h); } static void qsufsort(int64_t *I, const uint8_t *old, int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; int64_t *V; if ((V = req.stream-\u003emalloc((req.oldsize+1) * sizeof(int64_t))) == NULL) { return -1; } for (i=0; i\u003c256; i++) { buckets[i]=0; } for(i=0;i\u003coldsize;i++) buckets[old[i]]++; for(i=1;i\u003c256;i++) buckets[i]+=buckets[i-1]; for(i=255;i\u003e0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i\u003coldsize;i++) I[++buckets[old[i]]]=i; I[0]=oldsize; for(i=0;i\u003coldsize;i++) V[i]=buckets[old[i]]; V[oldsize]=0; for(i=1;i\u003c256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; I[0]=-1; for(h=1;I[0]!=-(oldsize+1);h+=h) { len=0; for(i=0;i\u003coldsize+1;) { if(I[i]\u003c0) { len-=I[i]; i-=I[i]; } else { if(len) I[i-len]=-len; len=V[I[i]]+1-i; split(I,V,i,len,h); i+=len; len=0; }; }; if(len) I[i-len]=-len; }; for(i=0;i\u003coldsize+1;i++) I[V[i]]=i; free(V); } ","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#排序"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行graph LR qsufsort --\u003e split split --\u003e split 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-3"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行graph LR qsufsort --\u003e split split --\u003e split 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-3"},{"categories":["Bsdiff"],"content":" 5.7 保存文件 简要写法 主要的操作就是将buffer直接写到文件中 static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { const int writeresult = stream-\u003ewrite(stream, buffer, length); return writeresult; } 原始写法 为了保证大小不超过API的大小 static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { int64_t result = 0; while (length \u003e 0) { const int smallsize = (int)MIN(length, INT_MAX); const int writeresult = stream-\u003ewrite(stream, buffer, smallsize); if (writeresult == -1) { return -1; } result += writeresult; length -= smallsize; buffer = (uint8_t*)buffer + smallsize; } return result; } ","date":"2022-08-17","objectID":"/bsdiff/:5:7","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#保存文件"},{"categories":["Bsdiff"],"content":" 6 打入补丁 bsdiff bspatch ","date":"2022-08-17","objectID":"/bsdiff/:6:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#打入补丁"},{"categories":["Bsdiff"],"content":" 6.1 缓存转偏移 偏移转缓存 缓存转偏移 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } ","date":"2022-08-17","objectID":"/bsdiff/:6:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#缓存转偏移"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i\u003cctrl[0];i++) if((oldpos+i\u003e=0) \u0026\u0026 (oldpos+i\u003coldsize)) new[newpos+i]+=old[oldpos+i]; /* Adjust pointers */ newpos+=ctrl[0]; oldpos+=ctrl[0]; /* Sanity-check */ if(newpos+ctrl[1]\u003enewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#核心功能"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#执行路线"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-4"},{"categories":["编程语言"],"content":"C++基础笔记","date":"2022-07-28","objectID":"/cxx_basic/","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 C++模板笔记 ","date":"2022-07-28","objectID":"/cxx_basic/:0:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#"},{"categories":["编程语言"],"content":" 1 第一个程序 #include \u003ciostream\u003e using namespace std; int main(int argc, char *argv[]) { cout \u003c\u003c \"Hello World\" \u003c\u003c endl; return 0; } 编译指令 从生成的汇编指令来看,复杂不少 __cxx_global_var_init: push {r11, lr} mov r11, sp sub sp, sp, #8 ldr r0, .LCPI0_0 .LPC0_0: add r0, pc, r0 str r0, [sp, #4] @ 4-byte Spill bl std::ios_base::Init::Init() [complete object constructor] ldr r1, [sp, #4] @ 4-byte Reload ldr r0, .LCPI0_1 .LPC0_1: ldr r0, [pc, r0] ldr r2, .LCPI0_2 .LPC0_2: add r2, pc, r2 bl __cxa_atexit mov sp, r11 pop {r11, lr} bx lr .LCPI0_0: .long _ZStL8__ioinit-(.LPC0_0+8) .LCPI0_1: .Ltmp2: .long _ZNSt8ios_base4InitD1Ev(GOT_PREL)-((.LPC0_1+8)-.Ltmp2) .LCPI0_2: .long __dso_handle-(.LPC0_2+8) main: push {r11, lr} mov r11, sp sub sp, sp, #16 mov r2, #0 str r2, [sp] @ 4-byte Spill str r2, [r11, #-4] str r0, [sp, #8] str r1, [sp, #4] ldr r0, .LCPI1_0 .LPC1_0: ldr r0, [pc, r0] ldr r1, .LCPI1_1 .LPC1_1: add r1, pc, r1 bl std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::operator\u003c\u003c \u003cstd::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026, char const*) ldr r1, .LCPI1_2 .LPC1_2: ldr r1, [pc, r1] bl std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e::operator\u003c\u003c(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 (*)(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026)) ldr r0, [sp] @ 4-byte Reload mov sp, r11 pop {r11, lr} bx lr .LCPI1_0: .Ltmp5: .long _ZSt4cout(GOT_PREL)-((.LPC1_0+8)-.Ltmp5) .LCPI1_1: .long .L.str-(.LPC1_1+8) .LCPI1_2: .Ltmp6: .long _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(GOT_PREL)-((.LPC1_2+8)-.Ltmp6) _GLOBAL__sub_I_example.cpp: push {r11, lr} mov r11, sp bl __cxx_global_var_init pop {r11, lr} bx lr .L.str: .asciz \"Hello World\" ","date":"2022-07-28","objectID":"/cxx_basic/:1:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#第一个程序"},{"categories":["编程语言"],"content":" 2 注释","date":"2022-07-28","objectID":"/cxx_basic/:2:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#注释"},{"categories":["编程语言"],"content":" 2.1 C++注释 // 这个是一个单行注释 ","date":"2022-07-28","objectID":"/cxx_basic/:2:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c注释"},{"categories":["编程语言"],"content":" 2.2 C注释 /* 这个里面是一个注释 */ 在C/C++中两种注释都是可以使用的 并不是绝对的,只因为提出者是C或者C++ 注释不影响程序的编译–\u003e(预编译删除所有注释) 推荐使用doxygen–\u003e(使用doxygen漂亮的注释) ","date":"2022-07-28","objectID":"/cxx_basic/:2:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c注释-1"},{"categories":["编程语言"],"content":" 3 标识符","date":"2022-07-28","objectID":"/cxx_basic/:3:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#标识符"},{"categories":["编程语言"],"content":" 3.1 变量变量的存在意义:方便我们管理内存 变量创建的语法 存储类型 数据类型 变量名 = 变量初始化; 自动,不使用标识符 寄存器(register) 静态static 外部extern /* auto */ int a = 0; // C++不在添加自动变量标识符 static int a = 0; // 静态 register int a = 0; // 寄存器 extern int a = 0; // 外部 总结 存储类型 持续性 作用域 链接性 定义 自动变量 自动 函数内 ❎ 无标志符,定义在函数内 寄存器 自动 函数内 ❎ register 静态 全局 函数内|文件内 ❎ static 外部 全局 文件内 ✅ 无标志符,定义在文件内 ","date":"2022-07-28","objectID":"/cxx_basic/:3:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#变量"},{"categories":["编程语言"],"content":" 3.2 常量作用: 记录程序中不可以改变的数据 define 宏常量(预编译期) const 修饰变量(编译期) ","date":"2022-07-28","objectID":"/cxx_basic/:3:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#常量"},{"categories":["编程语言"],"content":" 3.3 关键字 关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template ","date":"2022-07-28","objectID":"/cxx_basic/:3:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#关键字"},{"categories":["编程语言"],"content":" 3.4 命名规则 标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写 ","date":"2022-07-28","objectID":"/cxx_basic/:3:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#命名规则"},{"categories":["编程语言"],"content":" 4 数据类型指定类型,分配内存 ","date":"2022-07-28","objectID":"/cxx_basic/:4:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#数据类型"},{"categories":["编程语言"],"content":" 4.1 整形","date":"2022-07-28","objectID":"/cxx_basic/:4:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#整形"},{"categories":["编程语言"],"content":" 4.2 浮点型 单精度float 双精度double ","date":"2022-07-28","objectID":"/cxx_basic/:4:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#浮点型"},{"categories":["编程语言"],"content":" 4.3 字符型","date":"2022-07-28","objectID":"/cxx_basic/:4:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#字符型"},{"categories":["编程语言"],"content":" 4.4 转义字符","date":"2022-07-28","objectID":"/cxx_basic/:4:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#转义字符"},{"categories":["编程语言"],"content":" 4.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; ","date":"2022-07-28","objectID":"/cxx_basic/:4:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#字符串"},{"categories":["编程语言"],"content":" 4.6 布尔类型 bool A = true; bool B = false; ","date":"2022-07-28","objectID":"/cxx_basic/:4:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#布尔类型"},{"categories":["编程语言"],"content":" 5 运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#运算符"},{"categories":["编程语言"],"content":" 5.1 基本运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#基本运算符"},{"categories":["编程语言"],"content":" 5.2 取模运算就是取余数 ","date":"2022-07-28","objectID":"/cxx_basic/:5:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#取模运算"},{"categories":["编程语言"],"content":" 5.3 自增自减运算 a1++; a2--; ","date":"2022-07-28","objectID":"/cxx_basic/:5:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#自增自减运算"},{"categories":["编程语言"],"content":" 5.4 赋值运算 运算符 术语 示例 结果 = += -= *= /= %= ","date":"2022-07-28","objectID":"/cxx_basic/:5:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#赋值运算"},{"categories":["编程语言"],"content":" 5.5 比较运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#比较运算符"},{"categories":["编程语言"],"content":" 5.6 逻辑运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#逻辑运算符"},{"categories":["编程语言"],"content":" 6 流程控制","date":"2022-07-28","objectID":"/cxx_basic/:6:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#流程控制"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#顺序结构"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#if语句"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#三目运算符"},{"categories":["编程语言"],"content":" 6.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } ","date":"2022-07-28","objectID":"/cxx_basic/:6:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#选择结构"},{"categories":["编程语言"],"content":" 6.3 循环结构","date":"2022-07-28","objectID":"/cxx_basic/:6:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#循环结构"},{"categories":["编程语言"],"content":" 6.4 while循环 while(条件) { 循环体; } ###do...while循环 do { } while(条件) ","date":"2022-07-28","objectID":"/cxx_basic/:6:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#while循环"},{"categories":["编程语言"],"content":" 6.5 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } ","date":"2022-07-28","objectID":"/cxx_basic/:6:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#for循环"},{"categories":["编程语言"],"content":" 6.6 跳转语句 break continue 6.6.1 goto 绝对跳转语句 ","date":"2022-07-28","objectID":"/cxx_basic/:6:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#跳转语句"},{"categories":["编程语言"],"content":" 6.6 跳转语句 break continue 6.6.1 goto 绝对跳转语句 ","date":"2022-07-28","objectID":"/cxx_basic/:6:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#goto"},{"categories":["编程语言"],"content":" 7 函数定义 返回值类型 函数名 参数列表 函数体语句 return表达式 返回值类型 函数名字(参数列表) { 函数体语句; return 表达式; } ","date":"2022-07-28","objectID":"/cxx_basic/:7:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数定义"},{"categories":["编程语言"],"content":" 7.1 值传递 类似数值拷贝 ","date":"2022-07-28","objectID":"/cxx_basic/:7:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#值传递"},{"categories":["编程语言"],"content":" 7.2 函数的常见样式 无参无返 有参无返 无参有反 有参有返 ","date":"2022-07-28","objectID":"/cxx_basic/:7:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数的常见样式"},{"categories":["编程语言"],"content":" 7.3 声明作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现; ","date":"2022-07-28","objectID":"/cxx_basic/:7:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#声明"},{"categories":["编程语言"],"content":" 7.4 多文件","date":"2022-07-28","objectID":"/cxx_basic/:7:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#多文件"},{"categories":["编程语言"],"content":" 8 复合数据结构","date":"2022-07-28","objectID":"/cxx_basic/:8:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#复合数据结构"},{"categories":["编程语言"],"content":" 8.1 数组","date":"2022-07-28","objectID":"/cxx_basic/:8:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#数组"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针的定义和使用"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针所占用空间"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#空指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#野指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#const与指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针与数组"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针与函数"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体数组"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体指针"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体嵌套"},{"categories":["编程语言"],"content":" 8.4 枚举","date":"2022-07-28","objectID":"/cxx_basic/:8:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#枚举"},{"categories":["编程语言"],"content":" 8.5 联合","date":"2022-07-28","objectID":"/cxx_basic/:8:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#联合"},{"categories":["编程语言"],"content":" 8.6 位域","date":"2022-07-28","objectID":"/cxx_basic/:8:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#位域"},{"categories":["编程语言"],"content":" 9 C++内存分区c++程序在运行时,将内存分为4个区域 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放 ","date":"2022-07-28","objectID":"/cxx_basic/:9:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c内存分区"},{"categories":["编程语言"],"content":" 10 new/delete操作符 new操作符在堆区开辟内存 delete释放内存对象 ","date":"2022-07-28","objectID":"/cxx_basic/:10:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#newdelete操作符"},{"categories":["编程语言"],"content":" 11 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; ","date":"2022-07-28","objectID":"/cxx_basic/:11:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用"},{"categories":["编程语言"],"content":" 11.1 引用做参数 #include \u003ciostream\u003e void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 ","date":"2022-07-28","objectID":"/cxx_basic/:11:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用做参数"},{"categories":["编程语言"],"content":" 11.2 引用做返回值","date":"2022-07-28","objectID":"/cxx_basic/:11:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用做返回值"},{"categories":["编程语言"],"content":" 11.3 引用的本质引用的本质是C++内部实现的一个指针常量 ","date":"2022-07-28","objectID":"/cxx_basic/:11:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用的本质"},{"categories":["编程语言"],"content":" 11.4 常量引用 const int \u0026ref = 10; ","date":"2022-07-28","objectID":"/cxx_basic/:11:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#常量引用"},{"categories":["编程语言"],"content":" 12 函数提高","date":"2022-07-28","objectID":"/cxx_basic/:12:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数提高"},{"categories":["编程语言"],"content":" 12.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/cxx_basic/:12:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数默认值"},{"categories":["编程语言"],"content":" 12.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/cxx_basic/:12:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数的占位参数"},{"categories":["编程语言"],"content":" 12.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2022-07-28","objectID":"/cxx_basic/:12:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数重载"},{"categories":["编程语言"],"content":"C++提高笔记","date":"2022-07-28","objectID":"/cxx_enhance/","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 ","date":"2022-07-28","objectID":"/cxx_enhance/:0:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#"},{"categories":["编程语言"],"content":" 1 类和对象 类的访问属性 类的继承属性 public: protected: private: ","date":"2022-07-28","objectID":"/cxx_enhance/:1:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类和对象"},{"categories":["编程语言"],"content":" 1.1 成员函数 成员函数 + delete表示删除此函数 成员函数 + default表示默认函数 explicit: 关闭隐式类型转换 关键字只能作用域类构造函数 只作用单个参数的构造函数 final: 第一个用在类，用于说明该类是继承体系下最后的一个类，不要其他类继承我，当继承时就会报错。 第二个用在虚函数，表示这个虚函数不能再被override了，再override就会报错 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员函数"},{"categories":["编程语言"],"content":" 1.2 虚函数 override用于虚函数,上面的virtual void func(int)实际上不是重写父类的虚函数,而是定义一个新的虚函数; 我们的本意是重写虚函数,当不加overrride的时候,这样写编译器不会报错 那如果像下面加上override的话，则会报错，表示告诉了编译器，我确实要重写，但写错了，没有重写，于是就报错了 这样就能给我们对虚函数的重写做检查! ","date":"2022-07-28","objectID":"/cxx_enhance/:1:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数"},{"categories":["编程语言"],"content":" 1.3 class与struct的区别class默认权限是private struct默认权限是public ","date":"2022-07-28","objectID":"/cxx_enhance/:1:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#class与struct的区别"},{"categories":["编程语言"],"content":" 1.4 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数和析构函数"},{"categories":["编程语言"],"content":" 1.5 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数"},{"categories":["编程语言"],"content":" 1.6 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:6","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数的调用时机"},{"categories":["编程语言"],"content":" 1.7 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:7","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数的调用规则"},{"categories":["编程语言"],"content":" 1.8 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:8","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#深拷贝和浅拷贝"},{"categories":["编程语言"],"content":" 2 初始化列表作用:C++提供了初始化列表语法,用来初始化属性; 语法: 构造函数(): 属性1(值1),属性2(值2),属性3(值3) { /* 函数体 */ } ","date":"2022-07-28","objectID":"/cxx_enhance/:2:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#初始化列表"},{"categories":["编程语言"],"content":" 3 类对象作为类成员","date":"2022-07-28","objectID":"/cxx_enhance/:3:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类对象作为类成员"},{"categories":["编程语言"],"content":" 3.1 静态成员静态成员就是在静态成员变量和成员函数前加上static,称为静态成员; 静态成员变量 所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 class Person { public: static int age; static void func() { std::cout \u003c\u003c \"静态成员函数\" \u003c\u003c std::endl; } }; /* 通过对象访问 */ Person p; p.func(); /* 通过类访问 */ Person::func(); ","date":"2022-07-28","objectID":"/cxx_enhance/:3:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#静态成员"},{"categories":["编程语言"],"content":" 3.2 成员变量和成员函数分开存储 非静态成员, 属于类的对象 静态成员, 不属于类的对象 非静态成员函数, 不属于类的对象 静态成员函数, 不属于类的对象 空对象大小为1 ","date":"2022-07-28","objectID":"/cxx_enhance/:3:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员变量和成员函数分开存储"},{"categories":["编程语言"],"content":" 4 C++对象模型","date":"2022-07-28","objectID":"/cxx_enhance/:4:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#c对象模型"},{"categories":["编程语言"],"content":" 5 this指针this指针指向被调用成员函数所属的对象 this指针本质：指针常量 ","date":"2022-07-28","objectID":"/cxx_enhance/:5:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#this指针"},{"categories":["编程语言"],"content":" 6 空指针访问成员函数C++空指针也是可以访问成员函数的,但是要注意的this指针; ","date":"2022-07-28","objectID":"/cxx_enhance/:6:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#空指针访问成员函数"},{"categories":["编程语言"],"content":" 7 const修饰成员函数常函数: 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数 执行原理 this ==\u003e Person * const this; 后面新追加的const则会造成 const Person * const this; class Person { public: int m_A; mutable int m_B; void showPerson() const { m_A = 10; /* 错误,不可修改 */ m_B = 10; /* 正确,可以修改 */ } }; ","date":"2022-07-28","objectID":"/cxx_enhance/:7:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#const修饰成员函数"},{"categories":["编程语言"],"content":" 8 友元 全局函数 全局类 成员函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:8:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#友元"},{"categories":["编程语言"],"content":" 9 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; ","date":"2022-07-28","objectID":"/cxx_enhance/:9:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#运算符重载"},{"categories":["编程语言"],"content":" 9.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#通过成员函数重载运算符"},{"categories":["编程语言"],"content":" 9.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#通过全局函数重载"},{"categories":["编程语言"],"content":" 9.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#重载左移运算符"},{"categories":["编程语言"],"content":" 9.4 递增重载++注意: 前置递增 p++ 后置递增 ++p ","date":"2022-07-28","objectID":"/cxx_enhance/:9:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#递增重载"},{"categories":["编程语言"],"content":" 9.5 重载例子(复数) #include \u003ciostream\u003e class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#重载例子复数"},{"categories":["编程语言"],"content":" 10 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承"},{"categories":["编程语言"],"content":" 10.1 继承方式 公共继承 保护继承 私有继承 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承方式"},{"categories":["编程语言"],"content":" 10.2 继承中的对象模型","date":"2022-07-28","objectID":"/cxx_enhance/:10:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承中的对象模型"},{"categories":["编程语言"],"content":" 10.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造和析构的顺序"},{"categories":["编程语言"],"content":" 10.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A ","date":"2022-07-28","objectID":"/cxx_enhance/:10:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承中同名成员处理"},{"categories":["编程语言"],"content":" 11 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 ","date":"2022-07-28","objectID":"/cxx_enhance/:11:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#多重继承"},{"categories":["编程语言"],"content":" 11.1 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ ","date":"2022-07-28","objectID":"/cxx_enhance/:11:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#菱形继承"},{"categories":["编程语言"],"content":" 11.2 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2022-07-28","objectID":"/cxx_enhance/:11:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚基类指针vbptr"},{"categories":["编程语言"],"content":" 12 多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数; 有继承关系 子类重写父类的虚函数 重写：函数完全一致 ","date":"2022-07-28","objectID":"/cxx_enhance/:12:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#多态"},{"categories":["编程语言"],"content":" 13 虚函数 只要有一个纯虚函数，就称为抽象类 抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 ","date":"2022-07-28","objectID":"/cxx_enhance/:13:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数-1"},{"categories":["编程语言"],"content":" 13.1 虚析构和纯虚析构","date":"2022-07-28","objectID":"/cxx_enhance/:13:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚析构和纯虚析构"},{"categories":["编程语言"],"content":"C++增强笔记","date":"2022-07-28","objectID":"/cxx_advance/","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 ","date":"2022-07-28","objectID":"/cxx_advance/:0:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#"},{"categories":["编程语言"],"content":" 1 对象模型","date":"2022-07-28","objectID":"/cxx_advance/:1:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#对象模型"},{"categories":["编程语言"],"content":" 2 运行期间","date":"2022-07-28","objectID":"/cxx_advance/:2:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#运行期间"},{"categories":["编程语言"],"content":" 2.1 函数对象","date":"2022-07-28","objectID":"/cxx_advance/:2:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#函数对象"},{"categories":["编程语言"],"content":" 2.2 右值引用","date":"2022-07-28","objectID":"/cxx_advance/:2:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#右值引用"},{"categories":["编程语言"],"content":" 3 构造函数 普通构造 拷贝构造 移动构造 委托构造 ","date":"2022-07-28","objectID":"/cxx_advance/:3:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#构造函数"},{"categories":["编程语言"],"content":" 4 智能指针","date":"2022-07-28","objectID":"/cxx_advance/:4:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#智能指针"},{"categories":["编程语言"],"content":" 4.1 RAII 与引用计数","date":"2022-07-28","objectID":"/cxx_advance/:4:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#raii-与引用计数"},{"categories":["编程语言"],"content":" 4.2 std::shared_ptr","date":"2022-07-28","objectID":"/cxx_advance/:4:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdshared_ptr"},{"categories":["编程语言"],"content":" 4.3 std::unique_ptr","date":"2022-07-28","objectID":"/cxx_advance/:4:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdunique_ptr"},{"categories":["编程语言"],"content":" 4.4 std::weak_ptr","date":"2022-07-28","objectID":"/cxx_advance/:4:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdweak_ptr"},{"categories":["编程语言"],"content":" 5 强制类型转换","date":"2022-07-28","objectID":"/cxx_advance/:5:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#强制类型转换"},{"categories":["编程语言"],"content":" 5.1 C风格的强制转换","date":"2022-07-28","objectID":"/cxx_advance/:5:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#c风格的强制转换"},{"categories":["编程语言"],"content":" 5.2 const_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#const_cast"},{"categories":["编程语言"],"content":" 5.3 static_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#static_cast"},{"categories":["编程语言"],"content":" 5.4 dynamic_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#dynamic_cast"},{"categories":["编程语言"],"content":" 5.5 reinterpret_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:5","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#reinterpret_cast"},{"categories":["编程语言"],"content":" 6 模板类型","date":"2022-07-28","objectID":"/cxx_advance/:6:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#模板类型"},{"categories":["编程语言"],"content":" 6.1 class templates,","date":"2022-07-28","objectID":"/cxx_advance/:6:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#class-templates"},{"categories":["编程语言"],"content":" 6.2 function templates","date":"2022-07-28","objectID":"/cxx_advance/:6:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#function-templates"},{"categories":["编程语言"],"content":" 6.3 variable templates.","date":"2022-07-28","objectID":"/cxx_advance/:6:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#variable-templates"},{"categories":["编程语言"],"content":" 6.4 alias templates","date":"2022-07-28","objectID":"/cxx_advance/:6:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#alias-templates"},{"categories":["pthread"],"content":"线程局部存储分析","date":"2022-07-18","objectID":"/pthread_local_storage/","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/"},{"categories":["pthread"],"content":" 1 前言 在Linux C/C++编程时不可避免的会遇到以下的需求,全局变量线程共享;最为典型的功能则是errno,变量 在程序的任何地方都可以访问,但是不会影响到其他线程,这就是本文档说明的TLS(线程局部存储变量) 如何创建并且使用TLS? 存在下面两种方法 线程库函数 编译器提供 下面分别进行说明分析 ","date":"2022-07-18","objectID":"/pthread_local_storage/:1:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#前言"},{"categories":["pthread"],"content":" 2 线程库函数 pthread提供了函数用来处理TLS, 分别管理键值和数据 ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#线程库函数"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 j\u003cPTHREAD_DESTRUCTOR_ITERATIONS; j++) { self-\u003etsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#创建键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#销毁键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#析构调用"},{"categories":["pthread"],"content":" 2.2 数据 void *pthread_getspecific(pthread_key_t); int pthread_setspecific(pthread_key_t, const void *); // 设置 self-\u003etsd[k] = 私有数据; self-\u003etsd_used = 1; // 读取 return self-\u003etsd[k]; ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:2","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#数据"},{"categories":["pthread"],"content":" 3 编译器提供 musl线程库提供的私有数据还可以理解,但是GCC的__thread变量就比较难以分析了,因此此时只能通过 汇编文件进行分析 給出测试程序 __thread int num; int test(void) { return num; } GCC生成的汇编语言 num: test: push {r7} @ 进入函数,保存现场 add r7, sp, #0 @ R7 = SP mrc p15, 0, r3, c13, c0, 3 @ R3 = 线程号 ldr r2, .L3 @ R2 = \u0026num ldr r3, [r3, r2] @ R3 = *((int *)(R3 + R2)) mov r0, r3 @ R0 = R3 mov sp, r7 @ 恢复SP ldr r7, [sp], #4 @ 恢复R7 bx lr @ return .L3: .word num(tpoff) 但是到现在我们还是没有通过汇编理解原因,但是我们可以注意到一个可疑点.word num(tpoff),这个表达式中tpoff是什么?那么只好到GCC官网上看看是怎么处理的. GCC Thread-Local Storage 同时可以得到一份文档ELF Handling For Thread-Local Storage; 那么就开始分析此文档 ","date":"2022-07-18","objectID":"/pthread_local_storage/:3:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#编译器提供"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_lock/","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/"},{"categories":["pthread"],"content":" 1 futex原理 高级锁的实现都是与futex实现相关 Futex是Fast Userspace muTexes的缩写 常用的锁都是通过futex实现的 mutex (互斥锁) rwlock (读写锁) cond (条件变量) graph LR atom[原子操作] --\u003e spin[自旋锁] futex --\u003e mutex[互斥锁] futex --\u003e rwlock[读写锁] futex --\u003e cond[条件变量] #include \u003clinux/futex.h\u003e /* Definition of FUTEX_* constants */ #include \u003csys/syscall.h\u003e /* Definition of SYS_* constants */ #include \u003cunistd.h\u003e long syscall(SYS_futex, uint32_t *uaddr, int futex_op, uint32_t val, const struct timespec *timeout, /* or: uint32_t val2 */ uint32_t *uaddr2, uint32_t val3); uaddr futex_op val timeout uaddr2 val3 // 进入解析 long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout, u32 __user *uaddr2, u32 val2, u32 val3) { int cmd = op \u0026 FUTEX_CMD_MASK; unsigned int flags = 0; if (!(op \u0026 FUTEX_PRIVATE_FLAG)) flags |= FLAGS_SHARED; if (op \u0026 FUTEX_CLOCK_REALTIME) { flags |= FLAGS_CLOCKRT; if (cmd != FUTEX_WAIT_BITSET \u0026\u0026 cmd != FUTEX_WAIT_REQUEUE_PI) return -ENOSYS; } switch (cmd) { case FUTEX_LOCK_PI: case FUTEX_UNLOCK_PI: case FUTEX_TRYLOCK_PI: case FUTEX_WAIT_REQUEUE_PI: case FUTEX_CMP_REQUEUE_PI: if (!futex_cmpxchg_enabled) return -ENOSYS; } switch (cmd) { case FUTEX_WAIT: val3 = FUTEX_BITSET_MATCH_ANY; case FUTEX_WAIT_BITSET: return futex_wait(uaddr, flags, val, timeout, val3); case FUTEX_WAKE: val3 = FUTEX_BITSET_MATCH_ANY; case FUTEX_WAKE_BITSET: return futex_wake(uaddr, flags, val, val3); case FUTEX_REQUEUE: return futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0); case FUTEX_CMP_REQUEUE: return futex_requeue(uaddr, flags, uaddr2, val, val2, \u0026val3, 0); case FUTEX_WAKE_OP: return futex_wake_op(uaddr, flags, uaddr2, val, val2, val3); case FUTEX_LOCK_PI: return futex_lock_pi(uaddr, flags, timeout, 0); case FUTEX_UNLOCK_PI: return futex_unlock_pi(uaddr, flags); case FUTEX_TRYLOCK_PI: return futex_lock_pi(uaddr, flags, NULL, 1); case FUTEX_WAIT_REQUEUE_PI: val3 = FUTEX_BITSET_MATCH_ANY; return futex_wait_requeue_pi(uaddr, flags, val, timeout, val3, uaddr2); case FUTEX_CMP_REQUEUE_PI: return futex_requeue(uaddr, flags, uaddr2, val, val2, \u0026val3, 1); } return -ENOSYS; } 但是我并没有搞明白futex实现的原理,造成难以继续分析, 因此只能分析别人的文档(注:不分析原理,只进行使用) 主要存在文件futex-internal.c/futex-internal.h,lowlevellock-futex.h,lowlevellock.c 另外lll-\u003elowlevellock缩写形式 其中futex提供的最重要的两个操作wait和wake // 可以使用的op定义类型 #define FUTEX_WAIT 0 #define FUTEX_WAKE 1 #define FUTEX_REQUEUE 3 #define FUTEX_CMP_REQUEUE 4 #define FUTEX_WAKE_OP 5 #define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE ((4 \u003c\u003c 24) | 1) #define FUTEX_LOCK_PI 6 #define FUTEX_UNLOCK_PI 7 #define FUTEX_TRYLOCK_PI 8 #define FUTEX_WAIT_BITSET 9 #define FUTEX_WAKE_BITSET 10 #define FUTEX_WAIT_REQUEUE_PI 11 #define FUTEX_CMP_REQUEUE_PI 12 #define FUTEX_LOCK_PI2 13 #define FUTEX_PRIVATE_FLAG 128 #define FUTEX_CLOCK_REALTIME 256 futex管理结构 struct futex_hash_bucket { atomic_t waiters; spinlock_t lock; struct plist_head chain; } ____cacheline_aligned_in_smp; struct futex_q { struct plist_node list; struct task_struct *task; spinlock_t *lock_ptr; union futex_key key; struct futex_pi_state *pi_state; struct rt_mutex_waiter *rt_waiter; union futex_key *requeue_pi_key; u32 bitset; }; union futex_key { struct { unsigned long pgoff; struct inode *inode; int offset; } shared; struct { unsigned long address; struct mm_struct *mm; int offset; } private; struct { unsigned long word; void *ptr; int offset; } both; }; 进入内核层wait实现 static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val, ktime_t *abs_time, u32 bitset) { struct hrtimer_sleeper timeout, *to = NULL; struct restart_block *restart; struct futex_hash_bucket *hb; struct futex_q q = futex_q_init; int ret; if (!bitset) return -EINVAL; q.bitset = bitset; if (abs_time) { to = \u0026timeout; hrtimer_init_on_stack(\u0026to-\u003etimer, (flags \u0026 FLAGS_CLOCKRT) ? CLOCK_REALTIME : CLOCK_MONOTONIC, HRTIMER_MODE_ABS); hrtimer_init_sleeper(to, current); hrtimer_set_expires_range_ns(\u0026to-\u003etimer, *abs_time, current-\u003etimer_slack_ns); } retry: /* * Prepare to wait on uaddr. On success, holds hb lock and increments * q.key refs. */ ret = futex_wait_setup(uaddr, val, fl","date":"2022-07-18","objectID":"/pthread_lock/:1:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#futex原理"},{"categories":["pthread"],"content":" 2 futex实现 futex接口的用户层界面封装 futex_wait futex_wake ","date":"2022-07-18","objectID":"/pthread_lock/:2:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#futex实现"},{"categories":["pthread"],"content":" 2.1 musl实现 #define lll_trylock(lock) 原子的(lock 0 --\u003e 1) // 不等待 #define lll_cond_trylock(lock) 原子的(lock 0 --\u003e 2) // 不等待 #define lll_lock(futex, private) 1. 原子的(futex 0 --\u003e 1) // 等待 2. __lll_lock_wait (futex, private) #define __lll_cond_lock(futex, private) 1. 原子的(futex 0 --\u003e 2) // 等待 2. __lll_lock_wait (futex, private) #define __lll_unlock(futex, private) 1. 原子的(futex ? --\u003e 0) // 等待 2. __lll_lock_wait (futex, private) void __lll_lock_wake_private (int *futex); void __lll_lock_wait_private (int *futex); void __lll_lock_wait (int *futex, int private); void __lll_lock_wake (int *futex, int private); int lll_futex_wake(int *futex, int nr, int private); int lll_futex_wait(int *futex, int val, int private); int futex_wait(unsigned int *futex_word, unsigned int expected, int private); void futex_wake(unsigned int* futex_word, int processes_to_wake, int private); // 进入系统调用阶段 int lll_futex_syscall(int nargs, int *futexp, int op, ...); 那么进入到最后可以得知,一般会进行一些原子操作,启动的操作都是INTERNAL_SYSCALL进行实现的,然后就是swi指令实现的原理 ","date":"2022-07-18","objectID":"/pthread_lock/:2:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现"},{"categories":["pthread"],"content":" 2.2 glibc实现graph TD futex_wake --\u003e lll_futex_wake futex_wait --\u003e lll_futex_timed_wait lll_futex_timed_wait --\u003e lll_futex_syscall lll_futex_wake --\u003e lll_futex_syscall 关于futex private标志位存在一个优化FUTEX : new PRIVATE futexes,如果futex不在进程间共享会更快,因此pthread操作的时候都是使用的private版本,除非设置了PTHREAD_PROCESS_SHARED属性;因此.pthread的几个操作可以暂时忽略掉此标志位. # define lll_futex_wake(futexp, nr, private) \\ lll_futex_syscall (4, futexp, \\ __lll_private_flag (FUTEX_WAKE, private), nr, 0) # define lll_futex_timed_wait(futexp, val, timeout, private) \\ lll_futex_syscall (4, futexp, \\ __lll_private_flag (FUTEX_WAIT, private), \\ val, timeout) 进入到INTERNAL_SYSCALL,详情可以查看[Linux系统调用] # define lll_futex_syscall(nargs, futexp, op, ...) \\ ({ \\ long int __ret = INTERNAL_SYSCALL (futex, nargs, futexp, op, \\ __VA_ARGS__); \\ (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (__ret)) \\ ? -INTERNAL_SYSCALL_ERRNO (__ret) : 0); \\ }) ","date":"2022-07-18","objectID":"/pthread_lock/:2:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现"},{"categories":["pthread"],"content":" 3 原子操作","date":"2022-07-18","objectID":"/pthread_lock/:3:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#原子操作"},{"categories":["pthread"],"content":" 3.1 musl实现 static inline int a_ll(volatile int *p) { int v; __asm__ __volatile__ (\"ldrex %0, %1\" : \"=r\"(v) : \"Q\"(*p)); return v; } static inline int a_sc(volatile int *p, int v) { int r; __asm__ __volatile__ (\"strex %0,%2,%1\" : \"=\u0026r\"(r), \"=Q\"(*p) : \"r\"(v) : \"memory\"); return !r; } static inline void a_barrier() { __asm__ __volatile__ (\"dmb ish\" : : : \"memory\"); } static inline int a_cas(volatile int *p, int t, int s) { for (;;) { register int r0 __asm__(\"r0\") = t; register int r1 __asm__(\"r1\") = s; register volatile int *r2 __asm__(\"r2\") = p; register uintptr_t r3 __asm__(\"r3\") = __a_cas_ptr; int old; __asm__ __volatile__ ( BLX \" r3\" : \"+r\"(r0), \"+r\"(r3) : \"r\"(r1), \"r\"(r2) : \"memory\", \"lr\", \"ip\", \"cc\" ); if (!r0) return t; if ((old=*p)!=t) return old; } } static inline void a_barrier() { register uintptr_t ip __asm__(\"ip\") = __a_barrier_ptr; __asm__ __volatile__( BLX \" ip\" : \"+r\"(ip) : : \"memory\", \"cc\", \"lr\" ); } ","date":"2022-07-18","objectID":"/pthread_lock/:3:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-1"},{"categories":["pthread"],"content":" 3.2 glibc实现主要是gcc是实现的__atomic开头的函数,参考GCC编译器手册 __atomic_load_n __atomic_load __atomic_store_n __atomic_store __atomic_exchange_n __atomic_exchange __atomic_compare_exchange_n __atomic_compare_exchange __atomic_add_fetch __atomic_sub_fetch __atomic_and_fetch __atomic_xor_fetch __atomic_or_fetch __atomic_nand_fetch __atomic_fetch_add __atomic_fetch_sub __atomic_fetch_and __atomic_fetch_xor __atomic_fetch_or __atomic_fetch_nand __atomic_test_and_set __atomic_clear __atomic_thread_fence __atomic_signal_fence __atomic_always_lock_free __atomic_is_lock_free #define atomic_load_relaxed(mem) \\ ({ __atomic_check_size_ls((mem)); \\ __atomic_load_n ((mem), __ATOMIC_RELAXED); }) #define atomic_load_acquire(mem) \\ ({ __atomic_check_size_ls((mem)); \\ __atomic_load_n ((mem), __ATOMIC_ACQUIRE); }) #define atomic_store_relaxed(mem, val) \\ do { \\ __atomic_check_size_ls((mem)); \\ __atomic_store_n ((mem), (val), __ATOMIC_RELAXED); \\ } while (0) #define atomic_store_release(mem, val) \\ do { \\ __atomic_check_size_ls((mem)); \\ __atomic_store_n ((mem), (val), __ATOMIC_RELEASE); \\ } while (0) ","date":"2022-07-18","objectID":"/pthread_lock/:3:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-1"},{"categories":["pthread"],"content":" 4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); ","date":"2022-07-18","objectID":"/pthread_lock/:4:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#自旋锁"},{"categories":["pthread"],"content":" 4.1 musl实现spinlock句柄就是一个32位的数; typedef int pthread_spinlock_t; 五种函数的实现 int pthread_spin_init(pthread_spinlock_t *s, int shared) { return *s = 0; } int pthread_spin_destroy(pthread_spinlock_t *s) { return 0; } int pthread_spin_lock(pthread_spinlock_t *s) { while (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin(); return 0; } int pthread_spin_trylock(pthread_spinlock_t *s) { return a_cas(s, 0, EBUSY); } int pthread_spin_unlock(pthread_spinlock_t *s) { a_store(s, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:4:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-2"},{"categories":["pthread"],"content":" 4.2 glibc实现glibc的实现就较为复杂了点 typedef __pthread_spinlock_t pthread_spinlock_t; typedef volatile int __pthread_spinlock_t; 加上__作为内部使用的句柄 volatile使编译器强行读取 int pthread_spin_init(pthread_spinlock_t *lock, int pshared) { /* Relaxed MO is fine because this is an initializing store. */ atomic_store_relaxed(lock, 0); return 0; } int pthread_spin_destroy (pthread_spinlock_t *lock) { /* Nothing to do. */ return 0; } int pthread_spin_lock (pthread_spinlock_t *lock) { int val = 0; #if ! ATOMIC_EXCHANGE_USES_CAS if (__glibc_likely(atomic_exchange_acquire(lock, 1) == 0)) { return 0; } #else if (__glibc_likely(atomic_compare_exchange_weak_acquire(lock, \u0026val, 1))) { return 0; } #endif do { do { atomic_spin_nop(); val = atomic_load_relaxed(lock); } while (val != 0); } while (!atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)); return 0; } int pthread_spin_trylock(pthread_spinlock_t *lock) { #if ! ATOMIC_EXCHANGE_USES_CAS if (atomic_exchange_acquire (lock, 1) == 0) { return 0; } #else do { int val = 0; if (atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)) return 0; } while (atomic_load_relaxed (lock) == 0); #endif return EBUSY; } int pthread_spin_unlock(pthread_spinlock_t *lock) { atomic_store_release(lock, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:4:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-2"},{"categories":["pthread"],"content":" 5 内存屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); pthread_t p1, p2, p3; pthread_barrier_t test_barrier; void *test_thread(void *arg) { // make gcc happy unsigned int sleep_time = (unsigned int)((unsigned long)arg); sleep(sleep_time); printf(\"wait begin %d\\r\\n\", gettid()); pthread_barrier_wait(\u0026test_barrier); printf(\"wait finish\\r\\n\"); return NULL; } int main(int argc, char *argv[]) { pthread_barrier_init(\u0026test_barrier, NULL, 4); pthread_create(\u0026p1, NULL, \u0026test_thread, (void *)1); pthread_create(\u0026p2, NULL, \u0026test_thread, (void *)2); pthread_create(\u0026p3, NULL, \u0026test_thread, (void *)3); // 设置线程分离 pthread_detach(p1); pthread_detach(p2); pthread_detach(p3); printf(\"wait begin %d\\r\\n\", gettid()); pthread_barrier_wait(\u0026test_barrier); printf(\"wait finish\\r\\n\"); pthread_barrier_destroy(\u0026test_barrier); return 0; } 打印日志 wait begin 352789 wait begin 352790 wait begin 352791 wait begin 352792 wait finish 352792 wait finish 352791 wait finish 352790 wait finish 352789 ","date":"2022-07-18","objectID":"/pthread_lock/:5:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#内存屏障"},{"categories":["pthread"],"content":" 5.1 musl实现 // 初始化流程 int pthread_barrier_init(pthread_barrier_t *restrict b, const pthread_barrierattr_t *restrict a, unsigned count) { if (count-1 \u003e INT_MAX-1) return EINVAL; *b = (pthread_barrier_t){ ._b_limit = count-1 | (a?a-\u003e__attr:0) }; return 0; } int pthread_barrier_wait(pthread_barrier_t *b) { int limit = b-\u003e_b_limit; struct instance *inst; /* Trivial case: count was set at 1 */ if (!limit) return PTHREAD_BARRIER_SERIAL_THREAD; /* Process-shared barriers require a separate, inefficient wait */ if (limit \u003c 0) return pshared_barrier_wait(b); /* Otherwise we need a lock on the barrier object */ while (a_swap(\u0026b-\u003e_b_lock, 1)) __wait(\u0026b-\u003e_b_lock, \u0026b-\u003e_b_waiters, 1, 1); inst = b-\u003e_b_inst; /* First thread to enter the barrier becomes the \"instance owner\" */ if (!inst) { struct instance new_inst = { 0 }; int spins = 200; b-\u003e_b_inst = inst = \u0026new_inst; a_store(\u0026b-\u003e_b_lock, 0); if (b-\u003e_b_waiters) __wake(\u0026b-\u003e_b_lock, 1, 1); while (spins-- \u0026\u0026 !inst-\u003efinished) a_spin(); a_inc(\u0026inst-\u003efinished); while (inst-\u003efinished == 1) __syscall(SYS_futex,\u0026inst-\u003efinished,FUTEX_WAIT|FUTEX_PRIVATE,1,0) != -ENOSYS || __syscall(SYS_futex,\u0026inst-\u003efinished,FUTEX_WAIT,1,0); return PTHREAD_BARRIER_SERIAL_THREAD; } /* Last thread to enter the barrier wakes all non-instance-owners */ if (++inst-\u003ecount == limit) { b-\u003e_b_inst = 0; a_store(\u0026b-\u003e_b_lock, 0); if (b-\u003e_b_waiters) __wake(\u0026b-\u003e_b_lock, 1, 1); a_store(\u0026inst-\u003elast, 1); if (inst-\u003ewaiters) __wake(\u0026inst-\u003elast, -1, 1); } else { a_store(\u0026b-\u003e_b_lock, 0); if (b-\u003e_b_waiters) __wake(\u0026b-\u003e_b_lock, 1, 1); __wait(\u0026inst-\u003elast, \u0026inst-\u003ewaiters, 0, 1); } /* Last thread to exit the barrier wakes the instance owner */ if (a_fetch_add(\u0026inst-\u003ecount,-1)==1 \u0026\u0026 a_fetch_add(\u0026inst-\u003efinished,1)) __wake(\u0026inst-\u003efinished, 1, 1); return 0; } int pthread_barrier_destroy(pthread_barrier_t *b) { if (b-\u003e_b_limit \u003c 0) { if (b-\u003e_b_lock) { int v; a_or(\u0026b-\u003e_b_lock, INT_MIN); while ((v = b-\u003e_b_lock) \u0026 INT_MAX) __wait(\u0026b-\u003e_b_lock, 0, v, 0); } __vm_wait(); } return 0; } void __wait(volatile int *addr, volatile int *waiters, int val, int priv) { int spins=100; if (priv) priv = FUTEX_PRIVATE; while (spins-- \u0026\u0026 (!waiters || !*waiters)) { if (*addr==val) a_spin(); else return; } if (waiters) a_inc(waiters); while (*addr==val) { __syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS || __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0); } if (waiters) a_dec(waiters); } ","date":"2022-07-18","objectID":"/pthread_lock/:5:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-3"},{"categories":["pthread"],"content":" 5.2 glibc实现 int ___pthread_barrier_init (pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count) { ASSERT_TYPE_SIZE (pthread_barrier_t, __SIZEOF_PTHREAD_BARRIER_T); ASSERT_PTHREAD_INTERNAL_SIZE (pthread_barrier_t, struct pthread_barrier); struct pthread_barrier *ibarrier; /* XXX EINVAL is not specified by POSIX as a possible error code for COUNT being too large. See pthread_barrier_wait for the reason for the comparison with BARRIER_IN_THRESHOLD. */ if (__glibc_unlikely (count == 0 || count \u003e= BARRIER_IN_THRESHOLD)) return EINVAL; const struct pthread_barrierattr *iattr = (attr != NULL ? (struct pthread_barrierattr *) attr : \u0026default_barrierattr); ibarrier = (struct pthread_barrier *) barrier; /* Initialize the individual fields. */ ibarrier-\u003ein = 0; ibarrier-\u003eout = 0; ibarrier-\u003ecount = count; ibarrier-\u003ecurrent_round = 0; ibarrier-\u003eshared = (iattr-\u003epshared == PTHREAD_PROCESS_PRIVATE ? FUTEX_PRIVATE : FUTEX_SHARED); return 0; } int ___pthread_barrier_wait (pthread_barrier_t *barrier) { struct pthread_barrier *bar = (struct pthread_barrier *) barrier; /* How many threads entered so far, including ourself. */ unsigned int i; reset_restart: /* Try to enter the barrier. We need acquire MO to (1) ensure that if we observe that our round can be completed (see below for our attempt to do so), all pre-barrier-entry effects of all threads in our round happen before us completing the round, and (2) to make our use of the barrier happen after a potential reset. We need release MO to make sure that our pre-barrier-entry effects happen before threads in this round leaving the barrier. */ i = atomic_fetch_add_acq_rel (\u0026bar-\u003ein, 1) + 1; /* These loads are after the fetch_add so that we're less likely to first pull in the cache line as shared. */ unsigned int count = bar-\u003ecount; /* This is the number of threads that can enter before we need to reset. Always at the end of a round. */ unsigned int max_in_before_reset = BARRIER_IN_THRESHOLD - BARRIER_IN_THRESHOLD % count; if (i \u003e max_in_before_reset) { /* We're in a reset round. Just wait for a reset to finish; do not help finishing previous rounds because this could happen concurrently with a reset. */ while (i \u003e max_in_before_reset) { futex_wait_simple (\u0026bar-\u003ein, i, bar-\u003eshared); /* Relaxed MO is fine here because we just need an indication for when we should retry to enter (which will use acquire MO, see above). */ i = atomic_load_relaxed (\u0026bar-\u003ein); } goto reset_restart; } /* Look at the current round. At this point, we are just interested in whether we can complete rounds, based on the information we obtained through our acquire-MO load of IN. Nonetheless, if we notice that our round has been completed using this load, we use the acquire-MO fence below to make sure that all pre-barrier-entry effects of all threads in our round happen before us leaving the barrier. Therefore, relaxed MO is sufficient. */ unsigned cr = atomic_load_relaxed (\u0026bar-\u003ecurrent_round); /* Try to finish previous rounds and/or the current round. We simply consider just our position here and do not try to do the work of threads that entered more recently. */ while (cr + count \u003c= i) { /* Calculate the new current round based on how many threads entered. NEWCR must be larger than CR because CR+COUNT ends a round. */ unsigned int newcr = i - i % count; /* Try to complete previous and/or the current round. We need release MO to propagate the happens-before that we observed through reading with acquire MO from IN to other threads. If the CAS fails, it is like the relaxed-MO load of CURRENT_ROUND above. */ if (atomic_compare_exchange_weak_release (\u0026bar-\u003ecurrent_round, \u0026cr, newcr)) { /* Update CR with the modification we just did. */ cr = newcr; /* Wake threads belonging to the rounds we just finished. We may wake more threads than necessary if more than COUNT threads try to block concurrently on the barrier, but this is not a typical use of barriers. Note that we can still access SHARED because we h","date":"2022-07-18","objectID":"/pthread_lock/:5:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-3"},{"categories":["pthread"],"content":" 6 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); #define TEST_MUTEX pthread_t p1, p2; pthread_mutex_t test_mutex = PTHREAD_MUTEX_INITIALIZER; void *test_thread(void *arg) { // make gcc happy unsigned int sleep_time = (unsigned int)((unsigned long)arg); while (true) { #ifdef TEST_MUTEX pthread_mutex_lock(\u0026test_mutex); #endif printf(\"thread %p\\r\\n\", arg); sleep(sleep_time); #ifdef TEST_MUTEX pthread_mutex_unlock(\u0026test_mutex); #endif sleep(sleep_time); } return NULL; } int main(int argc, char *argv[]) { pthread_create(\u0026p1, NULL, \u0026test_thread, (void *)1); pthread_create(\u0026p2, NULL, \u0026test_thread, (void *)2); // 设置线程分离 pthread_detach(p1); pthread_detach(p2); while (true) { sleep(1); } return 0; } # 没有启动互斥锁 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x1 thread 0x2 thread 0x1 thread 0x1 thread 0x2 thread 0x1 thread 0x1 thread 0x2 thread 0x1 # 启动互斥锁 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 如果没有启动互斥锁,那么二者的运行时间是相同的概率,那么打印的个数2:1; 如果开始启动互斥锁,二者的运行时交替进行的; ","date":"2022-07-18","objectID":"/pthread_lock/:6:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#互斥锁"},{"categories":["pthread"],"content":" 6.1 musl实现在musl库上的互斥锁,但是我感觉musl的设计存在一些瑕疵,还是在去分析一下glibc的设计思路吧. typedef struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t; int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a) { *m = (pthread_mutex_t){0}; if (a) { m-\u003e_m_type = a-\u003e__attr; } return 0; } int pthread_mutex_destroy(pthread_mutex_t *mutex) { if (mutex-\u003e_m_type \u003e 128) { __vm_wait(); } return 0; } int pthread_mutex_lock(pthread_mutex_t *m) { if ((m-\u003e_m_type \u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; return __pthread_mutex_timedlock(m, 0); } int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at) { /* PTHREAD_MUTEX_NORMAL:死等 */ if ((m-\u003e_m_type\u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; int type = m-\u003e_m_type; int r, t, priv = (type \u0026 128) ^ 128; /* 尝试加锁 */ r = __pthread_mutex_trylock(m); if (r != EBUSY) { return r; } if (type\u00268) return pthread_mutex_timedlock_pi(m, at); int spins = 100; while (spins-- \u0026\u0026 m-\u003e_m_lock \u0026\u0026 !m-\u003e_m_waiters) a_spin(); while ((r=__pthread_mutex_trylock(m)) == EBUSY) { r = m-\u003e_m_lock; int own = r \u0026 0x3fffffff; if (!own \u0026\u0026 (!r || (type\u00264))) continue; if ((type\u00263) == PTHREAD_MUTEX_ERRORCHECK \u0026\u0026 own == __pthread_self()-\u003etid) return EDEADLK; a_inc(\u0026m-\u003e_m_waiters); t = r | 0x80000000; a_cas(\u0026m-\u003e_m_lock, r, t); r = __timedwait(\u0026m-\u003e_m_lock, t, CLOCK_REALTIME, at, priv); a_dec(\u0026m-\u003e_m_waiters); if (r \u0026\u0026 r != EINTR) break; } return r; } ","date":"2022-07-18","objectID":"/pthread_lock/:6:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-4"},{"categories":["pthread"],"content":" 6.2 glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) // 双向链表 typedef struct __pthread_internal_list { struct __pthread_internal_list *__prev; struct __pthread_internal_list *__next; } __pthread_list_t; struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; #define __SIZEOF_PTHREAD_MUTEX_T 40 typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 源代码经过改动，并不和Glibc源码一致 计算出type并且分析type的类型 enum { PTHREAD_MUTEX_KIND_MASK_NP = 3, PTHREAD_MUTEX_ELISION_NP = 256, PTHREAD_MUTEX_NO_ELISION_NP = 512, PTHREAD_MUTEX_ROBUST_NORMAL_NP = 16, PTHREAD_MUTEX_ROBUST_RECURSIVE_NP = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_RECURSIVE_NP, PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_ADAPTIVE_NP, PTHREAD_MUTEX_PRIO_INHERIT_NP = 32, PTHREAD_MUTEX_PI_NORMAL_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_PI_RECURSIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_RECURSIVE_NP, PTHREAD_MUTEX_PI_ERRORCHECK_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_PI_ADAPTIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ADAPTIVE_NP, PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_NORMAL_NP, PTHREAD_MUTEX_PI_ROBUST_RECURSIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_RECURSIVE_NP, PTHREAD_MUTEX_PI_ROBUST_ERRORCHECK_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP, PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP, PTHREAD_MUTEX_PRIO_PROTECT_NP = 64, PTHREAD_MUTEX_PP_NORMAL_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_PP_RECURSIVE_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_RECURSIVE_NP, PTHREAD_MUTEX_PP_ERRORCHECK_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_PP_ADAPTIVE_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_ADAPTIVE_NP, PTHREAD_MUTEX_ELISION_FLAGS_NP = PTHREAD_MUTEX_ELISION_NP | PTHREAD_MUTEX_NO_ELISION_NP, PTHREAD_MUTEX_TIMED_ELISION_NP = PTHREAD_MUTEX_TIMED_NP | PTHREAD_MUTEX_ELISION_NP, PTHREAD_MUTEX_TIMED_NO_ELISION_NP = PTHREAD_MUTEX_TIMED_NP | PTHREAD_MUTEX_NO_ELISION_NP, }; // 使用下面的宏提取类型信息 #define PTHREAD_MUTEX_TYPE_ELISION(m) \\ | ox100 (atomic_load_relaxed (\u0026((m)-\u003e__data.__kind)) \u0026 (0x7F | PTHREAD_MUTEX_ELISION_NP)) // ==\u003e \u0026((m)-\u003e__data.__kind \u0026 0x17F graph TD pthread_mutex_lock --\u003e ___pthread_mutex_lock ___pthread_mutex_lock --\u003e __pthread_mutex_lock_full ___pthread_mutex_lock --\u003e lll_mutex_lock_optimized futex封装函数 __lll_lock_wait_private __lll_lock_wait __lll_lock_wake_private __lll_lock_wake 继续深入的代码需要查看futex实现 void __lll_lock_wait_private (int *futex) { if (atomic_load_relaxed (futex) == 2) goto futex; while (atomic_exchange_acquire (futex, 2) != 0) { futex: LIBC_PROBE (lll_lock_wait_private, 1, futex); futex_wait ((unsigned int *) futex, 2, LLL_PRIVATE); /* Wait if *futex == 2. */ } } libc_hidden_def (__lll_lock_wait_private) void __lll_lock_wait (int *futex, int private) { if (atomic_load_relaxed (futex) == 2) goto futex; while (atomic_exchange_acquire (futex, 2) != 0) { futex: LIBC_PROBE (lll_lock_wait, 1, futex); futex_wait ((unsigned int *) futex, 2, private); /* Wait if *futex == 2. */ } } libc_hidden_def (__lll_lock_wait) # define lll_futex_wake(futexp, nr, private) \\ lll_futex_syscall (4, futexp, \\ __lll_private_flag (FUTEX_WAKE, private), nr, 0) void __lll_lock_wake_private (int *futex) { lll_futex_wake (futex, 1, LLL_PRIVATE); } libc_hidden_def (__lll_lock_wake_private) void __lll_lock_wake (int *futex, int private) { lll_futex_wake (futex, 1, private); } libc_hidden_def (__lll_lock_wake) 底层函数操作 # define LLL_MUTEX_LOCK(mutex) lll_lock ((mutex)-\u003e__data.__lock, PTHREAD_MUTEX_","date":"2022-07-18","objectID":"/pthread_lock/:6:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-4"},{"categories":["pthread"],"content":" 7 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); ","date":"2022-07-18","objectID":"/pthread_lock/:7:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#条件变量"},{"categories":["pthread"],"content":" 7.1 musl实现 ``` int pthread_cond_init(pthread_cond_t *restrict c, const pthread_condattr_t *restrict a) { *c = (pthread_cond_t){0}; if (a) { c-\u003e_c_clock = a-\u003e__attr \u0026 0x7fffffff; if (a-\u003e__attr\u003e\u003e31) c-\u003e_c_shared = (void *)-1; } return 0; } int pthread_cond_destroy(pthread_cond_t *c) { if (c-\u003e_c_shared \u0026\u0026 c-\u003e_c_waiters) { int cnt; a_or(\u0026c-\u003e_c_waiters, 0x80000000); a_inc(\u0026c-\u003e_c_seq); __wake(\u0026c-\u003e_c_seq, -1, 0); while ((cnt = c-\u003e_c_waiters) \u0026 0x7fffffff) __wait(\u0026c-\u003e_c_waiters, 0, cnt, 0); } return 0; } int pthread_cond_wait(pthread_cond_t *restrict c, pthread_mutex_t *restrict m) { return pthread_cond_timedwait(c, m, 0); } int __pthread_cond_timedwait(pthread_cond_t *restrict c, pthread_mutex_t *restrict m, const struct timespec *restrict ts) { struct waiter node = { 0 }; int e, seq, clock = c-\u003e_c_clock, cs, shared=0, oldstate, tmp; volatile int *fut; if ((m-\u003e_m_type\u002615) \u0026\u0026 (m-\u003e_m_lock\u0026INT_MAX) != __pthread_self()-\u003etid) return EPERM; if (ts \u0026\u0026 ts-\u003etv_nsec \u003e= 1000000000UL) return EINVAL; __pthread_testcancel(); if (c-\u003e_c_shared) { shared = 1; fut = \u0026c-\u003e_c_seq; seq = c-\u003e_c_seq; a_inc(\u0026c-\u003e_c_waiters); } else { lock(\u0026c-\u003e_c_lock); seq = node.barrier = 2; fut = \u0026node.barrier; node.state = WAITING; node.next = c-\u003e_c_head; c-\u003e_c_head = \u0026node; if (!c-\u003e_c_tail) c-\u003e_c_tail = \u0026node; else node.next-\u003eprev = \u0026node; unlock(\u0026c-\u003e_c_lock); } __pthread_mutex_unlock(m); __pthread_setcancelstate(PTHREAD_CANCEL_MASKED, \u0026cs); if (cs == PTHREAD_CANCEL_DISABLE) __pthread_setcancelstate(cs, 0); do e = __timedwait_cp(fut, seq, clock, ts, !shared); while (*fut==seq \u0026\u0026 (!e || e==EINTR)); if (e == EINTR) e = 0; if (shared) { /* Suppress cancellation if a signal was potentially * consumed; this is a legitimate form of spurious * wake even if not. */ if (e == ECANCELED \u0026\u0026 c-\u003e_c_seq != seq) e = 0; if (a_fetch_add(\u0026c-\u003e_c_waiters, -1) == -0x7fffffff) __wake(\u0026c-\u003e_c_waiters, 1, 0); oldstate = WAITING; goto relock; } oldstate = a_cas(\u0026node.state, WAITING, LEAVING); if (oldstate == WAITING) { /* Access to cv object is valid because this waiter was not * yet signaled and a new signal/broadcast cannot return * after seeing a LEAVING waiter without getting notified * via the futex notify below. */ lock(\u0026c-\u003e_c_lock); if (c-\u003e_c_head == \u0026node) c-\u003e_c_head = node.next; else if (node.prev) node.prev-\u003enext = node.next; if (c-\u003e_c_tail == \u0026node) c-\u003e_c_tail = node.prev; else if (node.next) node.next-\u003eprev = node.prev; unlock(\u0026c-\u003e_c_lock); if (node.notify) { if (a_fetch_add(node.notify, -1)==1) __wake(node.notify, 1, 1); } } else { /* Lock barrier first to control wake order. */ lock(\u0026node.barrier); } relock: /* Errors locking the mutex override any existing error or * cancellation, since the caller must see them to know the * state of the mutex. */ if ((tmp = pthread_mutex_lock(m))) e = tmp; if (oldstate == WAITING) goto done; if (!node.next \u0026\u0026 !(m-\u003e_m_type \u0026 8)) a_inc(\u0026m-\u003e_m_waiters); /* Unlock the barrier that's holding back the next waiter, and * either wake it or requeue it to the mutex. */ if (node.prev) { int val = m-\u003e_m_lock; if (val\u003e0) a_cas(\u0026m-\u003e_m_lock, val, val|0x80000000); unlock_requeue(\u0026node.prev-\u003ebarrier, \u0026m-\u003e_m_lock, m-\u003e_m_type \u0026 (8|128)); } else if (!(m-\u003e_m_type \u0026 8)) { a_dec(\u0026m-\u003e_m_waiters); } /* Since a signal was consumed, cancellation is not permitted. */ if (e == ECANCELED) e = 0; done: __pthread_setcancelstate(cs, 0); if (e == ECANCELED) { __pthread_testcancel(); __pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0); } return e; } int pthread_cond_signal(pthread_cond_t *c) { if (!c-\u003e_c_shared) return __private_cond_signal(c, 1); if (!c-\u003e_c_waiters) return 0; a_inc(\u0026c-\u003e_c_seq); __wake(\u0026c-\u003e_c_seq, 1, 0); return 0; } int pthread_cond_broadcast(pthread_cond_t *c) { if (!c-\u003e_c_shared) return __private_cond_signal(c, -1); if (!c-\u003e_c_waiters) return 0; a_inc(\u0026c-\u003e_c_seq); __wake(\u0026c-\u003e_c_seq, -1, 0); return 0; } int __private_cond_signal(pthread_cond_t *c, int n) { struct waiter *p, *first=0; volatile int ref = 0; int cur; lock(\u0026c-\u003e_c_lock); for (p=c-\u003e_c_tail; n \u0026\u0026 p; p=p-\u003e","date":"2022-07-18","objectID":"/pthread_lock/:7:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-5"},{"categories":["pthread"],"content":" 7.2 glibc实现 ","date":"2022-07-18","objectID":"/pthread_lock/:7:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-5"},{"categories":["pthread"],"content":" 8 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); ","date":"2022-07-18","objectID":"/pthread_lock/:8:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#读写锁"},{"categories":["pthread"],"content":" 8.1 musl实现 ","date":"2022-07-18","objectID":"/pthread_lock/:8:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-6"},{"categories":["pthread"],"content":" 8.2 glibc实现 ","date":"2022-07-18","objectID":"/pthread_lock/:8:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-6"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_thread/","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/"},{"categories":["pthread"],"content":" 基于musl源码库与glibc库,其中musl提供分析的思路,glibc分析具体实现 ","date":"2022-07-18","objectID":"/pthread_thread/:0:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#"},{"categories":["pthread"],"content":" 1 调试环境搭建","date":"2022-07-18","objectID":"/pthread_thread/:1:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#调试环境搭建"},{"categories":["pthread"],"content":" 1.1 下载源码执行/usr/lib/libc.so.6,确定版本 /usr/lib/libc.so.6 GNU C Library (GNU libc) stable release version 2.37. Copyright (C) 2023 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 12.2.1 20230201. libc ABIs: UNIQUE IFUNC ABSOLUTE Minimum supported kernel: 4.4.0 For bug reporting instructions, please see: \u003chttps://bugs.archlinux.org/\u003e. 清华源下载glibc2.37 ","date":"2022-07-18","objectID":"/pthread_thread/:1:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#下载源码"},{"categories":["pthread"],"content":" 1.2 编译glibc #!/bin/bash # shellcheck disable=SC2034 root_path=$(pwd) install_path=${root_path}/install/glibc glibc_path=${root_path}/glibc-2.37 pushd \"${glibc_path}\" \u003e\u003e /dev/null || exit mkdir build \u0026\u0026 pushd build \u003e\u003e /dev/null || exit CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" \\ CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" ../configure --prefix=\"${install_path}\" --disable-werror make -j\"$(nproc)\" make install popd \u003e\u003e /dev/null || exit popd \u003e\u003e /dev/null || exit 如果跳转异常，则可以将指令修改，调整编译优化等级,使用O0编译; CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -O0 -Wno-error\" CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -O0 -Wno-error\" ","date":"2022-07-18","objectID":"/pthread_thread/:1:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#编译glibc"},{"categories":["pthread"],"content":" 1.3 测试代码 gcc -g -L $(PWD)/../install/lib -Wl,--rpath=$(PWD)/../install/lib -Wl,-I $(PWD)/../install/lib/ld-linux-x86-64.so.2 test_main.c -o test_main 完美实现效果 ","date":"2022-07-18","objectID":"/pthread_thread/:1:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#测试代码"},{"categories":["pthread"],"content":" 2 pthread句柄","date":"2022-07-18","objectID":"/pthread_thread/:2:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread句柄"},{"categories":["pthread"],"content":" 2.1 musl实现 struct pthread { struct pthread *self; #ifndef TLS_ABOVE_TP uintptr_t *dtv; #endif /* 线程链表项 */ struct pthread *prev, *next; /* non-ABI */ /* 系统信息 */ uintptr_t sysinfo; #ifndef TLS_ABOVE_TP #ifdef CANARY_PAD uintptr_t canary_pad; #endif uintptr_t canary; #endif /* TLS_ABOVE_TP */ int tid; // 线程ID int errno_val; volatile int detach_state; // 分离状态 volatile int cancel; // cancle启动标志 volatile unsigned char canceldisable; // cancle控制 volatile unsigned char cancelasync; // cancle同步标志 unsigned char tsd_used:1; unsigned char dlerror_flag:1; unsigned char *map_base; // mmap size_t map_size; void *stack; // 堆栈 size_t stack_size; size_t guard_size; void *result; // 返回结果, /* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ struct __ptcb *cancelbuf; void **tsd; struct { volatile void *volatile head; long off; volatile void *volatile pending; } robust_list; int h_errno_val; volatile int timer_id; locale_t locale; volatile int killlock[1]; // 退出锁 char *dlerror_buf; void *stdio_locks; #ifdef TLS_ABOVE_TP uintptr_t canary; uintptr_t *dtv; #endif }; ","date":"2022-07-18","objectID":"/pthread_thread/:2:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#musl实现"},{"categories":["pthread"],"content":" 2.2 glibc实现 struct __pthread { /* 线程ID: typedef unsigned long int pthread_t; */ pthread_t thread; unsigned int nr_refs; /* Detached threads have a self reference only, while joinable threads have two references. These are used to keep the structure valid at thread destruction. Detaching/joining a thread drops a reference. */ /* Cancellation. */ pthread_mutex_t cancel_lock; /* Protect cancel_xxx members. */ void (*cancel_hook) (void *); /* Called to unblock a thread blocking in a cancellation point (namely, __pthread_cond_timedwait_internal). */ void *cancel_hook_arg; int cancel_state; int cancel_type; int cancel_pending; /* Thread stack. */ void *stackaddr; /* 堆栈地址 */ size_t stacksize; /* 堆栈大小 */ size_t guardsize; /* 预留用来保护堆栈大小的字节 */ int stack; /* Nonzero if the stack was allocated. */ /* Exit status. */ void *status; /* Thread state. */ enum pthread_state state; pthread_mutex_t state_lock; /* Locks the state. */ pthread_cond_t state_cond; /* Signalled when the state changes. */ bool terminated; /* Whether the kernel thread is over and we can reuse this structure. */ /* Resolver state. */ struct __res_state res_state; /* Indicates whether is a C11 thread created by thrd_creat. */ bool c11; /* Initial sigset for the thread. */ sigset_t init_sigset; /* Thread context. */ struct pthread_mcontext mcontext; PTHREAD_KEY_MEMBERS /* void **thread_specifics; // This is only resized by the thread, and always growing unsigned thread_specifics_size; // Number of entries in thread_specifics */ PTHREAD_SYSDEP_MEMBERS /* thread_t kernel_thread; mach_msg_header_t wakeupmsg; */ /* 线程控制块:与系统进行沟通 */ tcbhead_t *tcb; /* Queue links. Since PREVP is used to determine if a thread has been awaken, it must be protected by the queue lock. */ struct __pthread *next, **prevp; }; 但是在我们使用的时候发现与我们正常的使用不太一致,在用户层,我们一般认为pthread为线程ID，但是内部实现好像都是指针,因此出现了什么特殊的原因； 在musl中,直接抹掉了内部结构; // 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 #ifdef __cplusplus typedef unsigned long pthread_t; #else typedef struct __pthread* pthread_t; #endif 而在glibc中,线程ID仅仅是线程结构体中的一个成员,因此,glibc的处理更加安全, 下面分析一下id的实现, __pthread_create (pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine) (void *), void *arg) { int err; struct __pthread *pthread; err = __pthread_create_internal (\u0026pthread, attr, start_routine, arg); if (!err) *thread = pthread-\u003ethread; else if (err == ENOMEM) err = EAGAIN; return err; } /* 那么可以明白,线程ID */ int _dl_pthread_num_threads; struct __pthread **_dl_pthread_threads; __libc_rwlock_define_initialized (, _dl_pthread_threads_lock) /* 下面的代码实现线程ID的分配:只保留了成功的部分,没有考虑意外情况 */ __libc_rwlock_wrlock (GL(dl_pthread_threads_lock)); if (GL(dl_pthread_num_threads) \u003c __pthread_max_threads) { /* We have a free slot. Use the slot number plus one as the thread ID for the new thread. */ new-\u003ethread = 1 + GL(dl_pthread_num_threads)++; GL(dl_pthread_threads)[new-\u003ethread - 1] = NULL; __libc_rwlock_unlock (GL(dl_pthread_threads_lock)); *pthread = new; return 0; } 但是GL是什么呢?hehe #define GL(x) _##x ","date":"2022-07-18","objectID":"/pthread_thread/:2:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现"},{"categories":["pthread"],"content":" 3 所有的函数","date":"2022-07-18","objectID":"/pthread_thread/:3:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#所有的函数"},{"categories":["pthread"],"content":" 3.1 线程创建 // 线程创建 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict); // 线程退出 void pthread_exit(void *); ","date":"2022-07-18","objectID":"/pthread_thread/:3:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程创建"},{"categories":["pthread"],"content":" 3.2 线程属性 int pthread_attr_init(pthread_attr_t *); int pthread_attr_destroy(pthread_attr_t *); int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setguardsize(pthread_attr_t *, size_t); int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setstacksize(pthread_attr_t *, size_t); int pthread_attr_getdetachstate(const pthread_attr_t *, int *); int pthread_attr_setdetachstate(pthread_attr_t *, int); int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); int pthread_attr_setstack(pthread_attr_t *, void *, size_t); int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setscope(pthread_attr_t *, int); int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setschedpolicy(pthread_attr_t *, int); int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setinheritsched(pthread_attr_t *, int); ","date":"2022-07-18","objectID":"/pthread_thread/:3:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程属性"},{"categories":["pthread"],"content":" 3.3 线程分离 // 线程分离 int pthread_detach(pthread_t); // 线程等待 int pthread_join(pthread_t, void **); // 获取线程自己的ID pthread_t pthread_self(void); // 判断线程是否相等 int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 ","date":"2022-07-18","objectID":"/pthread_thread/:3:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离"},{"categories":["pthread"],"content":" 3.4 线程取消 int pthread_setcancelstate(int, int *); int pthread_setcanceltype(int, int *); void pthread_testcancel(void); int pthread_cancel(pthread_t); ","date":"2022-07-18","objectID":"/pthread_thread/:3:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程取消"},{"categories":["pthread"],"content":" 3.5 调度相关 int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param); __syscall(SYS_sched_getparam, pthread_t-\u003etid, sched_param); __syscall(SYS_sched_getscheduler, pthread_t-\u003etid); int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param); __syscall(SYS_sched_setscheduler, pthread_t-\u003etid, policy, sched_param); // sched_param保存着优先级参数 int pthread_setschedprio(pthread_t t, int prio); __syscall(SYS_sched_setparam, pthread_t-\u003etid, \u0026prio); ","date":"2022-07-18","objectID":"/pthread_thread/:3:5","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#调度相关"},{"categories":["pthread"],"content":" 4 Linux线程实现 ","date":"2022-07-18","objectID":"/pthread_thread/:4:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#linux线程实现"},{"categories":["pthread"],"content":" 5 系统调用","date":"2022-07-18","objectID":"/pthread_thread/:5:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用"},{"categories":["pthread"],"content":" 5.1 系统调用实现(musl) #define __asm_syscall(...) do { __asm__ __volatile__ ( \"svc 0\" : \"=r\"(r0) : __VA_ARGS__ : \"memory\"); return r0; } while (0); #define R7_OPERAND \"r\"(r7) static inline long __syscall0(long n) { register long r7 __ASM____R7__ = n; //使用R7传递个数 register long r0 __asm__(\"r0\"); __asm_syscall(R7_OPERAND); } static inline long __syscall1(long n, long a) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; __asm_syscall(R7_OPERAND, \"0\"(r0)); } static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; register long r1 __asm__(\"r1\") = b; register long r2 __asm__(\"r2\") = c; register long r3 __asm__(\"r3\") = d; register long r4 __asm__(\"r4\") = e; register long r5 __asm__(\"r5\") = f; __asm_syscall(R7_OPERAND, \"0\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3), \"r\"(r4), \"r\"(r5)); } // 一个相当巧妙的宏定义的实现 #define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n #define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) // 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 // 拼装函数调用 #define __SYSCALL_CONCAT_X(a,b) a##b #define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) #define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) // __syscall_ret仅仅检查了系统调用号 #define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) #define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束 系统调用号实现 #ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H #define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 #define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) #define __NR_exit (__NR_SYSCALL_BASE + 1) #define __NR_fork (__NR_SYSCALL_BASE + 2) #define __NR_read (__NR_SYSCALL_BASE + 3) #define __NR_write (__NR_SYSCALL_BASE + 4) #define __NR_open (__NR_SYSCALL_BASE + 5) #define __NR_close (__NR_SYSCALL_BASE + 6) #define __NR_creat (__NR_SYSCALL_BASE + 8) ... #define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) #endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */ ","date":"2022-07-18","objectID":"/pthread_thread/:5:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用实现musl"},{"categories":["pthread"],"content":" 5.2 系统调用实现(glibc)同样的道理,可以分析一下glibc的系统调用时如何进行 但是在一般的情况下此时就可以明白,与musl相同的调用方式时一样的 INLINE_SYSCALL_CALL --\u003e __INLINE_SYSCALL_DISP __INLINE_SYSCALL_DISP --\u003e __SYSCALL_CONCAT 生成一条调用指令的语言 # define INTERNAL_SYSCALL_RAW(name, nr, args...) \\ ({ \\ register int _a1 asm (\"r0\"), _nr asm (\"r7\"); \\ LOAD_ARGS_##nr (args) \\ _nr = name; \\ asm volatile (\"swi 0x0 @ syscall \" #name \\ : \"=r\" (_a1) \\ : \"r\" (_nr) ASM_ARGS_##nr \\ : \"memory\"); \\ _a1; }) ","date":"2022-07-18","objectID":"/pthread_thread/:5:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用实现glibc"},{"categories":["pthread"],"content":" 6 线程基础","date":"2022-07-18","objectID":"/pthread_thread/:6:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程基础"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程创建-1"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现的线程函数"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread管理单元申请与释放"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#内核线程创建"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#tls创建"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#设置启动参数"},{"categories":["pthread"],"content":" 6.2 ptrhead进程属性机制 int pthread_attr_init(pthread_attr_t *a); pthread_attr_t-\u003e_a_stacksize = __default_stacksize; pthread_attr_t-\u003e_a_guardsize = __default_guardsize; int pthread_attr_setdetachstate(pthread_attr_t *a, int state); pthread_attr_t-\u003e_a_detach = state; int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_guardsize = size; int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); pthread_attr_t-\u003e_a_sched = inherit; int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param); pthread_attr_t-\u003e_a_prio = param-\u003esched_priority; int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); pthread_attr_t-\u003e_a_policy = policy; int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); pthread_attr_t-\u003e_a_stackaddr = (size_t)addr + size; pthread_attr_t-\u003e_a_stacksize = size; int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_stackaddr = 0; pthread_attr_t-\u003e_a_stacksize = size; ","date":"2022-07-18","objectID":"/pthread_thread/:6:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#ptrhead进程属性机制"},{"categories":["pthread"],"content":" 6.3 自身线程ID // 在musl和glibc的实现上二者不太一样 static inline uintptr_t __get_tp() { uintptr_t tp; __asm__ ( \"mrc p15,0,%0,c13,c0,3\" : \"=r\"(tp) ); return tp; } // 获取线程自身的方法 #define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) // 二者实现不太一样 /* Return the thread descriptor for the current thread. */ # define THREAD_SELF ((struct pthread *)__builtin_thread_pointer () - 1) pthread_t __pthread_self (void) { return (pthread_t) THREAD_SELF; } ","date":"2022-07-18","objectID":"/pthread_thread/:6:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#自身线程id"},{"categories":["pthread"],"content":" 6.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 6.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:6:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程清理函数"},{"categories":["pthread"],"content":" 6.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 6.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:6:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#cancle设置"},{"categories":["pthread"],"content":" 6.5 线程分离 // 线程分离 int pthread_detach(pthread_t) --\u003e __pthread_join(pthread_t, 0) --\u003e __pthread_timedjoin_np(pthread_t, 0, 0) // 设置线程等待 int pthread_join(pthread_t, void **); --\u003e__pthread_timedjoin_np(pthread_t, res, 0) // 那么也就是说明都调用了相同的函数 static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { /* 设置线程分离状态 */ } ","date":"2022-07-18","objectID":"/pthread_thread/:6:5","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离-1"},{"categories":["编译原理"],"content":"编译原理","date":"2022-07-07","objectID":"/compile/","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/"},{"categories":["编译原理"],"content":" 1 词法分析","date":"2022-07-07","objectID":"/compile/:1:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#词法分析"},{"categories":["编译原理"],"content":" 1.1 概述 词法分析是编译原理的第一个阶段,词法分析的任务是读入源程序的输入字符,生成一个个的单词,其主要的功能是为语法分析提供词法单元 graph LR S1((源程序)) S2[词法分析器] S3[语法分析器] S4((符号表)) S5[输出之语义分析] S1--\u003eS2--\u003eS3--\u003eS5 S3--\u003eS2 S2--\u003eS4 S4--\u003eS2 S3--\u003eS4 S4--\u003eS3 ","date":"2022-07-07","objectID":"/compile/:1:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#概述"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compile/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#正则表达式"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compile/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#flex正则表达式"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA)graph LR 输入的字符串 --\u003e 有限状态自动机 有限状态自动机 --\u003e 判断结果[\"{Yes, No}\"] 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 graph LR 状态1((0)) 状态2((1)) 状态3((2)) 状态1--b--\u003e状态1 状态1--a--\u003e状态2 状态2--b--\u003e状态2 状态2--a--\u003e状态3 状态3--a,b--\u003e状态3 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#有限状态自动机fa"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA)graph LR 输入的字符串 --\u003e 有限状态自动机 有限状态自动机 --\u003e 判断结果[\"{Yes, No}\"] 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 graph LR 状态1((0)) 状态2((1)) 状态3((2)) 状态1--b--\u003e状态1 状态1--a--\u003e状态2 状态2--b--\u003e状态2 状态2--a--\u003e状态3 状态3--a,b--\u003e状态3 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#数学描述"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA)graph LR 输入的字符串 --\u003e 有限状态自动机 有限状态自动机 --\u003e 判断结果[\"{Yes, No}\"] 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 graph LR 状态1((0)) 状态2((1)) 状态3((2)) 状态1--b--\u003e状态1 状态1--a--\u003e状态2 状态2--b--\u003e状态2 状态2--a--\u003e状态3 状态3--a,b--\u003e状态3 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#例子"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自动生成"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#thompson算法"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#解释"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#例子-1"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#子集构造算法"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#hopcroft算法"},{"categories":["编译原理"],"content":" 2 语法分析","date":"2022-07-07","objectID":"/compile/:2:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#语法分析"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自顶向下"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1分析文法"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1文法概述"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1一般步骤"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#如何生成ll1分析表"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#first集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#follow集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#select集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#分析流程"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自底向上"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#lr0分析算法"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#点记号"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#生成一个逆序的最右推导"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#构造分析表"},{"categories":["编译原理"],"content":" 3 语义分析","date":"2022-07-07","objectID":"/compile/:3:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#语义分析"},{"categories":["编程语言"],"content":"C++高级编程","date":"2022-06-18","objectID":"/cxx_template/","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/"},{"categories":["编程语言"],"content":" 1 相关知识gcc中typeof关键字用来检查变量类型,那么则可以用来判断魔板生成中的数据类型, 但是在C++中存在这另外的运算符typeid,但是我个人认为typeof更加优秀，但是二者并不相同, typeid返回类型对象,typeof只可以判断类型; 代码如下: #define __toStr(x) #x #define toStr(x) __toStr(x) #define check_type_item(_x, type) \\ if (typeid(_x) == typeid(type)) { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is \" \u003c\u003c toStr(type) \u003c\u003c std::endl; \\ } else #define check_type_tail(_x) \\ { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is unknow\" \u003c\u003c std::endl; \\ } #define check_type(_x) \\ ({ \\ check_type_item(_x, bool) \\ check_type_item(_x, char) \\ check_type_item(_x, short) \\ check_type_item(_x, int) \\ check_type_item(_x, long) \\ check_type_item(_x, wchar_t) \\ check_type_item(_x, unsigned char) \\ check_type_item(_x, unsigned short) \\ check_type_item(_x, unsigned int) \\ check_type_item(_x, unsigned long) \\ check_type_item(_x, float) \\ check_type_item(_x, double) \\ check_type_item(_x, std::string) \\ check_type_tail(_x) \\ }) 从内核中学到的一种用来编译期间校验的宏函数,用来确定推导过程是否正确 #define BUILD_BUG_ON(cond) ((void)sizeof(int[1-2*(!!(cond))])) C++还提供了一种运算符static_assert,用作编译期间静态静态检查; static_assert(true); // 正确: 编译通过 static_assert(false); // 错误: static assertion failed 那么就可以通过此工具来分析模板推导过程是否是正确的 ","date":"2022-06-18","objectID":"/cxx_template/:1:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#相关知识"},{"categories":["编程语言"],"content":" 2 模板基础 模板和宏定义区别:模板在编译期进行,宏在预编译期间进行 建立通用的模板,提高复用率 C++提供两种模版机制:函数模版和类模板 ","date":"2022-06-18","objectID":"/cxx_template/:2:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板基础"},{"categories":["编程语言"],"content":" 2.1 函数模版 template \u003ctypename T\u003e 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template \u003ctypename T\u003e void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template \u003ctypename T\u003e T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add\u003cint\u003e(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template\u003ctypename T\u003e T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max\u003cdouble\u003e(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template\u003ctypename T1, typename T2, typename RT = std::decay_t\u003cdecltype(true ? T1() : T2())\u003e \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template\u003ctypename T1, typename T2\u003e auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template\u003ctypename T1, typename T2\u003e std::common_type_t\u003cT1,T2\u003e max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template\u003ctypename T = std::string\u003e T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模版"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#实例"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#注意事项"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#普通函数和函数模版的区别"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#普通函数和模版函数调用规则"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段编译检查two-phase-translation"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类型推断中的类型转换"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#多模板参数调用"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#显式指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#返回值指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#自动推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#公共类型推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#默认模板参数"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板重载"},{"categories":["编程语言"],"content":" 2.2 类模板 template \u003cclass T\u003e 类 例子 template \u003cclass NameType, class AgeType\u003e class Person { public: Person(NameType Name, AgeType Age) { m_Name = Name; m_Age = Age; } NameType m_Name; AgeType m_Age; }; 实例化 Person\u003cstd::string, int\u003e p(\"Hello\", 99); ","date":"2022-06-18","objectID":"/cxx_template/:2:2","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类模板"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template\u003cint Val, typename T\u003e T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template\u003cdouble VAT\u003e // ERROR: floating-point values are not void process (double v){} template\u003cstd::string name\u003e // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template\u003ctypename T, auto Maxsize\u003e class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板非类型参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数的限制"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template\u003ctypename T, typename... Types\u003e void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template\u003cclass... T\u003e auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板-1"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板实例"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参个运算符sizeof"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#折叠表达式"},{"categories":["编程语言"],"content":" 3 函数模板 编写时不指定具体类型，直到使用时才能确定，这个概念就是泛型。模板，顾名思义，编写一次即可适用于任意类型。模板定义以关键词 template 开始，后跟一个模板参数列表，类型参数前必须使用关键字 typename 或 class，在模板参数列表中这两个关键字含义相同，可以互换使用。函数模板通常不用声明为 inline，唯一例外的是特定类型的全特化，因为编译器可能忽略 inline，函数模板是否内联取决于编译器的优化策略 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max\u003cint\u003e(1, 3) == 3); assert(jc::max\u003cdouble\u003e(1.0, 3.14) == 3.14); std::string s1 = \"down\"; std::string s2 = \"demo\"; assert(jc::max\u003cstd::string\u003e(s1, s2) == \"down\"); } ","date":"2022-06-18","objectID":"/cxx_template/:3:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板httpsencppreferencecomwcpplanguagefunction_template"},{"categories":["编程语言"],"content":" 4 两阶段编译（Two-Phase Translation） 模板编译分为实例化前检查和实例化两个阶段。实例化前检查模板代码本身，包括 检查语法是否正确，如是否遗漏分号 检查是否使用不依赖于模板参数的未知名称，如未声明的类型名、函数名 检查不依赖于模板参数的静态断言 template \u003ctypename T\u003e void f(T x) { undeclared(); // 一阶段编译错误，未声明的函数 static_assert(sizeof(int) \u003e 10); // 一阶段，sizeof(int) \u003c= 10，总会编译失败 } int main() {} 实例化期间保证代码有效，比如对不能解引用的类型进行解引用就会实例化出错，此外会再次检查依赖于模板参数的部分 template \u003ctypename T\u003e void f(T x) { undeclared(x); // 调用 undeclared(T) 才会出现函数未声明的实例化错误 static_assert(sizeof(T) \u003e 10); // 如果 sizeof(T) \u003c= 10 则实例化错误 } int main() { f(42); // 调用函数才会进行实例化，不调用则不会有实例化错误 } ","date":"2022-06-18","objectID":"/cxx_template/:4:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段编译two-phase-translation"},{"categories":["编程语言"],"content":" 5 模板实参推断（Template Argument Deduction） 调用模板时，如果不显式指定模板参数类型，则编译器会根据传入的实参推断模板参数类型 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3) == 3); // T 推断为 int assert(jc::max(1.0, 3.14) == 3.14); // T 推断为 double std::string s1 = \"down\"; std::string s2 = \"demo\"; assert(jc::max(s1, s2) == \"down\"); // T 推断为 std::string } 实参的推断要求一致，其本身不会为了编译通过自动做类型转换 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { jc::max(1, 3.14); // 错误，T 分别推断出 int 和 double，类型不明确 } 字符串字面值传引用会推断为字符数组（传值则推断为 const char*，数组和函数会 decay 为指针） #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T, typename U\u003e T max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { std::string s = \"down\"; jc::max(\"down\", s); // 错误，T 推断为 char[5] 和 std::string } 对于推断不一致的情况，可以显式指定类型而不使用推断机制，或者强制转换实参为希望的类型使得推断结果一致 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T, typename U\u003e T max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { std::string s = \"demo\"; assert(jc::max\u003cstd::string\u003e(\"down\", \"demo\") == \"down\"); assert(jc::max(std::string{\"down\"}, s) == \"down\"); } 也可以增加一个模板参数，这样每个实参的推断都是独立的，不会出现矛盾 #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U\u003e T max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3.14) == 3); // T 推断为 int，返回值截断为 int assert(jc::max\u003cdouble\u003e(1, 3.14) == 3.14); } 模板实参不能推断返回类型，必须显式指定 #include \u003ccassert\u003e namespace jc { template \u003ctypename RT, typename T, typename U\u003e RT max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max\u003cdouble\u003e(1, 3.14) == 3.14); assert((jc::max\u003cdouble, int, int\u003e(1, 3.14) == 3)); } C++14 允许 auto 作为返回类型，它通过 return 语句推断返回类型，C++11 则需要额外指定尾置返回类型，对于三目运算符，其结果类型为两个操作数类型中更公用的类型，比如 int 和 double 的公用类型是 double #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U\u003e auto max(const T\u0026 a, const U\u0026 b) -\u003e decltype(true ? a : b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3.14) == 3.14); } 用 constexpr 函数可以生成编译期值 namespace jc { template \u003ctypename T, typename U\u003e constexpr auto max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { static_assert(jc::max(1, 3.14) == 3.14); } ","date":"2022-06-18","objectID":"/cxx_template/:5:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板实参推断template-argument-deductionhttpsencppreferencecomwcpplanguagetemplate_argument_deduction"},{"categories":["编程语言"],"content":" 6 type traits 对于类型进行计算的模板称为 type traits，也可以称为元函数，比如用 std::common_type 来计算不同类型中最通用的类型 #include \u003ccassert\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename U, typename RT = std::common_type_t\u003cT, U\u003e\u003e RT max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3.14) == 3.14); } ","date":"2022-06-18","objectID":"/cxx_template/:6:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#type-traitshttpsencppreferencecomwcppheadertype_traits"},{"categories":["编程语言"],"content":" 7 重载 当类型同时匹配普通函数和模板时，优先匹配普通函数 #include \u003ccassert\u003e namespace jc { int f(int a, int b) { return 1; } template \u003ctypename T, typename U\u003e int f(const T\u0026, const U\u0026) { return 2; } } // namespace jc int main() { assert(jc::f(1, 3) == 1); assert(jc::f\u003cdouble\u003e(1, 3) == 2); assert(jc::f\u003c\u003e(1, 3) == 2); assert(jc::f(1, 3.14) == 2); assert(jc::f(3.14, 1) == 2); } 模板参数不同就会构成重载，如果对于给定的实参能同时匹配两个模板，重载解析会优先匹配更特殊的模板，如果同样特殊则产生二义性错误 #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U\u003e int f(const T\u0026, const U\u0026) { return 1; } template \u003ctypename RT, typename T, typename U\u003e int f(const T\u0026 a, const U\u0026 b) { return 2; } } // namespace jc int main() { assert(jc::f(1, 3.14) == 1); assert(jc::f\u003cdouble\u003e(1, 3.14) == 2); // jc::f\u003cint\u003e(1, 3.14); // 二义性错误 } C-style 字符串的重载 #include \u003ccassert\u003e #include \u003ccstring\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e T max(T a, T b) { return a \u003c b ? b : a; } template \u003ctypename T\u003e T* max(T* a, T* b) { return *a \u003c *b ? b : a; } const char* max(const char* a, const char* b) { return std::strcmp(a, b) \u003c 0 ? b : a; } } // namespace jc int main() { int a = 1; int b = 3; assert(jc::max(a, b) == b); assert(jc::max(\u0026a, \u0026b) == \u0026b); std::string s1 = \"down\"; std::string s2 = \"demo\"; assert(jc::max(s1, s2) == \"down\"); assert(std::strcmp(jc::max(\"down\", \"demo\"), \"down\") == 0); } 注意不能返回 C-style 字符串的引用 namespace jc { template \u003ctypename T\u003e const T\u0026 f(const char* s) { return s; } } // namespace jc int main() { const char* s = \"downdemo\"; jc::f\u003cconst char*\u003e(s); // 错误：返回临时对象的引用 } 这种错误可能在添加代码的过程中引入 #include \u003ccstring\u003e namespace jc { template \u003ctypename T\u003e const T\u0026 max(const T\u0026 a, const T\u0026 b) { return b \u003c a ? a : b; } // 新增函数来支持 C-style 参数 const char* max(const char* a, const char* b) { return std::strcmp(a, b) \u003c 0 ? b : a; } template \u003ctypename T\u003e const T\u0026 max(const T\u0026 a, const T\u0026 b, const T\u0026 c) { return max(max(a, b), c); // max(\"down\", \"de\") 返回临时对象的引用 } } // namespace jc int main() { const char* a = \"down\"; const char* b = \"de\"; const char* c = \"mo\"; jc::max\u003cconst char*\u003e(a, b, c); // 错误：返回临时对象的引用 } 只有在函数调用前声明的重载才会被匹配，即使后续有更优先的匹配，由于不可见也会被忽略 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { return 1; } template \u003ctypename T\u003e int g(T a) { return f(a); } int f(int) { return 2; } } // namespace jc int main() { assert(jc::g(0) == 1); } ","date":"2022-06-18","objectID":"/cxx_template/:7:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#重载"},{"categories":["编程语言"],"content":" 8 用于原始数组与字符串字面值（string literal）的模板 字符串字面值传引用会推断为字符数组，为此需要为原始数组和字符串字面值提供特定处理的模板 #include \u003ccassert\u003e #include \u003ccstddef\u003e namespace jc { template \u003ctypename T, typename U\u003e constexpr bool less(const T\u0026 a, const U\u0026 b) { return a \u003c b; } template \u003ctypename T, std::size_t M, std::size_t N\u003e constexpr bool less(T (\u0026a)[M], T (\u0026b)[N]) { for (std::size_t i = 0; i \u003c M \u0026\u0026 i \u003c N; ++i) { if (a[i] \u003c b[i]) { return true; } if (b[i] \u003c a[i]) { return false; } } return M \u003c N; } } // namespace jc static_assert(jc::less(0, 42)); static_assert(!jc::less(\"down\", \"demo\")); static_assert(jc::less(\"demo\", \"down\")); int main() {} 各种类型的数组参数对应的偏特化 #include \u003ccstddef\u003e namespace jc { template \u003ctypename T\u003e struct A; template \u003ctypename T, std::size_t N\u003e struct A\u003cT[N]\u003e { static constexpr int value = 1; }; template \u003ctypename T, std::size_t N\u003e struct A\u003cT (\u0026)[N]\u003e { static constexpr int value = 2; }; template \u003ctypename T\u003e struct A\u003cT[]\u003e { static constexpr int value = 3; }; template \u003ctypename T\u003e struct A\u003cT (\u0026)[]\u003e { static constexpr int value = 4; }; template \u003ctypename T\u003e struct A\u003cT*\u003e { static constexpr int value = 5; }; template \u003ctypename T1, typename T2, typename T3\u003e constexpr void test(int a1[7], int a2[], int (\u0026a3)[42], int (\u0026x0)[], T1 x1, T2\u0026 x2, T3\u0026\u0026 x3) { static_assert(A\u003cdecltype(a1)\u003e::value == 5); // A\u003cT*\u003e static_assert(A\u003cdecltype(a2)\u003e::value == 5); // A\u003cT*\u003e static_assert(A\u003cdecltype(a3)\u003e::value == 2); // A\u003cT(\u0026)[N]\u003e static_assert(A\u003cdecltype(x0)\u003e::value == 4); // A\u003cT(\u0026)[]\u003e static_assert(A\u003cdecltype(x1)\u003e::value == 5); // A\u003cT*\u003e static_assert(A\u003cdecltype(x2)\u003e::value == 4); // A\u003cT(\u0026)[]\u003e static_assert(A\u003cdecltype(x3)\u003e::value == 4); // A\u003cT(\u0026)[]\u003e } } // namespace jc int main() { int a[42]; static_assert(jc::A\u003cdecltype(a)\u003e::value == 1); extern int x[]; // 传引用时将变为 int(\u0026)[] static_assert(jc::A\u003cdecltype(x)\u003e::value == 3); // A\u003cT[]\u003e jc::test(a, a, a, x, x, x, x); } int x[] = {1, 2, 3}; // 定义前置声明的数组 ","date":"2022-06-18","objectID":"/cxx_template/:8:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#用于原始数组与字符串字面值string-literal的模板"},{"categories":["编程语言"],"content":" 9 零初始化（Zero Initialization） 使用模板时常希望模板类型的变量已经用默认值初始化，但内置类型无法满足要求。解决方法是显式调用内置类型的默认构造函数 namespace jc { template \u003ctypename T\u003e constexpr T default_value() { T x{}; return x; } template \u003ctypename T\u003e struct DefaultValue { constexpr DefaultValue() : value() {} T value; }; template \u003ctypename T\u003e struct DefaultValue2 { T value{}; }; static_assert(default_value\u003cbool\u003e() == false); static_assert(default_value\u003cchar\u003e() == 0); static_assert(default_value\u003cint\u003e() == 0); static_assert(default_value\u003cdouble\u003e() == 0); static_assert(DefaultValue\u003cbool\u003e{}.value == false); static_assert(DefaultValue\u003cchar\u003e{}.value == 0); static_assert(DefaultValue\u003cint\u003e{}.value == 0); static_assert(DefaultValue\u003cdouble\u003e{}.value == 0); static_assert(DefaultValue2\u003cbool\u003e{}.value == false); static_assert(DefaultValue2\u003cchar\u003e{}.value == 0); static_assert(DefaultValue2\u003cint\u003e{}.value == 0); static_assert(DefaultValue2\u003cdouble\u003e{}.value == 0); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:9:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#零初始化zero-initialization"},{"categories":["编程语言"],"content":" 10 类模板 和函数类似，类也支持泛型，比如实现一个基于拓扑排序遍历的有向无环图的森林 #include \u003calgorithm\u003e #include \u003ccassert\u003e #include \u003cfunctional\u003e #include \u003cmap\u003e #include \u003cmemory\u003e #include \u003cqueue\u003e #include \u003cset\u003e #include \u003cunordered_set\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename K, typename V\u003e struct DAGNode { K k; V v; std::set\u003cDAGNode\u003cK, V\u003e*\u003e in; std::set\u003cDAGNode\u003cK, V\u003e*\u003e out; }; template \u003ctypename K, typename V\u003e class DAGGraph { public: bool AddEdge(const K\u0026 from, const K\u0026 to); V\u0026 operator[](const K\u0026 key); bool Exist(const K\u0026 key) const; void Clear(); std::size_t Size() const; void Walk(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f, bool start_from_head = true); void WalkHeads(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f); void WalkTails(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f); std::unordered_set\u003cK\u003e NextKeys(); std::unordered_set\u003cK\u003e NextKeys(const K\u0026 key); private: bool IsCyclic(const DAGNode\u003cK, V\u003e\u0026 from, const DAGNode\u003cK, V\u003e\u0026 to) const; void RefreshWalkSequences(); std::vector\u003cstd::set\u003cK\u003e\u003e ConnectedComponents() const; void DFS(const K\u0026 k, std::unordered_set\u003cK\u003e* visited, std::set\u003cK\u003e* connected_components) const; std::vector\u003cK\u003e TopologicalSequence(const std::set\u003cK\u003e\u0026 connected_components, bool start_from_head) const; private: std::map\u003cK, DAGNode\u003cK, V\u003e\u003e bucket_; std::unordered_set\u003cK\u003e heads_; std::unordered_set\u003cK\u003e tails_; std::vector\u003cstd::vector\u003cK\u003e\u003e sequences_start_from_head_; std::vector\u003cstd::vector\u003cK\u003e\u003e sequences_start_from_tail_; private: bool allow_modify_ = true; std::vector\u003cstd::vector\u003cK\u003e\u003e sequences_start_from_head_for_next_; std::unordered_set\u003cK\u003e current_heads_for_next_; }; template \u003ctypename K, typename V\u003e inline bool DAGGraph\u003cK, V\u003e::AddEdge(const K\u0026 from, const K\u0026 to) { assert(allow_modify_); if (from == to || !bucket_.count(from) || !bucket_.count(to) || IsCyclic(bucket_.at(from), bucket_.at(to))) { return false; } bucket_.at(from).out.emplace(\u0026bucket_.at(to)); bucket_.at(to).in.emplace(\u0026bucket_.at(from)); heads_.erase(to); tails_.erase(from); sequences_start_from_head_.clear(); sequences_start_from_tail_.clear(); return true; } template \u003ctypename K, typename V\u003e inline V\u0026 DAGGraph\u003cK, V\u003e::operator[](const K\u0026 key) { if (!bucket_.count(key)) { assert(allow_modify_); bucket_[key].k = key; heads_.emplace(key); tails_.emplace(key); sequences_start_from_head_.clear(); sequences_start_from_tail_.clear(); } return bucket_.at(key).v; } template \u003ctypename K, typename V\u003e inline bool DAGGraph\u003cK, V\u003e::Exist(const K\u0026 key) const { return bucket_.count(key); } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::Clear() { allow_modify_ = true; bucket_.clear(); heads_.clear(); tails_.clear(); sequences_start_from_head_.clear(); sequences_start_from_tail_.clear(); } template \u003ctypename K, typename V\u003e inline std::size_t DAGGraph\u003cK, V\u003e::Size() const { return bucket_.size(); } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::Walk(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f, bool start_from_head) { if (sequences_start_from_head_.empty()) { RefreshWalkSequences(); } const std::vector\u003cstd::vector\u003cK\u003e\u003e\u0026 seqs_to_walk = start_from_head ? sequences_start_from_head_ : sequences_start_from_tail_; for (const std::vector\u003cK\u003e\u0026 seq : seqs_to_walk) { std::for_each(std::begin(seq), std::end(seq), [\u0026](const K\u0026 key) { const DAGNode\u003cK, V\u003e\u0026 node = bucket_.at(key); f(node.k, node.v); }); } } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::WalkHeads( std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f) { if (sequences_start_from_head_.empty()) { RefreshWalkSequences(); } for (const std::vector\u003cK\u003e\u0026 seq : sequences_start_from_head_) { std::for_each(std::begin(seq), std::end(seq), [\u0026](const K\u0026 key) { if (heads_.count(key)) { const DAGNode\u003cK, V\u003e\u0026 node = bucket_.at(key); f(node.k, node.v); } }); } } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::WalkTails( std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f) { if (sequences_start_from_head_.empty()) { RefreshWalkSequences(); } for (const std::vector\u003cK\u003e\u0026 seq : sequences_start_from_tail_) { std::for_each(s","date":"2022-06-18","objectID":"/cxx_template/:10:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类模板httpsencppreferencecomwcpplanguageclass_template"},{"categories":["编程语言"],"content":" 11 友元 类内定义友元可以省略模板参数，但友元函数在类模板实例化后才会实例化，如果类模板中的友元函数不包含模板参数，则会出现重定义的错误 #include \u003ciostream\u003e #include \u003ctypeinfo\u003e namespace jc { template \u003ctypename T\u003e class A { // 类作用域内的 A 是注入类名，等价于 A\u003cT\u003e friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u0026 rhs) { return os \u003c\u003c \"A\u003c\" \u003c\u003c typeid(T).name() \u003c\u003c \"\u003e = \" \u003c\u003c rhs.n; } friend void f() {} private: int n = 0; }; } // namespace jc int main() { jc::A\u003cvoid\u003e a; // 实例化 operator\u003c\u003c(std::ostream\u0026, const A\u003cvoid\u003e\u0026) 和 f() std::cout \u003c\u003c a; // A\u003cvoid\u003e = 0 // jc::A\u003cint\u003e b; // 错误：第二次实例化 f()，重定义 } 类外定义友元不会有重定义的问题，需要在类内声明处为类模板额外指定不同的模板参数 #include \u003ciostream\u003e #include \u003ctypeinfo\u003e namespace jc { template \u003ctypename T\u003e class A { template \u003ctypename U\u003e friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cU\u003e\u0026 rhs); friend void f(); private: int n = 0; }; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs) { return os \u003c\u003c \"A\u003c\" \u003c\u003c typeid(T).name() \u003c\u003c \"\u003e = \" \u003c\u003c rhs.n; } void f() {} } // namespace jc int main() { jc::A\u003cvoid\u003e a; std::cout \u003c\u003c a; // A\u003cvoid\u003e = 0 jc::A\u003cint\u003e b; std::cout \u003c\u003c b; // A\u003cint\u003e = 0 } 如果要在类外定义友元，又不想在类内声明额外指定模板参数，则可以将友元声明为函数模板，在类内使用模板实例作为友元 #include \u003ciostream\u003e #include \u003ctypeinfo\u003e namespace jc { template \u003ctypename T\u003e class A; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs); template \u003ctypename T\u003e class A { friend std::ostream\u0026 operator\u003c\u003c\u003cT\u003e(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs); private: int n = 0; }; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs) { return os \u003c\u003c \"A\u003c\" \u003c\u003c typeid(T).name() \u003c\u003c \"\u003e = \" \u003c\u003c rhs.n; } } // namespace jc int main() { jc::A\u003cvoid\u003e a; std::cout \u003c\u003c a; // A\u003cvoid\u003e = 0 } 如果将类模板实例声明为友元，则类模板必须已声明并可见 namespace jc { template \u003ctypename T\u003e struct Node; template \u003ctypename T\u003e struct Tree { friend class Node\u003cT\u003e; // 友元类模板必须已声明并可见 friend class A; // 友元类可以未声明 }; } // namespace jc int main() {} 模板参数可以是友元 namespace jc { template \u003ctypename T\u003e class A { friend T; // 如果 T 不是 class 则忽略 private: int n = 0; }; class B { public: static int f(const A\u003cB\u003e\u0026 a) { return a.n; } }; } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:11:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#友元"},{"categories":["编程语言"],"content":" 12 特化（Specialization） 特化一般指的是全特化，即为一种特定类型指定一个特定实现，该类型将不使用模板的实例化版本 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class A { public: int f() { return 1; } }; template \u003c\u003e class A\u003cint\u003e { public: int f() { return 2; } int g() { return 3; } }; } // namespace jc int main() { jc::A\u003cvoid\u003e a; assert(a.f() == 1); jc::A\u003cint\u003e b; assert(b.f() == 2); assert(b.g() == 3); } ","date":"2022-06-18","objectID":"/cxx_template/:12:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#特化specializationhttpsencppreferencecomwcpplanguagetemplate_specialization"},{"categories":["编程语言"],"content":" 13 偏特化（Partial Specialization） 偏特化是为一类类型指定特定实现，是一种更通用的特化 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class A { public: int f() { return 1; } }; template \u003ctypename T\u003e class A\u003cT*\u003e { public: int f() { return 2; } int g() { return 3; } }; } // namespace jc int main() { jc::A\u003cint\u003e a; assert(a.f() == 1); jc::A\u003cint*\u003e b; assert(b.f() == 2); assert(b.g() == 3); jc::A\u003cjc::A\u003cint\u003e*\u003e c; assert(c.f() == 2); assert(c.g() == 3); } 偏特化可以指定多个模板参数之间的关系，如果多个偏特化匹配程度相同，将产生二义性错误。如果模板声明是一个普通声明（没有在模板名称后添加尖括号），这个声明就是一个主模板（primary template），编写偏特化通常会有一个主模板和其他偏特化模板 namespace jc { template \u003ctypename T, typename U\u003e struct A; // primary template template \u003ctypename T\u003e struct A\u003cT, T\u003e { static constexpr int i = 1; }; template \u003ctypename T\u003e struct A\u003cT, int\u003e { static constexpr int j = 2; }; template \u003ctypename T, typename U\u003e struct A\u003cT*, U*\u003e { static constexpr int k = 3; }; } // namespace jc using namespace jc; static_assert(A\u003cdouble, double\u003e::i == 1); static_assert(A\u003cdouble, int\u003e::j == 2); static_assert(A\u003cint*, double*\u003e::k == 3); int main() { // A\u003cint, int\u003e{}; // 错误，匹配 A\u003cT, T\u003e 和 A\u003cT, int\u003e // A\u003cint*, int*\u003e{}; // 错误，匹配 A\u003cT, T\u003e 和 A\u003cT*, U*\u003e } 如果多个特化中，有一个匹配程度最高，则不会有二义性错误 namespace jc { template \u003ctypename T, typename U\u003e struct A; template \u003ctypename T\u003e struct A\u003cT, T\u003e { static constexpr int i = 1; }; template \u003ctypename T\u003e struct A\u003cT, int\u003e { static constexpr int j = 2; }; template \u003ctypename T, typename U\u003e struct A\u003cT*, U*\u003e { static constexpr int k = 3; }; template \u003ctypename T\u003e struct A\u003cT*, T*\u003e { static constexpr int k = 4; }; } // namespace jc static_assert(jc::A\u003cdouble, double\u003e::i == 1); static_assert(jc::A\u003cdouble, int\u003e::j == 2); static_assert(jc::A\u003cint*, double*\u003e::k == 3); static_assert(jc::A\u003cdouble*, int*\u003e::k == 3); static_assert(jc::A\u003cint*, int*\u003e::k == 4); static_assert(jc::A\u003cdouble*, double*\u003e::k == 4); int main() {} 偏特化常用于元编程 #include \u003ctuple\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename Tuple\u003e struct is_among; template \u003ctypename T, template \u003ctypename...\u003e class Tuple, typename... List\u003e struct is_among\u003cT, Tuple\u003cList...\u003e\u003e : std::disjunction\u003cstd::is_same\u003cT, List\u003e...\u003e {}; template \u003ctypename T, typename Tuple\u003e inline constexpr bool is_among_v = is_among\u003cT, Tuple\u003e::value; } // namespace jc static_assert(jc::is_among_v\u003cint, std::tuple\u003cchar, int, double\u003e\u003e); static_assert(!jc::is_among_v\u003cfloat, std::tuple\u003cchar, int, double\u003e\u003e); int main() {} 偏特化遍历 std::tuple #include \u003ccstddef\u003e #include \u003ciostream\u003e #include \u003ctuple\u003e namespace jc { template \u003cstd::size_t Index, std::size_t N, typename... List\u003e struct PrintImpl { static void impl(const std::tuple\u003cList...\u003e\u0026 t) { std::cout \u003c\u003c std::get\u003cIndex\u003e(t) \u003c\u003c \" \"; PrintImpl\u003cIndex + 1, N, List...\u003e::impl(t); } }; template \u003cstd::size_t N, typename... List\u003e struct PrintImpl\u003cN, N, List...\u003e { static void impl(const std::tuple\u003cList...\u003e\u0026 t) {} }; template \u003ctypename... List\u003e void Print(const std::tuple\u003cList...\u003e\u0026 t) { PrintImpl\u003c0, sizeof...(List), List...\u003e::impl(t); } } // namespace jc int main() { auto t = std::make_tuple(3.14, 42, \"hello world\"); jc::Print(t); // 3.14 42 hello world } 成员模板也能特化或偏特化 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { struct A { template \u003ctypename T = std::string\u003e T as() const { return s; } std::string s; }; template \u003c\u003e inline bool A::as\u003cbool\u003e() const { return s == \"true\"; } } // namespace jc int main() { jc::A a{\"hello\"}; assert(a.as() == \"hello\"); assert(!a.as\u003cbool\u003e()); jc::A b{\"true\"}; assert(b.as\u003cbool\u003e()); } 成员函数模板不能为虚函数，因为虚函数表的大小是固定的，而成员函数模板的实例化个数要编译完成后才能确定 namespace jc { template \u003ctypename T\u003e class Dynamic { public: virtual ~Dynamic() {} // OK，每个 Dynamic\u003cT\u003e 对应一个析构函数 template \u003ctypename U\u003e virtual void f(const U\u0026) {} // 错误，编译器不知道一个 Dynamic\u003cT\u003e 中 f() 个数 }; } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:13:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#偏特化partial-specializationhttpsencppreferencecomwcpplanguagepartial_specialization"},{"categories":["编程语言"],"content":" 14 模板的模板参数（Template Template Parameter） 如果模板参数的类型是类模板，则需要使用模板的模板参数。对于模板的模板参数，C++11 之前只能用 class 关键字修饰，C++11 及其之后可以用别名模板的名称来替代，C++17 可以用 typename 修饰 #include \u003cset\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T, template \u003ctypename...\u003e class Container\u003e void f(const Container\u003cT\u003e\u0026) {} } // namespace jc int main() { jc::f(std::vector\u003cint\u003e{}); jc::f(std::vector\u003cdouble\u003e{}); jc::f(std::set\u003cint\u003e{}); } 实际上容器还有一个模板参数，即内存分配器 allocator #include \u003ccassert\u003e #include \u003cdeque\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T, template \u003ctypename Elem, typename = std::allocator\u003cElem\u003e\u003e class Container = std::deque\u003e class Stack { public: using reference = T\u0026; using const_reference = const T\u0026; template \u003ctypename, template \u003ctypename, typename\u003e class\u003e friend class Stack; template \u003ctypename U, template \u003ctypename Elem2, typename = std::allocator\u003cElem2\u003e\u003e class Container2\u003e Stack\u003cT, Container\u003e\u0026 operator=(const Stack\u003cU, Container2\u003e\u0026); void push(const T\u0026); void pop(); reference top(); const_reference top() const; std::size_t size() const; bool empty() const; private: Container\u003cT\u003e container_; }; template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e template \u003ctypename U, template \u003ctypename, typename\u003e class Container2\u003e inline Stack\u003cT, Container\u003e\u0026 Stack\u003cT, Container\u003e::operator=( const Stack\u003cU, Container2\u003e\u0026 rhs) { container_.assign(rhs.container_.begin(), rhs.container_.end()); return *this; } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline void Stack\u003cT, Container\u003e::push(const T\u0026 x) { container_.emplace_back(x); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline void Stack\u003cT, Container\u003e::pop() { assert(!empty()); container_.pop_back(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline typename Stack\u003cT, Container\u003e::reference Stack\u003cT, Container\u003e::top() { assert(!empty()); return container_.back(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline typename Stack\u003cT, Container\u003e::const_reference Stack\u003cT, Container\u003e::top() const { assert(!empty()); return container_.back(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline std::size_t Stack\u003cT, Container\u003e::size() const { return container_.size(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline bool Stack\u003cT, Container\u003e::empty() const { return container_.empty(); } } // namespace jc int main() { jc::Stack\u003cstd::string\u003e s; s.push(\"hello\"); s.push(\"world\"); assert(s.size() == 2); assert(s.top() == \"world\"); s.pop(); assert(s.size() == 1); assert(s.top() == \"hello\"); s.pop(); assert(s.empty()); } ","date":"2022-06-18","objectID":"/cxx_template/:14:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板的模板参数template-template-parameter"},{"categories":["编程语言"],"content":" 15 非类型模板参数（Non-type Template Parameter） 非类型模板参数表示在编译期或链接期可以确定的常量值 #include \u003cbitset\u003e #include \u003ccassert\u003e namespace jc { template \u003cbool IsSet = true, std::size_t N\u003e std::size_t find_next(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { for (std::size_t i = cur + 1; i \u003c N; ++i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } template \u003cbool IsSet = true, std::size_t N\u003e std::size_t find_prev(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { if (cur \u003e N) { cur = N; } for (int i = static_cast\u003cint\u003e(cur) - 1; i \u003e= 0; --i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } template \u003cbool IsSet = true, std::size_t N\u003e std::size_t circular_find_next(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { if (cur \u003e N) { cur = N; } std::size_t res = find_next\u003cIsSet\u003e(b, cur); if (res != N) { return res; } for (std::size_t i = 0; i \u003c cur; ++i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } template \u003cbool IsSet = true, std::size_t N\u003e std::size_t circular_find_prev(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { if constexpr (N == 0) { return N; } std::size_t res = find_prev\u003cIsSet\u003e(b, cur); if (res != N) { return res; } for (std::size_t i = N - 1; i \u003e cur; --i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } } // namespace jc void test_find_next() { std::bitset\u003c8\u003e b{\"10010111\"}; static constexpr int _next_set[] = {1, 2, 4, 4, 7, 7, 7, 8, 8, 8}; static constexpr int _next_unset[] = {3, 3, 3, 5, 5, 6, 8, 8, 8, 8}; for (std::size_t i = 0; i \u003c std::size(_next_set); ++i) { assert(jc::find_next\u003ctrue\u003e(b, i) == _next_set[i]); assert(jc::find_next\u003cfalse\u003e(b, i) == _next_unset[i]); } } void test_find_prev() { std::bitset\u003c8\u003e b{\"10010110\"}; static constexpr int _prev_set[] = {8, 8, 1, 2, 2, 4, 4, 4, 7, 7}; static constexpr int _prev_unset[] = {8, 0, 0, 0, 3, 3, 5, 6, 6, 6}; for (std::size_t i = 0; i \u003c std::size(_prev_set); ++i) { assert(jc::find_prev\u003ctrue\u003e(b, i) == _prev_set[i]); assert(jc::find_prev\u003cfalse\u003e(b, i) == _prev_unset[i]); } } void test_circular_find_next() { std::bitset\u003c8\u003e b{\"01010111\"}; static constexpr int _next_set[] = {1, 2, 4, 4, 6, 6, 0, 0, 0, 0}; static constexpr int _next_unset[] = {3, 3, 3, 5, 5, 7, 7, 3, 3, 3}; for (std::size_t i = 0; i \u003c std::size(_next_set); ++i) { assert(jc::circular_find_next\u003ctrue\u003e(b, i) == _next_set[i]); assert(jc::circular_find_next\u003cfalse\u003e(b, i) == _next_unset[i]); } } void test_circular_find_prev() { std::bitset\u003c8\u003e b{\"10011001\"}; static constexpr int _prev_set[] = {7, 0, 0, 0, 3, 4, 4, 4, 7, 7}; static constexpr int _prev_unset[] = {6, 6, 1, 2, 2, 2, 5, 6, 6, 6}; for (std::size_t i = 0; i \u003c std::size(_prev_set); ++i) { assert(jc::circular_find_prev\u003ctrue\u003e(b, i) == _prev_set[i]); assert(jc::circular_find_prev\u003cfalse\u003e(b, i) == _prev_unset[i]); } } int main() { test_find_next(); test_find_prev(); test_circular_find_next(); test_circular_find_prev(); } 模板参数可以由之前的参数推断类型，C++17 允许将非类型模板参数定义为 auto 或 decltype(auto) #include \u003ccassert\u003e namespace jc { template \u003ctypename\u003e struct get_class; template \u003ctypename ClassType, typename MemberType\u003e struct get_class\u003cMemberType ClassType::*\u003e { using type = ClassType; }; template \u003ctypename T\u003e using get_class_t = typename get_class\u003cT\u003e::type; template \u003cauto ClassMember\u003e class Wrapper { public: Wrapper(get_class_t\u003cdecltype(ClassMember)\u003e\u0026 obj) : obj_(obj) {} void increase() { ++(obj_.*ClassMember); } private: get_class_t\u003cdecltype(ClassMember)\u003e\u0026 obj_; }; struct A { int i = 0; }; } // namespace jc int main() { jc::A a; jc::Wrapper\u003c\u0026jc::A::i\u003e{a}.increase(); assert(a.i == 1); } C++14 允许 auto 作返回类型 namespace jc { template \u003ctypename T, typename U\u003e constexpr auto add(const T\u0026 a, const U\u0026 b) { return a + b; } } // namespace jc static_assert(jc::add('A', 2) == 'C'); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:15:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数non-type-template-parameterhttpsencppreferencecomwcpplanguagetemplate_parametersnon-type_template_parameter"},{"categories":["编程语言"],"content":" 16 限制 C++20 之前，非类型模板参数不能是浮点数 namespace jc { template \u003cauto N\u003e struct A { static constexpr auto f() { return N; } }; } // namespace jc static_assert(jc::A\u003c42\u003e::f() == 42); static_assert(jc::A\u003c3.14\u003e::f() == 3.14); // C++20 int main() {} 不能用字符串字面值常量、临时对象、数据成员或其他子对象作模板实参。C++ 标准演进过程中逐渐放宽了对字符数组作为模板实参的限制，C++11 仅允许外链接（external linkage，不定义于单一的文件作用域，链接到全局符号表），C++14 允许外链接或内链接（internal linkage，只能在单个文件内部看到，不能被其他文件访问，不暴露给链接器），C++17 不要求链接 namespace jc { template \u003cconst char* s\u003e struct A {}; } // namespace jc constexpr const char* s1 = \"hello\"; // 内链接对象的指针 extern const char s2[] = \"world\"; // 外链接 const char s3[] = \"down\"; // 内链接 int main() { static const char s4[] = \"demo\"; // 无链接 jc::A\u003c\"downdemo\"\u003e{}; // 错误 jc::A\u003cs1\u003e{}; // 错误 jc::A\u003cs2\u003e{}; // C++11 允许 jc::A\u003cs3\u003e{}; // C++14 允许 jc::A\u003cs4\u003e{}; // C++17 允许 } 非类型模板参数可以是左值引用，此时实参必须是静态常量 #include \u003ccassert\u003e namespace jc { template \u003cint\u0026 N\u003e struct A { A() { ++N; } ~A() { --N; } }; void test() { static int n = 0; { A\u003cn\u003e a; assert(n == 1); } assert(n == 0); } } // namespace jc int main() { jc::test(); } 函数和数组类型作为非类型模板参数会退化为指针类型 namespace jc { template \u003cint buf[5]\u003e struct Lexer {}; // template \u003cint* buf\u003e // struct Lexer {}; // 错误：重定义 template \u003cint fun()\u003e struct FuncWrap {}; // template \u003cint (*)()\u003e // struct FuncWrap {}; // 错误：重定义 } // namespace jc int main() {} 如果模板实参的表达式有大于号，必须用小括号包裹表达式，否则大于号会被编译器视为表示参数列表终止的右尖括号，导致编译错误 namespace jc { template \u003cbool b\u003e struct A { inline static constexpr bool value = b; }; } // namespace jc int main() { static_assert(jc::A\u003c(sizeof(int) \u003e 0)\u003e::value); } ","date":"2022-06-18","objectID":"/cxx_template/:16:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#限制"},{"categories":["编程语言"],"content":" 17 变量模板（Variable Template） C++14 提供了变量模板 namespace jc { template \u003ctypename T = double\u003e constexpr T pi{static_cast\u003cT\u003e(3.1415926535897932385)}; static_assert(pi\u003cbool\u003e == true); static_assert(pi\u003cint\u003e == 3); static_assert(pi\u003cdouble\u003e == 3.1415926535897932385); static_assert(pi\u003c\u003e == 3.1415926535897932385); } // namespace jc int main() {} 变量模板可以由非类型参数参数化 #include \u003carray\u003e #include \u003ccassert\u003e namespace jc { template \u003cint N\u003e std::array\u003cint, N\u003e arr{}; template \u003cauto N\u003e constexpr decltype(N) x = N; } // namespace jc static_assert(jc::x\u003c'c'\u003e == 'c'); int main() { jc::arr\u003c10\u003e[0] = 42; assert(jc::arr\u003c10\u003e[0] == 42); } ","date":"2022-06-18","objectID":"/cxx_template/:17:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变量模板variable-templatehttpsencppreferencecomwcpplanguagevariable_template"},{"categories":["编程语言"],"content":" 18 变参模板（Variadic Template） 如果函数要接受任意数量任意类型的参数，没有模板时可以通过 std::va_list 实现 #include \u003ccassert\u003e #include \u003ccstdarg\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003cstring\u003e namespace jc { void test(int n, ...) { std::va_list args; va_start(args, n); assert(va_arg(args, double) == 3.14); assert(va_arg(args, int) == 42); assert(std::strcmp(va_arg(args, const char*), \"hello\") == 0); assert(std::strcmp(va_arg(args, const char*), \"world\") == 0); va_end(args); } void test(const char* fmt, ...) { char buf[256]; std::va_list args; va_start(args, fmt); std::vsnprintf(buf, 256, fmt, args); va_end(args); assert(std::strcmp(buf, \"3.14 42 hello world\") == 0); } } // namespace jc int main() { jc::test(4, 3.14, 42, std::string{\"hello\"}.c_str(), \"world\"); jc::test(\"%.2f %d %s %s\", 3.14, 42, std::string{\"hello\"}.c_str(), \"world\"); } C++11 引入了变参模板，用省略号表示一个参数包，类型名后接省略号表示任意数量给定类型的参数。在表达式后跟省略号，如果表达式中有参数包，就会把表达式应用到参数包中的每个参数。如果表达式中出现两次参数包，对整个表达式扩展，而不会做笛卡尔积计算 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctuple\u003e #include \u003cutility\u003e namespace jc { void print() {} // 参数包展开到零参数时调用 template \u003ctypename T, typename... Args\u003e void print(const T\u0026 t, Args\u0026\u0026... args) { std::cout \u003c\u003c t \u003c\u003c \",\"; print(std::forward\u003cArgs\u003e(args)...); } template \u003cint... Index\u003e struct A {}; template \u003ctypename... List, int... Index\u003e void test1(const std::tuple\u003cList...\u003e\u0026 t, A\u003cIndex...\u003e) { print(std::get\u003cIndex\u003e(t)...); // print(std::get\u003c2\u003e(t), std::get\u003c3\u003e(t)); } template \u003ctypename... List, int... Index\u003e void test2(const std::tuple\u003cList...\u003e\u0026 t, A\u003cIndex...\u003e) { print((std::get\u003cIndex\u003e(t) + std::get\u003cIndex\u003e(t))...); } } // namespace jc int main() { auto t = std::make_tuple(3.14, 42, std::string{\"hello\"}, \"world\"); jc::test1(t, jc::A\u003c2, 3\u003e{}); // hello,world jc::test2(t, jc::A\u003c0, 1, 2\u003e{}); // 6.28,84,hellohello, } 注意参数包的省略号不能直接接在数值字面值后 template \u003ctypename... Args\u003e void f(const Args\u0026... args) { print(args + 1...); // ERROR：1... 是带多个小数点的字面值，不合法 print(args + 1 ...); // OK print((args + 1)...); // OK } 可以直接用逗号运算符做参数包扩展，逗号左侧是对参数包每个元素做的操作，右侧是一个无关紧要的值，这样展开后对每个元素都做了操作，并形成了一个以无关值为元素的数组，这个数组无作用，只是为了满足扩展时省略号不能为表达式最后的 token 而引入 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename... Args\u003e void print(Args\u0026\u0026... args) { auto a = {(std::cout \u003c\u003c std::forward\u003cArgs\u003e(args) \u003c\u003c std::endl, 0)...}; } } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } C++11 引入了 sizeof… 在编译期计算参数包中的元素数，C++17 引入了 if constexpr 判断编译期值，编译期结果为 true 才会实例化代码 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T, typename... Args\u003e void print(const T\u0026 t, Args\u0026\u0026... args) { std::cout \u003c\u003c t \u003c\u003c std::endl; if constexpr (sizeof...(args) \u003e 0) { // 不能用 if，因为零长包也会实例化代码 print(std::forward\u003cArgs\u003e(args)...); // 当条件满足时才实例化 } } } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } 在 C++11 中可以利用偏特化来达到 if constexpr 的效果 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { template \u003cbool b\u003e struct A; template \u003ctypename T, typename... Args\u003e void print(const T\u0026 t, Args\u0026\u0026... args) { std::cout \u003c\u003c t \u003c\u003c std::endl; A\u003c(sizeof...(args) \u003e 0)\u003e::f(std::forward\u003cArgs\u003e(args)...); } template \u003cbool b\u003e struct A { template \u003ctypename... Args\u003e static void f(Args\u0026\u0026... args) { print(std::forward\u003cArgs\u003e(args)...); } }; template \u003c\u003e struct A\u003cfalse\u003e { static void f(...) {} }; } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } ","date":"2022-06-18","objectID":"/cxx_template/:18:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板variadic-template"},{"categories":["编程语言"],"content":" 19 折叠表达式（Fold Expression） C++17 引入了折叠表达式，用于获取对所有参数包实参使用二元运算符的计算结果 #include \u003ciostream\u003e #include \u003ctuple\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename... Args\u003e auto sum(Args\u0026\u0026... args) { auto a = (... + std::forward\u003cArgs\u003e(args)); // (((1 + 2) + 3) + 4) auto b = (std::forward\u003cArgs\u003e(args) + ...); // (1 + (2 + (3 + 4))) auto c = (5 + ... + std::forward\u003cArgs\u003e(args)); // ((((5 + 1) + 2) + 3) + 4) auto d = (std::forward\u003cArgs\u003e(args) + ... + 5); // (1 + (2 + (3 + (4 + 5)))) return std::make_tuple(a, b, c, d); } auto print1 = [](auto\u0026\u0026... args) { // operator\u003c\u003c 左折叠，std::cout 是初始值 (std::cout \u003c\u003c ... \u003c\u003c std::forward\u003cdecltype(args)\u003e(args)); }; auto print2 = [](auto\u0026\u0026... args) { // operator, 左折叠 ((std::cout \u003c\u003c std::forward\u003cdecltype(args)\u003e(args) \u003c\u003c \",\"), ...); }; } // namespace jc int main() { auto [a, b, c, d] = jc::sum(1, 2, 3, 4); jc::print1(a, b, c, d); // 10101515 jc::print2(a, b, c, d); // 10,10,15,15, } 对于空扩展需要决定类型和值，空的一元折叠表达式通常会产生错误，除了三种例外情况 一个 \u0026\u0026 的一元折叠的空扩展产生值 true 一个 || 的一元折叠的空扩展产生值 false 一个 , 的一元折叠空扩展产生一个 void 表达式 折叠表达式 计算结果 (… op pack) (((pack1 op pack2) op pack3) … op PackN) (pack op …) (pack1 op (… (packN-1 op packN))) (init op … op pack) (((init op pack1) op pack2) … op PackN) (pack op … op init) (pack1 op (… (packN op init))) 折叠表达式借鉴的是 Haskell 的 fold import Data.List (foldl') foldlList :: [Char] foldlList = foldl' (\\x y -\u003e concat [\"(\", x, \"+\", y, \")\"]) \"0\" (map show [1 .. 4]) foldrList :: [Char] foldrList = foldr ((\\x y -\u003e concat [\"(\", x, \"+\", y, \")\"]) . show) \"0\" [1 .. 4] main :: IO () main = do putStrLn foldlList -- ((((0+1)+2)+3)+4) putStrLn foldrList -- (1+(2+(3+(4+0)))) 实现与 Haskell 类似的左折叠和右折叠 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename F, typename T, typename... Args\u003e void foldlList(F\u0026\u0026 f, T\u0026\u0026 zero, Args\u0026\u0026... x) { ((std::invoke(std::forward\u003cF\u003e(f), (std::string(sizeof...(Args), '('))), std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cT\u003e(zero)))), ..., (std::invoke(std::forward\u003cF\u003e(f), ('+')), std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cArgs\u003e(x))), std::invoke(std::forward\u003cF\u003e(f), (')')))); } template \u003ctypename F, typename T, typename... Args\u003e void foldrList(F\u0026\u0026 f, T\u0026\u0026 zero, Args\u0026\u0026... x) { ((std::invoke(std::forward\u003cF\u003e(f), ('(')), std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cArgs\u003e(x))), std::invoke(std::forward\u003cF\u003e(f), ('+'))), ..., (std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cT\u003e(zero))), std::invoke(std::forward\u003cF\u003e(f), (std::string(sizeof...(Args), ')'))))); } } // namespace jc int main() { auto print = [](const auto\u0026 x) { std::cout \u003c\u003c x; }; jc::foldlList(print, 0, 1, 2, 3, 4); // ((((0+1)+2)+3)+4) jc::foldrList(print, 0, 1, 2, 3, 4); // (1+(2+(3+(4+0)))) } 折叠表达式几乎可以使用所有二元运算符 #include \u003ccassert\u003e namespace jc { struct Node { Node(int i) : val(i) {} int val = 0; Node* left = nullptr; Node* right = nullptr; }; // 使用 operator-\u003e* 的折叠表达式，用于遍历指定的二叉树路径 template \u003ctypename T, typename... Args\u003e Node* traverse(T root, Args... paths) { return (root-\u003e*...-\u003e*paths); // root -\u003e* paths1 -\u003e* paths2 ... } void test() { Node* root = new Node{0}; root-\u003eleft = new Node{1}; root-\u003eleft-\u003eright = new Node{2}; root-\u003eleft-\u003eright-\u003eleft = new Node{3}; auto left = \u0026Node::left; auto right = \u0026Node::right; Node* node1 = traverse(root, left); assert(node1-\u003eval == 1); Node* node2 = traverse(root, left, right); assert(node2-\u003eval == 2); Node* node3 = traverse(node2, left); assert(node3-\u003eval == 3); } } // namespace jc int main() { jc::test(); } 包扩展可以用于编译期表达式 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename... Args\u003e constexpr bool is_homogeneous(T, Args...) { return (std::is_same_v\u003cT, Args\u003e \u0026\u0026 ...); // operator\u0026\u0026 的折叠表达式 } } // namespace jc static_assert(!jc::is_homogeneous(3.14, 42, \"hello\", \"world\")); static_assert(jc::is_homogeneous(\"hello\", \"\", \"world\")); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:19:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#折叠表达式fold-expressionhttpsencppreferencecomwcpplanguagefold"},{"categories":["编程语言"],"content":" 20 变参模板的应用 无需指定类型，自动获取 std::variant 值 #include \u003carray\u003e #include \u003ccassert\u003e #include \u003cfunctional\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cvariant\u003e namespace jc { template \u003ctypename F, std::size_t... N\u003e constexpr auto make_array_impl(F f, std::index_sequence\u003cN...\u003e) -\u003e std::array\u003cstd::invoke_result_t\u003cF, std::size_t\u003e, sizeof...(N)\u003e { return {std::invoke(f, std::integral_constant\u003cdecltype(N), N\u003e{})...}; } template \u003cstd::size_t N, typename F\u003e constexpr auto make_array(F f) -\u003e std::array\u003cstd::invoke_result_t\u003cF, std::size_t\u003e, N\u003e { return make_array_impl(f, std::make_index_sequence\u003cN\u003e{}); } template \u003ctypename T, typename Dst, typename... List\u003e bool get_value_impl(const std::variant\u003cList...\u003e\u0026 v, Dst\u0026 dst) { if (std::holds_alternative\u003cT\u003e(v)) { if constexpr (std::is_convertible_v\u003cT, Dst\u003e) { dst = static_cast\u003cDst\u003e(std::get\u003cT\u003e(v)); return true; } } return false; } template \u003ctypename Dst, typename... List\u003e bool get_value(const std::variant\u003cList...\u003e\u0026 v, Dst\u0026 dst) { using Variant = std::variant\u003cList...\u003e; using F = std::function\u003cbool(const Variant\u0026, Dst\u0026)\u003e; static auto _list = make_array\u003csizeof...(List)\u003e([](auto i) -\u003e F { return \u0026get_value_impl\u003cstd::variant_alternative_t\u003ci, Variant\u003e, Dst, List...\u003e; }); return std::invoke(_list[v.index()], v, dst); } } // namespace jc int main() { std::variant\u003cint, std::string\u003e v = std::string{\"test\"}; std::string s; assert(jc::get_value(v, s)); assert(s == \"test\"); v = 42; int i; assert(jc::get_value(v, i)); assert(i == 42); } 字节序转换 // https://en.cppreference.com/w/cpp/language/fold #include \u003ccstdint\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T, size_t... N\u003e constexpr T bswap_impl(T t, std::index_sequence\u003cN...\u003e) { return (((t \u003e\u003e N * 8 \u0026 0xFF) \u003c\u003c (sizeof(T) - 1 - N) * 8) | ...); } template \u003ctypename T, typename U = std::make_unsigned_t\u003cT\u003e\u003e constexpr U bswap(T t) { return bswap_impl\u003cU\u003e(t, std::make_index_sequence\u003csizeof(T)\u003e{}); } } // namespace jc static_assert(jc::bswap\u003cstd::uint32_t\u003e(0x12345678u) == 0x78563412u); static_assert((0x12345678u \u003e\u003e 0) == 0x12345678u); static_assert((0x12345678u \u003e\u003e 8) == 0x00123456u); static_assert((0x12345678u \u003e\u003e 16) == 0x00001234u); static_assert((0x12345678u \u003e\u003e 24) == 0x00000012u); static_assert(jc::bswap\u003cstd::uint16_t\u003e(0x1234u) == 0x3412u); int main() {} 自定义字面值（User-defined literals） #include \u003calgorithm\u003e #include \u003carray\u003e #include \u003ccassert\u003e #include \u003cfunctional\u003e #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003cstring\u003e namespace jc { template \u003cchar... args\u003e std::string operator\"\" _dbg() { std::array\u003cchar, sizeof...(args)\u003e v{args...}; std::stringstream os; for (const auto\u0026 x : v) { os \u003c\u003c x; }; #ifndef NDEBUG std::cout \u003c\u003c os.str() \u003c\u003c std::endl; #endif return os.str(); } std::string operator\"\" _encrypt(const char* c, size_t) { std::string s{c}; std::string p{R\"(passwd: \")\"}; auto it = std::search(s.begin(), s.end(), std::boyer_moore_horspool_searcher{p.begin(), p.end()}); if (it != s.end()) { it += p.size(); while (it != s.end() \u0026\u0026 *it != '\\\"') { *it++ = '*'; } } #if !defined(NDEBUG) std::cout \u003c\u003c s \u003c\u003c std::endl; #endif return s; } } // namespace jc int main() { using namespace jc; assert(12.34_dbg == \"12.34\"); std::string s = R\"JSON({ data_dir: \"C:\\Users\\downdemo\\.data\\*.txt\", user: \"downdemo(accelerate rapidly)\", passwd: \"123456\" })JSON\"_encrypt; std::string s2 = R\"JSON({ data_dir: \"C:\\Users\\downdemo\\.data\\*.txt\", user: \"downdemo(accelerate rapidly)\", passwd: \"******\" })JSON\"; assert(s == s2); } 变参基类 #include \u003cstring\u003e #include \u003cunordered_set\u003e namespace jc { struct A { std::string s; }; struct A_EQ { bool operator()(const A\u0026 lhs, const A\u0026 rhs) const { return lhs.s == rhs.s; } }; struct A_Hash { std::size_t operator()(const A\u0026 a) const { return std::hash\u003cstd::string\u003e{}(a.s); } }; // 定义一个组合所有基类的 operator() 的派生类 template \u003ctypename... Bases\u003e struct Overloader : Bases... { using Bases::operator()...; // C++17 }; using A_OP = Overloader\u003cA_Hash, A_EQ\u003e; } // namespace jc int main() { // 将 A_EQ 和 A_Hash 组合到一个类型中 /* unordered_set 的声明 template\u003c class K","date":"2022-06-18","objectID":"/cxx_template/:20:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板的应用"},{"categories":["编程语言"],"content":" 21 移动语义（Move Semantics） C++11 的值类别包括左值（lvalue）、纯右值（prvalue）、亡值（xvalue），左值和亡值组成了泛左值（glvalue），纯右值和亡值组成了右值（rvalue）。为了让编译器识别接受右值作为参数的构造函数，则需要引入右值引用符号（\u0026\u0026），以区分移动构造函数和拷贝构造函数 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003cutility\u003e #include \u003cvector\u003e namespace jc { struct A { A() : data(new std::string) {} A(const A\u0026 rhs) : data(new std::string{*rhs.data}) {} A(A\u0026\u0026 rhs) noexcept : data(rhs.data) { rhs.data = nullptr; } ~A() { delete data; } std::string* data = nullptr; }; } // namespace jc int main() { std::vector\u003cjc::A\u003e v; v.emplace_back(jc::A{}); // 调用默认构造函数、移动构造函数、析构函数 jc::A a; v.emplace_back(a); // 调用拷贝构造函数 assert(a.data); v.emplace_back(std::move(a)); // 调用移动构造函数 assert(!a.data); } 右值引用即只能绑定到右值的引用，字面值（纯右值）和临时变量（亡值）就是常见的右值。如果把左值传递给右值引动参数，则需要强制类型转换，std::move 就是不需要显式指定类型的到右值引用的强制类型转换 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T\u003e constexpr std::remove_reference_t\u003cT\u003e\u0026\u0026 move(T\u0026\u0026 x) noexcept { return static_cast\u003cstd::remove_reference_t\u003cT\u003e\u0026\u0026\u003e(x); } constexpr int f(const std::string\u0026) { return 1; } constexpr int f(std::string\u0026\u0026) { return 2; } } // namespace jc int main() { std::string s; static_assert(jc::f(s) == 1); assert(jc::f(std::string{}) == 2); static_assert(jc::f(static_cast\u003cstd::string\u0026\u0026\u003e(s)) == 2); static_assert(jc::f(jc::move(s)) == 2); static_assert(jc::f(std::move(s)) == 2); } ","date":"2022-06-18","objectID":"/cxx_template/:21:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#移动语义move-semantics"},{"categories":["编程语言"],"content":" 22 完美转发（Perfect Forwarding） 右值引用是能接受右值的引用，引用可以取址，是左值，因此右值引用是左值。如果一个函数接受右值引用参数，把参数传递给其他函数时，会按左值传递，这样就丢失了原有的值类别 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { constexpr int f(const std::string\u0026) { return 1; } constexpr int f(std::string\u0026\u0026) { return 2; } constexpr int g(std::string\u0026\u0026 s) { return f(s); } void test() { std::string s; assert(f(std::string{}) == 2); assert(g(std::string{}) == 1); static_assert(f(std::move(s)) == 2); static_assert(g(std::move(s)) == 1); } } // namespace jc int main() { jc::test(); } 为了转发时保持值类别不丢失，需要手写多个重载版本 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { constexpr int f(std::string\u0026) { return 1; } constexpr int f(const std::string\u0026) { return 2; } constexpr int f(std::string\u0026\u0026) { return 3; } constexpr int g(std::string\u0026 s) { return f(s); } constexpr int g(const std::string\u0026 s) { return f(s); } constexpr int g(std::string\u0026\u0026 s) { return f(std::move(s)); } void test() { std::string s; const std::string\u0026 s2 = s; static_assert(g(s) == 1); assert(g(s2) == 2); static_assert(g(std::move(s)) == 3); assert(g(std::string{}) == 3); } } // namespace jc int main() { jc::test(); } 模板参数中右值引用符号表示的是万能引用（universal reference），因为模板参数本身可以推断为引用，它可以匹配几乎任何类型（少部分特殊类型无法匹配，如位域），传入左值时推断为左值引用类型，传入右值时推断为右值引用类型。对万能引用参数使用 std::forward 则可以保持值类别不丢失，这种保留值类别的转发手法就叫完美转发，因此万能引用也叫转发引用（forwarding reference） #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e constexpr T\u0026\u0026 forward(std::remove_reference_t\u003cT\u003e\u0026 t) noexcept { return static_cast\u003cT\u0026\u0026\u003e(t); } constexpr int f(std::string\u0026) { return 1; } constexpr int f(const std::string\u0026) { return 2; } constexpr int f(std::string\u0026\u0026) { return 3; } template \u003ctypename T\u003e constexpr int g(T\u0026\u0026 s) { return f(jc::forward\u003cT\u003e(s)); // 等价于 std::forward } void test() { std::string s; const std::string\u0026 s2 = s; static_assert(g(s) == 1); // T = T\u0026\u0026 = std::string\u0026 assert(g(s2) == 2); // T = T\u0026\u0026 = const std::string\u0026 static_assert(g(std::move(s)) == 3); // T = std::string, T\u0026\u0026 = std::string\u0026\u0026 assert(g(std::string{}) == 3); // T = T\u0026\u0026 = std::string\u0026 assert(g(\"downdemo\") == 3); // T = T\u0026\u0026 = const char (\u0026)[9] } } // namespace jc int main() { jc::test(); } 结合变参模板完美转发转发任意数量的实参 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename F, typename... Args\u003e constexpr void constexpr_for(F\u0026\u0026 f, Args\u0026\u0026... args) { (std::invoke(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)), ...); } template \u003ctypename... Args\u003e void print(Args\u0026\u0026... args) { constexpr_for([](const auto\u0026 x) { std::cout \u003c\u003c x \u003c\u003c std::endl; }, std::forward\u003cArgs\u003e(args)...); } } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } Lambda 中使用完美转发需要借助 decltype 推断类型 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { constexpr auto constexpr_for = [](auto\u0026\u0026 f, auto\u0026\u0026... args) { (std::invoke(std::forward\u003cdecltype(f)\u003e(f), std::forward\u003cdecltype(args)\u003e(args)), ...); }; auto print = [](auto\u0026\u0026... args) { constexpr_for([](const auto\u0026 x) { std::cout \u003c\u003c x \u003c\u003c std::endl; }, std::forward\u003cdecltype(args)\u003e(args)...); }; } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } C++20 可以为 lambda 指定模板参数 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { constexpr auto constexpr_for = []\u003ctypename F, typename... Args\u003e(F\u0026\u0026 f, Args\u0026\u0026... args) { (std::invoke(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)), ...); }; auto print = []\u003ctypename... Args\u003e(Args\u0026\u0026 ... args) { constexpr_for([](const auto\u0026 x) { std::cout \u003c\u003c x \u003c\u003c std::endl; }, std::forward\u003cArgs\u003e(args)...); }; } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } C++20 的 lambda 可以捕获参数包 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename... Args\u003e void print(Args\u0026\u0026... args) { [... args = std::forward\u003cArgs\u003e(args)]\u003ctypename F\u003e(F\u0026\u0026 f) { (std::invoke(std::forward\u003cF\u003e(f), args),","date":"2022-06-18","objectID":"/cxx_template/:22:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#完美转发perfect-forwarding"},{"categories":["编程语言"],"content":" 23 构造函数模板 模板也能用于构造函数，但它不是真正的构造函数，从函数模板实例化而来的函数不和普通函数等价，由成员函数模板实例化的函数不会重写虚函数，由构造函数模板实例化的构造函数不是拷贝或移动构造函数，但对一个 non-const 对象调用构造函数时，万能引用是更优先的匹配 #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { struct A { template \u003ctypename T\u003e explicit A(T\u0026\u0026 t) : s(std::forward\u003cT\u003e(t)) {} A(const A\u0026 rhs) : s(rhs.s) {} A(A\u0026\u0026 rhs) noexcept : s(std::move(rhs.s)) {} std::string s; }; } // namespace jc int main() { const jc::A a{\"downdemo\"}; jc::A b{a}; // OK，匹配拷贝构造函数 // jc::A c{b}; // 错误，匹配模板构造函数 } 为此可以用 std::enable_if 约束模板参数，在条件满足的情况下才会匹配模板 #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { struct A { template \u003ctypename T, // 要求 T 能转为 std::string typename = std::enable_if_t\u003cstd::is_convertible_v\u003cT, std::string\u003e\u003e\u003e explicit A(T\u0026\u0026 t) : s(std::forward\u003cT\u003e(t)) {} A(const A\u0026 rhs) : s(rhs.s) {} A(A\u0026\u0026 rhs) noexcept : s(std::move(rhs.s)) {} std::string s; }; } // namespace jc int main() { const jc::A a{\"downdemo\"}; jc::A b{a}; // OK，匹配拷贝构造函数 jc::A c{b}; // OK，匹配拷贝构造函数 } C++20 可以用 concepts 约束模板参数 #include \u003cconcepts\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { struct A { template \u003ctypename T\u003e requires std::convertible_to\u003cT, std::string\u003e explicit A(T\u0026\u0026 t) : s(std::forward\u003cT\u003e(t)) {} A(const A\u0026 rhs) : s(rhs.s) {} A(A\u0026\u0026 rhs) noexcept : s(std::move(rhs.s)) {} std::string s; }; } // namespace jc int main() { const jc::A a{\"downdemo\"}; jc::A b{a}; // OK，匹配拷贝构造函数 jc::A c{b}; // OK，匹配拷贝构造函数 } ","date":"2022-06-18","objectID":"/cxx_template/:23:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#构造函数模板"},{"categories":["编程语言"],"content":" 24 ADL（Argument-Dependent Lookup，Koenig Lookup） Name lookup 是当程序中出现一个名称时，将其与引入它的声明联系起来的过程，它分为 qualified name lookup 和 unqualified name lookup，unqualified name lookup 对于函数名查找会使用 ADL namespace jc { struct A {}; struct B {}; void f1(int) {} void f2(A) {} } // namespace jc namespace jd { void f1(int i) { f1(i); // 调用 jd::f1()，造成无限递归 } void f2(jc::A t) { f2(t); // 通过 t 的类型 jc::A 看到 jc，通过 jc 看到 jc::f2() // 因为 jd::f2() 也可见，此处产生二义性调用错误 } void f3(jc::B t) { f3(t); // 通过 t 的类型 jc::B 看到 jc，但 jc 中无 jc::f3() // 此处调用 jd::f3()，造成无限递归 } } // namespace jd int main() {} Qualified name lookup 即对使用了作用域运算符的名称做查找，查找在受限的作用域内进行 namespace jc { int x; struct Base { int i; }; struct Derived : Base {}; void f(Derived* p) { p-\u003ei = 0; // 找到 Base::i Derived::x = 0; // 错误：在受限作用域中找不到 ::x } } // namespace jc int main() {} Unqualified name lookup 即对不指定作用域的名称做查找，先查找当前作用域，若找不到再继续查找外围作用域 namespace jc { extern int x; // 1 int f(int x) { // 2 if (x \u003c 0) { int x = 1; // 3 f(x); // 使用 3 } return x + ::x; // 分别使用 2、1 } } // namespace jc int main() {} ADL 即实参依赖查找，对于一个类，其成员函数与使用了它的非成员函数，都是该类的逻辑组成部分，如果函数接受一个类作为参数，编译器查找函数名时，不仅会查找局部作用域，还会查找类所在的命名空间 #include \u003ciostream\u003e #include \u003cstring\u003e namespace jc { struct A {}; void f(const A\u0026) {} // f() 是 A 的逻辑组成部分 } // namespace jc jc::A a; int main() { f(a); // 通过 ADL 找到 jc::f()，如果没有 ADL，就要写成 jc::f(a) std::string s; std::cout \u003c\u003c s; // std::operator\u003c\u003c() 是 std::string 的逻辑组成部分 // 如果没有 ADL，就要写成 std::operator\u003c\u003c(std::cout, s) } ADL 是通过实参查找，对于函数模板，查找前无法先得知其为函数，也就无法确定实参，因此不会使用 ADL namespace jc { class A {}; template \u003ctypename\u003e void f(A*) {} } // namespace jc void g(jc::A* p) { f\u003cint\u003e(p); // 错误，不知道 f\u003cint\u003e 是函数，所以不知道 p 是实参，不会用 ADL } int main() {} ADL 会忽略 using 声明 namespace jc { template \u003ctypename T\u003e constexpr int f(T) { return 1; } } // namespace jc namespace jd { using namespace jc; // 忽略 using 声明，不会调用 jc::f enum Color { red }; constexpr int f(Color) { return 2; } } // namespace jd constexpr int f(int) { return 3; } static_assert(::f(jd::red) == 3); // 受限的函数名称，不使用 ADL static_assert(f(jd::red) == 2); // 使用 ADL 找到 jd::f() int main() {} ADL 会查找实参关联的命名空间和类，关联的命名空间和类组成的集合定义如下 内置类型：集合为空 指针和数组类型：所引用类型关联的命名空间和类 枚举类型：关联枚举声明所在的命名空间 类成员：关联成员所在的类 类类型：关联的类包括该类本身、外围类型、直接和间接基类，关联的命名空间为每个关联类所在的命名空间，如果类是一个类模板实例则还包含模板实参本身类型、模板的模板实参所在的类和命名空间 函数类型：所有参数和返回类型关联的命名空间和类 类成员指针类型：成员和类关联的命名空间和类 友元声明在外围作用域不可见，因为如果可见的话，实例化类模板会使普通函数的声明可见，如果没有先实例化类就调用函数，将导致编译错误，但如果友元函数所在类属于 ADL 的关联类集合，则在外围作用域可以找到该友元声明，且调用时，未实例化的类会被实例化 namespace jc { template \u003ctypename T\u003e class A { friend void f() {} friend void f(A\u003cT\u003e) {} }; void g(const A\u003cint\u003e\u0026 a) { f(); // f() 无参数，不能使用 ADL，不可见 f(a); // f(A\u003cint\u003e) 关联类 A\u003cint\u003e 所以可见，若类 A\u003cint\u003e 未实例化则调用时实例化 } } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:24:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#adlargument-dependent-lookupkoenig-lookuphttpsencppreferencecomwcpplanguageadl"},{"categories":["编程语言"],"content":" 25 注入类名（Injected Class Name） 为了便于查找，在类作用域中，类名称是自身类型的 public 别名，该名称称为注入类名 namespace jc { int A; struct A { void f() { A* p; // OK：A 是注入类名 ::A* q; // 错误：查找到变量名 A，隐藏了 struct A 的名称 } }; } // namespace jc int main() {} 类模板的注入类名可以被用作模板名或类型名 namespace jc { template \u003ctemplate \u003ctypename\u003e class\u003e struct A {}; template \u003ctypename T\u003e struct B { B* a; // B 被当作类型名，等价于 B\u003cT\u003e B\u003cvoid\u003e* b; // B 被当作模板名 using c = A\u003cB\u003e; // B 被当作模板名 A\u003cjc::B\u003e d; // jc::B 不是注入类名，总会被当作模板名 }; } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:25:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#注入类名injected-class-namehttpsencppreferencecomwcpplanguageinjected-class-name"},{"categories":["编程语言"],"content":" 26 非模板中的上下文相关性 解析理论主要面向上下文无关语言，而 C++ 是上下文相关语言，为了解决这个问题，编译器使用一张符号表结合扫描器和解析器 解析某个声明时会把它添加到表中，扫描器找到一个标识符时，会在符号表中查找，如果发现该符号是一个类型就会注释这个标记，如编译器看见 x*，扫描器会查找 x，如果发现 x 是一个类型，解析器会看到标记如下，认为表达式是一个声明 identifier, type, x symbol, * 如果 x 不是类型，则解析器从扫描器获得标记如下，表达式被视为一个乘积 identifier, nontype, x symbol, * 对于 A\u003c1\u003e(0)，如果 A 是类模板，则表达式是把 0 转换成 A\u003c1\u003e 类型。如果不是类模板，表达式等价于 (A\u003c1)\u003e0，计算表达式 A 小于 1 的结果，再将结果与 0 比较大小。因此解析器先查找 \u003c 前的名称，如果名称是模板才会把 \u003c 看作左尖括号，其他情况则看作小于号 namespace jc { template \u003cbool B\u003e struct A { static const bool value = B; }; static_assert(A\u003c(1 \u003e 0)\u003e::value); // 必须使用小括号 } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:26:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非模板中的上下文相关性"},{"categories":["编程语言"],"content":" 27 Dependent name","date":"2022-06-18","objectID":"/cxx_template/:27:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#dependent-namehttpsencppreferencecomwcpplanguagedependent_name"},{"categories":["编程语言"],"content":" 27.1 当前实例化（current instantiation）和未知特化（unknown specialization） Name lookup 对 dependent name 与 non-dependent name 有不同的查找规则，在模板定义中，依赖于模板参数的名称称为 dependent name，dependent name 包含当前实例化和未知特化。类模板的注入类名属于当前实例化，依赖于模板参数但不是当前实例化的为未知特化（unknown specialization） namespace jc { template \u003ctypename T\u003e struct A { using type = T; A* a; // A 是当前实例化 A\u003ctype\u003e* b; // A\u003ctype\u003e 是当前实例化 A\u003cT*\u003e* c; // A\u003cT*\u003e 是未知特化 struct B { A* a; // A 是当前实例化 A\u003ctype\u003e* b; // A\u003ctype\u003e 是当前实例化 B* c; // B 是当前实例化 }; struct C { A* a; // A 是当前实例化 A\u003ctype\u003e* b; // A\u003ctype\u003e 是当前实例化 B* c; // 不在 B 的作用域内，B 是未知特化 C* d; // C 是当前实例化 }; }; template \u003c\u003e struct A\u003cint\u003e::B { int i; }; } // namespace jc int main() { jc::A\u003cdouble\u003e::C{}.c-\u003ea; jc::A\u003cint\u003e::C{}.c-\u003ei; // 使用特化的 A\u003cint\u003e::B } ","date":"2022-06-18","objectID":"/cxx_template/:27:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#当前实例化current-instantiation和未知特化unknown-specialization"},{"categories":["编程语言"],"content":" 27.2 typename 消歧义符 模板名称的问题主要是不能有效确定名称，模板中不能引用其他模板的名称，因为其他模板可能有使原名称失效的特化 namespace jc { template \u003ctypename T\u003e struct A { static constexpr int x = 0; // x 是值 }; template \u003ctypename T\u003e struct B { int y; void f() { A\u003cT\u003e::x* y; // 默认被看作乘法表达式 } }; template \u003c\u003e struct A\u003cint\u003e { using x = int; // x 是类型 }; } // namespace jc int main() { jc::B\u003cint\u003e{}.f(); // A\u003cint\u003e::x* y 是声明，int* y jc::B\u003cvoid\u003e{}.f(); // A\u003cvoid\u003e::x* y 是乘法，0 * y } Dependent name 默认不会被看作类型，如果要表明是类型则需要加上 typename 消歧义符 namespace jc { template \u003ctypename T\u003e struct A { static constexpr int x = 0; // x 是值 }; template \u003ctypename T\u003e struct B { int y; void f() { typename A\u003cT\u003e::x* y; // 默认被看作声明 } }; template \u003c\u003e struct A\u003cint\u003e { using x = int; // x 是类型 }; } // namespace jc int main() { jc::B\u003cint\u003e{}.f(); // A\u003cint\u003e::x* y 是声明，int* y jc::B\u003cvoid\u003e{}.f(); // A\u003cvoid\u003e::x* y 是乘法，0 * y } typename 消歧义符只能用于不在基类列表和初始化列表中的 dependent name，用作用域运算符访问 dependent name 中的成员类型时，必须指定 typename 消歧义符 namespace jc { struct Base { int i; }; template \u003ctypename T\u003e struct A { using type = T; }; template \u003ctypename T\u003e struct Derived : A\u003cT\u003e::type { // 基类列表中不能加 typename 消歧义符 Derived() : A\u003cT\u003e::type // 初始化列表中不能加 typename 消歧义符 (typename A\u003cT\u003e::type{0}) // 必须加 typename 消歧义符 {} A\u003cT\u003e f() { typename A\u003cT\u003e::type* p; // 必须加 typename 消歧义符 return {}; } A\u003cint\u003e::type* s; // non-dependent name，typename 消歧义符可有可无 }; } // namespace jc int main() { jc::Derived\u003cjc::Base\u003e{}.f(); } ","date":"2022-06-18","objectID":"/cxx_template/:27:2","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#typename-消歧义符"},{"categories":["编程语言"],"content":" 27.3 template 消歧义符 访问模板参数的 dependent name 时，要在 dependent name 前加 template 消歧义符，才能让编译器知道引用的是一个模板，否则 \u003c 会被视为小于号 namespace jc { template \u003ctypename T\u003e struct A { template \u003ctypename U\u003e struct Impl { template \u003ctypename Y\u003e static void f() {} }; template \u003ctypename U\u003e static void f() {} }; } // namespace jc template \u003ctypename T\u003e void test() { T::template Impl\u003cT\u003e::template f\u003cT\u003e(); T::template f\u003cT\u003e(); } int main() { test\u003cjc::A\u003cint\u003e\u003e(); } ","date":"2022-06-18","objectID":"/cxx_template/:27:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#template-消歧义符"},{"categories":["编程语言"],"content":" 28 Non-dependent base Non-dependent base 是不用知道模板实参就可以推断类型的基类，派生类中查找 non-dependent name 时会先查找 non-dependent base，再查找模板参数列表 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename\u003e struct Base { using T = char; }; template \u003ctypename T\u003e struct Derived1 : Base\u003cvoid\u003e { // non-dependent base using type = T; // T 是 Base\u003cvoid\u003e::T }; template \u003ctypename T\u003e struct Derived2 : Base\u003cT\u003e { // dependent base using type = T; // T 是模板参数 }; static_assert(std::is_same_v\u003cDerived1\u003cint\u003e::type, char\u003e); static_assert(std::is_same_v\u003cDerived2\u003cint\u003e::type, int\u003e); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:28:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#non-dependent-base"},{"categories":["编程语言"],"content":" 29 Dependent base 对于 non-dependent name，不会在 dependent base 中做查找 namespace jc { template \u003ctypename\u003e struct Base { static constexpr int value = 1; }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base constexpr int get_value() const { return value; // 错误：不会在 dependent base 中查找 non-dependent name } }; } // namespace jc int main() {} 如果要在 dependent base 中查找，则可以使用 this-\u003e 或作用域运算符将 non-dependent name 变为 dependent name namespace jc { template \u003ctypename\u003e struct Base { static constexpr int value = 1; }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base constexpr int get_value() const { return this-\u003evalue; // dependent name，会在 dependent base 中查找 } }; template \u003c\u003e struct Base\u003cbool\u003e { static constexpr int value = 2; }; } // namespace jc int main() { static_assert(jc::Derived\u003cint\u003e{}.get_value() == 1); static_assert(jc::Derived\u003cbool\u003e{}.get_value() == 2); } 或者使用 using 声明，这样只需要引入一次 namespace jc { template \u003ctypename\u003e struct Base { static constexpr int value = 1; }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base using Base\u003cT\u003e::value; constexpr int get_value() const { return value; // dependent name，会在 dependent base 中查找 } }; template \u003c\u003e struct Base\u003cbool\u003e { static constexpr int value = 2; }; } // namespace jc int main() { static_assert(jc::Derived\u003cint\u003e{}.get_value() == 1); static_assert(jc::Derived\u003cbool\u003e{}.get_value() == 2); } 使用作用域运算符不会访问虚函数 #include \u003ccassert\u003e namespace jc { template \u003ctypename\u003e struct Base { virtual int f() const { return 1; } }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base virtual int f() const { return 2; } int get_value() const { return Base\u003cT\u003e::f(); } }; template \u003c\u003e struct Base\u003cbool\u003e { virtual int f() const { return 3; } }; } // namespace jc int main() { assert(jc::Derived\u003cint\u003e{}.get_value() == 1); assert(jc::Derived\u003cbool\u003e{}.get_value() == 3); } 如果需要使用虚函数，则只能使用 this-\u003e 或 using 声明 #include \u003ccassert\u003e namespace jc { template \u003ctypename\u003e struct Base { virtual int f() const { return 1; } }; template \u003ctypename T\u003e struct Derived1 : Base\u003cT\u003e { // dependent base virtual int f() const { return 2; } int get_value() const { return this-\u003ef(); } }; template \u003ctypename T\u003e struct Derived2 : Base\u003cT\u003e { // dependent base using Base\u003cT\u003e::f; virtual int f() const { return 2; } int get_value() const { return f(); } }; template \u003c\u003e struct Base\u003cbool\u003e { virtual int f() const { return 3; } }; } // namespace jc int main() { assert(jc::Derived1\u003cint\u003e{}.get_value() == 2); assert(jc::Derived1\u003cbool\u003e{}.get_value() == 2); assert(jc::Derived2\u003cint\u003e{}.get_value() == 2); assert(jc::Derived2\u003cbool\u003e{}.get_value() == 2); } ","date":"2022-06-18","objectID":"/cxx_template/:29:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#dependent-base"},{"categories":["编程语言"],"content":" 30 隐式实例化 编译器遇到模板特化时会用所给的模板实参替换对应的模板参数，从而产生特化。如果声明类模板的指针或引用，不需要看到类模板定义，但如果要访问特化的成员或想知道模板特化的大小，就要先看到定义 namespace jc { template \u003ctypename T\u003e struct A; A\u003cint\u003e* p = 0; // OK：不需要类模板定义 template \u003ctypename T\u003e struct A { void f(); }; void g(A\u003cint\u003e\u0026 a) { // 只使用类模板声明 a.f(); // 使用了类模板定义，需要 A::f() 的定义 } template \u003ctypename T\u003e void A\u003cT\u003e::f() {} } // namespace jc int main() {} 函数重载时，如果候选函数的参数是类类型，则该类必须可见。如果重载函数的参数是类模板，为了检查重载匹配，就需要实例化类模板。通过 C++ Insights 或在 Visual Studio 中使用 /d1templateStats 命令行参数查看模板的实例化结果 namespace jc { template \u003ctypename T\u003e struct A { A(int); }; void f(A\u003cdouble\u003e) {} void f(int) {} } // namespace jc int main() { jc::f(42); // 两个函数声明都匹配，调用第二个，但仍会实例化第一个 } ","date":"2022-06-18","objectID":"/cxx_template/:30:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#隐式实例化"},{"categories":["编程语言"],"content":" 31 延迟实例化（Lazy Instantiation） 隐式实例化类模板时，也会实例化每个成员声明，但不会实例化定义。例外的是匿名 union 和虚函数，union 成员会被实例化，虚函数是否实例化依赖于具体实现 namespace jc { template \u003cint N\u003e struct A { int a[N]; // 编译器会假设 N 是正整数，实例化时 N \u003c= 0 则失败 }; template \u003ctypename T, int N\u003e struct B { void f() { A\u003cN\u003e a; // 如果 N \u003c= 0，调用时出错 } // void error() { // 即使不被调用也会引发错误 // A\u003c-1\u003e a; // 要求给出 A\u003c-1\u003e 的完整定义，定义 -1 大小的数组出错 // } // virtual void g(); // 虚函数只有声明没有定义会导致链接错误 struct Nested { // N \u003c= 0 时使用该定义出错 A\u003cN\u003e a; }; // union { // union 的所有成员声明都会被生成 // A\u003cN\u003e a; // N \u003c= 0 时出错 // }; }; } // namespace jc int main() { jc::B\u003cint, -1\u003e b; // b.f(); // 调用则出错 // jc::B\u003cint, -1\u003e::Nested{}; // 错误 } ","date":"2022-06-18","objectID":"/cxx_template/:31:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#延迟实例化lazy-instantiation"},{"categories":["编程语言"],"content":" 32 两阶段查找（Two-Phase Lookup） 编译器解析模板时，不能解析 dependent name，于是会在 POI（point of instantiation）再次查找 dependent name，而 non-dependent name 在首次看到模板时就会进行查找，因此就有了两阶段查找，第一阶段发生在模板解析阶段，第二阶段在模板实例化阶段 第一阶段使用 unqualified name lookup（对于函数名查找会使用 ADL）查找 non-dependent name 和非受限的 dependent name（如具有 dependent name 实参的函数名称），但后者的查找不完整，在实例化时还会再次查找 第二阶段发生的地点称为 POI，该阶段查找受限的 dependent name，并对非受限的 dependent name 再次进行 ADL ","date":"2022-06-18","objectID":"/cxx_template/:32:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段查找two-phase-lookup"},{"categories":["编程语言"],"content":" 33 POI（Points of Instantiation） 编译器会在模板中的某个位置访问模板实例的声明或定义，实例化相应的模板定义时就会产生 POI，POI 是代码中的一个点，在该点会插入替换后的模板实例 namespace jc { struct A { A(int i) : i(i) {} int i; }; A operator-(const A\u0026 a) { return A{-a.i}; } bool operator\u003c(const A\u0026 lhs, const A\u0026 rhs) { return lhs.i \u003c rhs.i; } using Int = A; // 若使用 int 而不使用 A 则无法使用 ADL 找到 g template \u003ctypename T\u003e void f(T i) { if (i \u003c 0) { g(-i); // POI 二阶段查找，T 为 A 可以使用 ADL，T 为 int 则找不到 g } } // 此处不能为 POI，因为 g() 不可见，无法解析 g(-i) void g(Int) { // 此处不能为 POI，不允许在此处插入 f\u003cInt\u003e(Int) 的定义 f\u003cInt\u003e(42); // 调用点 // 此处不能为 POI，不允许在此处插入 f\u003cInt\u003e(Int) 的定义 } // 是 POI，此时 g() 可见，实例化 f\u003cInt\u003e(Int) } // namespace jc int main() {} 类模板实例的 POI 位置只能定义在包含该实例的声明或定义前的最近作用域 namespace jc { template \u003ctypename T\u003e struct A { T x; }; // POI int f() { // 不能是 POI，A\u003cint\u003e 的定义不能出现在函数作用域内 return sizeof(A\u003cint\u003e); // 不能是 POI，A\u003cint\u003e 的定义不能出现在函数作用域内 } // 不能是 POI，如果是 POI 则 sizeof(A\u003cint\u003e) 无效，因为编译后才知道大小 } // namespace jc int main() {} 实例化一个模板时，可能附带实例化其他模板 namespace jc { template \u003ctypename T\u003e struct A { using type = int; }; // A\u003cchar\u003e 的 POI template \u003ctypename T\u003e void f() { A\u003cchar\u003e::type a = 0; typename A\u003cT\u003e::type b = 0; } } // namespace jc int main() { jc::f\u003cdouble\u003e(); // A\u003cdouble\u003e 的 POI // f\u003cdouble\u003e 的 POI // f 使用了 dependent name A\u003cT\u003e，需要一个二次 POI // 此处有两个 POI，对于类实例，二次 POI 位于主 POI 之前（函数实例则位置相同） } 一个编译单元通常会包含一个实例的多个 POI，对类模板实例，每个编译单元只保留首个 POI，忽略其他 POI（它们不会被真正认为是 POI），对函数模板和变量模板的实例，所有 POI 都会被保留 ","date":"2022-06-18","objectID":"/cxx_template/:33:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#poipoints-of-instantiation"},{"categories":["编程语言"],"content":" 34 模板的链接（Linkage of Template） 类模板不能和其他实例共用一个名称 namespace jc { int A; class A; // OK：两者名称在不同的空间 int B; template \u003ctypename T\u003e struct B; // 错误：名称冲突 struct C; template \u003ctypename T\u003e struct C; // 错误：名称冲突 } // namespace jc int main() {} 模板不能有 C linkage namespace jc { extern \"C++\" template \u003ctypename T\u003e void normal(); // 默认方式，链接规范可以省略不写 extern \"C\" template \u003ctypename T\u003e void invalid(); // 错误：不能使用 C 链接 extern \"Java\" template \u003ctypename T\u003e void java_link(); // 非标准链接，某些编译器可能支持 } // namespace jc int main() {} 模板通常具有外链接（external linkage），唯一例外的是 static 修饰的函数模板 template \u003ctypename T\u003e // 与其他文件中同名的声明指向相同的实例 void external(); template \u003ctypename T\u003e // 与其他文件中同名的模板无关 static void internal(); template \u003ctypename T\u003e // 重复声明 static void internal(); namespace { template \u003ctypename\u003e // 与其他文件中同名的模板无关 void other_internal(); } namespace { template \u003ctypename\u003e // 重复声明 void other_internal(); } struct { template \u003ctypename T\u003e void f(T) {} // 无链接：不能被重复声明 } x; int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:34:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板的链接linkage-of-template"},{"categories":["编程语言"],"content":" 35 链接错误 和普通的函数不同，如果将模板的声明和实现分离，将出现链接错误，原因是编译器在函数调用处未看到实例化的函数定义，只是假设在别处提供了定义，并产生一个指向该定义的引用，并让链接器利用该引用解决此问题 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; } // namespace jc // a.cpp #include \"a.hpp\" namespace jc { template \u003ctypename T\u003e void A\u003cT\u003e::f() {} } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); // 链接错误 } 推荐的做法是直接在头文件中实现模板 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; template \u003ctypename T\u003e inline void A\u003cT\u003e::f() {} } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); } ","date":"2022-06-18","objectID":"/cxx_template/:35:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#链接错误"},{"categories":["编程语言"],"content":" 36 显式实例化（Explicit Instantiation） 如果希望在头文件中不暴露模板实现，则可以使用显式实例化，显式实例化相当于为模板手动实例化指定的类型，但用户仅能使用已指定类型的模板，可以在头文件中使用 extern 声明显式实例化，告知用户支持的实例化类型 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; extern template class A\u003cint\u003e; // 声明 extern template void A\u003cdouble\u003e::f(); // 声明 } // namespace jc // a.cpp #include \"a.hpp\" namespace jc { template \u003ctypename T\u003e void A\u003cT\u003e::f() {} template class A\u003cint\u003e; // 实例化 A\u003cint\u003e，同时会实例化其所有成员 template void A\u003cdouble\u003e::f(); // 仅实例化该成员 } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); jc::A\u003cdouble\u003e{}.f(); } 可以把显式实例化可提取到一个单独的文件中，注意这个文件要包含定义模板的文件 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; extern template class A\u003cint\u003e; extern template void A\u003cdouble\u003e::f(); } // namespace jc // a.cpp #include \"a.hpp\" namespace jc { template \u003ctypename T\u003e void A\u003cT\u003e::f() {} template class A\u003cint\u003e; template void A\u003cdouble\u003e::f(); } // namespace jc // a_init.cpp #include \"a.cpp\" namespace jc { template class A\u003cint\u003e; template void A\u003cdouble\u003e::f(); } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); jc::A\u003cdouble\u003e{}.f(); } 显式实例化不会影响类型推断规则，它只是实例化了一个实例，并不是一个可以优先匹配的非模板函数。从函数模板实例化而来的函数永远不和普通函数等价 namespace jc { template \u003ctypename T\u003e void f(T, T) {} template void f\u003cdouble\u003e(double, double); } // namespace jc int main() { jc::f\u003cdouble\u003e(1, 3.14); // OK jc::f(1, 3.14); // 错误：推断类型不一致，不存在普通函数 f(double, double) } 显式实例化的本质是创建一个特化的实例，因此显式实例化之后，不能定义同类型的特化 namespace jc { template \u003ctypename T\u003e struct A { void f(); }; template \u003ctypename T\u003e void A\u003cT\u003e::f() {} // template\u003c\u003e struct A\u003cint\u003e { void f() {} }; template struct A\u003cint\u003e; // 相当于创建如上实例 // template \u003c\u003e // struct A\u003cint\u003e {}; // 不允许重定义 } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:36:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#显式实例化explicit-instantiationhttpsencppreferencecomwcpplanguageclass_templateexplicit_instantiation"},{"categories":["编程语言"],"content":" 37 Deduced Context 复杂的类型声明的匹配过程从最顶层构造开始，然后不断递归子构造，即各种组成元素，这些构造被称为 deduced context，non-deduced context 不会参与推断，而是使用其他处推断的结果，受限类型名称如 A\u003cT\u003e::type 不能用来推断 T，非类型表达式如 A\u003cN + 1\u003e 不能用来推断 N namespace jc { template \u003cint N\u003e struct A { using T = int; void f(int) {} }; template \u003cint N\u003e // A\u003cN\u003e::T 是 non-deduced context，X\u003cN\u003e::*p 是 deduced context void f(void (A\u003cN\u003e::*p)(typename A\u003cN\u003e::T)) {} } // namespace jc int main() { using namespace jc; f(\u0026A\u003c0\u003e::f); // 由 A\u003cN\u003e::*p 推断 N 为 0，A\u003cN\u003e::T 则使用 N 变为 A\u003c0\u003e::T } 默认实参不能用于推断 namespace jc { template \u003ctypename T\u003e void f(T x = 42) {} } // namespace jc int main() { jc::f\u003cint\u003e(); // T = int jc::f(); // 错误：无法推断 T } ","date":"2022-06-18","objectID":"/cxx_template/:37:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#deduced-context"},{"categories":["编程语言"],"content":" 38 特殊的推断情况 成员函数的推断 namespace jc { struct A { void f(int*) const noexcept {} }; template \u003ctypename RT, typename T, typename... Args\u003e void f(RT (T::*)(Args...) const) {} } // namespace jc int main() { jc::f(\u0026jc::A::f); // RT = void，T = A，Args = int* } 取函数模板地址和调用转型运算符模板的推断 namespace jc { template \u003ctypename T\u003e void f(T) {} struct A { template \u003ctypename T\u003e operator T\u0026() { static T x; return x; } }; void g(int (\u0026)[3]) {} } // namespace jc int main() { void (*pf)(int) = \u0026jc::f; // 推断为 f\u003cint\u003e(int) jc::A a; jc::g(a); // a 要转为 int(\u0026)[3]，T 推断为 int[3] } 初始化列表作为实参没有具体类型，不能直接推断为初始化列表 #include \u003cinitializer_list\u003e namespace jc { template \u003ctypename T\u003e void f(T) {} template \u003ctypename T\u003e void g(std::initializer_list\u003cT\u003e) {} } // namespace jc int main() { // jc::f({1, 2, 3}); // 错误：不能推断出 T 为 initializer_list jc::g({1, 2, 3}); // OK：T 为 int } 参数包的推断 namespace jc { template \u003ctypename T, typename U\u003e struct A {}; template \u003ctypename T, typename... Args\u003e void f(const A\u003cT, Args\u003e\u0026...); template \u003ctypename... T, typename... U\u003e void g(const A\u003cT, U\u003e\u0026...); } // namespace jc int main() { using namespace jc; f(A\u003cint, bool\u003e{}, A\u003cint, char\u003e{}); // T = int, Args = [bool,char] g(A\u003cint, bool\u003e{}, A\u003cint, char\u003e{}); // T = [int, int], U = [bool, char] g(A\u003cint, bool\u003e{}, A\u003cchar, char\u003e{}); // T = [int, char], U = [bool, char] // f(A\u003cint, bool\u003e{}, A\u003cchar, char\u003e{}); // 错误，T 分别推断为 int 和 char } 完美转发处理空指针常量时，整型值会被当作常量值 0 #include \u003cutility\u003e namespace jc { constexpr int g(...) { return 1; } constexpr int g(int*) { return 2; } template \u003ctypename T\u003e constexpr int f(T\u0026\u0026 t) { return g(std::forward\u003cT\u003e(t)); } } // namespace jc static_assert(jc::f(0) == 1); static_assert(jc::g(0) == 2); static_assert(jc::f(nullptr) == 2); static_assert(jc::g(nullptr) == 2); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:38:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#特殊的推断情况"},{"categories":["编程语言"],"content":" 39 SFINAE（Substitution Failure Is Not An Error） SFINAE 用于禁止不相关函数模板在重载解析时造成错误，当替换返回类型无意义时，会忽略（SFINAE out）匹配而选择另一个更差的匹配 #include \u003cvector\u003e namespace jc { template \u003ctypename T, std::size_t N\u003e T* begin(T (\u0026a)[N]) { return a; } template \u003ctypename Container\u003e typename Container::iterator begin(Container\u0026 c) { return c.begin(); } } // namespace jc int main() { std::vector\u003cint\u003e v; int a[10] = {}; jc::begin(v); // OK：只匹配第二个，SFINAE out 第一个 jc::begin(a); // OK：只匹配第一个，SFINAE out 第二个 } SFINAE 只发生于函数模板替换的即时上下文中，对于模板定义中不合法的表达式，不会使用 SFINAE 机制 namespace jc { template \u003ctypename T, typename U\u003e auto f(T t, U u) -\u003e decltype(t + u) { return t + u; } void f(...) {} template \u003ctypename T, typename U\u003e auto g(T t, U u) -\u003e decltype(auto) { // 必须实例化 t 和 u 来确定返回类型 return t + u; // 不是即时上下文，不会使用 SFINAE } void g(...) {} struct X {}; using A = decltype(f(X{}, X{})); // OK：A 为 void using B = decltype(g(X{}, X{})); // 错误：g\u003cX, X\u003e 的实例化非法 } // namespace jc int main() {} 一个简单的 SFINAE 技巧是使用尾置返回类型，用 devltype 和逗号运算符定义返回类型，在 decltype 中定义必须有效的表达式 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e auto size(const T\u0026 t) -\u003e decltype(t.size(), T::size_type()) { return t.size(); } } // namespace jc int main() { std::string s; assert(jc::size(s) == 0); } 如果替换时使用了类成员，则会实例化类模板，此期间发生的错误不在即时上下文中，即使另一个函数模板匹配无误也不会使用 SFINAE namespace jc { template \u003ctypename T\u003e class Array { public: using iterator = T*; }; template \u003ctypename T\u003e void f(typename Array\u003cT\u003e::iterator) {} template \u003ctypename T\u003e void f(T*) {} } // namespace jc int main() { jc::f\u003cint\u0026\u003e(0); // 错误：第一个模板实例化 Array\u003cint\u0026\u003e，创建引用的指针是非法的 } SFINAE 最出名的应用是 std::enable_if #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003c typename K, typename V, std::enable_if_t\u003cstd::is_same_v\u003cstd::decay_t\u003cV\u003e, bool\u003e, void*\u003e = nullptr\u003e void append(std::ostringstream\u0026 os, const K\u0026 k, const V\u0026 v) { os \u003c\u003c R\"(\")\" \u003c\u003c k \u003c\u003c R\"(\":)\" \u003c\u003c std::boolalpha \u003c\u003c v; } template \u003ctypename K, typename V, std::enable_if_t\u003c!std::is_same_v\u003cstd::decay_t\u003cV\u003e, bool\u003e \u0026\u0026 std::is_arithmetic_v\u003cstd::decay_t\u003cV\u003e\u003e, void*\u003e = nullptr\u003e void append(std::ostringstream\u0026 os, const K\u0026 k, const V\u0026 v) { os \u003c\u003c R\"(\")\" \u003c\u003c k \u003c\u003c R\"(\":)\" \u003c\u003c v; } template \u003c typename K, typename V, std::enable_if_t\u003cstd::is_constructible_v\u003cstd::string, std::decay_t\u003cV\u003e\u003e, void*\u003e = nullptr\u003e void append(std::ostringstream\u0026 os, const K\u0026 k, const V\u0026 v) { os \u003c\u003c R\"(\")\" \u003c\u003c k \u003c\u003c R\"(\":\")\" \u003c\u003c v \u003c\u003c R\"(\")\"; } void kv_string_impl(std::ostringstream\u0026 os) {} template \u003ctypename V, typename... Args\u003e std::void_t\u003cdecltype(std::cout \u003c\u003c std::declval\u003cstd::decay_t\u003cV\u003e\u003e())\u003e kv_string_impl(std::ostringstream\u0026 os, const std::string\u0026 k, const V\u0026 v, const Args\u0026... args) { append(os, k, v); if constexpr (sizeof...(args) \u003e= 2) { os \u003c\u003c \",\"; } kv_string_impl(os, args...); } template \u003ctypename... Args\u003e std::string kv_string(const std::string\u0026 field, const Args\u0026... args) { std::ostringstream os; os \u003c\u003c field \u003c\u003c \":{\"; kv_string_impl(os, args...); os \u003c\u003c \"}\"; return os.str(); } } // namespace jc int main() { std::string a{R\"(data:{})\"}; std::string b{R\"(data:{\"name\":\"jc\",\"ID\":1})\"}; std::string c{R\"(data:{\"name\":\"jc\",\"ID\":1,\"active\":true})\"}; assert(a == jc::kv_string(\"data\")); assert(b == jc::kv_string(\"data\", \"name\", \"jc\", \"ID\", 1)); assert(c == jc::kv_string(\"data\", \"name\", \"jc\", \"ID\", 1, \"active\", true)); } ","date":"2022-06-18","objectID":"/cxx_template/:39:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#sfinaesubstitution-failure-is-not-an-errorhttpsencppreferencecomwcpplanguagesfinae"},{"categories":["编程语言"],"content":" 40 Deduction Guides 字符串字面值传引用时推断为字符数组 #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(const T\u0026 val) : container_({val}) {} private: std::vector\u003cT\u003e container_; }; } // namespace jc int main() { jc::A a = \"downdemo\"; // 错误：T 为 char[9]，构造 std::vector\u003cchar[9]\u003e 出错 } 改为传值，字符串字面值会推断为 const char* #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(T val) : container_({std::move(val)}) {} private: std::vector\u003cT\u003e container_; }; } // namespace jc int main() { jc::A a = \"downdemo\"; static_assert(std::is_same_v\u003cdecltype(a), jc::A\u003cconst char*\u003e\u003e); } C++17 可以定义 deduction guides 对特定类型的实参指定其推断类型 #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(const T\u0026 val) : container_({val}) {} private: std::vector\u003cT\u003e container_; }; A(const char*)-\u003eA\u003cstd::string\u003e; } // namespace jc int main() { jc::A a{\"downdemo\"}; // 等号初始化会出错，const char[9] 不能转为 std::string static_assert(std::is_same_v\u003cdecltype(a), jc::A\u003cstd::string\u003e\u003e); } 为聚合类模板定义 deduction guides #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { T x; std::string s; }; A(const char*, const char*)-\u003eA\u003cstd::string\u003e; } // namespace jc int main() { jc::A a = {\"down\", \"demo\"}; assert(a.x == \"down\"); static_assert(std::is_same_v\u003cdecltype(a.x), std::string\u003e); } 使用花括号赋值可以解决没有初始化列表的问题，圆括号则不行 namespace jc { template \u003ctypename T\u003e struct A { T x; }; template \u003ctypename T\u003e A(T) -\u003e A\u003cT\u003e; } // namespace jc int main() { jc::A a1{0}; // OK jc::A a2 = {0}; // OK jc::A a3(0); // 错误：没有初始化列表，int 不能转为 jc::A\u003cint\u003e jc::A a4 = 0; // 错误：没有初始化列表，int 不能转为 jc::A\u003cint\u003e } explicit 声明的 deduction guides 只用于直接初始化 namespace jc { template \u003ctypename T, typename U\u003e struct A { A(const T\u0026) {} A(T\u0026\u0026) {} }; template \u003ctypename T\u003e A(const T\u0026) -\u003e A\u003cT, T\u0026\u003e; template \u003ctypename T\u003e explicit A(T\u0026\u0026) -\u003e A\u003cT, T\u003e; // 只能用于直接初始化 } // namespace jc int main() { jc::A a = 1; // A\u003cint, int\u0026\u003e a = 1; jc::A b{2}; // A\u003cint, int\u003e b{2}; } std::array 是一个聚合类模板，C++17 为其定义了一个 deduction guides 来推断模板参数 #include \u003carray\u003e #include \u003ctype_traits\u003e // template \u003ctypename T, typename... U\u003e // array(T, U...) // -\u003e array\u003c // enable_if_t\u003c(is_same_v\u003cT, U\u003e \u0026\u0026 ...), T\u003e, // 1 + sizeof...(U) // \u003e; int main() { std::array a{1, 2, 3, 4}; static_assert(std::is_same_v\u003cdecltype(a), std::array\u003cint, 4\u003e\u003e); } C++17 允许类模板实参推断，但类模板的所有参数要么通过显式指定指出，要么通过实参推断推出，不能一部分使用显式指定一部分使用推断 #include \u003cstring\u003e namespace jc { template \u003ctypename T, typename U, typename Y = U\u003e struct A { A(T x = T{}, U y = U{}, Y z = Y{}) {} }; } // namespace jc int main() { jc::A{1, 3.14, \"hello\"}; // T = int，U = double，T3 = const char* jc::A{1, 3.14}; // T = int，U = Y = double jc::A{\"hi\", \"downdemo\"}; // T = U = Y = const char* jc::A\u003cstd::string\u003e{\"hi\", \"downdemo\", 42}; // 错误：只指定了 T，U 未推断 jc::A\u003c\u003e{1, 3.14, 42}; // 错误：T 和 U 都未指定 } 类模板实参推断的本质是为每个构造函数和构造函数模板隐式添加一个 deduction guides #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(const T\u0026 val) : container_({val}) {} private: std::vector\u003cT\u003e container_; }; // template \u003ctypename T\u003e // A(const T\u0026) -\u003e A\u003cT\u003e; // 隐式 deduction guides } // namespace jc int main() { jc::A a1 = 0; jc::A a2{0}; jc::A a3(0); auto a4 = jc::A{0}; static_assert(std::is_same_v\u003cdecltype(a1), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a2), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a3), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a4), jc::A\u003cint\u003e\u003e); } ","date":"2022-06-18","objectID":"/cxx_template/:40:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#deduction-guides"},{"categories":["编程语言"],"content":" 41 Deduction Guides 的问题 用类模板实例作为实参时，Deduction guides 对实参推断的类型有歧义，标准委员会对于该情况有争议地规定，推断时不会将实参推断为类模板的实例 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { A(T x) {} }; template \u003ctypename T\u003e A(T) -\u003e A\u003cT\u003e; } // namespace jc int main() { jc::A a1{0}; jc::A a2{a1}; // A\u003cint\u003e 还是 A\u003cA\u003cint\u003e\u003e？标准委员会规定为 A\u003cint\u003e jc::A a3(a1); // A\u003cint\u003e 还是 A\u003cA\u003cint\u003e\u003e？标准委员会规定为 A\u003cint\u003e static_assert(std::is_same_v\u003cdecltype(a1), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a2), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a3), jc::A\u003cint\u003e\u003e); } 这个争议造成的问题如下 #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T, typename... Args\u003e auto f(const T\u0026 x, const Args\u0026... args) { // 如果 T 为 std::vector return std::vector{x, args...}; // 参数包是否为空将决定不同的返回类型 } } // namespace jc int main() { using std::vector; vector v1{1, 2, 3}; vector v2{v1}; vector v3{v1, v1}; static_assert(std::is_same_v\u003cdecltype(v1), vector\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(v2), vector\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(v3), vector\u003cvector\u003cint\u003e\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(jc::f(v1)), vector\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(jc::f(v1, v1)), vector\u003cvector\u003cint\u003e\u003e\u003e); } 添加隐式 deduction guides 是有争议的，主要反对观点是这个特性自动将接口添加到已存在的库中，并且对于有限定名称的情况，deduction guides 会失效 namespace jc { template \u003ctypename T\u003e struct type_identity { using type = T; }; template \u003ctypename T\u003e class A { public: using ArgType = typename type_identity\u003cT\u003e::type; A(ArgType) {} }; template \u003ctypename T\u003e A(typename type_identity\u003cT\u003e::type) -\u003e A\u003cT\u003e; // 该 deduction guides 无效，因为有限定名称符 type_identity\u003cT\u003e:: } // namespace jc int main() { jc::A a{0}; // 错误 } 为了保持向后兼容性，如果模板名称是注入类名，则禁用类模板实参推断 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { template \u003ctypename U\u003e A(U x) {} template \u003ctypename U\u003e auto f(U x) { return A(x); // 根据注入类名规则 A 是 A\u003cT\u003e，根据类模板实参推断 A 是 A\u003cU\u003e } }; } // namespace jc int main() { jc::A\u003cint\u003e a{0}; auto res = a.f\u003cdouble\u003e(3.14); static_assert(std::is_same_v\u003cdecltype(res), jc::A\u003cint\u003e\u003e); } 使用转发引用的 deduction guides 可能推断出引用类型，导致实例化错误或产生空悬引用，因此标准委员会决定使用隐式 deduction guides 的推断时，禁用 T\u0026\u0026 这个特殊的推断规则 #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { A(const T\u0026) {} A(T\u0026\u0026) {} }; // template \u003ctypename T\u003e // A(const T\u0026) -\u003e A\u003cT\u003e; // 隐式生成 // template \u003ctypename T\u003e // A(T\u0026\u0026) -\u003e A\u003cT\u003e; // 不会隐式生成该 deduction guides } // namespace jc int main() { std::string s; jc::A a = s; // T 推断为 std::string static_assert(std::is_same_v\u003cdecltype(a), jc::A\u003cstd::string\u003e\u003e); // 若指定 T\u0026\u0026 的 deduction guides，则 T 推断为 std::string\u0026 } Deduction guides 只用于推断而非调用，实参的传递方式不必完全对应构造函数 #include \u003ciostream\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T\u003e struct A {}; template \u003ctypename T\u003e struct B { B(const A\u003cT\u003e\u0026) { std::cout \u003c\u003c 1 \u003c\u003c std::endl; } B(A\u003cT\u003e\u0026\u0026) { std::cout \u003c\u003c 2 \u003c\u003c std::endl; } }; template \u003ctypename T\u003e B(A\u003cT\u003e) -\u003e B\u003cT\u003e; // 不需要完全对应构造函数 } // namespace jc int main() { jc::A\u003cint\u003e a; jc::B{a}; // 1 jc::B{std::move(a)}; // 2 } ","date":"2022-06-18","objectID":"/cxx_template/:41:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#deduction-guides-的问题"},{"categories":["编程语言"],"content":" 42 函数模板重载 对于实参推断能匹配多个模板的情况，标准规定了偏序（partial ordering）规则，最终将调用最特殊（能接受更少类型）的模板 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { return 1; } template \u003ctypename T\u003e int f(T*) { return 2; } } // namespace jc int main() { int* p = nullptr; assert(jc::f\u003cint*\u003e(p) == 1); assert(jc::f\u003cint\u003e(p) == 2); assert(jc::f(p) == 2); // 两个模板均匹配，第二个模板更特殊 assert(jc::f(0) == 1); // 0 推断为 int，匹配第一个模板 assert(jc::f(nullptr) == 1); // nullptr 推断为 std::nullptr_t，匹配第一个模板 } 对于两个模板，用实参替代第一个模板的参数，替代后的结果作为实参去推断第二个模板，如果推断成功，反过来用第二个模板推断第一个模板，若推断失败，则第一个模板更特殊，如果均推断失败或推断成功，则两个模板没有偏序关系 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { // 1 return 1; } template \u003ctypename T\u003e int f(T*) { // 2 return 2; } template \u003ctypename T\u003e int f(const T*) { // 3 return 3; } } // namespace jc int main() { const int* p = nullptr; assert(jc::f(p) == 3); // 推断结果： // 1: f(T) [T = const int*] // 2: f(T*) [T = const int] // 3: f(const T*) [T = int] // 偏序处理： // 用 2 推断 1，T = U*，推断成功 // 用 1 推断 2，T* = U，无法推断 T // 2 比 1 特殊 // 用 3 推断 1，T = const U*，推断成功 // 用 1 推断 3，const T* = U，无法推断 T // 3 比 1 特殊 // 用 3 推断 2，T = const U，推断成功 // 用 2 推断 3，const T = U，无法推断 T // 3 比 2 特殊 // 3 最特殊，因此调用 3 } 函数模板可以和非模板函数重载 #include \u003ciostream\u003e namespace jc { struct A { A() = default; A(const A\u0026) { std::cout \u003c\u003c 1; } A(A\u0026\u0026) { std::cout \u003c\u003c 2; } template \u003ctypename T\u003e A(T\u0026\u0026) { std::cout \u003c\u003c 3; } }; } // namespace jc int main() { jc::A a1; jc::A a2{a1}; // 3，对 non-const 对象，成员模板优于拷贝构造函数 jc::A a3{std::move(a1)}; // 2，移动构造函数 const jc::A b1; jc::A b2{b1}; // 1，拷贝构造函数 jc::A b3{std::move(b1)}; // 3，const A\u0026\u0026，更匹配成员模板 } 变参模板的重载 namespace jc { template \u003ctypename... Ts\u003e struct A {}; template \u003ctypename T\u003e constexpr int f(A\u003cT*\u003e) { return 1; } template \u003ctypename... Ts\u003e constexpr int f(A\u003cTs...\u003e) { return 2; } template \u003ctypename... Ts\u003e constexpr int f(A\u003cTs*...\u003e) { return 3; } static_assert(f(A\u003cint*\u003e{}) == 1); static_assert(f(A\u003cint, double\u003e{}) == 2); static_assert(f(A\u003cint*, double*\u003e{}) == 3); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:42:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板重载httpsencppreferencecomwcpplanguagefunction_templatefunction_template_overloading"},{"categories":["编程语言"],"content":" 43 特化（Specialization） 函数模板特化引入了重载和实参推断，如果能推断特化版本，就可以不显式声明模板实参 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { // 1 return 1; } template \u003ctypename T\u003e int f(T*) { // 2 return 2; } template \u003c\u003e int f(int) { // OK：1 的特化 return 3; } template \u003c\u003e int f(int*) { // OK：2 的特化 return 4; } } // namespace jc int main() { int* p = nullptr; assert(jc::f(p) == 4); assert(jc::f(0) == 3); assert(jc::f(nullptr) == 1); } 函数模板的特化不能有默认实参，但会使用要被特化的模板的默认实参 namespace jc { template \u003ctypename T\u003e constexpr int f(T x = 1) { // T 不会由默认实参推断 return x; } template \u003c\u003e constexpr int f(int x) { // 不能指定默认实参 return x + 1; } static_assert(f\u003cint\u003e() == 2); } // namespace jc int main() {} 类模板特化的实参列表必须对应模板参数，如果有默认实参可以不指定对应参数。可以特化整个类模板，也可以特化部分成员。如果对某种类型特化类模板成员，就不能再特化整个类模板，其他未特化的成员会被保留 #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U = int\u003e struct A; template \u003c\u003e struct A\u003cvoid\u003e { constexpr int f(); }; constexpr int A\u003cvoid\u003e::f() { return 1; } template \u003c\u003e struct A\u003cint, int\u003e { int i = 0; }; template \u003c\u003e struct A\u003cchar, char\u003e { template \u003ctypename T\u003e struct B { int f() { return i; } static int i; }; }; template \u003ctypename T\u003e int A\u003cchar, char\u003e::B\u003cT\u003e::i = 1; template \u003c\u003e int A\u003cchar, char\u003e::B\u003cdouble\u003e::i = 2; template \u003c\u003e int A\u003cchar, char\u003e::B\u003cchar\u003e::f() { return 0; }; // template \u003c\u003e // struct A\u003cchar, char\u003e {}; // 错误，不能对已经特化过成员的类型做特化 template \u003c\u003e struct A\u003cchar, char\u003e::B\u003cbool\u003e { int j = 3; }; } // namespace jc int main() { static_assert(jc::A\u003cvoid\u003e{}.f() == 1); static_assert(jc::A\u003cvoid, int\u003e{}.f() == 1); // jc::A\u003cvoid, double\u003e{}; // 错误：未定义类型 assert((jc::A\u003cint, int\u003e{}.i == 0)); assert((jc::A\u003cchar, char\u003e::B\u003cint\u003e{}.i == 1)); assert((jc::A\u003cchar, char\u003e::B\u003cint\u003e{}.f() == 1)); assert((jc::A\u003cchar, char\u003e::B\u003cdouble\u003e{}.i == 2)); assert((jc::A\u003cchar, char\u003e::B\u003cdouble\u003e{}.f() == 2)); assert((jc::A\u003cchar, char\u003e::B\u003cchar\u003e{}.i == 1)); assert((jc::A\u003cchar, char\u003e::B\u003cchar\u003e{}.f() == 0)); assert((jc::A\u003cchar, char\u003e::B\u003cbool\u003e{}.j == 3)); } 类模板特化必须在实例化之前，对已实例化的类型不能再进行特化 namespace jc { template \u003ctypename T\u003e struct A {}; A\u003cint\u003e a; template \u003c\u003e struct A\u003cdouble\u003e {}; // OK template \u003c\u003e struct A\u003cint\u003e {}; // 错误：不能特化已实例化的 A\u003cint\u003e } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:43:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#特化specializationhttpsencppreferencecomwcpplanguagetemplate_specialization-1"},{"categories":["编程语言"],"content":" 44 偏特化（Partial Specialization） 类模板偏特化限定一些类型，而非某个具体类型 namespace jc { template \u003ctypename T\u003e struct A; // primary template template \u003ctypename T\u003e struct A\u003cconst T\u003e {}; template \u003ctypename T\u003e struct A\u003cT*\u003e { static constexpr int size = 0; }; template \u003ctypename T, int N\u003e struct A\u003cT[N]\u003e { static constexpr int size = N; }; template \u003ctypename Class\u003e struct A\u003cint * Class::*\u003e { static constexpr int i = 1; }; template \u003ctypename T, typename Class\u003e struct A\u003cT * Class::*\u003e { static constexpr int i = 2; }; template \u003ctypename Class\u003e struct A\u003cvoid (Class::*)()\u003e { static constexpr int i = 3; }; template \u003ctypename RT, typename Class\u003e struct A\u003cRT (Class::*)() const\u003e { static constexpr int i = 4; }; template \u003ctypename RT, typename Class, typename... Args\u003e struct A\u003cRT (Class::*)(Args...)\u003e { static constexpr int i = 5; }; template \u003ctypename RT, typename Class, typename... Args\u003e struct A\u003cRT (Class::*)(Args...) const noexcept\u003e { static constexpr int i = 6; }; struct B { int* i = nullptr; double* j = nullptr; void f1() {} constexpr int f2() const { return 0; } void f3(int\u0026, double) {} void f4(int\u0026, double) const noexcept {} }; static_assert(A\u003cdecltype(\u0026B::i)\u003e::i == 1); static_assert(A\u003cdecltype(\u0026B::j)\u003e::i == 2); static_assert(A\u003cdecltype(\u0026B::f1)\u003e::i == 3); static_assert(A\u003cdecltype(\u0026B::f2)\u003e::i == 4); static_assert(A\u003cdecltype(\u0026B::f3)\u003e::i == 5); static_assert(A\u003cdecltype(\u0026B::f4)\u003e::i == 6); } // namespace jc int main() { int a[] = {1, 2, 3}; static_assert(jc::A\u003cdecltype(\u0026a)\u003e::size == 0); static_assert(jc::A\u003cdecltype(a)\u003e::size == 3); // jc::A\u003cconst int[3]\u003e{}; // 错误：匹配多个版本 } 变量模板（variable template）的特化和偏特化 #include \u003ccassert\u003e #include \u003clist\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e constexpr int i = sizeof(T); template \u003c\u003e constexpr int i\u003cvoid\u003e = 0; template \u003ctypename T\u003e constexpr int i\u003cT\u0026\u003e = sizeof(void*); static_assert(i\u003cint\u003e == sizeof(int)); static_assert(i\u003cdouble\u003e == sizeof(double)); static_assert(i\u003cvoid\u003e == 0); static_assert(i\u003cint\u0026\u003e == sizeof(void*)); // 变量模板特化的类型可以不匹配 primary template template \u003ctypename T\u003e typename T::iterator null_iterator; template \u003c\u003e int* null_iterator\u003cstd::vector\u003cint\u003e\u003e = nullptr; template \u003ctypename T, std::size_t N\u003e T* null_iterator\u003cT[N]\u003e = nullptr; } // namespace jc int main() { auto it1 = jc::null_iterator\u003cstd::vector\u003cint\u003e\u003e; auto it2 = jc::null_iterator\u003cstd::list\u003cint\u003e\u003e; auto it3 = jc::null_iterator\u003cdouble[3]\u003e; static_assert(std::is_same_v\u003cdecltype(it1), int*\u003e); assert(!it1); static_assert(std::is_same_v\u003cdecltype(it2), std::list\u003cint\u003e::iterator\u003e); static_assert(std::is_same_v\u003cdecltype(it3), double*\u003e); assert(!it3); } ","date":"2022-06-18","objectID":"/cxx_template/:44:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#偏特化partial-specializationhttpsencppreferencecomwcpplanguagepartial_specialization-1"},{"categories":["编程语言"],"content":" 45 Traits 的偏特化实现 std::is_same #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename U\u003e struct is_same { static constexpr bool value = false; }; template \u003ctypename T\u003e struct is_same\u003cT, T\u003e { static constexpr bool value = true; }; template \u003ctypename T, typename U\u003e constexpr bool is_same_v = is_same\u003cT, U\u003e::value; } // namespace jc static_assert(jc::is_same_v\u003cint, int\u003e); static_assert(!jc::is_same_v\u003cint, double\u003e); static_assert(!jc::is_same_v\u003cint, int\u0026\u003e); int main() {} 获取元素类型 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct get_element { using type = T; }; template \u003ctypename T\u003e struct get_element\u003cT[]\u003e { using type = typename get_element\u003cT\u003e::type; }; template \u003ctypename T, std::size_t N\u003e struct get_element\u003cT[N]\u003e { using type = typename get_element\u003cT\u003e::type; }; template \u003ctypename T\u003e using get_element_t = typename get_element\u003cT\u003e::type; } // namespace jc static_assert(std::is_same_v\u003cjc::get_element_t\u003cint\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::get_element_t\u003cint[]\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::get_element_t\u003cint[3][4][5]\u003e, int\u003e); int main() {} std::remove_reference #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct remove_reference { using type = T; }; template \u003ctypename T\u003e struct remove_reference\u003cT\u0026\u003e { using type = T; }; template \u003ctypename T\u003e struct remove_reference\u003cT\u0026\u0026\u003e { using type = T; }; template \u003ctypename T\u003e using remove_reference_t = typename remove_reference\u003cT\u003e::type; } // namespace jc static_assert(std::is_same_v\u003cjc::remove_reference_t\u003cint\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::remove_reference_t\u003cint\u0026\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::remove_reference_t\u003cint\u0026\u0026\u003e, int\u003e); int main() {} std::enable_if #include \u003clist\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e #include \u003cvector\u003e namespace jc { template \u003cbool, typename T = void\u003e struct enable_if {}; template \u003ctypename T\u003e struct enable_if\u003ctrue, T\u003e { using type = T; }; template \u003cbool B, typename T = void\u003e using enable_if_t = typename enable_if\u003cB, T\u003e::type; } // namespace jc struct Base {}; struct Derived1 : Base {}; struct Derived2 : Base {}; template \u003ctypename T, template \u003ctypename...\u003e class V\u003e void impl(const V\u003cT\u003e\u0026) { static_assert(std::is_constructible_v\u003cBase*, T*\u003e); } template \u003ctypename T, template \u003ctypename...\u003e class V, typename... Args, jc::enable_if_t\u003cstd::is_constructible_v\u003cBase*, T*\u003e, void*\u003e = nullptr\u003e void f(const V\u003cT\u003e\u0026 t, Args\u0026\u0026... args) { impl(t); if constexpr (sizeof...(args) \u003e 0) { f(std::forward\u003cArgs\u003e(args)...); } } int main() { f(std::vector\u003cDerived1\u003e{}, std::list\u003cDerived2\u003e{}); } ","date":"2022-06-18","objectID":"/cxx_template/:45:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#traits-的偏特化实现"},{"categories":["编程语言"],"content":" 46 元函数转发（Metafunction Forwarding） Traits 可以视为对类型做操作的函数，称为元函数，元函数一般包含一些相同的成员，将相同成员封装成一个基类作为基本元函数，继承这个基类即可使用成员，这种实现方式称为元函数转发，标准库中实现了 std::integral_constant 作为基本元函数 #include \u003ccassert\u003e #include \u003ctype_traits\u003e namespace jc { template \u003cclass T, T v\u003e struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant\u003cT, v\u003e; constexpr operator value_type() const noexcept { return value; } constexpr value_type operator()() const noexcept { return value; } }; constexpr int to_int(char c) { // hexadecimal letters: if (c \u003e= 'A' \u0026\u0026 c \u003c= 'F') { return static_cast\u003cint\u003e(c) - static_cast\u003cint\u003e('A') + 10; } if (c \u003e= 'a' \u0026\u0026 c \u003c= 'f') { return static_cast\u003cint\u003e(c) - static_cast\u003cint\u003e('a') + 10; } assert(c \u003e= '0' \u0026\u0026 c \u003c= '9'); return static_cast\u003cint\u003e(c) - static_cast\u003cint\u003e('0'); } template \u003cstd::size_t N\u003e constexpr int parse_int(const char (\u0026arr)[N]) { int base = 10; // to handle base (default: decimal) int offset = 0; // to skip prefixes like 0x if (N \u003e 2 \u0026\u0026 arr[0] == '0') { switch (arr[1]) { case 'x': // prefix 0x or 0X, so hexadecimal case 'X': base = 16; offset = 2; break; case 'b': // prefix 0b or 0B (since C++14), so binary case 'B': base = 2; offset = 2; break; default: // prefix 0, so octal base = 8; offset = 1; break; } } int res = 0; int multiplier = 1; for (std::size_t i = 0; i \u003c N - offset; ++i) { if (arr[N - 1 - i] != '\\'') { res += to_int(arr[N - 1 - i]) * multiplier; multiplier *= base; } } return res; } template \u003cchar... cs\u003e constexpr auto operator\"\" _c() { return integral_constant\u003cint, parse_int\u003csizeof...(cs)\u003e({cs...})\u003e{}; } static_assert(std::is_same_v\u003cdecltype(2_c), integral_constant\u003cint, 2\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(0xFF_c), integral_constant\u003cint, 255\u003e\u003e); static_assert( std::is_same_v\u003cdecltype(0b1111'1111_c), integral_constant\u003cint, 255\u003e\u003e); } // namespace jc static_assert(jc::integral_constant\u003cint, 42\u003e::value == 42); static_assert(std::is_same_v\u003cint, jc::integral_constant\u003cint, 0\u003e::value_type\u003e); static_assert(jc::integral_constant\u003cint, 42\u003e{} == 42); int main() { jc::integral_constant\u003cint, 42\u003e f; static_assert(f() == 42); } 利用元函数转发实现 std::is_same namespace jc { template \u003cclass T, T v\u003e struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant\u003cT, v\u003e; constexpr operator value_type() const noexcept { return value; } constexpr value_type operator()() const noexcept { return value; } }; template \u003cbool B\u003e using bool_constant = integral_constant\u003cbool, B\u003e; using true_type = bool_constant\u003ctrue\u003e; using false_type = bool_constant\u003cfalse\u003e; template \u003ctypename T, typename U\u003e struct is_same : false_type {}; template \u003ctypename T\u003e struct is_same\u003cT, T\u003e : true_type {}; template \u003ctypename T, typename U\u003e constexpr bool is_same_v = is_same\u003cT, U\u003e::value; } // namespace jc static_assert(jc::is_same_v\u003cint, int\u003e); static_assert(!jc::is_same_v\u003cint, double\u003e); static_assert(!jc::is_same_v\u003cint, int\u0026\u003e); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:46:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#元函数转发metafunction-forwarding"},{"categories":["编程语言"],"content":" 47 SFINAE-based traits std::is_default_constructible #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct is_default_constructible { private: template \u003ctypename U, typename = decltype(U())\u003e static std::true_type test(void*); template \u003ctypename\u003e static std::false_type test(...); public: static constexpr bool value = decltype(test\u003cT\u003e(nullptr))::value; }; template \u003ctypename T\u003e constexpr bool is_default_constructible_v = is_default_constructible\u003cT\u003e::value; } // namespace jc struct A { A() = delete; }; static_assert(!jc::is_default_constructible_v\u003cA\u003e); int main() {} std::void_t #include \u003ctype_traits\u003e namespace jc { template \u003ctypename...\u003e using void_t = void; template \u003ctypename, typename = void_t\u003c\u003e\u003e struct is_default_constructible : std::false_type {}; template \u003ctypename T\u003e struct is_default_constructible\u003cT, void_t\u003cdecltype(T())\u003e\u003e : std::true_type {}; template \u003ctypename T\u003e constexpr bool is_default_constructible_v = is_default_constructible\u003cT\u003e::value; } // namespace jc struct A { A() = delete; }; static_assert(!jc::is_default_constructible_v\u003cA\u003e); int main() {} std::declval #include \u003ctype_traits\u003e namespace jc { template \u003ctypename\u003e constexpr bool always_false = false; template \u003ctypename T\u003e std::add_rvalue_reference_t\u003cT\u003e declval() noexcept { static_assert(always_false\u003cT\u003e, \"declval not allowed in an evaluated context\"); } template \u003ctypename, typename = std::void_t\u003c\u003e\u003e struct has_less : std::false_type {}; template \u003ctypename T\u003e struct has_less\u003cT, std::void_t\u003cdecltype(jc::declval\u003cT\u003e() \u003c jc::declval\u003cT\u003e())\u003e\u003e : std::true_type {}; template \u003ctypename T\u003e constexpr bool has_less_v = has_less\u003cT\u003e::value; } // namespace jc struct A { A() = delete; bool operator\u003c(const A\u0026 rhs) const { return i \u003c rhs.i; } int i; }; static_assert(jc::has_less_v\u003cA\u003e); int main() {} std::is_nothrow_move_constructible #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename = std::void_t\u003c\u003e\u003e struct is_nothrow_move_constructible : std::false_type {}; template \u003ctypename T\u003e struct is_nothrow_move_constructible\u003c T, std::void_t\u003cdecltype(T(std::declval\u003cT\u003e()))\u003e\u003e : std::bool_constant\u003cnoexcept(T(std::declval\u003cT\u003e()))\u003e {}; template \u003ctypename T\u003e constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible\u003cT\u003e::value; } // namespace jc struct A { A(A\u0026\u0026) noexcept {} }; struct B { private: B(B\u0026\u0026) noexcept {}; }; static_assert(jc::is_nothrow_move_constructible_v\u003cA\u003e); static_assert(!jc::is_nothrow_move_constructible_v\u003cB\u003e); int main() {} std::is_convertible #include \u003ctype_traits\u003e namespace jc { // 转为 void 类型需要单独处理，转为数组和函数类型总是 false template \u003ctypename From, typename To, bool = std::is_void_v\u003cTo\u003e || std::is_array_v\u003cTo\u003e || std::is_function_v\u003cTo\u003e\u003e struct is_convertible_impl { using type = std::bool_constant\u003cstd::is_void_v\u003cTo\u003e \u0026\u0026 std::is_void_v\u003cFrom\u003e\u003e; }; template \u003ctypename From, typename To\u003e struct is_convertible_impl\u003cFrom, To, false\u003e { private: static void f(To); template \u003ctypename T, typename U, typename = decltype(f(std::declval\u003cT\u003e()))\u003e // 将 T 转为 To static std::true_type test(void*); template \u003ctypename, typename\u003e static std::false_type test(...); public: using type = decltype(test\u003cFrom, To\u003e(nullptr)); }; template \u003ctypename From, typename To\u003e struct is_convertible : is_convertible_impl\u003cFrom, To\u003e::type {}; template \u003ctypename From, typename To\u003e constexpr bool is_convertible_v = is_convertible\u003cFrom, To\u003e::value; } // namespace jc struct A {}; struct B : A {}; static_assert(jc::is_convertible_v\u003cB, A\u003e); static_assert(jc::is_convertible_v\u003cB*, A*\u003e); static_assert(!jc::is_convertible_v\u003cA*, B*\u003e); static_assert(jc::is_convertible_v\u003cvoid, void\u003e); static_assert(!jc::is_convertible_v\u003cint*, int[]\u003e); int main() {} std::is_class #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T, typename = std::void_t\u003c\u003e\u003e struct is_class : std::false_type {}; template \u003ctypename T\u003e struct is_class\u003cT, std::void_t\u003cint T::*\u003e\u003e : std::true_type {}; template \u003cclass T\u003e constexpr bool is_class_v = is_class\u003cT\u003e::value; } // namespace jc union A {}; sta","date":"2022-06-18","objectID":"/cxx_template/:47:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#sfinae-based-traits"},{"categories":["编程语言"],"content":" 48 空基类优化（EBCO，Empty Base Class Optimization） 为了保证给类动态分配内存时有不同的地址，C++ 规定空类大小必须大于 0 namespace jc { struct A {}; struct B {}; static_assert(sizeof(A) \u003e 0); static_assert(sizeof(B) \u003e 0); } // namespace jc int main() { jc::A a; jc::B b; static_assert((void*)\u0026a != (void*)\u0026b); } 一般编译器将空类大小设为 1 字节，对于空类存在继承关系的情况，如果支持 EBCO，可以优化派生类的空间占用大小 /* 不支持 EBCO 的内存布局： * [ ] } A } B } C * [ ] } } * [ ] } * * 支持 EBCO 的内存布局： * [ ] } A } B } C */ namespace jc { struct A { using Int = int; }; struct B : A {}; struct C : B {}; static_assert(sizeof(A) == 1); static_assert(sizeof(A) == sizeof(B)); static_assert(sizeof(A) == sizeof(C)); } // namespace jc int main() {} 模板参数可能是空类 namespace jc { struct A {}; struct B {}; template \u003ctypename T, typename U\u003e struct C { T a; U b; }; static_assert(sizeof(C\u003cA, B\u003e) == 2); } // namespace jc int main() {} 为了利用 EBCO 压缩内存空间，可以将模板参数设为基类 namespace jc { struct A {}; struct B {}; template \u003ctypename T, typename U\u003e struct C : T, U {}; static_assert(sizeof(C\u003cA, B\u003e) == 1); } // namespace jc int main() {} 但模板参数可能是相同类型，或者不一定是类，此时将其设为基类在实例化时会报错。如果已知一个模板参数类型为空类，把可能为空的类型参数与一个不为空的成员利用 EBCO 合并起来，即可把空类占用的空间优化掉 namespace jc { template \u003ctypename Base, typename Member\u003e class Pair : private Base { public: Pair(const Base\u0026 b, const Member\u0026 m) : Base(b), member_(m) {} const Base\u0026 first() const { return (const Base\u0026)*this; } Base\u0026 first() { return (Base\u0026)*this; } const Member\u0026 second() const { return this-\u003emember_; } Member\u0026 second() { return this-\u003emember_; } private: Member member_; }; template \u003ctypename T\u003e struct Unoptimizable { T info; void* storage; }; template \u003ctypename T\u003e struct Optimizable { Pair\u003cT, void*\u003e info_and_storage; }; } // namespace jc struct A {}; static_assert(sizeof(jc::Unoptimizable\u003cA\u003e) == 2 * sizeof(void*)); static_assert(sizeof(jc::Optimizable\u003cA\u003e) == sizeof(void*)); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:48:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#空基类优化ebcoempty-base-class-optimization"},{"categories":["编程语言"],"content":" 49 奇异递归模板模式（CRTP，The Curiously Recurring Template Pattern） CRTP 的实现手法是将派生类作为基类的模板参数 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class Base { public: static int count() { return i; } protected: Base() { ++i; } Base(const Base\u003cT\u003e \u0026) { ++i; } Base(Base\u003cT\u003e \u0026\u0026) noexcept { ++i; } ~Base() { --i; } private: inline static int i = 0; }; template \u003ctypename T\u003e class Derived : public Base\u003cDerived\u003cT\u003e\u003e {}; } // namespace jc int main() { jc::Derived\u003cint\u003e a, b; jc::Derived\u003cchar\u003e c; assert(jc::Derived\u003cint\u003e::count() == 2); assert(jc::Derived\u003cchar\u003e::count() == 1); } 通常大量运算符重载会一起出现，但通常这些运算符只需要一个定义，其他运算符可以提取到基类中基于这一个来实现 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class Base { friend bool operator!=(const T\u0026 lhs, const T\u0026 rhs) { return !(lhs == rhs); } }; class Derived : public Base\u003cDerived\u003e { friend bool operator==(const Derived\u0026 lhs, const Derived\u0026 rhs) { return lhs.i_ == rhs.i_; } public: Derived(int i) : i_(i) {} private: int i_ = 0; }; } // namespace jc int main() { jc::Derived a{1}; jc::Derived b{2}; assert(a != b); } CRTP 基类可以基于 CRTP 派生类暴露的小得多的接口定义大部分接口，这个模式称为 facade 模式 #include \u003ccassert\u003e #include \u003citerator\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename Derived, typename Value, typename Category\u003e class IteratorFacade { public: using value_type = std::remove_const_t\u003cValue\u003e; using reference = Value\u0026; using pointer = Value*; using difference_type = std::ptrdiff_t; using iterator_category = Category; public: reference operator*() const { return as_derived().dereference(); } Derived\u0026 operator++() { as_derived().increment(); return as_derived(); } Derived operator++(int) { Derived tmp(as_derived()); as_derived().increment(); return tmp; } friend bool operator==(const IteratorFacade\u0026 lhs, const IteratorFacade\u0026 rhs) { return lhs.as_derived().equals(rhs.as_derived()); } friend bool operator!=(const IteratorFacade\u0026 lhs, const IteratorFacade\u0026 rhs) { return !operator==(lhs, rhs); } private: Derived\u0026 as_derived() { return *static_cast\u003cDerived*\u003e(this); } const Derived\u0026 as_derived() const { return *static_cast\u003cconst Derived*\u003e(this); } }; template \u003ctypename T\u003e struct ListNode { ListNode(T x) : value(x) {} T value; ListNode\u003cT\u003e* next = nullptr; }; template \u003ctypename T\u003e class ListNodeIterator : public IteratorFacade\u003cListNodeIterator\u003cT\u003e, T, std::forward_iterator_tag\u003e { public: ListNodeIterator(ListNode\u003cT\u003e* t = nullptr) : t_(t) {} T\u0026 dereference() const { return t_-\u003evalue; } void increment() { t_ = t_-\u003enext; } bool equals(const ListNodeIterator\u0026 rhs) const { return t_ == rhs.t_; } private: ListNode\u003cT\u003e* t_ = nullptr; }; } // namespace jc int main() { auto a = new jc::ListNode\u003cint\u003e{1}; auto b = new jc::ListNode\u003cint\u003e{2}; auto c = new jc::ListNode\u003cint\u003e{3}; a-\u003enext = b; b-\u003enext = c; auto first = jc::ListNodeIterator{a}; auto last = ++jc::ListNodeIterator{c}; std::vector\u003cint\u003e v; for (auto it = first; it != last; ++it) { v.emplace_back(*it); } assert((v == std::vector\u003cint\u003e{1, 2, 3})); delete c; delete b; delete a; } ","date":"2022-06-18","objectID":"/cxx_template/:49:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#奇异递归模板模式crtpthe-curiously-recurring-template-pattern"},{"categories":["编程语言"],"content":" 50 Mixins 使用 Mixins 手法可以更方便地引入额外信息 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename... Mixins\u003e struct Point : Mixins... { Point() : Mixins()..., x(0.0), y(0.0) {} Point(double x, double y) : Mixins()..., x(x), y(y) {} double x; double y; }; struct Label { std::string label = \"point\"; }; struct Color { enum { red, green, blue }; }; using CustomPoint = Point\u003cLabel, Color\u003e; } // namespace jc int main() { jc::CustomPoint p; assert(p.label == \"point\"); assert(p.red == jc::Color::red); assert(p.green == jc::Color::green); assert(p.blue == jc::Color::blue); } CRTP-mixin #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e class Base { public: static int count() { return i; } protected: Base() { ++i; } Base(const Base\u003cT\u003e \u0026) { ++i; } Base(Base\u003cT\u003e \u0026\u0026) noexcept { ++i; } ~Base() { --i; } private: inline static int i = 0; }; template \u003ctemplate \u003ctypename\u003e class... Mixins\u003e struct Point : Mixins\u003cPoint\u003c\u003e\u003e... { Point() : Mixins\u003cPoint\u003c\u003e\u003e()..., x(0.0), y(0.0) {} Point(double x, double y) : Mixins\u003cPoint\u003c\u003e\u003e()..., x(x), y(y) {} double x; double y; }; template \u003ctypename T\u003e struct Label { std::string label = \"point\"; }; template \u003ctypename T\u003e struct Color { enum { red, green, blue }; }; using PointCount = Point\u003cBase, Label, Color\u003e; } // namespace jc int main() { jc::PointCount a, b, c; assert(jc::PointCount::count() == 3); assert(a.label == \"point\"); assert(a.red == jc::Color\u003cvoid\u003e::red); assert(a.green == jc::Color\u003cvoid\u003e::green); assert(a.blue == jc::Color\u003cvoid\u003e::blue); } Mixins 参数化成员函数的虚拟性 #include \u003ccassert\u003e namespace jc { template \u003ctypename... Mixins\u003e class Base : private Mixins... { public: int f() { return 1; } // 是否为虚函数由 Mixins 中的声明决定 }; template \u003ctypename... Mixins\u003e class Derived : public Base\u003cMixins...\u003e { public: int f() { return 2; } }; } // namespace jc struct A {}; struct B { virtual int f() = 0; }; int main() { jc::Base\u003cA\u003e* p = new jc::Derived\u003cA\u003e; assert(p-\u003ef() == 1); jc::Base\u003cB\u003e* q = new jc::Derived\u003cB\u003e; assert(q-\u003ef() == 2); } ","date":"2022-06-18","objectID":"/cxx_template/:50:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#mixins"},{"categories":["编程语言"],"content":" 51 指定模板参数 模板常常带有一长串类型参数，不过通常都设有默认值 struct A {}; struct B {}; struct C {}; template \u003ctypename T1 = A, typename T2 = B, typename T3 = C\u003e struct MyClass {}; 现在想指定某个实参，而其他参数依然使用默认实参 namespace jc { struct A {}; struct B {}; struct C { static constexpr int f() { return 1; } }; struct Alias { using P1 = A; using P2 = B; using P3 = C; }; template \u003ctypename T\u003e struct SetT1 : virtual Alias { using P1 = T; }; template \u003ctypename T\u003e struct SetT2 : virtual Alias { using P2 = T; }; template \u003ctypename T\u003e struct SetT3 : virtual Alias { using P3 = T; }; // 由于不能从多个相同类直接继承，需要一个中间层用于区分 template \u003ctypename T, int N\u003e struct Mid : T {}; template \u003ctypename T1, typename T2, typename T3\u003e struct SetBase : Mid\u003cT1, 1\u003e, Mid\u003cT2, 2\u003e, Mid\u003cT3, 3\u003e {}; /* Alias 要被用作默认实参 * 但 SetBase 会将其多次指定为 Mid 的基类 * 为了防止多次继承产生二义性 * 虚派生一个新类替代 Alias 作为默认实参 */ struct Args : virtual Alias {}; // Args 即包含了别名 P1、P2、P3 template \u003ctypename T1 = Args, typename T2 = Args, typename T3 = Args\u003e struct MyClass { using Policies = SetBase\u003cT1, T2, T3\u003e; constexpr int f() { return Policies::P3::f(); } }; struct D { static constexpr int f() { return 2; } }; static_assert(MyClass{}.f() == 1); static_assert(MyClass\u003cSetT3\u003cD\u003e\u003e{}.f() == 2); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:51:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#指定模板参数"},{"categories":["编程语言"],"content":" 52 类型擦除（Type Erasure） 类型擦除即将不同类型抽象为相同的表示，但使用时仍可以还原出原有类型的行为，std::any 和 std::function 就使用了类型擦除的手法。比起函数指针，std::function 在编译期擦除掉了不需要关心的原有类型，用同一种表示抽象了所有函数类型，并且能存储 lambda 或函数对象，使用时又能像调用函数一样使用原有类型 #include \u003cany\u003e #include \u003ccassert\u003e #include \u003cexception\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e class is_equality_comparable { private: static void* conv(bool); template \u003ctypename U\u003e static std::true_type test( decltype(conv(std::declval\u003cconst U\u0026\u003e() == std::declval\u003cconst U\u0026\u003e())), decltype(conv(!(std::declval\u003cconst U\u0026\u003e() == std::declval\u003cconst U\u0026\u003e())))); template \u003ctypename U\u003e static std::false_type test(...); public: static constexpr bool value = decltype(test\u003cT\u003e(nullptr, nullptr))::value; }; template \u003ctypename T, bool = is_equality_comparable\u003cT\u003e::value\u003e struct try_equals { static bool equals(const T\u0026 lhs, const T\u0026 rhs) { return lhs == rhs; } }; struct not_equality_comparable : std::exception {}; template \u003ctypename T\u003e struct try_equals\u003cT, false\u003e { static bool equals(const T\u0026 lhs, const T\u0026 rhs) { throw not_equality_comparable(); } }; template \u003ctypename R, typename... Args\u003e class functor_bridge { public: virtual ~functor_bridge() {} virtual functor_bridge* clone() const = 0; virtual R invoke(Args... args) const = 0; virtual bool equals(const functor_bridge*) const = 0; }; template \u003ctypename F, typename R, typename... Args\u003e class functor_bridge_impl : public functor_bridge\u003cR, Args...\u003e { public: template \u003ctypename T\u003e functor_bridge_impl(T\u0026\u0026 f) : f_(std::forward\u003cT\u003e(f)) {} virtual functor_bridge_impl* clone() const override { return new functor_bridge_impl(f_); } virtual R invoke(Args... args) const override { return f_(std::forward\u003cArgs\u003e(args)...); } virtual bool equals(const functor_bridge\u003cR, Args...\u003e* rhs) const override { if (auto p = dynamic_cast\u003cconst functor_bridge_impl*\u003e(rhs)) { return try_equals\u003cF\u003e::equals(f_, p-\u003ef_); } return false; } private: F f_; }; template \u003ctypename\u003e class function; template \u003ctypename R, typename... Args\u003e class function\u003cR(Args...)\u003e { friend bool operator==(const function\u0026 lhs, const function\u0026 rhs) { if (!lhs || !rhs) { return !lhs \u0026\u0026 !rhs; } return lhs.bridge_-\u003eequals(rhs.bridge_); } friend bool operator!=(const function\u0026 lhs, const function\u0026 rhs) { return !(lhs == rhs); } friend void swap(function\u0026 lhs, function\u0026 rhs) noexcept { std::swap(lhs.bridge_, rhs.bridge_); } public: function() = default; function(const function\u0026 rhs) { if (rhs.bridge_) { bridge_ = rhs.bridge_-\u003eclone(); } } function(function\u0026 rhs) : function(static_cast\u003cconst function\u0026\u003e(rhs)) {} function(function\u0026\u0026 rhs) noexcept : bridge_(rhs.bridge_) { rhs.bridge_ = nullptr; } template \u003ctypename F\u003e function(F\u0026\u0026 f) { using Bridge = functor_bridge_impl\u003cstd::decay_t\u003cF\u003e, R, Args...\u003e; bridge_ = new Bridge(std::forward\u003cF\u003e(f)); // type erasure } ~function() { delete bridge_; } function\u0026 operator=(const function\u0026 rhs) { function tmp(rhs); swap(*this, tmp); return *this; } function\u0026 operator=(function\u0026\u0026 rhs) noexcept { delete bridge_; bridge_ = rhs.bridge_; rhs.bridge_ = nullptr; return *this; } template \u003ctypename F\u003e function\u0026 operator=(F\u0026\u0026 rhs) { function tmp(std::forward\u003cF\u003e(rhs)); swap(*this, tmp); return *this; } explicit operator bool() const { return bridge_ == nullptr; } R operator()(Args... args) const { return bridge_-\u003einvoke(std::forward\u003cArgs\u003e(args)...); } private: functor_bridge\u003cR, Args...\u003e* bridge_ = nullptr; }; } // namespace jc int main() { jc::function\u003cbool(int)\u003e f = [](const std::any\u0026 a) -\u003e int { return std::any_cast\u003cint\u003e(a); }; assert(f(3.14) == 1); } ","date":"2022-06-18","objectID":"/cxx_template/:52:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类型擦除type-erasure"},{"categories":["编程语言"],"content":" 53 元编程（Metaprogramming） 元编程将计算在编译期完成，避免了运行期计算的开销 #include \u003ctype_traits\u003e namespace jc { template \u003cint N, int... Ns\u003e struct max; template \u003cint N\u003e struct max\u003cN\u003e : std::integral_constant\u003cint, N\u003e {}; template \u003cint N1, int N2, int... Ns\u003e struct max\u003cN1, N2, Ns...\u003e : std::integral_constant\u003cint, (N1 \u003c N2) ? max\u003cN2, Ns...\u003e::value : max\u003cN1, Ns...\u003e::value\u003e {}; template \u003cint... Ns\u003e inline constexpr auto max_v = max\u003cNs...\u003e::value; } // namespace jc static_assert(jc::max_v\u003c3, 2, 1, 5, 4\u003e == 5); int main() {} 模板元编程通常使用偏特化和递归实现，由于编译期需要实例化代码，如果递归层次过深，会带来代码体积膨胀的问题 #include \u003ctype_traits\u003e namespace jc { template \u003cint N, int L = 1, int R = N\u003e struct sqrt { static constexpr auto M = L + (R - L) / 2; static constexpr auto T = N / M; static constexpr auto value = // 避免递归实例化所有分支 std::conditional_t\u003c(T \u003c M), sqrt\u003cN, L, M\u003e, sqrt\u003cN, M + 1, R\u003e\u003e::value; }; template \u003cint N, int M\u003e struct sqrt\u003cN, M, M\u003e { static constexpr auto value = M - 1; }; template \u003cint N\u003e inline constexpr auto sqrt_v = sqrt\u003cN, 1, N\u003e::value; } // namespace jc static_assert(jc::sqrt_v\u003c10000\u003e == 100); int main() {} C++14 支持 constexpr 函数，简化了实现并且没有递归实例化的代码膨胀问题 namespace jc { template \u003cint N\u003e constexpr int sqrt() { if constexpr (N \u003c= 1) { return N; } int l = 1; int r = N; while (l \u003c r) { int m = l + (r - l) / 2; int t = N / m; if (m == t) { return m; } else if (m \u003e t) { r = m; } else { l = m + 1; } } return l - 1; } } // namespace jc static_assert(jc::sqrt\u003c10000\u003e() == 100); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:53:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#元编程metaprogramming"},{"categories":["编程语言"],"content":" 54 循环展开（Loop Unrolling） 在一些机器上，for 循环的汇编将产生分支指令 #include \u003carray\u003e #include \u003ccassert\u003e namespace jc { template \u003ctypename T, std::size_t N\u003e auto dot_product(const std::array\u003cT, N\u003e\u0026 lhs, const std::array\u003cT, N\u003e\u0026 rhs) { T res{}; for (std::size_t i = 0; i \u003c N; ++i) { res += lhs[i] * rhs[i]; } return res; } } // namespace jc int main() { std::array\u003cint, 3\u003e a{1, 2, 3}; std::array\u003cint, 3\u003e b{4, 5, 6}; assert(jc::dot_product(a, b) == 32); } 循环展开是一种牺牲体积加快程序执行速度的方法，现代编译器会优化循环为目标平台最高效形式。使用元编程可以展开循环，虽然已经没有必要，但还是给出实现 #include \u003carray\u003e #include \u003ccassert\u003e namespace jc { template \u003ctypename T, std::size_t N\u003e struct dot_product_impl { static T value(const T* lhs, const T* rhs) { return *lhs * *rhs + dot_product_impl\u003cT, N - 1\u003e::value(lhs + 1, rhs + 1); } }; template \u003ctypename T\u003e struct dot_product_impl\u003cT, 0\u003e { static T value(const T*, const T*) { return T{}; } }; template \u003ctypename T, std::size_t N\u003e auto dot_product(const std::array\u003cT, N\u003e\u0026 lhs, const std::array\u003cT, N\u003e\u0026 rhs) { return dot_product_impl\u003cT, N\u003e::value(\u0026*std::begin(lhs), \u0026*std::begin(rhs)); } } // namespace jc int main() { std::array\u003cint, 3\u003e a{1, 2, 3}; std::array\u003cint, 3\u003e b{4, 5, 6}; assert(jc::dot_product(a, b) == 32); } ","date":"2022-06-18","objectID":"/cxx_template/:54:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#循环展开loop-unrolling"},{"categories":["编程语言"],"content":" 55 Unit Type std::ratio #include \u003ccassert\u003e #include \u003ccmath\u003e #include \u003ctype_traits\u003e namespace jc { template \u003cint N, int D = 1\u003e struct ratio { static constexpr int num = N; static constexpr int den = D; using type = ratio\u003cnum, den\u003e; }; template \u003ctypename R1, typename R2\u003e struct ratio_add_impl { private: static constexpr int den = R1::den * R2::den; static constexpr int num = R1::num * R2::den + R2::num * R1::den; public: using type = ratio\u003cnum, den\u003e; }; template \u003ctypename R1, typename R2\u003e using ratio_add = typename ratio_add_impl\u003cR1, R2\u003e::type; template \u003ctypename T, typename U = ratio\u003c1\u003e\u003e class duration { public: using rep = T; using period = typename U::type; public: constexpr duration(rep r = 0) : r_(r) {} constexpr rep count() const { return r_; } private: rep r_; }; template \u003ctypename T1, typename U1, typename T2, typename U2\u003e constexpr auto operator+(const duration\u003cT1, U1\u003e\u0026 lhs, const duration\u003cT2, U2\u003e\u0026 rhs) { using CommonType = ratio\u003c1, ratio_add\u003cU1, U2\u003e::den\u003e; auto res = (lhs.count() * U1::num / U1::den + rhs.count() * U2::num / U2::den) * CommonType::den; return duration\u003cdecltype(res), CommonType\u003e{res}; } } // namespace jc int main() { constexpr auto a = jc::duration\u003cdouble, jc::ratio\u003c1, 1000\u003e\u003e(10); // 10 ms constexpr auto b = jc::duration\u003cdouble, jc::ratio\u003c1, 3\u003e\u003e(7.5); // 2.5 s constexpr auto c = a + b; // 10 * 3 + 7.5 * 1000 = 7530 * 1/3000 s assert(std::abs(c.count() - 7530) \u003c 1e-6); static_assert(std::is_same_v\u003cstd::decay_t\u003cdecltype(c)\u003e, jc::duration\u003cdouble, jc::ratio\u003c1, 3000\u003e\u003e\u003e); static_assert(decltype(c)::period::num == 1); static_assert(decltype(c)::period::den == 3000); } ","date":"2022-06-18","objectID":"/cxx_template/:55:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#unit-typehttpsenwikipediaorgwikiunit_type"},{"categories":["编程语言"],"content":" 56 Typelist // typelist.hpp #pragma once #include \u003ctype_traits\u003e namespace jc { template \u003ctypename...\u003e struct typelist {}; template \u003ctypename List\u003e struct front; template \u003ctypename Head, typename... Tail\u003e struct front\u003ctypelist\u003cHead, Tail...\u003e\u003e { using type = Head; }; template \u003ctypename List\u003e using front_t = typename front\u003cList\u003e::type; // pop_front_t template \u003ctypename List\u003e struct pop_front; template \u003ctypename Head, typename... Tail\u003e struct pop_front\u003ctypelist\u003cHead, Tail...\u003e\u003e { using type = typelist\u003cTail...\u003e; }; template \u003ctypename List\u003e using pop_front_t = typename pop_front\u003cList\u003e::type; // push_front_t template \u003ctypename List, typename NewElement\u003e struct push_front; template \u003ctypename... Elements, typename NewElement\u003e struct push_front\u003ctypelist\u003cElements...\u003e, NewElement\u003e { using type = typelist\u003cNewElement, Elements...\u003e; }; template \u003ctypename List, typename NewElement\u003e using push_front_t = typename push_front\u003cList, NewElement\u003e::type; // nth_element_t template \u003ctypename List, std::size_t N\u003e struct nth_element : nth_element\u003cpop_front_t\u003cList\u003e, N - 1\u003e {}; template \u003ctypename List\u003e struct nth_element\u003cList, 0\u003e : front\u003cList\u003e {}; template \u003ctypename List, std::size_t N\u003e using nth_element_t = typename nth_element\u003cList, N\u003e::type; // is_empty template \u003ctypename T\u003e struct is_empty { static constexpr bool value = false; }; template \u003c\u003e struct is_empty\u003ctypelist\u003c\u003e\u003e { static constexpr bool value = true; }; template \u003ctypename T\u003e inline constexpr bool is_empty_v = is_empty\u003cT\u003e::value; // find_index_of_t template \u003ctypename List, typename T, std::size_t N = 0, bool Empty = is_empty_v\u003cList\u003e\u003e struct find_index_of; template \u003ctypename List, typename T, std::size_t N\u003e struct find_index_of\u003cList, T, N, false\u003e : std::conditional_t\u003cstd::is_same_v\u003cfront_t\u003cList\u003e, T\u003e, std::integral_constant\u003cstd::size_t, N\u003e, find_index_of\u003cpop_front_t\u003cList\u003e, T, N + 1\u003e\u003e {}; template \u003ctypename List, typename T, std::size_t N\u003e struct find_index_of\u003cList, T, N, true\u003e {}; template \u003ctypename List, typename T\u003e using find_index_of_t = typename find_index_of\u003cList, T\u003e::type; // push_back_t template \u003ctypename List, typename NewElement, bool = is_empty_v\u003cList\u003e\u003e struct push_back_impl; template \u003ctypename List, typename NewElement\u003e struct push_back_impl\u003cList, NewElement, false\u003e { private: using head = front_t\u003cList\u003e; using tail = pop_front_t\u003cList\u003e; using new_tail = typename push_back_impl\u003ctail, NewElement\u003e::type; public: using type = push_front_t\u003cnew_tail, head\u003e; }; template \u003ctypename List, typename NewElement\u003e struct push_back_impl\u003cList, NewElement, true\u003e { using type = push_front_t\u003cList, NewElement\u003e; }; template \u003ctypename List, typename NewElement\u003e struct push_back : push_back_impl\u003cList, NewElement\u003e {}; /* * template \u003ctypename List, typename NewElement\u003e * struct push_back; * * template \u003ctypename... Elements, typename NewElement\u003e * struct push_back\u003ctypelist\u003cElements...\u003e, NewElement\u003e { * using type = typelist\u003cElements..., NewElement\u003e; * }; */ template \u003ctypename List, typename NewElement\u003e using push_back_t = typename push_back\u003cList, NewElement\u003e::type; // reverse_t template \u003ctypename List, bool Empty = is_empty_v\u003cList\u003e\u003e struct reverse; template \u003ctypename List\u003e using reverse_t = typename reverse\u003cList\u003e::type; template \u003ctypename List\u003e struct reverse\u003cList, false\u003e : push_back\u003creverse_t\u003cpop_front_t\u003cList\u003e\u003e, front_t\u003cList\u003e\u003e {}; template \u003ctypename List\u003e struct reverse\u003cList, true\u003e { using type = List; }; // pop_back_t template \u003ctypename List\u003e struct pop_back { using type = reverse_t\u003cpop_front_t\u003creverse_t\u003cList\u003e\u003e\u003e; }; template \u003ctypename List\u003e using pop_back_t = typename pop_back\u003cList\u003e::type; // largest_type_t template \u003ctypename List, bool = is_empty_v\u003cList\u003e\u003e struct largest_type; template \u003ctypename List\u003e struct largest_type\u003cList, false\u003e { private: using contender = front_t\u003cList\u003e; using best = typename largest_type\u003cpop_front_t\u003cList\u003e\u003e::type; public: using type = std::conditional_t\u003c(sizeof(contender) \u003e= sizeof(best)), contender, best\u003e; }; template \u003ctypename List\u003e struct largest_type\u003cList, true\u003e { using type = char; }; ","date":"2022-06-18","objectID":"/cxx_template/:56:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#typelist"},{"categories":["编程语言"],"content":" 57 std::tuple #include \u003ccassert\u003e #include \u003ccomplex\u003e #include \u003ccstring\u003e #include \u003cfunctional\u003e #include \u003costream\u003e #include \u003csstream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e #include \"typelist.hpp\" namespace jc { template \u003ctypename... Types\u003e class tuple; template \u003ctypename Head, typename... Tail\u003e class tuple\u003cHead, Tail...\u003e { public: tuple() = default; tuple(const Head\u0026 head, const tuple\u003cTail...\u003e\u0026 tail) : head_(head), tail_(tail) {} template \u003c typename VHead, typename... VTail, std::enable_if_t\u003csizeof...(VTail) == sizeof...(Tail), void*\u003e = nullptr\u003e tuple(VHead\u0026\u0026 head, VTail\u0026\u0026... tail) : head_(std::forward\u003cVHead\u003e(head)), tail_(std::forward\u003cVTail\u003e(tail)...) {} template \u003c typename VHead, typename... VTail, std::enable_if_t\u003csizeof...(VTail) == sizeof...(Tail), void*\u003e = nullptr\u003e tuple(const tuple\u003cVHead, VTail...\u003e\u0026 rhs) : head_(rhs.get_head()), tail_(rhs.get_tail()) {} // for push_back_tuple template \u003ctypename V, typename VHead, typename... VTail\u003e tuple(const V\u0026 v, const tuple\u003cVHead, VTail...\u003e\u0026 rhs) : head_(v), tail_(rhs) {} Head\u0026 get_head() { return head_; } const Head\u0026 get_head() const { return head_; } tuple\u003cTail...\u003e\u0026 get_tail() { return tail_; } const tuple\u003cTail...\u003e\u0026 get_tail() const { return tail_; } template \u003ctypename T, T Index\u003e auto\u0026 operator[](std::integral_constant\u003cT, Index\u003e); private: Head head_; tuple\u003cTail...\u003e tail_; }; template \u003c\u003e class tuple\u003c\u003e {}; template \u003cstd::size_t N\u003e struct tuple_get { template \u003ctypename Head, typename... Tail\u003e static auto\u0026 apply(const tuple\u003cHead, Tail...\u003e\u0026 t) { return tuple_get\u003cN - 1\u003e::apply(t.get_tail()); } }; template \u003c\u003e struct tuple_get\u003c0\u003e { template \u003ctypename Head, typename... Tail\u003e static const Head\u0026 apply(const tuple\u003cHead, Tail...\u003e\u0026 t) { return t.get_head(); } }; template \u003cstd::size_t N, typename... Types\u003e auto\u0026 get(const tuple\u003cTypes...\u003e\u0026 t) { return tuple_get\u003cN\u003e::apply(t); } template \u003ctypename Head, typename... Tail\u003e template \u003ctypename T, T Index\u003e inline auto\u0026 tuple\u003cHead, Tail...\u003e::operator[]( std::integral_constant\u003cT, Index\u003e) { return get\u003cIndex\u003e(*this); } template \u003ctypename... Types\u003e auto make_tuple(Types\u0026\u0026... args) { return tuple\u003cstd::decay_t\u003cTypes\u003e...\u003e(std::forward\u003cTypes\u003e(args)...); } bool operator==(const tuple\u003c\u003e\u0026, const tuple\u003c\u003e\u0026) { return true; } template \u003c typename Head1, typename... Tail1, typename Head2, typename... Tail2, std::enable_if_t\u003csizeof...(Tail1) == sizeof...(Tail2), void*\u003e = nullptr\u003e bool operator==(const tuple\u003cHead1, Tail1...\u003e\u0026 lhs, const tuple\u003cHead2, Tail2...\u003e\u0026 rhs) { return lhs.get_head() == rhs.get_head() \u0026\u0026 lhs.get_tail() == rhs.get_tail(); } void print_tuple(std::ostream\u0026 os, const tuple\u003c\u003e\u0026, bool is_first = true) { os \u003c\u003c (is_first ? '(' : ')'); } template \u003ctypename Head, typename... Tail\u003e void print_tuple(std::ostream\u0026 os, const tuple\u003cHead, Tail...\u003e\u0026 t, bool is_first = true) { os \u003c\u003c (is_first ? \"(\" : \", \") \u003c\u003c t.get_head(); print_tuple(os, t.get_tail(), false); } template \u003ctypename... Types\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const tuple\u003cTypes...\u003e\u0026 t) { print_tuple(os, t); return os; } } // namespace jc namespace jc { // typelist template \u003c\u003e struct is_empty\u003ctuple\u003c\u003e\u003e { static constexpr bool value = true; }; template \u003ctypename Head, typename... Tail\u003e class front\u003ctuple\u003cHead, Tail...\u003e\u003e { public: using type = Head; }; template \u003ctypename Head, typename... Tail\u003e class pop_front\u003ctuple\u003cHead, Tail...\u003e\u003e { public: using type = tuple\u003cTail...\u003e; }; template \u003ctypename... Types, typename Element\u003e class push_front\u003ctuple\u003cTypes...\u003e, Element\u003e { public: using type = tuple\u003cElement, Types...\u003e; }; template \u003ctypename... Types, typename Element\u003e class push_back\u003ctuple\u003cTypes...\u003e, Element\u003e { public: using type = tuple\u003cTypes..., Element\u003e; }; template \u003ctypename... Types\u003e pop_front_t\u003ctuple\u003cTypes...\u003e\u003e pop_front_tuple(const tuple\u003cTypes...\u003e\u0026 t) { return t.get_tail(); } template \u003ctypename... Types, typename V\u003e push_front_t\u003ctuple\u003cTypes...\u003e, V\u003e push_front_tuple(const tuple\u003cTypes...\u003e\u0026 t, const V\u0026 v) { return push_front_t\u003ctuple\u003cTypes...\u003e, V\u003e{v, t}; } template \u003ctypename V\u003e tuple\u003cV\u003e ","date":"2022-06-18","objectID":"/cxx_template/:57:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#stdtuplehttpsencppreferencecomwcpputilitytuple"},{"categories":["编程语言"],"content":" 58 std::variant #include \u003ccassert\u003e #include \u003cexception\u003e #include \u003cnew\u003e // for std::launder() #include \u003csstream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e #include \"typelist.hpp\" namespace jc { class computed_result_type; template \u003ctypename Visitor, typename T\u003e using visit_element_result = decltype(std::declval\u003cVisitor\u003e()(std::declval\u003cT\u003e())); template \u003ctypename R, typename Visitor, typename... Types\u003e struct visit_result { using type = R; }; template \u003ctypename Visitor, typename... Types\u003e struct visit_result\u003ccomputed_result_type, Visitor, Types...\u003e { using type = std::common_type_t\u003cvisit_element_result\u003cVisitor, Types\u003e...\u003e; }; template \u003ctypename R, typename Visitor, typename... Types\u003e using visit_result_t = typename visit_result\u003cR, Visitor, Types...\u003e::type; struct empty_variant : std::exception {}; template \u003ctypename R, typename V, typename Visitor, typename Head, typename... Tail\u003e R variant_visit_impl(V\u0026\u0026 variant, Visitor\u0026\u0026 vis, typelist\u003cHead, Tail...\u003e) { if (variant.template is\u003cHead\u003e()) { return static_cast\u003cR\u003e(std::forward\u003cVisitor\u003e(vis)( std::forward\u003cV\u003e(variant).template get\u003cHead\u003e())); } else if constexpr (sizeof...(Tail) \u003e 0) { return variant_visit_impl\u003cR\u003e(std::forward\u003cV\u003e(variant), std::forward\u003cVisitor\u003e(vis), typelist\u003cTail...\u003e{}); } else { throw empty_variant(); } } template \u003ctypename... Types\u003e class variant_storage { public: unsigned char get_discriminator() const { return discriminator_; } void set_discriminator(unsigned char d) { discriminator_ = d; } void* get_raw_buffer() { return buffer_; } const void* get_raw_buffer() const { return buffer_; } template \u003ctypename T\u003e T* get_buffer_as() { return std::launder(reinterpret_cast\u003cT*\u003e(buffer_)); } template \u003ctypename T\u003e const T* get_buffer_as() const { return std::launder(reinterpret_cast\u003cconst T*\u003e(buffer_)); } private: using largest_t = largest_type_t\u003ctypelist\u003cTypes...\u003e\u003e; alignas(Types...) unsigned char buffer_[sizeof(largest_t)]; unsigned char discriminator_ = 0; }; template \u003ctypename... Types\u003e class variant; template \u003ctypename T, typename... Types\u003e class variant_choice { using Derived = variant\u003cTypes...\u003e; Derived\u0026 get_derived() { return *static_cast\u003cDerived*\u003e(this); } const Derived\u0026 get_derived() const { return *static_cast\u003cconst Derived*\u003e(this); } protected: static constexpr unsigned Discriminator = find_index_of_t\u003ctypelist\u003cTypes...\u003e, T\u003e::value + 1; public: variant_choice() = default; variant_choice(const T\u0026 value) { new (get_derived().get_raw_buffer()) T(value); // CRTP get_derived().set_discriminator(Discriminator); } variant_choice(T\u0026\u0026 value) { new (get_derived().get_raw_buffer()) T(std::move(value)); get_derived().set_discriminator(Discriminator); } bool destroy() { if (get_derived().get_discriminator() == Discriminator) { get_derived().template get_buffer_as\u003cT\u003e()-\u003e~T(); return true; } return false; } Derived\u0026 operator=(const T\u0026 value) { if (get_derived().get_discriminator() == Discriminator) { *get_derived().template get_buffer_as\u003cT\u003e() = value; } else { get_derived().destroy(); new (get_derived().get_raw_buffer()) T(value); get_derived().set_discriminator(Discriminator); } return get_derived(); } Derived\u0026 operator=(T\u0026\u0026 value) { if (get_derived().get_discriminator() == Discriminator) { *get_derived().template get_buffer_as\u003cT\u003e() = std::move(value); } else { get_derived().destroy(); new (get_derived().get_raw_buffer()) T(std::move(value)); get_derived().set_discriminator(Discriminator); } return get_derived(); } }; /* * class variant\u003cint, double, std::string\u003e * : private variant_storage\u003cint, double, std::string\u003e, * private variant_choice\u003cint, int, double, std::string\u003e, * private variant_choice\u003cdouble, int, double, std::string\u003e, * private variant_choice\u003cstd::string, int, double, std::string\u003e {}; * * variant_choice\u003cint, int, double, std::string\u003e::discriminator_ == 1; * variant_choice\u003cdouble, int, double, std::string\u003e::discriminator_ == 2; * variant_choice\u003cstd::string, int, double, std::string\u003e::discriminator_ == 3; */ template \u003ctypename... Types\u003e class varia","date":"2022-06-18","objectID":"/cxx_template/:58:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#stdvarianthttpsencppreferencecomwcpputilityvariant"},{"categories":["编程语言"],"content":" 59 表达式模板（Expression Template） 表达式模板支持对数组像内置类型一样进行数值运算，并且不会产生临时对象 #include \u003ccassert\u003e #include \u003ccstddef\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e class SArray { public: explicit SArray(std::size_t sz) : data_(new T[sz]), sz_(sz) { init(); } SArray(const SArray\u003cT\u003e\u0026 rhs) : data_(new T[rhs.sz_]), sz_(rhs.sz_) { copy(rhs); } SArray\u003cT\u003e\u0026 operator=(const SArray\u003cT\u003e\u0026 rhs) { if (\u0026rhs != this) { copy(rhs); } return *this; } ~SArray() { delete[] data_; } std::size_t size() const { return sz_; } T\u0026 operator[](std::size_t i) { return data_[i]; } const T\u0026 operator[](std::size_t i) const { return data_[i]; } SArray\u003cT\u003e\u0026 operator+=(const SArray\u003cT\u003e\u0026 rhs) { assert(sz_ == rhs.sz_); for (std::size_t i = 0; i \u003c sz_; ++i) { (*this)[i] += rhs[i]; } return *this; } SArray\u003cT\u003e\u0026 operator*=(const SArray\u003cT\u003e\u0026 rhs) { assert(sz_ == rhs.sz_); for (std::size_t i = 0; i \u003c sz_; ++i) { (*this)[i] *= rhs[i]; } return *this; } SArray\u003cT\u003e\u0026 operator*=(const T\u0026 rhs) { for (std::size_t i = 0; i \u003c sz_; ++i) { (*this)[i] *= rhs; } return *this; } protected: void init() { for (std::size_t i = 0; i \u003c sz_; ++i) { data_[i] = T{}; } } void copy(const SArray\u003cT\u003e\u0026 rhs) { assert(sz_ == rhs.sz_); for (std::size_t i = 0; i \u003c sz_; ++i) { data_[i] = rhs.data_[i]; } } private: T* data_; std::size_t sz_; }; template \u003ctypename T\u003e SArray\u003cT\u003e operator+(const SArray\u003cT\u003e\u0026 lhs, const SArray\u003cT\u003e\u0026 rhs) { assert(lhs.size() == rhs.size()); SArray\u003cT\u003e res{lhs.size()}; for (std::size_t i = 0; i \u003c lhs.size(); ++i) { res[i] = lhs[i] + rhs[i]; } return res; } template \u003ctypename T\u003e SArray\u003cT\u003e operator*(const SArray\u003cT\u003e\u0026 lhs, const SArray\u003cT\u003e\u0026 rhs) { assert(lhs.size() == rhs.size()); SArray\u003cT\u003e res{lhs.size()}; for (std::size_t i = 0; i \u003c lhs.size(); ++i) { res[i] = lhs[i] * rhs[i]; } return res; } template \u003ctypename T\u003e SArray\u003cT\u003e operator*(const T\u0026 lhs, const SArray\u003cT\u003e\u0026 rhs) { SArray\u003cT\u003e res{rhs.size()}; for (std::size_t i = 0; i \u003c rhs.size(); ++i) { res[i] = lhs * rhs[i]; } return res; } template \u003ctypename T\u003e class A_Scalar { public: constexpr A_Scalar(const T\u0026 v) : value_(v) {} constexpr const T\u0026 operator[](std::size_t) const { return value_; } constexpr std::size_t size() const { return 0; }; private: const T\u0026 value_; }; template \u003ctypename T\u003e struct A_Traits { using type = const T\u0026; }; template \u003ctypename T\u003e struct A_Traits\u003cA_Scalar\u003cT\u003e\u003e { using type = A_Scalar\u003cT\u003e; }; template \u003ctypename T, typename OP1, typename OP2\u003e class A_Add { public: A_Add(const OP1\u0026 op1, const OP2\u0026 op2) : op1_(op1), op2_(op2) {} T operator[](std::size_t i) const { return op1_[i] + op2_[i]; } std::size_t size() const { assert(op1_.size() == 0 || op2_.size() == 0 || op1_.size() == op2_.size()); return op1_.size() != 0 ? op1_.size() : op2_.size(); } private: typename A_Traits\u003cOP1\u003e::type op1_; typename A_Traits\u003cOP2\u003e::type op2_; }; template \u003ctypename T, typename OP1, typename OP2\u003e class A_Mult { public: A_Mult(const OP1\u0026 op1, const OP2\u0026 op2) : op1_(op1), op2_(op2) {} T operator[](std::size_t i) const { return op1_[i] * op2_[i]; } std::size_t size() const { assert(op1_.size() == 0 || op2_.size() == 0 || op1_.size() == op2_.size()); return op1_.size() != 0 ? op1_.size() : op2_.size(); } private: typename A_Traits\u003cOP1\u003e::type op1_; typename A_Traits\u003cOP2\u003e::type op2_; }; template \u003ctypename T, typename A1, typename A2\u003e class A_Subscript { public: A_Subscript(const A1\u0026 a1, const A2\u0026 a2) : a1_(a1), a2_(a2) {} T\u0026 operator[](std::size_t i) { return const_cast\u003cT\u0026\u003e(a1_[static_cast\u003cstd::size_t\u003e(a2_[i])]); } decltype(auto) operator[](std::size_t i) const { return a1_[static_cast\u003cstd::size_t\u003e(a2_[i])]; } std::size_t size() const { return a2_.size(); } private: const A1\u0026 a1_; const A2\u0026 a2_; }; } // namespace jc namespace jc::test { template \u003ctypename T, typename Rep = SArray\u003cT\u003e\u003e class Array { public: explicit Array(std::size_t i) : r_(i) {} Array(const Rep\u0026 rhs) : r_(rhs) {} Array\u0026 operator=(const Array\u0026 rhs) { assert(size() == rhs.size()); for (std::size_t i = 0; i \u003c rhs.size(); ++i) { r_[i] = rhs[i]; } return *this; } template \u003ctypename T2, t","date":"2022-06-18","objectID":"/cxx_template/:59:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#表达式模板expression-template"},{"categories":["编程语言"],"content":" 60 性能与约束 表达式模板可以提高数组操作性能，跟踪其行为可以发现很多小的内联函数互相调用，调用堆栈分配了很多小的表达式模板对象，因此编译器必须执行完整的内联和去除小对象操作，以产生性能上和手写循环媲美的代码 表达式模板没有解决所有数组数值运算的问题，如对 x = A * x 的运算，A 是 n * n 矩阵，x 是 n 个元素的 vector，临时变量的使用不可避免，因为最终结果的每个元素都依赖于 x 每个元素的初始值，而表达式模板会在一次计算后更新 x 的元素，计算下一个元素时用到已更新的元素就改变了原数组，但针对 x = A * y，如果 x 和 y 不互为别名，就不需要临时对象，因此必须在运行期知道操作数是否为别名关系，即必须生成运行期结构来表示表达式树，而不是在表达式模板的类型中编码这棵树 ","date":"2022-06-18","objectID":"/cxx_template/:60:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#性能与约束"},{"categories":["编程语言"],"content":" 61 浅实例化（Shallow Instantiation） 模板的报错会跟踪导致问题的所有层次，冗长的报错信息使调试变得更为繁琐，真正的问题一般出现在一长串实例化之后 template \u003ctypename T\u003e void f1(T\u0026 i) { *i = 0; // 假设 T 为指针类型 } template \u003ctypename T\u003e void f2(T\u0026 i) { f1(i); } template \u003ctypename T\u003e void f3(typename T::Type i) { f2(i); } template \u003ctypename T\u003e void f4(const T\u0026) { typename T::Type i = 42; f3\u003cT\u003e(i); } struct A { using Type = int; }; int main() { f4(A{}); // 错误，只能在实例化时被检测到 // 实例化 f4\u003cA\u003e(const A\u0026) // 实例化 f3\u003cA\u003e(int) // 实例化 f2\u003cint\u003e(int\u0026) // 实例化 f1\u003cint\u003e(int\u0026)，解引用 int 出错 } /* * error C2100: 非法的间接寻址 * message : 查看对正在编译的函数 模板 实例化“void f1\u003cT\u003e(T \u0026)”的引用 * with * [ * T=A::Type * ] * message : 查看对正在编译的函数 模板 实例化“void f2\u003cA::Type\u003e(T \u0026)”的引用 * with * [ * T=A::Type * ] * message : 查看对正在编译的函数 模板 实例化“void f3\u003cT\u003e(A::Type)”的引用 * with * [ * T=A * ] * message : 查看对正在编译的函数 模板 实例化“void f4\u003cA\u003e(const T \u0026)”的引用 * with * [ * T=A * ] */ 一种简单的减少报错信息长度的方式是提前使用参数 template \u003ctypename T\u003e void f1(T\u0026 i) { *i = 0; // 假设 T 为指针类型 } template \u003ctypename T\u003e void f2(T\u0026 i) { f1(i); } template \u003ctypename T\u003e void f3(typename T::Type i) { f2(i); } template \u003ctypename T\u003e void f4(const T\u0026) { class ShallowChecks { // 未调用，不影响运行期 static void deref(typename T::Type p) { *p; } }; typename T::Type i = 42; f3\u003cT\u003e(i); } struct A { using Type = int; }; int main() { f4(A{}); // 实例化 f4\u003cA\u003e(const A\u0026) 时检测到错误 } /* * error C2100: 非法的间接寻址 * message : 查看对正在编译的函数 模板 实例化“void f4\u003cA\u003e(const T \u0026)”的引用 * with * [ * T=A * ] */ ","date":"2022-06-18","objectID":"/cxx_template/:61:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#浅实例化shallow-instantiation"},{"categories":["编程语言"],"content":" 62 静态断言（Static Assertion） C++11 引入了static_assert，在编译期进行断言，比如下列静态断言确保编译平台带 64 位指针 static_assert(sizeof(void*) * CHAR_BIT == 64, \"Not a 64-bit platform\"); 创建一个检查解引用的 traits，用 static_assert 提供更明确的诊断信息 #include \u003ctype_traits\u003e template \u003ctypename T\u003e class has_dereference { private: template \u003ctypename U\u003e struct Identity; template \u003ctypename U\u003e static std::true_type test(Identity\u003cdecltype(*std::declval\u003cU\u003e())\u003e*); template \u003ctypename U\u003e static std::false_type test(...); public: static constexpr bool value = decltype(test\u003cT\u003e(nullptr))::value; }; template \u003ctypename T\u003e inline constexpr bool has_dereference_v = has_dereference\u003cT\u003e::value; template \u003ctypename T\u003e void f(T\u0026 i) { static_assert(has_dereference_v\u003cT\u003e, \"T is not dereferenceable\"); *i = 0; } int main() { int i = 42; f(i); // static_assert 报错：T is not dereferenceable } C++17 可以用 std::void_t 简化 traits 的实现 #include \u003ctype_traits\u003e template \u003ctypename, typename = std::void_t\u003c\u003e\u003e struct has_dereference : std::false_type {}; template \u003ctypename T\u003e struct has_dereference\u003cT, std::void_t\u003cdecltype(*std::declval\u003cT\u003e())\u003e\u003e : std::true_type {}; template \u003ctypename T\u003e inline constexpr bool has_dereference_v = has_dereference\u003cT\u003e::value; ","date":"2022-06-18","objectID":"/cxx_template/:62:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#静态断言static-assertion"},{"categories":["编程语言"],"content":" 63 Concepts C++20 可以用 concepts 约束类型，代码更简洁 template \u003ctypename T\u003e concept Dereferenceable = requires(T x) { *x; }; template \u003ctypename T\u003e requires Dereferenceable\u003cT\u003e void f(T\u0026 i) { *i = 0; } /* 等价写法 * template \u003ctypename T\u003e * requires requires(T x) { *x; } * void f(T\u0026 i) { * *i = 0; * } */ int main() { int i = 42; f(i); // 未满足关联约束 } ","date":"2022-06-18","objectID":"/cxx_template/:63:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#conceptshttpsencppreferencecomwcppconcepts"},{"categories":["编程语言"],"content":" 64 原型（Archetype） 模板的一个挑战是确保满足特定约束的实参都能通过编译，为了测试满足要求的模板参数，引入原型的概念。原型是用户定义的类，以尽可能小的方式来满足模板大多数要求，而不提供任何外来的操作 // 要求 T 是可比较类型 template \u003ctypename T\u003e int find(const T* a, int n, const T\u0026 v) { int i = 0; while (i != n \u0026\u0026 a[i] != v) { ++i; } return i; } struct EqualityComparable {}; struct ConvertibleToBool { operator bool() const { return true; } // 提供本类型到 bool 的隐式转换 }; ConvertibleToBool // 返回类型要求能转换为 bool operator==(const EqualityComparable\u0026, const EqualityComparable\u0026) { return ConvertibleToBool{}; } // 实例化 find\u003cEqualityComparable\u003e template int find(const EqualityComparable*, int, const EqualityComparable\u0026); int main() {} 实例化将失败，改用 operator== 比较即可解决此问题 template \u003ctypename T\u003e int find(const T* a, int n, const T\u0026 v) { int i = 0; while (i != n \u0026\u0026 !(a[i] == v)) { ++i; } return i; } 但这又在无意中对结果使用了 operator!，如果要发现这点，在 ConvertibleToBool 中禁用 operator! 即可，当其被使用时将报错 struct ConvertibleToBool { operator bool() const { return true; } bool operator!() = delete; }; 可以再对原型做其他扩展，比如禁用 operator\u0026\u0026 和 operator|| 来找出其他的一些模板定义中的问题 ","date":"2022-06-18","objectID":"/cxx_template/:64:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#原型archetype"},{"categories":["编程语言"],"content":" 65 跟踪程序（Tracer） 以上都是编译或链接时的 bug，更大的挑战是确保程序在运行期表现正确 Tracer 是一个用户定义的类，它能用作要测试的模板的实参。通常 tracer 也是一个原型，但包含一些额外的信息。下面是一个用于测试 std::sort 的 tracer，它提供 std::sort 需要的功能（比如 operator== 和 operator\u003e），并给出算法开销的直观结果，但不揭示排序模板的正确性 #include \u003calgorithm\u003e #include \u003ciostream\u003e class SortTracer { public: static long creations() { return n_created; } static long destructions() { return n_destroyed; } static long assignments() { return n_assigned; } static long comparisons() { return n_compared; } static long max_live() { return n_max_live; } public: SortTracer(int v = 0) : value(v), generation(1) { ++n_created; update_max_live(); std::cerr \u003c\u003c \"SortTracer #\" \u003c\u003c n_created \u003c\u003c \", created generation \" \u003c\u003c generation \u003c\u003c \" (total: \" \u003c\u003c n_created - n_destroyed \u003c\u003c \")\\n\"; } SortTracer(const SortTracer\u0026 rhs) : value(rhs.value), generation(rhs.generation + 1) { ++n_created; update_max_live(); std::cerr \u003c\u003c \"SortTracer #\" \u003c\u003c n_created \u003c\u003c \", copied as generation \" \u003c\u003c generation \u003c\u003c \" (total: \" \u003c\u003c n_created - n_destroyed \u003c\u003c \")\\n\"; } ~SortTracer() { ++n_destroyed; update_max_live(); std::cerr \u003c\u003c \"SortTracer generation \" \u003c\u003c generation \u003c\u003c \" destroyed (total: \" \u003c\u003c n_created - n_destroyed \u003c\u003c \")\\n\"; } SortTracer\u0026 operator=(const SortTracer\u0026 rhs) { ++n_assigned; std::cerr \u003c\u003c \"SortTracer assignment #\" \u003c\u003c n_assigned \u003c\u003c \" (generation \" \u003c\u003c generation \u003c\u003c \" = \" \u003c\u003c rhs.generation \u003c\u003c \")\\n\"; value = rhs.value; return *this; } friend bool operator\u003c(const SortTracer\u0026 lhs, const SortTracer\u0026 rhs) { ++n_compared; std::cerr \u003c\u003c \"SortTracer comparison #\" \u003c\u003c n_compared \u003c\u003c \" (generation \" \u003c\u003c lhs.generation \u003c\u003c \" \u003c \" \u003c\u003c rhs.generation \u003c\u003c \")\\n\"; return lhs.value \u003c rhs.value; } int val() const { return value; } private: int value; // integer value to be sorted int generation; // generation of this tracer inline static long n_created = 0; // number of constructor calls inline static long n_destroyed = 0; // number of destructor calls inline static long n_assigned = 0; // number of assignments inline static long n_compared = 0; // number of comparisons inline static long n_max_live = 0; // maximum of existing objects // recompute maximum of existing objects static void update_max_live() { if (n_created - n_destroyed \u003e n_max_live) { n_max_live = n_created - n_destroyed; } } }; int main() { SortTracer input[] = {7, 3, 5, 6, 4, 2, 0, 1, 9, 8}; // 打印初始值 for (int i = 0; i \u003c 10; ++i) { std::cerr \u003c\u003c input[i].val() \u003c\u003c ' '; } std::cerr \u003c\u003c '\\n'; // 记录初始条件 long created_at_start = SortTracer::creations(); long max_live_at_start = SortTracer::max_live(); long assigned_at_start = SortTracer::assignments(); long compared_at_start = SortTracer::comparisons(); // 执行 std::cerr \u003c\u003c \"---[ Start std::sort() ]--------------------\\n\"; std::sort\u003c\u003e(\u0026input[0], \u0026input[9] + 1); std::cerr \u003c\u003c \"---[ End std::sort() ]----------------------\\n\"; // 检查结果 for (int i = 0; i \u003c 10; ++i) { std::cerr \u003c\u003c input[i].val() \u003c\u003c ' '; } std::cerr \u003c\u003c \"\\n\\n\"; // final report std::cerr \u003c\u003c \"std::sort() of 10 SortTracer's was performed by:\\n\" \u003c\u003c SortTracer::creations() - created_at_start \u003c\u003c \" temporary tracers\\n\" \u003c\u003c \"up to \" \u003c\u003c SortTracer::max_live() \u003c\u003c \" tracers at the same time (\" \u003c\u003c max_live_at_start \u003c\u003c \" before)\\n\" \u003c\u003c SortTracer::assignments() - assigned_at_start \u003c\u003c \" assignments\\n\" \u003c\u003c SortTracer::comparisons() - compared_at_start \u003c\u003c \" comparisons\\n\\n\"; } /* * SortTracer #1, created generation 1 (total: 1) * SortTracer #2, created generation 1 (total: 2) * SortTracer #3, created generation 1 (total: 3) * SortTracer #4, created generation 1 (total: 4) * SortTracer #5, created generation 1 (total: 5) * SortTracer #6, created generation 1 (total: 6) * SortTracer #7, created generation 1 (total: 7) * SortTracer #8, created generation 1 (total: 8) * SortTracer #9, created generation 1 (total: 9) * SortTracer #10, created generation 1 (total: 10) * 7 3 5 6 4 2 0 1 9 8 * ---[ Start std::sort() ]-------------------- * SortTracer #11, copied as generation 2 (total: 11) * SortTracer comparison #1 (generation 2 \u003c 1) * SortTracer comparison #2 (generation 1 \u003c 2) *","date":"2022-06-18","objectID":"/cxx_template/:65:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#跟踪程序tracer"},{"categories":["rootfs"],"content":"Buildroot构建文件系统 ","date":"2022-03-13","objectID":"/buildroot/:0:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#"},{"categories":["rootfs"],"content":" 1 下载buildroot git clone --depth=1 https://git.busybox.net/buildroot git branch -a [new branch] git checkout [new branch] ","date":"2022-03-13","objectID":"/buildroot/:1:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#下载buildroot"},{"categories":["rootfs"],"content":" 2 快速开始 可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026\u0026 make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh ","date":"2022-03-13","objectID":"/buildroot/:2:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#快速开始"},{"categories":["rootfs"],"content":" 3 基础配置","date":"2022-03-13","objectID":"/buildroot/:3:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#基础配置"},{"categories":["rootfs"],"content":" 3.1 使用自定义的内核在defconfig文件中添加下面的配置 BR2_LINUX_KERNEL=y # 是否编译内核 BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"git@github.com:mengdemao/kernel.git\" # kernel的地址 BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"master\" # 版本 BR2_LINUX_KERNEL_VERSION=\"master\" BR2_LINUX_KERNEL_USE_DEFCONFIG=y BR2_LINUX_KERNEL_DEFCONFIG=\"debian\" BR2_LINUX_KERNEL_ZIMAGE=y BR2_LINUX_KERNEL_GZIP=y ","date":"2022-03-13","objectID":"/buildroot/:3:1","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#使用自定义的内核"},{"categories":["环境搭建"],"content":" 1 nfs","date":"2022-01-28","objectID":"/linux_developer_server/:1:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#nfs"},{"categories":["环境搭建"],"content":" 1.1 安装 sudo apt-get install nfs-kernel-server ","date":"2022-01-28","objectID":"/linux_developer_server/:1:1","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#安装"},{"categories":["环境搭建"],"content":" 1.2 设置导出 /home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) ","date":"2022-01-28","objectID":"/linux_developer_server/:1:2","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#设置导出"},{"categories":["环境搭建"],"content":" 1.3 开启服务 sudo /etc/init.d/nfs-kernel-server restart ","date":"2022-01-28","objectID":"/linux_developer_server/:1:3","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#开启服务"},{"categories":["环境搭建"],"content":" 1.4 测试 sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt ls /mnt ","date":"2022-01-28","objectID":"/linux_developer_server/:1:4","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#测试"},{"categories":["环境搭建"],"content":" 2 samba","date":"2022-01-28","objectID":"/linux_developer_server/:2:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#samba"},{"categories":["环境搭建"],"content":" 3 tftp","date":"2022-01-28","objectID":"/linux_developer_server/:3:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#tftp"},{"categories":["环境搭建"],"content":" 4 ftp","date":"2022-01-28","objectID":"/linux_developer_server/:4:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#ftp"},{"categories":["环境搭建"],"content":" 5 apache","date":"2022-01-28","objectID":"/linux_developer_server/:5:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#apache"},{"categories":["linux"],"content":" 需要处理的问题? 如何确定哪个进程可以运行 进程切换发生后,老的进程去了哪里,新的进程如何变化 PLET实现中,谁负责移动调度实体 ","date":"2021-10-28","objectID":"/cfs/:0:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#"},{"categories":["linux"],"content":" 1 虚拟时间(vruntime) static u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw) { u64 fact = scale_load_down(weight); int shift = WMULT_SHIFT; __update_inv_weight(lw); if (unlikely(fact \u003e\u003e 32)) { while (fact \u003e\u003e 32) { fact \u003e\u003e= 1; shift--; } } /* hint to use a 32x32-\u003e64 mul */ fact = (u64)(u32)fact * lw-\u003einv_weight; while (fact \u003e\u003e 32) { fact \u003e\u003e= 1; shift--; } return mul_u64_u32_shr(delta_exec, fact, shift); } static inline u64 calc_delta_fair(u64 delta, struct sched_entity *se) { if (unlikely(se-\u003eload.weight != NICE_0_LOAD)) delta = __calc_delta(delta, NICE_0_LOAD, \u0026se-\u003eload); return delta; } 最后得到公式 $$ vruntime = \\frac{{delta\\_exec} \\times {nice\\_0\\_weight} \\times {2 ^ {32}}}{weight} $$ ","date":"2021-10-28","objectID":"/cfs/:1:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#虚拟时间vruntime"},{"categories":["linux"],"content":" 2 负载追踪(PLET) struct sched_avg { /* * These sums represent an infinite geometric series and so are bound * above by 1024/(1-y). Thus we only need a u32 to store them for all * choices of y \u003c 1-2^(-32)*1024. */ u32 runnable_avg_sum; // 调度实体在就绪队列 u32 runnable_avg_period; // 调度实体在系统中 u64 last_runnable_update; // 上次更新时间 s64 decay_count; // 衰变计数 unsigned long load_avg_contrib; // 进程平均负载贡献度 }; static __always_inline u64 decay_load(u64 val, u64 n) { unsigned int local_n; if (!n) return val; else if (unlikely(n \u003e LOAD_AVG_PERIOD * 63)) return 0; /* after bounds checking we can collapse to 32-bit */ local_n = n; /* * As y^PERIOD = 1/2, we can combine * y^n = 1/2^(n/PERIOD) * y^(n%PERIOD) * With a look-up table which covers y^n (n\u003cPERIOD) * * To achieve constant time decay_load. */ if (unlikely(local_n \u003e= LOAD_AVG_PERIOD)) { val \u003e\u003e= local_n / LOAD_AVG_PERIOD; local_n %= LOAD_AVG_PERIOD; } val *= runnable_avg_yN_inv[local_n]; /* We don't use SRR here since we always want to round down. */ return val \u003e\u003e 32; } static u32 __compute_runnable_contrib(u64 n) { u32 contrib = 0; if (likely(n \u003c= LOAD_AVG_PERIOD)) return runnable_avg_yN_sum[n]; else if (unlikely(n \u003e= LOAD_AVG_MAX_N)) return LOAD_AVG_MAX; /* Compute \\Sum k^n combining precomputed values for k^i, \\Sum k^j */ do { contrib /= 2; /* y^LOAD_AVG_PERIOD = 1/2 */ contrib += runnable_avg_yN_sum[LOAD_AVG_PERIOD]; n -= LOAD_AVG_PERIOD; } while (n \u003e LOAD_AVG_PERIOD); contrib = decay_load(contrib, n); return contrib + runnable_avg_yN_sum[n]; } static __always_inline int __update_entity_runnable_avg(u64 now, struct sched_avg *sa, int runnable) { u64 delta, periods; u32 runnable_contrib; int delta_w, decayed = 0; delta = now - sa-\u003elast_runnable_update; /* * This should only happen when time goes backwards, which it * unfortunately does during sched clock init when we swap over to TSC. */ if ((s64)delta \u003c 0) { sa-\u003elast_runnable_update = now; return 0; } /* * Use 1024ns as the unit of measurement since it's a reasonable * approximation of 1us and fast to compute. */ delta \u003e\u003e= 10; if (!delta) return 0; sa-\u003elast_runnable_update = now; /* delta_w is the amount already accumulated against our next period */ delta_w = sa-\u003erunnable_avg_period % 1024; if (delta + delta_w \u003e= 1024) { /* period roll-over */ decayed = 1; /* * Now that we know we're crossing a period boundary, figure * out how much from delta we need to complete the current * period and accrue it. */ delta_w = 1024 - delta_w; if (runnable) sa-\u003erunnable_avg_sum += delta_w; sa-\u003erunnable_avg_period += delta_w; delta -= delta_w; /* Figure out how many additional periods this update spans */ periods = delta / 1024; delta %= 1024; sa-\u003erunnable_avg_sum = decay_load(sa-\u003erunnable_avg_sum, periods + 1); sa-\u003erunnable_avg_period = decay_load(sa-\u003erunnable_avg_period, periods + 1); /* Efficiently calculate \\sum (1..n_period) 1024*y^i */ runnable_contrib = __compute_runnable_contrib(periods); if (runnable) sa-\u003erunnable_avg_sum += runnable_contrib; sa-\u003erunnable_avg_period += runnable_contrib; } /* Remainder of delta accrued against u_0` */ if (runnable) sa-\u003erunnable_avg_sum += delta; sa-\u003erunnable_avg_period += delta; return decayed; } static inline void update_entity_load_avg(struct sched_entity *se, int update_cfs_rq) { struct cfs_rq *cfs_rq = cfs_rq_of(se); long contrib_delta; u64 now; /* * For a group entity we need to use their owned cfs_rq_clock_task() in * case they are the parent of a throttled hierarchy. */ if (entity_is_task(se)) now = cfs_rq_clock_task(cfs_rq); else now = cfs_rq_clock_task(group_cfs_rq(se)); if (!__update_entity_runnable_avg(now, \u0026se-\u003eavg, se-\u003eon_rq)) return; contrib_delta = __update_entity_load_avg_contrib(se); if (!update_cfs_rq) return; if (se-\u003eon_rq) cfs_rq-\u003erunnable_load_avg += contrib_delta; else subtract_blocked_load_contrib(cfs_rq, -contrib_delta); } static inline void __update_task_entity_contrib(struct sched_entity *se) { u32 contrib; /* avoid overflowing a 32-bit type w/ SCHED_LOAD_SCALE */ contrib = se-\u003eavg.runnable_avg_","date":"2021-10-28","objectID":"/cfs/:2:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#负载追踪plet"},{"categories":["linux"],"content":" 3 调度器类 const struct sched_class fair_sched_class = { .next = \u0026idle_sched_class, .enqueue_task = enqueue_task_fair, .dequeue_task = dequeue_task_fair, .yield_task = yield_task_fair, .yield_to_task = yield_to_task_fair, .check_preempt_curr = check_preempt_wakeup, .pick_next_task = pick_next_task_fair, .put_prev_task = put_prev_task_fair, #ifdef CONFIG_SMP .select_task_rq = select_task_rq_fair, .migrate_task_rq = migrate_task_rq_fair, .rq_online = rq_online_fair, .rq_offline = rq_offline_fair, .task_dead = task_dead_fair, .set_cpus_allowed = set_cpus_allowed_common, #endif .set_curr_task = set_curr_task_fair, .task_tick = task_tick_fair, .task_fork = task_fork_fair, .prio_changed = prio_changed_fair, .switched_from = switched_from_fair, .switched_to = switched_to_fair, .get_rr_interval = get_rr_interval_fair, .update_curr = update_curr_fair, #ifdef CONFIG_FAIR_GROUP_SCHED .task_change_group = task_change_group_fair, #endif }; 调度器类分析 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf); void (*put_prev_task)(struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int new_cpu); void (*task_woken)(struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task)(struct rq *rq); void (*task_tick)(struct rq *rq, struct task_struct *p, int queued); void (*task_fork)(struct task_struct *p); void (*task_dead)(struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from)(struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval)(struct rq *rq, struct task_struct *task); void (*update_curr)(struct rq *rq); #define TASK_SET_GROUP 0 #define TASK_MOVE_GROUP 1 #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_change_group)(struct task_struct *p, int type); #endif }; ","date":"2021-10-28","objectID":"/cfs/:3:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#调度器类"},{"categories":["linux"],"content":" 4 enqueue_task_fair static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; /* * The code below (indirectly) updates schedutil which looks at * the cfs_rq utilization to select a frequency. * Let's add the task's estimated utilization to the cfs_rq's * estimated utilization, before we update schedutil. */ util_est_enqueue(\u0026rq-\u003ecfs, p); /* * If in_iowait is set, the code below may not trigger any cpufreq * utilization updates, so do it here explicitly with the IOWAIT flag * passed. */ if (p-\u003ein_iowait) cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); for_each_sched_entity(se) { if (se-\u003eon_rq) break; cfs_rq = cfs_rq_of(se); enqueue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running increment below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running++; flags = ENQUEUE_WAKEUP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running++; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) add_nr_running(rq, 1); if (cfs_bandwidth_used()) { /* * When bandwidth control is enabled; the cfs_rq_throttled() * breaks in the above iteration can result in incomplete * leaf list maintenance, resulting in triggering the assertion * below. */ for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); if (list_add_leaf_cfs_rq(cfs_rq)) break; } } assert_list_leaf_cfs_rq(rq); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/cfs/:4:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#enqueue_task_fair"},{"categories":["linux"],"content":" 5 dequeue_task_fair 将任务从CFS队列中移除 static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; int task_sleep = flags \u0026 DEQUEUE_SLEEP; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); dequeue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running decrement below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running--; /* Don't dequeue parent if it has other entities besides us */ if (cfs_rq-\u003eload.weight) { /* Avoid re-evaluating load for this entity: */ se = parent_entity(se); /* * Bias pick_next to pick a task from this cfs_rq, as * p is sleeping when it is within its sched_slice. */ if (task_sleep \u0026\u0026 se \u0026\u0026 !throttled_hierarchy(cfs_rq)) set_next_buddy(se); break; } flags |= DEQUEUE_SLEEP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running--; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) sub_nr_running(rq, 1); util_est_dequeue(\u0026rq-\u003ecfs, p, task_sleep); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/cfs/:5:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#dequeue_task_fair"},{"categories":["linux"],"content":" 6 yield_task_fair static void yield_task_fair(struct rq *rq) { struct task_struct *curr = rq-\u003ecurr; struct cfs_rq *cfs_rq = task_cfs_rq(curr); struct sched_entity *se = \u0026curr-\u003ese; /* * Are we the only task in the tree? */ if (unlikely(rq-\u003enr_running == 1)) return; clear_buddies(cfs_rq, se); if (curr-\u003epolicy != SCHED_BATCH) { update_rq_clock(rq); /* * Update run-time statistics of the 'current'. */ update_curr(cfs_rq); /* * Tell update_rq_clock() that we've just updated, * so we don't do microscopic update in schedule() * and double the fastpath cost. */ rq_clock_skip_update(rq, true); } set_skip_buddy(se); } ","date":"2021-10-28","objectID":"/cfs/:6:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#yield_task_fair"},{"categories":["linux"],"content":" 7 yield_to_task_fair static bool yield_to_task_fair(struct rq *rq, struct task_struct *p, bool preempt) { struct sched_entity *se = \u0026p-\u003ese; /* throttled hierarchies are not runnable */ if (!se-\u003eon_rq || throttled_hierarchy(cfs_rq_of(se))) return false; /* Tell the scheduler that we'd really like pse to run next. */ set_next_buddy(se); yield_task_fair(rq); return true; } ","date":"2021-10-28","objectID":"/cfs/:7:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#yield_to_task_fair"},{"categories":["linux"],"content":" 8 check_preempt_wakeup static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) { struct task_struct *curr = rq-\u003ecurr; struct sched_entity *se = \u0026curr-\u003ese, *pse = \u0026p-\u003ese; struct cfs_rq *cfs_rq = task_cfs_rq(curr); int scale = cfs_rq-\u003enr_running \u003e= sched_nr_latency; int next_buddy_marked = 0; if (unlikely(se == pse)) return; /* * This is possible from callers such as attach_tasks(), in which we * unconditionally check_prempt_curr() after an enqueue (which may have * lead to a throttle). This both saves work and prevents false * next-buddy nomination below. */ if (unlikely(throttled_hierarchy(cfs_rq_of(pse)))) return; if (sched_feat(NEXT_BUDDY) \u0026\u0026 scale \u0026\u0026 !(wake_flags \u0026 WF_FORK)) { set_next_buddy(pse); next_buddy_marked = 1; } /* * We can come here with TIF_NEED_RESCHED already set from new task * wake up path. * * Note: this also catches the edge-case of curr being in a throttled * group (e.g. via set_curr_task), since update_curr() (in the * enqueue of curr) will have resulted in resched being set. This * prevents us from potentially nominating it as a false LAST_BUDDY * below. */ if (test_tsk_need_resched(curr)) return; /* Idle tasks are by definition preempted by non-idle tasks. */ if (unlikely(curr-\u003epolicy == SCHED_IDLE) \u0026\u0026 likely(p-\u003epolicy != SCHED_IDLE)) goto preempt; /* * Batch and idle tasks do not preempt non-idle tasks (their preemption * is driven by the tick): */ if (unlikely(p-\u003epolicy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION)) return; find_matching_se(\u0026se, \u0026pse); update_curr(cfs_rq_of(se)); BUG_ON(!pse); if (wakeup_preempt_entity(se, pse) == 1) { /* * Bias pick_next to pick the sched entity that is * triggering this preemption. */ if (!next_buddy_marked) set_next_buddy(pse); goto preempt; } return; preempt: resched_curr(rq); /* * Only set the backward buddy when the current task is still * on the rq. This can happen when a wakeup gets interleaved * with schedule on the -\u003epre_schedule() or idle_balance() * point, either of which can * drop the rq lock. * * Also, during early boot the idle thread is in the fair class, * for obvious reasons its a bad idea to schedule back to it. */ if (unlikely(!se-\u003eon_rq || curr == rq-\u003eidle)) return; if (sched_feat(LAST_BUDDY) \u0026\u0026 scale \u0026\u0026 entity_is_task(se)) set_last_buddy(se); } ","date":"2021-10-28","objectID":"/cfs/:8:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#check_preempt_wakeup"},{"categories":["linux"],"content":" 9 pick_next_task_fair static struct task_struct * pick_next_task_fair(struct rq *rq, struct task_struct *prev) { struct cfs_rq *cfs_rq = \u0026rq-\u003ecfs; struct sched_entity *se; struct task_struct *p; int new_tasks; again: #ifdef CONFIG_FAIR_GROUP_SCHED if (!cfs_rq-\u003enr_running) goto idle; if (prev-\u003esched_class != \u0026fair_sched_class) goto simple; /* * Because of the set_next_buddy() in dequeue_task_fair() it is rather * likely that a next task is from the same cgroup as the current. * * Therefore attempt to avoid putting and setting the entire cgroup * hierarchy, only change the part that actually changes. */ do { struct sched_entity *curr = cfs_rq-\u003ecurr; /* * Since we got here without doing put_prev_entity() we also * have to consider cfs_rq-\u003ecurr. If it is still a runnable * entity, update_curr() will update its vruntime, otherwise * forget we've ever seen it. */ if (curr \u0026\u0026 curr-\u003eon_rq) update_curr(cfs_rq); else curr = NULL; /* * This call to check_cfs_rq_runtime() will do the throttle and * dequeue its entity in the parent(s). Therefore the 'simple' * nr_running test will indeed be correct. */ if (unlikely(check_cfs_rq_runtime(cfs_rq))) goto simple; se = pick_next_entity(cfs_rq, curr); cfs_rq = group_cfs_rq(se); } while (cfs_rq); p = task_of(se); /* * Since we haven't yet done put_prev_entity and if the selected task * is a different task than we started out with, try and touch the * least amount of cfs_rqs. */ if (prev != p) { struct sched_entity *pse = \u0026prev-\u003ese; while (!(cfs_rq = is_same_group(se, pse))) { int se_depth = se-\u003edepth; int pse_depth = pse-\u003edepth; if (se_depth \u003c= pse_depth) { put_prev_entity(cfs_rq_of(pse), pse); pse = parent_entity(pse); } if (se_depth \u003e= pse_depth) { set_next_entity(cfs_rq_of(se), se); se = parent_entity(se); } } put_prev_entity(cfs_rq, pse); set_next_entity(cfs_rq, se); } if (hrtick_enabled(rq)) hrtick_start_fair(rq, p); return p; simple: cfs_rq = \u0026rq-\u003ecfs; #endif if (!cfs_rq-\u003enr_running) goto idle; put_prev_task(rq, prev); do { se = pick_next_entity(cfs_rq, NULL); set_next_entity(cfs_rq, se); cfs_rq = group_cfs_rq(se); } while (cfs_rq); p = task_of(se); if (hrtick_enabled(rq)) hrtick_start_fair(rq, p); return p; idle: new_tasks = idle_balance(rq); /* * Because idle_balance() releases (and re-acquires) rq-\u003elock, it is * possible for any higher priority task to appear. In that case we * must re-start the pick_next_entity() loop. */ if (new_tasks \u003c 0) return RETRY_TASK; if (new_tasks \u003e 0) goto again; return NULL; } ","date":"2021-10-28","objectID":"/cfs/:9:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#pick_next_task_fair"},{"categories":["linux"],"content":" 10 put_prev_task_fair static void put_prev_task_fair(struct rq *rq, struct task_struct *prev) { struct sched_entity *se = \u0026prev-\u003ese; struct cfs_rq *cfs_rq; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); put_prev_entity(cfs_rq, se); } } ","date":"2021-10-28","objectID":"/cfs/:10:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#put_prev_task_fair"},{"categories":["linux"],"content":" 11 set_curr_task_fair static void set_curr_task_fair(struct rq *rq) { struct sched_entity *se = \u0026rq-\u003ecurr-\u003ese; for_each_sched_entity(se) { struct cfs_rq *cfs_rq = cfs_rq_of(se); set_next_entity(cfs_rq, se); /* ensure bandwidth has been allocated on our new cfs_rq */ account_cfs_rq_runtime(cfs_rq, 0); } } ","date":"2021-10-28","objectID":"/cfs/:11:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#set_curr_task_fair"},{"categories":["linux"],"content":" 12 task_tick_fair static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026curr-\u003ese; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); entity_tick(cfs_rq, se, queued); } if (numabalancing_enabled) task_tick_numa(rq, curr); update_rq_runnable_avg(rq, 1); } ","date":"2021-10-28","objectID":"/cfs/:12:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#task_tick_fair"},{"categories":["linux"],"content":" 13 task_fork_fair static void task_fork_fair(struct task_struct *p) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese, *curr; int this_cpu = smp_processor_id(); struct rq *rq = this_rq(); unsigned long flags; raw_spin_lock_irqsave(\u0026rq-\u003elock, flags); update_rq_clock(rq); cfs_rq = task_cfs_rq(current); curr = cfs_rq-\u003ecurr; /* * Not only the cpu but also the task_group of the parent might have * been changed after parent-\u003ese.parent,cfs_rq were copied to * child-\u003ese.parent,cfs_rq. So call __set_task_cpu() to make those * of child point to valid ones. */ rcu_read_lock(); __set_task_cpu(p, this_cpu); rcu_read_unlock(); update_curr(cfs_rq); if (curr) se-\u003evruntime = curr-\u003evruntime; place_entity(cfs_rq, se, 1); if (sysctl_sched_child_runs_first \u0026\u0026 curr \u0026\u0026 entity_before(curr, se)) { /* * Upon rescheduling, sched_class::put_prev_task() will place * 'current' within the tree based on its new key value. */ swap(curr-\u003evruntime, se-\u003evruntime); resched_curr(rq); } se-\u003evruntime -= cfs_rq-\u003emin_vruntime; raw_spin_unlock_irqrestore(\u0026rq-\u003elock, flags); } ","date":"2021-10-28","objectID":"/cfs/:13:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#task_fork_fair"},{"categories":["linux"],"content":" 14 update_curr_fair static void update_curr_fair(struct rq *rq) { update_curr(cfs_rq_of(\u0026rq-\u003ecurr-\u003ese)); } static void update_curr(struct cfs_rq *cfs_rq) { struct sched_entity *curr = cfs_rq-\u003ecurr; u64 now = rq_clock_task(rq_of(cfs_rq)); u64 delta_exec; if (unlikely(!curr)) return; delta_exec = now - curr-\u003eexec_start; if (unlikely((s64)delta_exec \u003c= 0)) return; curr-\u003eexec_start = now; schedstat_set(curr-\u003estatistics.exec_max, max(delta_exec, curr-\u003estatistics.exec_max)); curr-\u003esum_exec_runtime += delta_exec; schedstat_add(cfs_rq, exec_clock, delta_exec); curr-\u003evruntime += calc_delta_fair(delta_exec, curr); update_min_vruntime(cfs_rq); if (entity_is_task(curr)) { struct task_struct *curtask = task_of(curr); trace_sched_stat_runtime(curtask, delta_exec, curr-\u003evruntime); cpuacct_charge(curtask, delta_exec); account_group_exec_runtime(curtask, delta_exec); } account_cfs_rq_runtime(cfs_rq, delta_exec); } ","date":"2021-10-28","objectID":"/cfs/:14:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#update_curr_fair"},{"categories":["linux"],"content":"物理页面分配器","date":"2021-10-28","objectID":"/page_allocator/","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/"},{"categories":["linux"],"content":" 1 alloc_pageslinux常用的物理界面分配器的函数是alloc_pages,下面分析是如何实现的. #define alloc_pages(gfp_mask, order) alloc_pages_node(numa_node_id(), gfp_mask, order) static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order) { /* Unknown node is current node */ if (nid \u003c 0) nid = numa_node_id(); return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask)); } static inline struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist) { return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL); } 此时正式进入函数分析阶段 /** * @brief 分配物理页面 * @param gfp_mask 分配掩码 * @param order 分配阶数 * @param zonelist 内存区域 * @param nodemask 节点掩码 * @return struct page* 分配的物理页面 */ struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist, nodemask_t *nodemask); 详细解析接口实现 分配掩码 // 分配掩码就是一个unsigned int类型 typedef unsigned __bitwise__ gfp_t; #define ___GFP_DMA 0x01u #define ___GFP_HIGHMEM 0x02u #define ___GFP_DMA32 0x04u #define ___GFP_MOVABLE 0x08u #define ___GFP_WAIT 0x10u #define ___GFP_HIGH 0x20u #define ___GFP_IO 0x40u #define ___GFP_FS 0x80u #define ___GFP_COLD 0x100u #define ___GFP_NOWARN 0x200u #define ___GFP_REPEAT 0x400u #define ___GFP_NOFAIL 0x800u #define ___GFP_NORETRY 0x1000u #define ___GFP_MEMALLOC 0x2000u #define ___GFP_COMP 0x4000u #define ___GFP_ZERO 0x8000u #define ___GFP_NOMEMALLOC 0x10000u #define ___GFP_HARDWALL 0x20000u #define ___GFP_THISNODE 0x40000u #define ___GFP_RECLAIMABLE 0x80000u #define ___GFP_NOTRACK 0x200000u #define ___GFP_NO_KSWAPD 0x400000u #define ___GFP_OTHER_NODE 0x800000u #define ___GFP_WRITE 0x1000000u #define __force __attribute__((force)) #define __GFP_DMA ((__force gfp_t)___GFP_DMA) #define __GFP_HIGHMEM ((__force gfp_t)___GFP_HIGHMEM) #define __GFP_DMA32 ((__force gfp_t)___GFP_DMA32) #define __GFP_MOVABLE ((__force gfp_t)___GFP_MOVABLE) /* Page is movable */ #define __GFP_WAIT ((__force gfp_t)___GFP_WAIT) /* Can wait and reschedule? */ #define __GFP_HIGH ((__force gfp_t)___GFP_HIGH) /* Should access emergency pools? */ #define __GFP_IO ((__force gfp_t)___GFP_IO) /* Can start physical IO? */ #define __GFP_FS ((__force gfp_t)___GFP_FS) /* Can call down to low-level FS? */ #define __GFP_COLD ((__force gfp_t)___GFP_COLD) /* Cache-cold page required */ #define __GFP_NOWARN ((__force gfp_t)___GFP_NOWARN) /* Suppress page allocation failure warning */ #define __GFP_REPEAT ((__force gfp_t)___GFP_REPEAT) /* See above */ #define __GFP_NOFAIL ((__force gfp_t)___GFP_NOFAIL) /* See above */ #define __GFP_NORETRY ((__force gfp_t)___GFP_NORETRY) /* See above */ #define __GFP_MEMALLOC ((__force gfp_t)___GFP_MEMALLOC)/* Allow access to emergency reserves */ #define __GFP_COMP ((__force gfp_t)___GFP_COMP) /* Add compound page metadata */ #define __GFP_ZERO ((__force gfp_t)___GFP_ZERO) /* Return zeroed page on success */ #define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC) /* Don't use emergency reserves. * This takes precedence over the * __GFP_MEMALLOC flag if both are * set */ #define __GFP_HARDWALL ((__force gfp_t)___GFP_HARDWALL) /* Enforce hardwall cpuset memory allocs */ #define __GFP_THISNODE ((__force gfp_t)___GFP_THISNODE)/* No fallback, no policies */ #define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) /* Page is reclaimable */ #define __GFP_NOTRACK ((__force gfp_t)___GFP_NOTRACK) /* Don't track with kmemcheck */ #define __GFP_NO_KSWAPD ((__force gfp_t)___GFP_NO_KSWAPD) #define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) /* On behalf of other node */ #define __GFP_WRITE ((__force gfp_t)___GFP_WRITE) /* Allocator intends to dirty page */ 分配阶数 描述分配的大小 $$ {page_number} = 2 ^ {order} $$ 内存区域 zone令行分析 节点掩码 nodemask令行分析 ","date":"2021-10-28","objectID":"/page_allocator/:1:0","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#alloc_pages"},{"categories":["linux"],"content":" 1.1 __alloc_pages_nodemask struct page * __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist, nodemask_t *nodemask) { struct zoneref *preferred_zoneref; struct page *page = NULL; unsigned int cpuset_mems_cookie; int alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET|ALLOC_FAIR; gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */ struct alloc_context ac = { .high_zoneidx = gfp_zone(gfp_mask), .nodemask = nodemask, .migratetype = gfpflags_to_migratetype(gfp_mask), }; gfp_mask \u0026= gfp_allowed_mask; lockdep_trace_alloc(gfp_mask); might_sleep_if(gfp_mask \u0026 __GFP_WAIT); if (should_fail_alloc_page(gfp_mask, order)) return NULL; /* * Check the zones suitable for the gfp_mask contain at least one * valid zone. It's possible to have an empty zonelist as a result * of GFP_THISNODE and a memoryless node */ if (unlikely(!zonelist-\u003e_zonerefs-\u003ezone)) return NULL; if (IS_ENABLED(CONFIG_CMA) \u0026\u0026 ac.migratetype == MIGRATE_MOVABLE) alloc_flags |= ALLOC_CMA; retry_cpuset: cpuset_mems_cookie = read_mems_allowed_begin(); /* We set it here, as __alloc_pages_slowpath might have changed it */ ac.zonelist = zonelist; /* The preferred zone is used for statistics later */ preferred_zoneref = first_zones_zonelist(ac.zonelist, ac.high_zoneidx, ac.nodemask ? : \u0026cpuset_current_mems_allowed, \u0026ac.preferred_zone); if (!ac.preferred_zone) goto out; ac.classzone_idx = zonelist_zone_idx(preferred_zoneref); /* First allocation attempt */ alloc_mask = gfp_mask|__GFP_HARDWALL; page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026ac); if (unlikely(!page)) { /* * Runtime PM, block IO and its error handling path * can deadlock because I/O on the device might not * complete. */ alloc_mask = memalloc_noio_flags(gfp_mask); page = __alloc_pages_slowpath(alloc_mask, order, \u0026ac); } if (kmemcheck_enabled \u0026\u0026 page) kmemcheck_pagealloc_alloc(page, order, gfp_mask); trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); out: /* * When updating a task's mems_allowed, it is possible to race with * parallel threads in such a way that an allocation can fail while * the mask is being updated. If a page allocation is about to fail, * check if the cpuset changed during allocation and if so, retry. */ if (unlikely(!page \u0026\u0026 read_mems_allowed_retry(cpuset_mems_cookie))) goto retry_cpuset; return page; } struct alloc_context { struct zonelist *zonelist; nodemask_t *nodemask; struct zone *preferred_zone; int classzone_idx; int migratetype; enum zone_type high_zoneidx; }; struct alloc_context ac = { .high_zoneidx = gfp_zone(gfp_mask), .nodemask = nodemask, .migratetype = gfpflags_to_migratetype(gfp_mask), }; static inline enum zone_type gfp_zone(gfp_t flags) { enum zone_type z; int bit = (__force int) (flags \u0026 GFP_ZONEMASK); z = (GFP_ZONE_TABLE \u003e\u003e (bit * ZONES_SHIFT)) \u0026 ((1 \u003c\u003c ZONES_SHIFT) - 1); VM_BUG_ON((GFP_ZONE_BAD \u003e\u003e bit) \u0026 1); return z; } // GFP --\u003e migratetype static inline int gfpflags_to_migratetype(const gfp_t gfp_flags) { WARN_ON((gfp_flags \u0026 GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK); if (unlikely(page_group_by_mobility_disabled)) return MIGRATE_UNMOVABLE; /* Group based on mobility */ return (((gfp_flags \u0026 __GFP_MOVABLE) != 0) \u003c\u003c 1) | ((gfp_flags \u0026 __GFP_RECLAIMABLE) != 0); } ","date":"2021-10-28","objectID":"/page_allocator/:1:1","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__alloc_pages_nodemask"},{"categories":["linux"],"content":" 1.2 first_zones_zonelist static inline struct zoneref *first_zones_zonelist(struct zonelist *zonelist, enum zone_type highest_zoneidx, nodemask_t *nodes, struct zone **zone) { struct zoneref *z = next_zones_zonelist(zonelist-\u003e_zonerefs, highest_zoneidx, nodes); *zone = zonelist_zone(z); return z; } // 提取zone的指针 static inline struct zone *zonelist_zone(struct zoneref *zoneref) { return zoneref-\u003ezone; } struct zoneref *next_zones_zonelist(struct zoneref *z, enum zone_type highest_zoneidx, nodemask_t *nodes) { /* * Find the next suitable zone to use for the allocation. * Only filter based on nodemask if it's set */ if (likely(nodes == NULL)) while (zonelist_zone_idx(z) \u003e highest_zoneidx) z++; else while (zonelist_zone_idx(z) \u003e highest_zoneidx || (z-\u003ezone \u0026\u0026 !zref_in_nodemask(z, nodes))) z++; return z; } ","date":"2021-10-28","objectID":"/page_allocator/:1:2","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#first_zones_zonelist"},{"categories":["linux"],"content":" 2 free_pages void free_pages(unsigned long addr, unsigned int order) { if (addr != 0) { VM_BUG_ON(!virt_addr_valid((void *)addr)); __free_pages(virt_to_page((void *)addr), order); } } ","date":"2021-10-28","objectID":"/page_allocator/:2:0","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#free_pages"},{"categories":["linux"],"content":" 2.1 __free_pages void __free_pages(struct page *page, unsigned int order) { if (put_page_testzero(page)) { if (order == 0) free_hot_cold_page(page, false); else __free_pages_ok(page, order); } } ","date":"2021-10-28","objectID":"/page_allocator/:2:1","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_pages"},{"categories":["linux"],"content":" 2.2 __free_pages_ok static void __free_pages_ok(struct page *page, unsigned int order) { unsigned long flags; int migratetype; unsigned long pfn = page_to_pfn(page); if (!free_pages_prepare(page, order)) return; migratetype = get_pfnblock_migratetype(page, pfn); local_irq_save(flags); __count_vm_events(PGFREE, 1 \u003c\u003c order); set_freepage_migratetype(page, migratetype); free_one_page(page_zone(page), page, pfn, order, migratetype); local_irq_restore(flags); } ","date":"2021-10-28","objectID":"/page_allocator/:2:2","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_pages_ok"},{"categories":["linux"],"content":" 2.3 free_one_page static void free_one_page(struct zone *zone, struct page *page, unsigned long pfn, unsigned int order, int migratetype) { unsigned long nr_scanned; spin_lock(\u0026zone-\u003elock); nr_scanned = zone_page_state(zone, NR_PAGES_SCANNED); if (nr_scanned) __mod_zone_page_state(zone, NR_PAGES_SCANNED, -nr_scanned); if (unlikely(has_isolate_pageblock(zone) || is_migrate_isolate(migratetype))) { migratetype = get_pfnblock_migratetype(page, pfn); } __free_one_page(page, pfn, zone, order, migratetype); spin_unlock(\u0026zone-\u003elock); } ","date":"2021-10-28","objectID":"/page_allocator/:2:3","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#free_one_page"},{"categories":["linux"],"content":" 2.4 __free_one_page static inline void __free_one_page(struct page *page, unsigned long pfn, struct zone *zone, unsigned int order, int migratetype) { unsigned long page_idx; unsigned long combined_idx; unsigned long uninitialized_var(buddy_idx); struct page *buddy; int max_order = MAX_ORDER; VM_BUG_ON(!zone_is_initialized(zone)); VM_BUG_ON_PAGE(page-\u003eflags \u0026 PAGE_FLAGS_CHECK_AT_PREP, page); VM_BUG_ON(migratetype == -1); if (is_migrate_isolate(migratetype)) { /* * We restrict max order of merging to prevent merge * between freepages on isolate pageblock and normal * pageblock. Without this, pageblock isolation * could cause incorrect freepage accounting. */ max_order = min(MAX_ORDER, pageblock_order + 1); } else { __mod_zone_freepage_state(zone, 1 \u003c\u003c order, migratetype); } page_idx = pfn \u0026 ((1 \u003c\u003c max_order) - 1); VM_BUG_ON_PAGE(page_idx \u0026 ((1 \u003c\u003c order) - 1), page); VM_BUG_ON_PAGE(bad_range(zone, page), page); while (order \u003c max_order - 1) { buddy_idx = __find_buddy_index(page_idx, order); buddy = page + (buddy_idx - page_idx); if (!page_is_buddy(page, buddy, order)) break; /* * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page, * merge with it and move up one order. */ if (page_is_guard(buddy)) { clear_page_guard(zone, buddy, order, migratetype); } else { list_del(\u0026buddy-\u003elru); zone-\u003efree_area[order].nr_free--; rmv_page_order(buddy); } combined_idx = buddy_idx \u0026 page_idx; page = page + (combined_idx - page_idx); page_idx = combined_idx; order++; } set_page_order(page, order); /* * If this is not the largest possible page, check if the buddy * of the next-highest order is free. If it is, it's possible * that pages are being freed that will coalesce soon. In case, * that is happening, add the free page to the tail of the list * so it's less likely to be used soon and more likely to be merged * as a higher order page */ if ((order \u003c MAX_ORDER-2) \u0026\u0026 pfn_valid_within(page_to_pfn(buddy))) { struct page *higher_page, *higher_buddy; combined_idx = buddy_idx \u0026 page_idx; higher_page = page + (combined_idx - page_idx); buddy_idx = __find_buddy_index(combined_idx, order + 1); higher_buddy = higher_page + (buddy_idx - combined_idx); if (page_is_buddy(higher_page, higher_buddy, order + 1)) { list_add_tail(\u0026page-\u003elru, \u0026zone-\u003efree_area[order].free_list[migratetype]); goto out; } } list_add(\u0026page-\u003elru, \u0026zone-\u003efree_area[order].free_list[migratetype]); out: zone-\u003efree_area[order].nr_free++; } ","date":"2021-10-28","objectID":"/page_allocator/:2:4","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_one_page"},{"categories":["前端知识"],"content":"javascript基础教程","date":"2021-10-07","objectID":"/javascript/","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/"},{"categories":["前端知识"],"content":" 1 基础知识 JavaScript是一种运行在浏览器中的解释型的编程语言 JavaScript（JS）是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。 虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多非浏览器环境中， 例如 Node.js、Apache CouchDB、Adobe Acrobat 等。 进一步说，JavaScript 是一种基于原型、多范式、单线程的动态 (en-US)语言， 并且支持面向对象、命令式和声明式（如函数式编程）风格。 在hugo中运行javacsript脚本,可以使用hugo的script shortcode在文章中插入Javascript脚本 {{\u003c script \u003e}} console.log('javascript基础教程!'); {{\u003c /script \u003e}} 可以在浏览器的后台中看到日志javascript基础教程! 同样的道理,也可以直接写在html中; \u003cbutton onclick='alert(Date())'\u003e现在的时间是? \u003c/button\u003e 点击下面的按钮，显示效果 现在的时间是? JavaScript严格区分大小写 作为一个新的语言,我们学的第一个程序 打印hello world /* 打印弹窗 */ alert(\"hello world\"); /* 打印在html */ document.write(\"hello world\"); /* 打印在调试窗口 */ console.log(\"Hello world\") 但是直接在浏览器中运行显得特别麻烦,此时我们可以使用NodeJS在命令行中运行程序 Nodejs中的内容 执行js脚本 ","date":"2021-10-07","objectID":"/javascript/:1:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基础知识"},{"categories":["前端知识"],"content":" 2 基本语句 赋值语句 var x = 1; // 定义全局变量 let y = 12; // 定义局部变量 注释语句 // 单行注释 /** * 多行注释 */ 变量 变量必须以字母开头 变量也能以$和_符号开头 变量名称对大小写敏感 ","date":"2021-10-07","objectID":"/javascript/:2:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基本语句"},{"categories":["前端知识"],"content":" 3 数据类型 九种数据类型 值类型(基本类型) 字符串(String) 数字(Number) 布尔(Boolean) 空(Null) 未定义(Undefined) Symbol 引用数据类型(对象类型) 对象(Object) 数组(Array) 函数(Function) ","date":"2021-10-07","objectID":"/javascript/:3:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数据类型"},{"categories":["前端知识"],"content":" 3.1 定义数据 var a = 'Hello'; // 字符串(String) var b = 10; // 数字(Number) var c = true; // 布尔(Boolean) var d = function() { // 函数(Function) console.log(\"Hello\"); }; var e = [1, 2, 3]; // 数组(Array) var f = null; // 空(Null) var g = Symbol(); // Symbol var h; // 未定义(Undefined) var i = Object(); // 对象(Object) ","date":"2021-10-07","objectID":"/javascript/:3:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义数据"},{"categories":["前端知识"],"content":" 3.2 检测数据 typeof 只可以检测基本数据类型 constructor返回实例的构造函数 instanceof 原型查找 Object.prototype.toString // 1. typeof检测类型 console.log(\"\\r\\n1. typeof检测类型\") console.log('type of a is ' + typeof(a)); console.log('type of b is ' + typeof(b)); console.log('type of c is ' + typeof(c)); console.log('type of d is ' + typeof(d)); console.log('type of e is ' + typeof(e)); console.log('type of f is ' + typeof(f)); console.log('type of g is ' + typeof(g)); console.log('type of h is ' + typeof(h)); console.log('type of i is ' + typeof(i)); // 2. constructor返回实例的构造函数 console.log(\"\\r\\n2. constructor返回实例的构造函数\") console.log(a.constructor == String); console.log(a.constructor == Number); console.log(e.constructor == Object); console.log(e.constructor == Array); // 3. instanceof 原型查找 console.log(\"\\r\\n3. instanceof 原型查找\") console.log(a instanceof String); console.log(a instanceof Number); console.log(e instanceof Object); console.log(e instanceof Array); // 4. Object.prototype.toString console.log(\"\\r\\n4. Object.prototype.toString\") console.log('type of a is ' + toString.call(a)); console.log('type of b is ' + toString.call(b)); console.log('type of c is ' + toString.call(c)); console.log('type of d is ' + toString.call(d)); console.log('type of e is ' + toString.call(e)); console.log('type of f is ' + toString.call(f)); console.log('type of g is ' + toString.call(g)); console.log('type of h is ' + toString.call(h)); console.log('type of i is ' + toString.call(i)); ","date":"2021-10-07","objectID":"/javascript/:3:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#检测数据"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#拼接字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串函数"},{"categories":["前端知识"],"content":" 3.4 数组JavaScript的数组可以包含任意数据类型;并通过索引来访问每个元素. var array = [1, 2, 'hello', \"world\", true]; // 定义一个数组 array.length; // 5 array[0]; // 打印 ","date":"2021-10-07","objectID":"/javascript/:3:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数组"},{"categories":["前端知识"],"content":" 4 条件判断 与C相似,此处就不过多赘述 if else else if switch if (1 \u003c 3) { console.log(\"1 \u003c 3 \\r\\n\"); } if (false) { console.log(\"false \\r\\n\"); } else { console.log(\"true \\r\\n\"); } if (false) { console.log(\"false \\r\\n\"); } else if(false) { console.log(\"false \\r\\n\"); } else { console.log(\"true \\r\\n\"); } 同样的道理,js也存在这多路选择 switch (new Date().getDay()) { case 0: day = \"星期天\"; break; case 1: day = \"星期一\"; break; case 2: day = \"星期二\"; break; case 3: day = \"星期三\"; break; case 4: day = \"星期四\"; break; case 5: day = \"星期五\"; break; case 6: day = \"星期六\"; } console.log('今天是' + day); ","date":"2021-10-07","objectID":"/javascript/:4:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#条件判断"},{"categories":["前端知识"],"content":" 5 循环语句 for for (语句 1; 语句 2; 语句 3) { 要执行的代码块 } for-in for (key in object) { // code block to be executed } for-of while do-while ","date":"2021-10-07","objectID":"/javascript/:5:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#循环语句"},{"categories":["前端知识"],"content":" 6 遍历语句","date":"2021-10-07","objectID":"/javascript/:6:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#遍历语句"},{"categories":["前端知识"],"content":" 7 函数","date":"2021-10-07","objectID":"/javascript/:7:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数"},{"categories":["前端知识"],"content":" 7.1 函数模型 c语言类型 function functionName(args) { return retVal; } function:函数定义 functionName parameter retVal 一种完全等价的定义 var functionName = function(args) { return retVal; } ","date":"2021-10-07","objectID":"/javascript/:7:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数模型"},{"categories":["前端知识"],"content":" 7.2 函数调用","date":"2021-10-07","objectID":"/javascript/:7:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数调用"},{"categories":["前端知识"],"content":" 7.3 箭头函数","date":"2021-10-07","objectID":"/javascript/:7:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#箭头函数"},{"categories":["前端知识"],"content":" 8 面向对象","date":"2021-10-07","objectID":"/javascript/:8:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#面向对象"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建对象es5"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#object对象"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#对象初始化器"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#构造函数"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#继承语法"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装语法"},{"categories":["前端知识"],"content":" 8.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 8.2.1 继承语法 8.2.2 封装语法","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建对象es6"},{"categories":["前端知识"],"content":" 8.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 8.2.1 继承语法 8.2.2 封装语法","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#继承语法-1"},{"categories":["前端知识"],"content":" 8.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 8.2.1 继承语法 8.2.2 封装语法","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装语法-1"},{"categories":["前端知识"],"content":" 8.3 访问成员 访问成员的方式存在两种 C方式:对象名.成员名 反射式:对象名['成员名'] 'use strict'; var student = { name: \"hello\", age: 18 }; console.log(student.name); // hello console.log(student['age']); // 18 ","date":"2021-10-07","objectID":"/javascript/:8:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#访问成员"},{"categories":["前端知识"],"content":" 9 标准对象 JS为我们定义的标准对象 Map(映射) Set(集合) Date(日期) RegExp(正则表达式) JSON(JSON) Math(数学) ","date":"2021-10-07","objectID":"/javascript/:9:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#标准对象"},{"categories":["前端知识"],"content":" 9.1 Map(映射)","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#map映射"},{"categories":["前端知识"],"content":" 9.2 Set(集合)","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#set集合"},{"categories":["前端知识"],"content":" 9.3 Date(日期)","date":"2021-10-07","objectID":"/javascript/:9:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#date日期"},{"categories":["前端知识"],"content":" 9.4 RegExp(正则表达式)","date":"2021-10-07","objectID":"/javascript/:9:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#regexp正则表达式"},{"categories":["前端知识"],"content":" 9.5 JSON(JSON) 序列化: stringify() 反序列化: parse() var text = '{ \"student\" : [' + '{ \"name\":\"hello\" , \"age\": 18 },' + '{ \"name\":\"world\" , \"age\": 18 }]}'; var jsonObj = JSON.parse(text); var jsonTxt = JSON.stringify(jsonObj); console.log(jsonObj); console.log(jsonTxt); ","date":"2021-10-07","objectID":"/javascript/:9:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#jsonjson"},{"categories":["前端知识"],"content":" 9.6 Math(数学) 与其他全局对象不同的是，Math 不是一个构造器。 Math 的所有属性与方法都是静态的. 引用圆周率的写法是 Math.PI,调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参数。 Math 的常量是使用 JavaScript 中的全精度浮点数来定义的。 Math 用于 Number 类型。它不支持 BigInt // 常数 console.log(\"自然常数: \" + Math.E); console.log(\"2的自然对数: \" + Math.LN2); console.log(\"10的自然对数: \" + Math.LN10); // 函数 console.log(\"-10的绝对值: \" + Math.abs(-10)); console.log(\"10的正弦值: \" + Math.sin(10)); console.log(\"10的余弦值: \" + Math.cos(10)); 输出值 $ node Math.js 自然常数: 2.718281828459045 2的自然对数: 0.6931471805599453 10的自然对数: 2.302585092994046 -10的绝对值: 10 10的正弦值: -0.5440211108893698 10的余弦值: -0.8390715290764524 ","date":"2021-10-07","objectID":"/javascript/:9:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#math数学"},{"categories":["前端知识"],"content":" 10 宿主对象 由浏览器提供的对象 window navigator location document history Dom Bom 表单 文件 AJAX Promise Canvas ","date":"2021-10-07","objectID":"/javascript/:10:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#宿主对象"},{"categories":["前端知识"],"content":" 10.1 window window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档。 使用 document.defaultView 属性可以获取指定文档所在窗口。 window作为全局变量，代表了脚本正在运行的窗口，暴露给 Javascript 代码。 ","date":"2021-10-07","objectID":"/javascript/:10:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#window"},{"categories":["前端知识"],"content":" 10.2 navigator","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#navigator"},{"categories":["前端知识"],"content":" 10.3 location","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#location"},{"categories":["前端知识"],"content":" 10.4 document","date":"2021-10-07","objectID":"/javascript/:10:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#document"},{"categories":["前端知识"],"content":" 10.5 history","date":"2021-10-07","objectID":"/javascript/:10:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#history"},{"categories":["前端知识"],"content":" 10.6 DOM 文档对象模型(DOM)将web页面与到脚本或编程语言连接起来. JS通过DOM访问文档; ","date":"2021-10-07","objectID":"/javascript/:10:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#dom"},{"categories":["前端知识"],"content":" 10.7 BOM","date":"2021-10-07","objectID":"/javascript/:10:7","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#bom"},{"categories":["前端知识"],"content":" 10.8 表单","date":"2021-10-07","objectID":"/javascript/:10:8","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#表单"},{"categories":["前端知识"],"content":" 10.9 文件","date":"2021-10-07","objectID":"/javascript/:10:9","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#文件"},{"categories":["前端知识"],"content":" 10.10 AJAX","date":"2021-10-07","objectID":"/javascript/:10:10","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#ajax"},{"categories":["前端知识"],"content":" 10.11 Promise","date":"2021-10-07","objectID":"/javascript/:10:11","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#promise"},{"categories":["前端知识"],"content":" 10.12 Canvas","date":"2021-10-07","objectID":"/javascript/:10:12","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#canvas"},{"categories":["前端知识"],"content":" 11 错误处理 程序有可能会出错,因此需要进行错误处理;高级语言try ... catch ... finally, 'use strict'; var r1, r2, s = null; try { r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行 } catch (e) { console.log('error: ' + e); } finally { console.log('finally'); } console.log('r1 = ' + r1); // r1应为undefined console.log('r2 = ' + r2); // r2应为undefined // 下面的文件 // 出错了：TypeError: Cannot read properties of null (reading 'length') // finally // r1 = undefined // r2 = undefined 出错 先执行try { ... }的代码; 执行到出错的语句时,后续语句不再继续执行.转而执行catch (e) { ... }代码； 最后执行finally{ ... }代码。 无错 先执行try { … }的代码； 因为没有出错，catch (e) { … }代码不会被执行； 最后执行finally { … }代码。 ","date":"2021-10-07","objectID":"/javascript/:11:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#错误处理"},{"categories":["前端知识"],"content":"CSS3基础教程","date":"2021-10-07","objectID":"/css3/","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/"},{"categories":["前端知识"],"content":" 1 基础知识 Cascading Style Sheets(层叠样式表) HTML + CSS + JavaScript =\u003e 名词 + 形容词 + 动词 CSS可以认为对原始的HTML进行美化 ","date":"2021-10-07","objectID":"/css3/:1:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基础知识"},{"categories":["前端知识"],"content":" 1.1 快速入门 CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画 ","date":"2021-10-07","objectID":"/css3/:1:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#快速入门"},{"categories":["前端知识"],"content":" 1.2 什么是CSS美化:字体, 颜色,高度,宽度, 背景图片 ","date":"2021-10-07","objectID":"/css3/:1:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#什么是css"},{"categories":["前端知识"],"content":" 1.3 CSS的优势 内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件 ","date":"2021-10-07","objectID":"/css3/:1:3","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css的优势"},{"categories":["前端知识"],"content":" 1.4 CSS导入的方法 行内样式 \u003ch1 style=\"color: red\"\u003e一级标题\u003c/h1\u003e style标签 \u003cstyle\u003e\u003c/style\u003e 外部样式 链接方式 \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e 导入式 \u003cstyle\u003e @import url(\"css/style.css\"); \u003c/style\u003e ","date":"2021-10-07","objectID":"/css3/:1:4","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css导入的方法"},{"categories":["前端知识"],"content":" 1.5 基本语法 /* 注释语法 */ selector { /* 声明 */ attr:value; } 下面的代码可以直接修改背景颜色 \u003cstyle\u003e body { background-color:gray; } \u003c/style\u003e CSS基本操作 选中元素(选择某一类或者某一个) 属性修改(修改一个或者多个) ","date":"2021-10-07","objectID":"/css3/:1:5","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基本语法"},{"categories":["前端知识"],"content":" 2 选择器 选择某一类或者某一个元素 ","date":"2021-10-07","objectID":"/css3/:2:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 \u003ch1 class=\"test\"\u003e测试\u003c/h1\u003e 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 \u003ch1 id=\"test\"\u003e测试\u003c/h1\u003e #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基本选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#标签选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#类选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#id选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 \u003cp class=\"active\"\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp id=\"test\"\u003ep3\u003c/p\u003e \u003cp\u003ep4\u003c/p\u003e \u003cstyle\u003e .active+p { color: red; } #test+p { color: blue; } \u003c/style\u003e 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 \u003cp\u003ep1\u003c/p\u003e \u003cp class=\"hello\"\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cstyle\u003e .hello~{ color: red; } \u003c/style\u003e p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp id=\"test\"\u003ep7\u003c/p\u003e \u003cp\u003ep8\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#高级选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#层次选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#后代选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#子选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#相邻兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#通用兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#结构伪类选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性选择器"},{"categories":["前端知识"],"content":" 3 CSS属性 选中元素开始设置属性 ","date":"2021-10-07","objectID":"/css3/:3:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css属性"},{"categories":["前端知识"],"content":" 3.1 属性基础 字体样式 文本样式 文本阴影 超链接 列表样式 背景 span标签强调,这是一个标签, div标签,分块 \u003c!-- 字体样式 --\u003e \u003cstyle\u003e body { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-style: oblique; } \u003c/style\u003e font-family; 字体设置 font-size 字体大小 font-style 字体风格 ","date":"2021-10-07","objectID":"/css3/:3:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性基础"},{"categories":["前端知识"],"content":" 3.2 属性提高 盒子模型与边框 ","date":"2021-10-07","objectID":"/css3/:3:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性提高"},{"categories":["前端知识"],"content":"html5基础教程","date":"2021-10-07","objectID":"/html5/","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/"},{"categories":["前端知识"],"content":" hugo中markdown可以直接渲染html,可以直接得到效果 但是网页基础结构却不可以编写,这样会破坏渲染过程 因此点击例子,同时点击F12,确定效果. 页面显示空白 但是我们可以在源代码中看到 \u003c!-- 告诉浏览器,需要使用的规范 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 网页标题 --\u003e \u003chead\u003e \u003c!-- 描述标签 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页标题 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 网页主体 --\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 因此后面我们就使用独立的html文件进行学习 ","date":"2021-10-07","objectID":"/html5/:0:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#"},{"categories":["前端知识"],"content":" 1 网页结构 \u003c!DOCTYPE html\u003e www规范\r注释的写法 \u003c!-- 注释 --\u003e html: 网页 head: 标题标签 meta: 网站信息 body: 网页主题 meta标签处于head区,对用户不可见,用于对网页进行描述,一般SEO优化 \u003chead\u003e \u003cmeta name=\"description\" content=\"前端基础\"\u003e \u003cmeta name=\"keywords\" content=\"HTML,CSS,JavaScript\"\u003e \u003cmeta name=\"author\" content=\"孟德茂\"\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c/head\u003e 实现自动跳转 因此点击例子,网页显示空白,等待3S,网页自动回到本页面 实现原理 \u003cmeta http-equiv=\"refresh\" content=\"3; https://mengdemao.github.io/html5\"/\u003e 头文件区添加,可以看到虽然meta没有显示,但还是存在较大用处 ","date":"2021-10-07","objectID":"/html5/:1:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#网页结构"},{"categories":["前端知识"],"content":" 2 基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号标签 ","date":"2021-10-07","objectID":"/html5/:2:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#基本标签"},{"categories":["前端知识"],"content":" 2.1 标题标签 \u003ch1\u003e一级标签\u003c/h1\u003e \u003ch2\u003e二级标签\u003c/h2\u003e \u003ch3\u003e三级标签\u003c/h3\u003e \u003ch4\u003e四级标签\u003c/h4\u003e \u003ch5\u003e五级标签\u003c/h5\u003e \u003ch6\u003e六级标签\u003c/h6\u003e 在HUGO中实现,但是效果会显示的很诡异,因此独立文件实现; 点击例子,可以看到效果;同时F12，检查元素实现 ","date":"2021-10-07","objectID":"/html5/:2:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#标题标签"},{"categories":["前端知识"],"content":" 2.2 段落标签 \u003cp\u003e段落标签\u003c/p\u003e 显示如下: 我是一个段落 我又是一个段落 ","date":"2021-10-07","objectID":"/html5/:2:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#段落标签"},{"categories":["前端知识"],"content":" 2.3 换行标签 \u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:2:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#换行标签"},{"categories":["前端知识"],"content":" 2.4 抄录环境 pre code pre显示的是原始的结构文本,程序不修改其中的tab,回车空格等;pre演示 code标签显示的语义化文本,显示等宽字体,但是格式被打乱code演示 语义化演示 var 定义程序变量 kbd 定义用户输入 samp 定义程序输出 \u003cp\u003e定义变量\u003cvar\u003euser_input\u003c/var\u003e,用作用户的输入\u003c/p\u003e \u003cp\u003e接收用户的输入\u003ckbd\u003e用户输入\u003c/kbd\u003e\u003c/p\u003e \u003cp\u003e执行程序的输出\u003csamp\u003e程序输出\u003c/samp\u003e\u003c/p\u003e 但是程序好像并没有产生什么效果 演示 ","date":"2021-10-07","objectID":"/html5/:2:4","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#抄录环境"},{"categories":["前端知识"],"content":" 2.5 引用标签","date":"2021-10-07","objectID":"/html5/:2:5","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#引用标签"},{"categories":["前端知识"],"content":" 2.6 强调标签","date":"2021-10-07","objectID":"/html5/:2:6","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#强调标签"},{"categories":["前端知识"],"content":" 2.7 水平线标签 \u003chr/\u003e 我在水平线标签上方 我在水平线标签下方 ","date":"2021-10-07","objectID":"/html5/:2:7","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#水平线标签"},{"categories":["前端知识"],"content":" 2.8 字体样式标签 \u003c!-- 字体样式标签 --\u003e 普通文本\u003cspan\u003e无效果\u003c/span\u003e\u003c/br\u003e 普通文本\u003cb\u003e加粗\u003c/b\u003e\u003c/br\u003e 普通文本\u003cstrong\u003e粗体\u003c/strong\u003e\u003c/br\u003e 普通文本\u003ci\u003e斜体\u003c/i\u003e\u003c/br\u003e 普通文本\u003cem\u003e斜体\u003c/em\u003e\u003c/br\u003e 普通文本\u003cu\u003e下划线\u003c/u\u003e\u003c/br\u003e 普通文本\u003cins\u003e下划线\u003c/ins\u003e\u003c/br\u003e 普通文本\u003cs\u003e删除线\u003c/s\u003e\u003c/br\u003e 普通文本\u003cdel\u003e删除线\u003c/del\u003e\u003c/br\u003e 普通文本\u003csub\u003e下标文本\u003c/sub\u003e\u003c/br\u003e 普通文本\u003csup\u003e上标文本\u003c/sup\u003e\u003c/br\u003e 普通文本无效果 普通文本加粗 普通文本粗体 普通文本斜体 普通文本斜体 普通文本下划线 普通文本下划线 普通文本删除线 普通文本删除线 普通文本下标文本 普通文本上标文本 ","date":"2021-10-07","objectID":"/html5/:2:8","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#字体样式标签"},{"categories":["前端知识"],"content":" 3 图片标签 \u003cimg src=\"测试.png\" alt=\"测试\" title=\"测试\"/\u003e ","date":"2021-10-07","objectID":"/html5/:3:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#图片标签"},{"categories":["前端知识"],"content":" 4 链接 \u003c!-- 当前页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_self\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e \u003c!-- 新建页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:4:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#链接"},{"categories":["前端知识"],"content":" 5 列表标签","date":"2021-10-07","objectID":"/html5/:5:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#列表标签"},{"categories":["前端知识"],"content":" 5.1 有序列表 \u003col\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ol\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#有序列表"},{"categories":["前端知识"],"content":" 5.2 无序列表 \u003cul\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ul\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#无序列表"},{"categories":["前端知识"],"content":" 5.3 定义列表 \u003cdl\u003e \u003cdt\u003e前端\u003c/dt\u003e \u003cdd\u003ehtml\u003c/dd\u003e \u003cdd\u003eCSS\u003c/dd\u003e \u003cdd\u003eJavaScript\u003c/dd\u003e \u003c/dl\u003e 前端\rhtml\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#定义列表"},{"categories":["前端知识"],"content":" 6 表格 \u003ctable border=\"1px\"\u003e \u003ctr\u003e \u003ctd\u003e1-1\u003c/td\u003e \u003ctd\u003e1-2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2-1\u003c/td\u003e \u003ctd\u003e2-2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 1-1\r1-2\r2-1\r2-2\r","date":"2021-10-07","objectID":"/html5/:6:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表格"},{"categories":["前端知识"],"content":" 7 页面结构分析 元素名 描述 header 标题头部区域 footer 标记尾部内容 section web页面中一块独立的区域 article 独立文章内容 aside 相关页面或者内容 nav 导航类辅助内容 ","date":"2021-10-07","objectID":"/html5/:7:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#页面结构分析"},{"categories":["前端知识"],"content":" 8 iframe内联框架 \u003ciframe src=\"path\" name=\"mainFrame\"\u003e\u003c/frame\u003e bilibili的例子 \u003ciframe src=\"//player.bilibili.com/player.html?aid=55631961\u0026bvid=BV1x4411V75C\u0026cid=97257967\u0026page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e \u003c/iframe\u003e ","date":"2021-10-07","objectID":"/html5/:8:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#iframe内联框架"},{"categories":["前端知识"],"content":" 9 表单 \u003cform action=\"submit.html\" method=\"GET/POST\"\u003e \u003cp\u003e名字: \u003cinput type=\"text\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003e密码: \u003cinput type=\"password\" name=\"password\"\u003e\u003c/p\u003e \u003cp\u003e \u003cinput type=\"submit\"\u003e \u003cinput type=\"reset\"\u003e \u003c/p\u003e \u003c/form\u003e 出入账户和密码,点击按钮会触发相应的 动作http://url/html5/submit.html?name=mengdemao\u0026password=1234, 但是此时会显示失败,因为没有处理函数. 名字: 密码: ","date":"2021-10-07","objectID":"/html5/:9:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表单"},{"categories":["开源软件"],"content":"sds","date":"2021-10-06","objectID":"/sds/","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/"},{"categories":["开源软件"],"content":" A C dynamic strings library C语言版本动态字符串库 ","date":"2021-10-06","objectID":"/sds/:0:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#"},{"categories":["开源软件"],"content":" 1 SDSSDS的类型就是 typedef char *sds; 可以明显的看到,sds就是普通的char类型 ","date":"2021-10-06","objectID":"/sds/:1:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#sds"},{"categories":["开源软件"],"content":" 1.1 下面是sds的数据类型 +--------+-------------------------------+-----------+ | Header | Binary safe C alike string... | Null term | +--------+-------------------------------+-----------+ | -\u003e Pointer returned to the user. #define SDS_HDR_VAR(T,s) \\ struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); #define SDS_HDR(T,s) \\ ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) #define SDS_TYPE_5_LEN(f) ((f)\u003e\u003eSDS_TYPE_BITS) ","date":"2021-10-06","objectID":"/sds/:1:1","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#下面是sds的数据类型"},{"categories":["开源软件"],"content":" 1.2 SDS 头根据不同的标志计算不同的头部数据 宏定义 标志 SDS_TYPE_5 sdshdr5 SDS_TYPE_8 sdshdr8 SDS_TYPE_16 sdshdr16 SDS_TYPE_32 sdshdr32 SDS_TYPE_64 sdshdr64 flag标志: unsigned char flags = s[-1]; /* 最后一个头部数据 */ #define SDS_TYPE_5 0 #define SDS_TYPE_8 1 #define SDS_TYPE_16 2 #define SDS_TYPE_32 3 #define SDS_TYPE_64 4 /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; #define SDS_TYPE_MASK 7 #define SDS_TYPE_BITS 3 ","date":"2021-10-06","objectID":"/sds/:1:2","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#sds-头"},{"categories":["开源软件"],"content":" 2 创建SDS函数原型 sds sdsnewlen(const void *init, size_t initlen); ","date":"2021-10-06","objectID":"/sds/:2:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#创建sds"},{"categories":["开源软件"],"content":" 3 扩张字符串缓存区 sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh; void *newsh; size_t avail = sdsavail(s); /* 计算剩余的可以使用的大小 */ size_t len; size_t newlen; char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; int hdrlen; if (avail \u003e= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ return s; } len = sdslen(s); /* 计算字符串大小 */ sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ /* 计算得到新的长度 */ newlen = (len+addlen); if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; /* 重新生成类型 */ type = sdsReqType(newlen); /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) { type = SDS_TYPE_8; } /* 计算头部大小 */ hdrlen = sdsHdrSize(type); if (oldtype == type) { newsh = s_realloc(sh, hdrlen + newlen + 1); if (newsh == NULL) { return NULL; } s = (char*)newsh + hdrlen; } else { /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc(hdrlen+newlen+1); if (newsh == NULL) { return NULL; } memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); } sdssetalloc(s, newlen); return s; } ","date":"2021-10-06","objectID":"/sds/:3:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#扩张字符串缓存区"},{"categories":["开源软件"],"content":" 4 追加字符串 sds sdscatlen(sds s, const void *t, size_t len) { size_t curlen = sdslen(s); /* 计算字符串的长度 */ s = sdsMakeRoomFor(s,len); /* 扩展字符串缓冲区长度 */ if (s == NULL) { return NULL; } memcpy(s+curlen, t, len); /* 添加字符串 */ sdssetlen(s, curlen+len); /* 设置长度标志 */ s[curlen+len] = '\\0'; /* 补全结束符 */ return s; } ","date":"2021-10-06","objectID":"/sds/:4:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#追加字符串"},{"categories":["操作系统"],"content":"进程创建","date":"2021-10-04","objectID":"/fork/","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/"},{"categories":["操作系统"],"content":" fork linux创建线程的函数 fork –\u003e do_fork do_fork的执行线路 graph LR do_fork --\u003e copy_process --\u003e get_task_pid --\u003e wake_up_new_task --\u003e put_pid do_fork函数原型 long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); clone_flags stack_start stack_size parent_tidptr child_tidptr tls ","date":"2021-10-04","objectID":"/fork/:0:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#fork"},{"categories":["操作系统"],"content":" 1 copy_process","date":"2021-10-04","objectID":"/fork/:1:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#copy_process"},{"categories":["操作系统"],"content":" 2 get_task_pid","date":"2021-10-04","objectID":"/fork/:2:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#get_task_pid"},{"categories":["操作系统"],"content":" 3 wake_up_new_task","date":"2021-10-04","objectID":"/fork/:3:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#wake_up_new_task"},{"categories":["linux"],"content":"系统调度","date":"2021-10-04","objectID":"/scheduler/","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/"},{"categories":["linux"],"content":" 调度器分为主调度器和周期调度器 但是本节不考虑调度器的具体实现 只进行大方向接口的分析 系统调度器基础 完全公平调度器 ","date":"2021-10-04","objectID":"/scheduler/:0:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#"},{"categories":["linux"],"content":" 1 权重计算","date":"2021-10-04","objectID":"/scheduler/:1:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#权重计算"},{"categories":["linux"],"content":" 1.1 优先级计算优先级 // 1. 当前优先级normal_prio p-\u003eprio = current-\u003enormal_prio; // 2. 静态优先级 p-\u003estatic_prio = NICE_TO_PRIO(0) // 3. 继续计算优先级 p-\u003eprio = p-\u003enormal_prio = __normal_prio(p); // 4. 这在计算什么? #define NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO) #define PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO) static inline int __normal_prio(struct task_struct *p) { return p-\u003estatic_prio; } ","date":"2021-10-04","objectID":"/scheduler/:1:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#优先级计算"},{"categories":["linux"],"content":" 1.2 权重计算 struct load_weight { unsigned long weight; u32 inv_weight; }; static void set_load_weight(struct task_struct *p) { int prio = p-\u003estatic_prio - MAX_RT_PRIO; struct load_weight *load = \u0026p-\u003ese.load; /* * SCHED_IDLE tasks get minimal weight: */ if (p-\u003epolicy == SCHED_IDLE) { load-\u003eweight = scale_load(WEIGHT_IDLEPRIO); load-\u003einv_weight = WMULT_IDLEPRIO; return; } load-\u003eweight = scale_load(prio_to_weight[prio]); load-\u003einv_weight = prio_to_wmult[prio]; } static const int prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; static const u32 prio_to_wmult[40] = { /* -20 */ 48388, 59856, 76040, 92818, 118348, /* -15 */ 147320, 184698, 229616, 287308, 360437, /* -10 */ 449829, 563644, 704093, 875809, 1099582, /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, }; 优先级与负载计算关系 $weight = \\frac{1024}{1.25^{nice}}$ ${inv_weight} = \\frac{2^{32}}{weight}$ ","date":"2021-10-04","objectID":"/scheduler/:1:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#权重计算-1"},{"categories":["linux"],"content":" 2 调度器类linux内核充分使用了面向对象的思想, 依靠sched_class将所有的调度器整合 linux上的调度器 调度器类 描述信息 用户接口调度策略 dl_sched_class deadline调度器 SCHED_DEADLINE rt_sched_class 实时调度器 SCHED_FIFO、``SCHED_RR` fair_sched_class 完全公平调度器 SCHED_NORMAL、``SCHED_BATCH` idle_sched_class idle task SCHED_IDLE ","date":"2021-10-04","objectID":"/scheduler/:2:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器类"},{"categories":["linux"],"content":" 2.1 调度器类结构体 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task) (struct rq *rq, struct task_struct *prev); void (*put_prev_task) (struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int next_cpu); void (*post_schedule) (struct rq *this_rq); void (*task_waking) (struct task_struct *task); void (*task_woken) (struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task) (struct rq *rq); void (*task_tick) (struct rq *rq, struct task_struct *p, int queued); void (*task_fork) (struct task_struct *p); void (*task_dead) (struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from) (struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval) (struct rq *rq, struct task_struct *task); void (*update_curr) (struct rq *rq); #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_move_group) (struct task_struct *p, int on_rq); #endif }; ","date":"2021-10-04","objectID":"/scheduler/:2:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器类结构体"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器封装"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#入队出队"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#激活销毁"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#主动放弃"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#唤醒抢占任务"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#获取释放任务"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#任务切换"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#更新当前任务"},{"categories":["linux"],"content":" 3 任务创建任务创建是由do_fork进行,与调度器进行沟通的函数是sched_fork,沟通的数据结构是 int sched_fork(unsigned long clone_flags, struct task_struct *p) { unsigned long flags; // #define get_cpu() ({ preempt_disable(); smp_processor_id(); }) // #define put_cpu() preempt_enable() int cpu = get_cpu(); // 获取CPUID // 进入内部实现 __sched_fork(clone_flags, p); /* * We mark the process as running here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u003estate = TASK_RUNNING; // 设置运行状态 /* * Make sure we do not leak PI boosting priority to the child. */ p-\u003eprio = current-\u003enormal_prio; // 复制父优先级到当前 /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u003esched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { p-\u003epolicy = SCHED_NORMAL; p-\u003estatic_prio = NICE_TO_PRIO(0); p-\u003ert_priority = 0; } else if (PRIO_TO_NICE(p-\u003estatic_prio) \u003c 0) p-\u003estatic_prio = NICE_TO_PRIO(0); p-\u003eprio = p-\u003enormal_prio = __normal_prio(p); set_load_weight(p); /* * We don't need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u003esched_reset_on_fork = 0; } if (dl_prio(p-\u003eprio)) { put_cpu(); return -EAGAIN; } else if (rt_prio(p-\u003eprio)) { p-\u003esched_class = \u0026rt_sched_class; } else { p-\u003esched_class = \u0026fair_sched_class; } if (p-\u003esched_class-\u003etask_fork) p-\u003esched_class-\u003etask_fork(p); /* * The child is not yet in the pid-hash so no cgroup attach races, * and the cgroup is pinned to this child due to cgroup_fork() * is ran before sched_fork(). * * Silence PROVE_RCU. */ raw_spin_lock_irqsave(\u0026p-\u003epi_lock, flags); set_task_cpu(p, cpu); raw_spin_unlock_irqrestore(\u0026p-\u003epi_lock, flags); #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) if (likely(sched_info_on())) memset(\u0026p-\u003esched_info, 0, sizeof(p-\u003esched_info)); #endif #if defined(CONFIG_SMP) p-\u003eon_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026p-\u003epushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026p-\u003epushable_dl_tasks); #endif put_cpu(); return 0; } static void __sched_fork(unsigned long clone_flags, struct task_struct *p) { p-\u003eon_rq = 0; // 当前不在队列中 // 设置sched_entity p-\u003ese.on_rq = 0; // 当前不在队列中 p-\u003ese.exec_start = 0; p-\u003ese.sum_exec_runtime = 0; p-\u003ese.prev_sum_exec_runtime = 0; p-\u003ese.nr_migrations = 0; p-\u003ese.vruntime = 0; #ifdef CONFIG_SMP p-\u003ese.avg.decay_count = 0; #endif INIT_LIST_HEAD(\u0026p-\u003ese.group_node); #ifdef CONFIG_SCHEDSTATS memset(\u0026p-\u003ese.statistics, 0, sizeof(p-\u003ese.statistics)); #endif RB_CLEAR_NODE(\u0026p-\u003edl.rb_node); init_dl_task_timer(\u0026p-\u003edl); __dl_clear_params(p); INIT_LIST_HEAD(\u0026p-\u003ert.run_list); #ifdef CONFIG_PREEMPT_NOTIFIERS INIT_HLIST_HEAD(\u0026p-\u003epreempt_notifiers); #endif #ifdef CONFIG_NUMA_BALANCING if (p-\u003emm \u0026\u0026 atomic_read(\u0026p-\u003emm-\u003emm_users) == 1) { p-\u003emm-\u003enuma_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); p-\u003emm-\u003enuma_scan_seq = 0; } if (clone_flags \u0026 CLONE_VM) p-\u003enuma_preferred_nid = current-\u003enuma_preferred_nid; else p-\u003enuma_preferred_nid = -1; p-\u003enode_stamp = 0ULL; p-\u003enuma_scan_seq = p-\u003emm ? p-\u003emm-\u003enuma_scan_seq : 0; p-\u003enuma_scan_period = sysctl_numa_balancing_scan_delay; p-\u003enuma_work.next = \u0026p-\u003enuma_work; p-\u003enuma_faults = NULL; p-\u003elast_task_numa_placement = 0; p-\u003elast_sum_exec_runtime = 0; p-\u003enuma_group = NULL; #endif /* CONFIG_NUMA_BALANCING */ } 分析函数执行 根据上图，我们可以得知创建的是一个线程函数,但是这个不是我们要分析的,我们要分析``sched_fork`函数实现; 设置sched_entity成员 设置优先级 调用调度器类中的task_fork函数 执行结束之后 // 将任务添加到调度器 void wake_up_new_task(struct task_struct *p) { unsigned long flags; struct rq *rq; raw_spin_lock_irqsave(\u0026p-\u003epi_lock, flags); #ifdef CONFIG_SMP /* * Fork balancing, do it here and not earlier because: * - cpus_allowed can change in the fork path * - any previously selected cpu might disappear through hotplug */ set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); #endif /* Initialize new task's runnable average */ init_task_runnable_average(p); rq = __task_rq_lock(p); activate_task(rq, p, 0); // 激活任务 p-\u003eon_rq = TASK_ON_RQ_QUEUED; // 进入队列 trac","date":"2021-10-04","objectID":"/scheduler/:3:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#任务创建"},{"categories":["linux"],"content":" 4 调度基础 主调度器 滴答调度器 ","date":"2021-10-04","objectID":"/scheduler/:4:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度基础"},{"categories":["linux"],"content":" 4.1 主调度器 static void __sched __schedule(void) { struct task_struct *prev, *next; unsigned long *switch_count; struct rq *rq; int cpu; preempt_disable(); cpu = smp_processor_id(); rq = cpu_rq(cpu); rcu_note_context_switch(); prev = rq-\u003ecurr; schedule_debug(prev); if (sched_feat(HRTICK)) hrtick_clear(rq); /* * Make sure that signal_pending_state()-\u003esignal_pending() below * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) * done by the caller to avoid the race with signal_wake_up(). */ smp_mb__before_spinlock(); raw_spin_lock_irq(\u0026rq-\u003elock); rq-\u003eclock_skip_update \u003c\u003c= 1; /* promote REQ to ACT */ switch_count = \u0026prev-\u003enivcsw; if (prev-\u003estate \u0026\u0026 !(preempt_count() \u0026 PREEMPT_ACTIVE)) { if (unlikely(signal_pending_state(prev-\u003estate, prev))) { prev-\u003estate = TASK_RUNNING; } else { deactivate_task(rq, prev, DEQUEUE_SLEEP); prev-\u003eon_rq = 0; /* * If a worker went to sleep, notify and ask workqueue * whether it wants to wake up a task to maintain * concurrency. */ if (prev-\u003eflags \u0026 PF_WQ_WORKER) { struct task_struct *to_wakeup; to_wakeup = wq_worker_sleeping(prev, cpu); if (to_wakeup) try_to_wake_up_local(to_wakeup); } } switch_count = \u0026prev-\u003envcsw; } if (task_on_rq_queued(prev)) update_rq_clock(rq); next = pick_next_task(rq, prev); clear_tsk_need_resched(prev); clear_preempt_need_resched(); rq-\u003eclock_skip_update = 0; if (likely(prev != next)) { rq-\u003enr_switches++; rq-\u003ecurr = next; ++*switch_count; rq = context_switch(rq, prev, next); /* unlocks the rq */ cpu = cpu_of(rq); } else raw_spin_unlock_irq(\u0026rq-\u003elock); post_schedule(rq); sched_preempt_enable_no_resched(); } graph TD schedule --\u003e __schedule --\u003e context_switch 进入任务切换的核心函数context_switch,这个函数真够复杂的; static inline struct rq *context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next) { struct mm_struct *mm, *oldmm; // 执行切换前准备 prepare_task_switch(rq, prev, next); // 普通进程mm和active_mm相等 // 但是内核线程没有mm,只有active_mm mm = next-\u003emm; oldmm = prev-\u003eactive_mm; arch_start_context_switch(prev); if (!mm) { // 这个是内核线程 next-\u003eactive_mm = oldmm; // next线程借用oldmem，什么原因 atomic_inc(\u0026oldmm-\u003emm_count); // 减少计数 enter_lazy_tlb(oldmm, next); // 进入lazytlb，arm上为空 } else // 这个是用户线程 switch_mm(oldmm, mm, next); if (!prev-\u003emm) { // 代表prev是一个内核线程 prev-\u003eactive_mm = NULL; rq-\u003eprev_mm = oldmm; // 内核线程共享内存 } /* * Since the runqueue lock will be released by the next * task (which is an invalid locking op but in the case * of the scheduler it's an obvious special-case), so we * do an early lockdep release here: */ spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); context_tracking_task_switch(prev, next); // 调试使用 /* Here we just switch the register state and the stack. */ switch_to(prev, next, prev); // 这个函数和体系相关 barrier(); return finish_task_switch(prev); } extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *); #define switch_to(prev,next,last) \\ do { \\ last = __switch_to(prev,task_thread_info(prev), task_thread_info(next)); \\ } while (0) 在arm32的实现中,这个是汇编编写的；我并没有看明白 这个地方和硬件进行强相关； 最终需要考虑的是进程在队列中的实现; ","date":"2021-10-04","objectID":"/scheduler/:4:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#主调度器"},{"categories":["linux"],"content":" 4.2 内存空间切换switch_mm当然也是和硬件体系强相关 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { #ifdef CONFIG_MMU unsigned int cpu = smp_processor_id(); /* * __sync_icache_dcache doesn't broadcast the I-cache invalidation, * so check for possible thread migration and invalidate the I-cache * if we're new to this CPU. */ if (cache_ops_need_broadcast() \u0026\u0026 !cpumask_empty(mm_cpumask(next)) \u0026\u0026 !cpumask_test_cpu(cpu, mm_cpumask(next))) __flush_icache_all(); if (!cpumask_test_and_set_cpu(cpu, mm_cpumask(next)) || prev != next) { check_and_switch_context(next, tsk); if (cache_is_vivt()) cpumask_clear_cpu(cpu, mm_cpumask(prev)); } #endif } ","date":"2021-10-04","objectID":"/scheduler/:4:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#内存空间切换switch_mm"},{"categories":["linux"],"content":" 4.3 滴答调度器 void scheduler_tick(void) { int cpu = smp_processor_id(); struct rq *rq = cpu_rq(cpu); struct task_struct *curr = rq-\u003ecurr; sched_clock_tick(); raw_spin_lock(\u0026rq-\u003elock); update_rq_clock(rq); curr-\u003esched_class-\u003etask_tick(rq, curr, 0); update_cpu_load_active(rq); raw_spin_unlock(\u0026rq-\u003elock); perf_event_task_tick(); #ifdef CONFIG_SMP rq-\u003eidle_balance = idle_cpu(cpu); trigger_load_balance(rq); #endif rq_last_tick_reset(rq); } ","date":"2021-10-04","objectID":"/scheduler/:4:3","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#滴答调度器"},{"categories":["linux"],"content":" 5 就绪队列","date":"2021-10-04","objectID":"/scheduler/:5:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#就绪队列"},{"categories":["linux"],"content":" 5.1 成员分析 struct rq { /* runqueue lock: */ raw_spinlock_t lock; /* * nr_running and cpu_load should be in the same cacheline because * remote CPUs use both these fields when doing load calculation. */ unsigned int nr_running; #ifdef CONFIG_NUMA_BALANCING unsigned int nr_numa_running; unsigned int nr_preferred_running; #endif #define CPU_LOAD_IDX_MAX 5 unsigned long cpu_load[CPU_LOAD_IDX_MAX]; unsigned long last_load_update_tick; #ifdef CONFIG_NO_HZ_COMMON u64 nohz_stamp; unsigned long nohz_flags; #endif #ifdef CONFIG_NO_HZ_FULL unsigned long last_sched_tick; #endif /* capture load from *all* tasks on this cpu: */ struct load_weight load; unsigned long nr_load_updates; u64 nr_switches; struct cfs_rq cfs; struct rt_rq rt; struct dl_rq dl; #ifdef CONFIG_FAIR_GROUP_SCHED /* list of leaf cfs_rq on this cpu: */ struct list_head leaf_cfs_rq_list; struct sched_avg avg; #endif /* CONFIG_FAIR_GROUP_SCHED */ /* * This is part of a global counter where only the total sum * over all CPUs matters. A task can increase this counter on * one CPU and if it got migrated afterwards it may decrease * it on another CPU. Always updated under the runqueue lock: */ unsigned long nr_uninterruptible; struct task_struct *curr, *idle, *stop; unsigned long next_balance; struct mm_struct *prev_mm; unsigned int clock_skip_update; u64 clock; u64 clock_task; atomic_t nr_iowait; #ifdef CONFIG_SMP struct root_domain *rd; struct sched_domain *sd; unsigned long cpu_capacity; unsigned char idle_balance; /* For active balancing */ int post_schedule; int active_balance; int push_cpu; struct cpu_stop_work active_balance_work; /* cpu of this runqueue: */ int cpu; int online; struct list_head cfs_tasks; u64 rt_avg; u64 age_stamp; u64 idle_stamp; u64 avg_idle; /* This is used to determine avg_idle's max value */ u64 max_idle_balance_cost; #endif #ifdef CONFIG_IRQ_TIME_ACCOUNTING u64 prev_irq_time; #endif #ifdef CONFIG_PARAVIRT u64 prev_steal_time; #endif #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING u64 prev_steal_time_rq; #endif /* calc_load related fields */ unsigned long calc_load_update; long calc_load_active; #ifdef CONFIG_SCHED_HRTICK #ifdef CONFIG_SMP int hrtick_csd_pending; struct call_single_data hrtick_csd; #endif struct hrtimer hrtick_timer; #endif #ifdef CONFIG_SCHEDSTATS /* latency stats */ struct sched_info rq_sched_info; unsigned long long rq_cpu_time; /* could above be rq-\u003ecfs_rq.exec_clock + rq-\u003ert_rq.rt_runtime ? */ /* sys_sched_yield() stats */ unsigned int yld_count; /* schedule() stats */ unsigned int sched_count; unsigned int sched_goidle; /* try_to_wake_up() stats */ unsigned int ttwu_count; unsigned int ttwu_local; #endif #ifdef CONFIG_SMP struct llist_head wake_list; #endif #ifdef CONFIG_CPU_IDLE /* Must be inspected within a rcu lock section */ struct cpuidle_state *idle_state; #endif }; 系统中每一个CPU都存在一个就绪队列,一个percpu变量. #define DEFINE_PER_CPU_SHARED_ALIGNED(type, name) \\ DEFINE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \\ ____cacheline_aligned_in_smp DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); 操作宏 DECLARE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); #define cpu_rq(cpu) (\u0026per_cpu(runqueues, (cpu))) #define this_rq() this_cpu_ptr(\u0026runqueues) #define task_rq(p) cpu_rq(task_cpu(p)) #define cpu_curr(cpu) (cpu_rq(cpu)-\u003ecurr) #define raw_rq() raw_cpu_ptr(\u0026runqueues) 设置当前运行队列的任务 ","date":"2021-10-04","objectID":"/scheduler/:5:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#成员分析"},{"categories":["linux"],"content":" 5.2 操作函数 void update_rq_clock(struct rq *rq) { s64 delta; lockdep_assert_held(\u0026rq-\u003elock); if (rq-\u003eclock_skip_update \u0026 RQCF_ACT_SKIP) return; delta = sched_clock_cpu(cpu_of(rq)) - rq-\u003eclock; if (delta \u003c 0) return; rq-\u003eclock += delta; update_rq_clock_task(rq, delta); } ","date":"2021-10-04","objectID":"/scheduler/:5:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#操作函数"},{"categories":["linux"],"content":" 6 调度增强","date":"2021-10-04","objectID":"/scheduler/:6:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度增强"},{"categories":["linux"],"content":" 6.1 组调度组调度:多个用户登录时平均分配计算机时间; /* task group related information */ struct task_group { struct cgroup_subsys_state css; #ifdef CONFIG_FAIR_GROUP_SCHED /* schedulable entities of this group on each cpu */ struct sched_entity **se; /* runqueue \"owned\" by this group on each cpu */ struct cfs_rq **cfs_rq; unsigned long shares; #ifdef CONFIG_SMP atomic_long_t load_avg; atomic_t runnable_avg; #endif #endif #ifdef CONFIG_RT_GROUP_SCHED struct sched_rt_entity **rt_se; struct rt_rq **rt_rq; struct rt_bandwidth rt_bandwidth; #endif struct rcu_head rcu; struct list_head list; struct task_group *parent; struct list_head siblings; struct list_head children; #ifdef CONFIG_SCHED_AUTOGROUP struct autogroup *autogroup; #endif struct cfs_bandwidth cfs_bandwidth; }; ","date":"2021-10-04","objectID":"/scheduler/:6:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#组调度"},{"categories":["linux"],"content":" 6.2 负载均衡","date":"2021-10-04","objectID":"/scheduler/:6:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#负载均衡"},{"categories":["前端知识"],"content":"WebAssembly","date":"2021-10-03","objectID":"/webassembly/","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/"},{"categories":["前端知识"],"content":"WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。 ","date":"2021-10-03","objectID":"/webassembly/:0:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#"},{"categories":["前端知识"],"content":" 1 安装 $ git clone https://github.com/juj/emsdk.git $ cd emsdk $ ./emsdk install sdk-incoming-64bit binaryen-master-64bit $ ./emsdk activate sdk-incoming-64bit binaryen-master-64bit # 使用最新的代码 $ ./emsdk install latest $ ./emsdk activate latest 但是因为llvm需要连接github进行下载,常常会失败,因此需要使用mirror, 修改emsdk_manifest.json,找到https://github.com/llvm/llvm-project.git,修改为 https://mirrors.tuna.tsinghua.edu.cn/git/llvm-project.git,然后在执行下编译. 工具链编译结束,导入环境变量 source ./emsdk_env.sh ","date":"2021-10-03","objectID":"/webassembly/:1:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#安装"},{"categories":["前端知识"],"content":" 2 入门 #include \u003cstdio.h\u003e int main(int argc, char *argv[]) { printf(\"Hello world\\r\\n\"); return 0; } #include \u003ciostream\u003e int main(int argc, char *argv[]) { std::cout \u003c\u003c \"Hello world\\r\\n\" \u003c\u003c std::endl; return 0; } 执行编译 emcc hello.c -s WASM=1 -o hello.html # 执行编译 emrun --no_browser --port 8080 . # 运行 ","date":"2021-10-03","objectID":"/webassembly/:2:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#入门"},{"categories":null,"content":" 博客内容 大部分都没有完成 C C++ C++教程 C++模板 stl分析 汇编语言 kernel 系统调度 组调度 PLET 负载均衡 完全公平调度算法 实时系统 FreeRTOS RT-Thread 编译原理 cmake 编程语言 python rust go lua 前端 html5 css3 javascript typescript wasm ","date":"2021-09-25","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/#博客内容"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制 ","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#"},{"categories":null,"content":" 使用","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#使用"},{"categories":null,"content":" 1 等待队列头 struct __wait_queue_head { wq_lock_t lock; struct list_head task_list; }; typedef struct __wait_queue_head wait_queue_head_t; ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列头"},{"categories":null,"content":" 2 等待队列实体 struct __wait_queue { unsigned int flags; struct task_struct * task; struct list_head task_list; }; typedef struct __wait_queue wait_queue_t; ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列实体"},{"categories":null,"content":" 3 初始化等待队列头 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *); void init_waitqueue_head(struct wait_queue_head *wq_head); ","date":"2021-05-04","objectID":"/wait_queue/:3:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列头"},{"categories":null,"content":" 4 初始化等待队列 #define __WAITQUEUE_INITIALIZER(name, tsk) \\ { \\ .private = tsk, \\ .func = default_wake_function, \\ .entry = { NULL, NULL } \\ } #define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) // 但是，一般直接 DECLARE_WAITQUEUE(wait, current); 等待队列入口 等待的任务 ","date":"2021-05-04","objectID":"/wait_queue/:4:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列"},{"categories":null,"content":" 5 等待队列操作 void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); 等待队列头 等待队列实体 ","date":"2021-05-04","objectID":"/wait_queue/:5:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列操作"},{"categories":null,"content":" 6 等待事件 void wait_event(wq, condition); void wait_event_interruptible(wq, condition); ","date":"2021-05-04","objectID":"/wait_queue/:6:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待事件"},{"categories":null,"content":" 7 唤醒队列 wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync ","date":"2021-05-04","objectID":"/wait_queue/:7:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#唤醒队列"},{"categories":null,"content":" 例子","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#例子"},{"categories":null,"content":" 1 写端 ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = -1; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_write; } add_wait_queue(\u0026wait_device.wait_w, \u0026wait); while (wait_device.wait_flag == true) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); pure_write: wait_device.wait_flag = true; pr_err(\"Write Successful\"); wake_up_interruptible(\u0026wait_device.wait_r); pr_err(\"Wakeup Read\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return ret; } ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#写端"},{"categories":null,"content":" 2 读端 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = 0; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_read; } add_wait_queue(\u0026wait_device.wait_r, \u0026wait); while (wait_device.wait_flag == false) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); pure_read: wait_device.wait_flag = false; pr_err(\"Read Successful\"); wake_up_interruptible(\u0026wait_device.wait_w); pr_err(\"Wakeup Write\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return 0; } ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#读端"},{"categories":null,"content":" 原理","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#原理"},{"categories":["编译原理"],"content":"编译原理","date":"2021-05-04","objectID":"/antlr/","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/"},{"categories":["编译原理"],"content":" 1 简介 ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件. 类似于flex/bison,根据描述文件,自动生成词法语法分析器; 解析规则文件,生成解析源文件,与SDK组合编译生成可执行文件; 生成器可以支持的语言,但是下面我只会其中的几个语言: 因此暂时只进行下面几种语言的开发,下面描述开发的情况和进度 Python3 JavaScript Go C++ ","date":"2021-05-04","objectID":"/antlr/:1:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#简介"},{"categories":["编译原理"],"content":" 2 安装说明 下载antlr 设置path和classpath 编写相关脚本 ","date":"2021-05-04","objectID":"/antlr/:2:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#安装说明"},{"categories":["编译原理"],"content":" 3 语法设计","date":"2021-05-04","objectID":"/antlr/:3:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#语法设计"},{"categories":["编译原理"],"content":" 4 错误处理","date":"2021-05-04","objectID":"/antlr/:4:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#错误处理"},{"categories":["编译原理"],"content":" 5 解析器","date":"2021-05-04","objectID":"/antlr/:5:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#解析器"},{"categories":["编译原理"],"content":" 6 测试程序","date":"2021-05-04","objectID":"/antlr/:6:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#测试程序"},{"categories":["编译原理"],"content":" 6.1 antlr4编译器 #!/bin/sh antlr4 Expr.g4 ","date":"2021-05-04","objectID":"/antlr/:6:1","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#antlr4编译器"},{"categories":["编译原理"],"content":" 6.2 编译生成的java文件 $ javac *.java ","date":"2021-05-04","objectID":"/antlr/:6:2","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#编译生成的java文件"},{"categories":["编译原理"],"content":" 6.3 运行编译的结果 $ grun Expr prog -tree (prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) grun Expr prog -gui grun Expr prog -tokens [@0,0:0='1',\u003cINT\u003e,1:0] [@1,1:1='+',\u003c'+'\u003e,1:1] [@2,2:2='2',\u003cINT\u003e,1:2] [@3,3:3='+',\u003c'+'\u003e,1:3] [@4,4:4='3',\u003cINT\u003e,1:4] [@5,5:6='\\r\\n',\u003cNEWLINE\u003e,1:5] [@6,7:6='\u003cEOF\u003e',\u003cEOF\u003e,2:0] ","date":"2021-05-04","objectID":"/antlr/:6:3","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#运行编译的结果"},{"categories":["编译原理"],"content":" 7 antlr语法详解","date":"2021-05-04","objectID":"/antlr/:7:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#antlr语法详解"},{"categories":["编译原理"],"content":" 7.1 Hello // antlr4 Hello.g4 // javac *.java // grun Hello r -gui grammar Hello; // 定义一个Hello的grammer r : 'hello' ID ; // 开头是hello后面接着一个ID ID : [a-z]+ ; // ID由小写字母组成 WS : [ \\t\\r\\n]+ -\u003e skip ; // 控制符清除 ","date":"2021-05-04","objectID":"/antlr/:7:1","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#hello"},{"categories":["编译原理"],"content":" 7.2 ArrayInit // antlr4 ArrayInit.g4 // javac *.java // grun ArrayInit init -gui grammar ArrayInit; // 定义一个ArrayInit的grammer init : '{' value (',' value)* '}' ; // value : init // 嵌套定义 | INT // 定义整数 ; INT : [0-9]+ ; WS : [ \\t\\r\\n]+ -\u003e skip ; ()* –\u003e 相当于扩展 ","date":"2021-05-04","objectID":"/antlr/:7:2","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#arrayinit"},{"categories":["编译原理"],"content":" 7.3 Expr // antlr4 Expr.g4 // javac *.java // grun Expr prog -gui grammar Expr; prog : stat+; stat: expr NEWLINE # printExpr | ID '=' expr NEWLINE # assign | NEWLINE # blank ; expr: expr op=('*'|'/') expr # MulDiv | expr op=('+'|'-') expr # AddSub | INT # int | ID # id | '('expr')' # parens ; MUL : '*' ; // assigns token name to '*' used above in grammar DIV : '/' ; ADD : '+' ; SUB : '-' ; ID : [a-zA-Z]+ ; INT : [0-9]+ ; NEWLINE :'\\r'? '\\n' ; WS : [ \\t]+ -\u003e skip; ","date":"2021-05-04","objectID":"/antlr/:7:3","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#expr"},{"categories":["编译原理"],"content":" 7.4 json 在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础 grammar JSON; // 声明一个grammar json : value // 一个value候选 ; obj // 对象类型 : '{' pair (',' pair)* '}' | '{' '}' ; pair : STRING ':' value ; arr : '[' value (',' value)* ']' | '[' ']' ; value : STRING | NUMBER | obj | arr | 'true' | 'false' | 'null' ; STRING : '\"' (ESC | SAFECODEPOINT)* '\"' ; fragment ESC : '\\\\' ([\"\\\\/bfnrt] | UNICODE) ; fragment UNICODE : 'u' HEX HEX HEX HEX ; fragment HEX : [0-9a-fA-F] ; fragment SAFECODEPOINT : ~ [\"\\\\\\u0000-\\u001F] ; NUMBER : '-'? INT ('.' [0-9] +)? EXP? ; fragment INT : '0' | [1-9] [0-9]* ; // no leading zeros fragment EXP : [Ee] [+\\-]? INT ; // \\- since - means \"range\" inside [...] WS : [ \\t\\n\\r] + -\u003e skip ; 测试例子 { \"glossary\": { \"title\": \"example glossary\", \"GlossDiv\": { \"title\": \"S\", \"GlossList\": { \"GlossEntry\": { \"ID\": \"SGML\", \"SortAs\": \"SGML\", \"GlossTerm\": \"Standard Generalized Markup Language\", \"Acronym\": \"SGML\", \"Abbrev\": \"ISO 8879:1986\", \"GlossDef\": { \"para\": \"A meta-markup language\", \"GlossSeeAlso\": [\"GML\", \"XML\"] }, \"GlossSee\": \"markup\" } } } } } 显示结果： ","date":"2021-05-04","objectID":"/antlr/:7:4","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#json"},{"categories":["编译原理"],"content":" 7.5 XML 孤岛语法: ","date":"2021-05-04","objectID":"/antlr/:7:5","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#xml"},{"categories":["编译原理"],"content":" 7.6 dot grammar DOT; graph : STRICT? ( GRAPH | DIGRAPH ) id_? '{' stmt_list '}' ; stmt_list : ( stmt ';'? )* ; stmt : node_stmt | edge_stmt | attr_stmt | id_ '=' id_ | subgraph ; attr_stmt : ( GRAPH | NODE | EDGE ) attr_list ; attr_list : ( '[' a_list? ']' )+ ; a_list : ( id_ ( '=' id_ )? ','? )+ ; edge_stmt : ( node_id | subgraph ) edgeRHS attr_list? ; edgeRHS : ( edgeop ( node_id | subgraph ) )+ ; edgeop : '-\u003e' | '--' ; node_stmt : node_id attr_list? ; node_id : id_ port? ; port : ':' id_ ( ':' id_ )? ; subgraph : ( SUBGRAPH id_? )? '{' stmt_list '}' ; id_ : ID | STRING | HTML_STRING | NUMBER ; // \"The keywords node, edge, graph, digraph, subgraph, and strict are // case-independent\" STRICT : [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] ; GRAPH : [Gg] [Rr] [Aa] [Pp] [Hh] ; DIGRAPH : [Dd] [Ii] [Gg] [Rr] [Aa] [Pp] [Hh] ; NODE : [Nn] [Oo] [Dd] [Ee] ; EDGE : [Ee] [Dd] [Gg] [Ee] ; SUBGRAPH : [Ss] [Uu] [Bb] [Gg] [Rr] [Aa] [Pp] [Hh] ; /** \"a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\" */ NUMBER : '-'? ( '.' DIGIT+ | DIGIT+ ( '.' DIGIT* )? ) ; fragment DIGIT : [0-9] ; /** \"any double-quoted string (\"...\") possibly containing escaped quotes\" */ STRING : '\"' ( '\\\\\"' | . )*? '\"' ; /** \"Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores * ('_') or digits ([0-9]), not beginning with a digit\" */ ID : LETTER ( LETTER | DIGIT )* ; fragment LETTER : [a-zA-Z\\u0080-\\u00FF_] ; /** \"HTML strings, angle brackets must occur in matched pairs, and * unescaped newlines are allowed.\" */ HTML_STRING : '\u003c' ( TAG | ~ [\u003c\u003e] )* '\u003e' ; fragment TAG : '\u003c' .*? '\u003e' ; COMMENT : '/*' .*? '*/' -\u003e skip ; LINE_COMMENT : '//' .*? '\\r'? '\\n' -\u003e skip ; /** \"a '#' character is considered a line output from a C preprocessor (e.g., * # 34 to indicate line 34 ) and discarded\" */ PREPROC : '#' ~[\\r\\n]* -\u003e skip ; WS : [ \\t\\n\\r]+ -\u003e skip ; ","date":"2021-05-04","objectID":"/antlr/:7:6","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#dot"},{"categories":null,"content":" 1 基本操作","date":"2021-05-04","objectID":"/hugo/:1:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#基本操作"},{"categories":null,"content":" 1.1 安装hugo在linux/windows上只能通过直接release下载, ","date":"2021-05-04","objectID":"/hugo/:1:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#安装hugo"},{"categories":null,"content":" 1.2 创建网站 hugo new site 路径 ","date":"2021-05-04","objectID":"/hugo/:1:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建网站"},{"categories":null,"content":" 1.3 添加主题 将主题直接添加到theme文件下面 将主题作为一个submodule ","date":"2021-05-04","objectID":"/hugo/:1:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#添加主题"},{"categories":null,"content":" 1.4 创建文档 hugo new posts/hugo.md ","date":"2021-05-04","objectID":"/hugo/:1:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建文档"},{"categories":null,"content":" 1.5 设置预览 hugo server -D --disableFastRender ","date":"2021-05-04","objectID":"/hugo/:1:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#设置预览"},{"categories":null,"content":" 2 文件结构 . ├── archetypes ├── config ├── content ├── data ├── layouts ├── static ├── themes ├── static └── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。 ","date":"2021-05-04","objectID":"/hugo/:2:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#文件结构"},{"categories":null,"content":" 2.1 archetypeshugo模板,在创建文件时作为模板自动生成 ","date":"2021-05-04","objectID":"/hugo/:2:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#archetypes"},{"categories":null,"content":" 2.2 assets存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录 ","date":"2021-05-04","objectID":"/hugo/:2:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#assets"},{"categories":null,"content":" 2.3 configHugo配置目录 ","date":"2021-05-04","objectID":"/hugo/:2:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#config"},{"categories":null,"content":" 2.4 content此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分. ","date":"2021-05-04","objectID":"/hugo/:2:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#content"},{"categories":null,"content":" 2.5 data该目录用于存储 Hugo 在生成网站时可以使用的配置文件 ","date":"2021-05-04","objectID":"/hugo/:2:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#data"},{"categories":null,"content":" 2.6 layouts以 .html文件的形式存储模板. ","date":"2021-05-04","objectID":"/hugo/:2:6","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#layouts"},{"categories":null,"content":" 2.7 static存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制 ","date":"2021-05-04","objectID":"/hugo/:2:7","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#static"},{"categories":null,"content":" 3 编写工具","date":"2021-05-04","objectID":"/hugo/:3:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#编写工具"},{"categories":null,"content":" 3.1 typora使用typora作为markdown编写工具 ","date":"2021-05-04","objectID":"/hugo/:3:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#typora"},{"categories":null,"content":" 3.2 picgo ","date":"2021-05-04","objectID":"/hugo/:3:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#picgo"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线","uri":"/offline/#"}]
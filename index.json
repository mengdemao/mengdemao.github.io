[{"categories":["pthread"],"content":"线程局部存储分析","date":"2022-07-18","objectID":"/pthread_local_storage/","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/"},{"categories":["pthread"],"content":" 1 前言 在Linux C/C++编程时不可避免的会遇到以下的需求,全局变量线程共享;最为典型的功能则是errno,变量 在程序的任何地方都可以访问,但是不会影响到其他线程,这就是本文档说明的TLS(线程局部存储变量) 如何创建并且使用TLS? 存在下面两种方法 线程库函数 编译器提供 下面分别进行说明分析 ","date":"2022-07-18","objectID":"/pthread_local_storage/:1:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#前言"},{"categories":["pthread"],"content":" 2 线程库函数 pthread提供了函数用来处理TLS, 分别管理键值和数据 ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#线程库函数"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 j\u003cPTHREAD_DESTRUCTOR_ITERATIONS; j++) { self-\u003etsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#创建键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#销毁键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#析构调用"},{"categories":["pthread"],"content":" 2.2 数据 void *pthread_getspecific(pthread_key_t); int pthread_setspecific(pthread_key_t, const void *); // 设置 self-\u003etsd[k] = 私有数据; self-\u003etsd_used = 1; // 读取 return self-\u003etsd[k]; ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:2","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#数据"},{"categories":["pthread"],"content":" 3 编译器提供 musl线程库提供的私有数据还可以理解,但是GCC的__thread变量就比较难以分析了,因此此时只能通过 汇编文件进行分析 給出测试程序 __thread int num; int test(void) { return num; } GCC生成的汇编语言 num: test: push {r7} @ 进入函数,保存现场 add r7, sp, #0 @ R7 = SP mrc p15, 0, r3, c13, c0, 3 @ R3 = 线程号 ldr r2, .L3 @ R2 = \u0026num ldr r3, [r3, r2] @ R3 = *((int *)(R3 + R2)) mov r0, r3 @ R0 = R3 mov sp, r7 @ 恢复SP ldr r7, [sp], #4 @ 恢复R7 bx lr @ return .L3: .word num(tpoff) 但是到现在我们还是没有通过汇编理解原因,但是我们可以注意到一个可疑点.word num(tpoff),这个表达式中tpoff是什么?那么只好到GCC官网上看看是怎么处理的. GCC Thread-Local Storage 同时可以得到一份文档ELF Handling For Thread-Local Storage; 那么就开始分析此文档 ","date":"2022-07-18","objectID":"/pthread_local_storage/:3:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#编译器提供"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_lock/","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/"},{"categories":["pthread"],"content":" 1 futex实现 高级锁的实现都是与futex实现相关 Futex是Fast Userspace muTexes的缩写 常用的锁都是通过futex实现的 mutex (互斥锁) rwlock (读写锁) cond (条件变量) ","date":"2022-07-18","objectID":"/pthread_lock/:1:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#futex实现"},{"categories":["pthread"],"content":" 1.1 内核实现但是我并没有搞明白futex实现的原理,造成难以继续分析, 因此只能分析别人的文档(注:不分析原理,只进行使用) 主要存在文件futex-internal.c/futex-internal.h,lowlevellock-futex.h,lowlevellock.c 另外lll-\u003elowlevellock缩写形式 其中futex提供的最重要的两个操作wait和wake // 可以使用的op定义类型 #define FUTEX_WAIT 0 #define FUTEX_WAKE 1 #define FUTEX_REQUEUE 3 #define FUTEX_CMP_REQUEUE 4 #define FUTEX_WAKE_OP 5 #define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE ((4 \u003c\u003c 24) | 1) #define FUTEX_LOCK_PI 6 #define FUTEX_UNLOCK_PI 7 #define FUTEX_TRYLOCK_PI 8 #define FUTEX_WAIT_BITSET 9 #define FUTEX_WAKE_BITSET 10 #define FUTEX_WAIT_REQUEUE_PI 11 #define FUTEX_CMP_REQUEUE_PI 12 #define FUTEX_LOCK_PI2 13 #define FUTEX_PRIVATE_FLAG 128 #define FUTEX_CLOCK_REALTIME 256 ","date":"2022-07-18","objectID":"/pthread_lock/:1:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#内核实现"},{"categories":["pthread"],"content":" 1.2 musl实现 #define lll_trylock(lock) 原子的(lock 0 --\u003e 1) // 不等待 #define lll_cond_trylock(lock) 原子的(lock 0 --\u003e 2) // 不等待 #define lll_lock(futex, private) 1. 原子的(futex 0 --\u003e 1) // 等待 2. __lll_lock_wait (futex, private) #define __lll_cond_lock(futex, private) 1. 原子的(futex 0 --\u003e 2) // 等待 2. __lll_lock_wait (futex, private) #define __lll_unlock(futex, private) 1. 原子的(futex ? --\u003e 0) // 等待 2. __lll_lock_wait (futex, private) void __lll_lock_wake_private (int *futex); void __lll_lock_wait_private (int *futex); void __lll_lock_wait (int *futex, int private); void __lll_lock_wake (int *futex, int private); int lll_futex_wake(int *futex, int nr, int private); int lll_futex_wait(int *futex, int val, int private); int futex_wait(unsigned int *futex_word, unsigned int expected, int private); void futex_wake(unsigned int* futex_word, int processes_to_wake, int private); // 进入系统调用阶段 int lll_futex_syscall(int nargs, int *futexp, int op, ...); 那么进入到最后可以得知,一般会进行一些原子操作,启动的操作都是INTERNAL_SYSCALL进行实现的,然后就是swi指令实现的原理 ","date":"2022-07-18","objectID":"/pthread_lock/:1:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现"},{"categories":["pthread"],"content":" 2 原子操作","date":"2022-07-18","objectID":"/pthread_lock/:2:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#原子操作"},{"categories":["pthread"],"content":" 2.1 musl实现 /// 原子操作由汇编实现 ","date":"2022-07-18","objectID":"/pthread_lock/:2:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-1"},{"categories":["pthread"],"content":" 2.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:2:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现"},{"categories":["pthread"],"content":" 3 自旋锁","date":"2022-07-18","objectID":"/pthread_lock/:3:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#自旋锁"},{"categories":["pthread"],"content":" 3.1 musl实现spinlock句柄就是一个32位的数; typedef int pthread_spinlock_t; 五种函数的实现 int pthread_spin_init(pthread_spinlock_t *s, int shared) { return *s = 0; } int pthread_spin_destroy(pthread_spinlock_t *s) { return 0; } int pthread_spin_lock(pthread_spinlock_t *s) { while (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin(); return 0; } int pthread_spin_trylock(pthread_spinlock_t *s) { return a_cas(s, 0, EBUSY); } int pthread_spin_unlock(pthread_spinlock_t *s) { a_store(s, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:3:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-2"},{"categories":["pthread"],"content":" 3.2 glibc实现glibc的实现就较为复杂了点 typedef __pthread_spinlock_t pthread_spinlock_t; typedef volatile int __pthread_spinlock_t; 加上__作为内部使用的句柄 volatile使编译器强行读取 int pthread_spin_init(pthread_spinlock_t *lock, int pshared) { /* Relaxed MO is fine because this is an initializing store. */ atomic_store_relaxed(lock, 0); return 0; } int pthread_spin_destroy (pthread_spinlock_t *lock) { /* Nothing to do. */ return 0; } int pthread_spin_lock (pthread_spinlock_t *lock) { int val = 0; #if ! ATOMIC_EXCHANGE_USES_CAS if (__glibc_likely(atomic_exchange_acquire(lock, 1) == 0)) { return 0; } #else if (__glibc_likely(atomic_compare_exchange_weak_acquire(lock, \u0026val, 1))) { return 0; } #endif do { do { atomic_spin_nop(); val = atomic_load_relaxed(lock); } while (val != 0); } while (!atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)); return 0; } int pthread_spin_trylock(pthread_spinlock_t *lock) { #if ! ATOMIC_EXCHANGE_USES_CAS if (atomic_exchange_acquire (lock, 1) == 0) { return 0; } #else do { int val = 0; if (atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)) return 0; } while (atomic_load_relaxed (lock) == 0); #endif return EBUSY; } int pthread_spin_unlock(pthread_spinlock_t *lock) { atomic_store_release(lock, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:3:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-1"},{"categories":["pthread"],"content":" 4 内存屏障","date":"2022-07-18","objectID":"/pthread_lock/:4:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#内存屏障"},{"categories":["pthread"],"content":" 4.1 musl实现 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); ","date":"2022-07-18","objectID":"/pthread_lock/:4:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-3"},{"categories":["pthread"],"content":" 4.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:4:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-2"},{"categories":["pthread"],"content":" 5 互斥锁","date":"2022-07-18","objectID":"/pthread_lock/:5:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#互斥锁"},{"categories":["pthread"],"content":" 5.1 musl实现在musl库上的互斥锁,但是我感觉musl的设计存在一些瑕疵,还是在去分析一下glibc的设计思路吧. typedef struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t; int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a) { *m = (pthread_mutex_t){0}; if (a) { m-\u003e_m_type = a-\u003e__attr; } return 0; } int pthread_mutex_destroy(pthread_mutex_t *mutex) { if (mutex-\u003e_m_type \u003e 128) { __vm_wait(); } return 0; } int pthread_mutex_lock(pthread_mutex_t *m) { if ((m-\u003e_m_type \u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; return __pthread_mutex_timedlock(m, 0); } int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at) { /* PTHREAD_MUTEX_NORMAL:死等 */ if ((m-\u003e_m_type\u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; int type = m-\u003e_m_type; int r, t, priv = (type \u0026 128) ^ 128; /* 尝试加锁 */ r = __pthread_mutex_trylock(m); if (r != EBUSY) { return r; } if (type\u00268) return pthread_mutex_timedlock_pi(m, at); int spins = 100; while (spins-- \u0026\u0026 m-\u003e_m_lock \u0026\u0026 !m-\u003e_m_waiters) a_spin(); while ((r=__pthread_mutex_trylock(m)) == EBUSY) { r = m-\u003e_m_lock; int own = r \u0026 0x3fffffff; if (!own \u0026\u0026 (!r || (type\u00264))) continue; if ((type\u00263) == PTHREAD_MUTEX_ERRORCHECK \u0026\u0026 own == __pthread_self()-\u003etid) return EDEADLK; a_inc(\u0026m-\u003e_m_waiters); t = r | 0x80000000; a_cas(\u0026m-\u003e_m_lock, r, t); r = __timedwait(\u0026m-\u003e_m_lock, t, CLOCK_REALTIME, at, priv); a_dec(\u0026m-\u003e_m_waiters); if (r \u0026\u0026 r != EINTR) break; } return r; } ","date":"2022-07-18","objectID":"/pthread_lock/:5:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-4"},{"categories":["pthread"],"content":" 5.2 glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) 5.2.1 互斥锁的定义 struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 int __pthread_mutex_lock (pthread_mutex_t *mtxp) { struct __pthread *self; int flags = mtxp-\u003e__flags \u0026 GSYNC_SHARED; int ret = 0; // 根据不同的类型确定 #define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED #define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) #define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) switch (MTX_TYPE (mtxp)) { /* 普通上锁方式 */ case PT_MTX_NORMAL: lll_lock (mtxp-\u003e__lock, flags); break; /* 迭代锁 */ case PT_MTX_RECURSIVE: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) { if (__glibc_unlikely (mtxp-\u003e__cnt + 1 == 0)) return EAGAIN; ++mtxp-\u003e__cnt; return ret; } lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); mtxp-\u003e__cnt = 1; break; case PT_MTX_ERRORCHECK: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) return EDEADLK; lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); break; case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: self = _pthread_self (); ROBUST_LOCK (self, mtxp, lll_robust_lock, flags); break; default: ret = EINVAL; break; } return ret; } ","date":"2022-07-18","objectID":"/pthread_lock/:5:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-3"},{"categories":["pthread"],"content":" 5.2 glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) 5.2.1 互斥锁的定义 struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 int __pthread_mutex_lock (pthread_mutex_t *mtxp) { struct __pthread *self; int flags = mtxp-\u003e__flags \u0026 GSYNC_SHARED; int ret = 0; // 根据不同的类型确定 #define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED #define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) #define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) switch (MTX_TYPE (mtxp)) { /* 普通上锁方式 */ case PT_MTX_NORMAL: lll_lock (mtxp-\u003e__lock, flags); break; /* 迭代锁 */ case PT_MTX_RECURSIVE: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) { if (__glibc_unlikely (mtxp-\u003e__cnt + 1 == 0)) return EAGAIN; ++mtxp-\u003e__cnt; return ret; } lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); mtxp-\u003e__cnt = 1; break; case PT_MTX_ERRORCHECK: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) return EDEADLK; lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); break; case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: self = _pthread_self (); ROBUST_LOCK (self, mtxp, lll_robust_lock, flags); break; default: ret = EINVAL; break; } return ret; } ","date":"2022-07-18","objectID":"/pthread_lock/:5:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#互斥锁的定义"},{"categories":["pthread"],"content":" 6 条件变量","date":"2022-07-18","objectID":"/pthread_lock/:6:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#条件变量"},{"categories":["pthread"],"content":" 6.1 musl实现","date":"2022-07-18","objectID":"/pthread_lock/:6:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-5"},{"categories":["pthread"],"content":" 6.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:6:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-4"},{"categories":["pthread"],"content":" 7 读写锁","date":"2022-07-18","objectID":"/pthread_lock/:7:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#读写锁"},{"categories":["pthread"],"content":" 7.1 musl实现","date":"2022-07-18","objectID":"/pthread_lock/:7:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-6"},{"categories":["pthread"],"content":" 7.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:7:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-5"},{"categories":["pthread"],"content":" 8 pthread杂项","date":"2022-07-18","objectID":"/pthread_lock/:8:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#pthread杂项"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_thread/","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/"},{"categories":["pthread"],"content":" 基于musl源码库与glibc库,其中musl提供分析的思路,glibc分析具体实现 ","date":"2022-07-18","objectID":"/pthread_thread/:0:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#"},{"categories":["pthread"],"content":" 1 pthread句柄","date":"2022-07-18","objectID":"/pthread_thread/:1:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread句柄"},{"categories":["pthread"],"content":" 1.1 musl实现 struct pthread { struct pthread *self; #ifndef TLS_ABOVE_TP uintptr_t *dtv; #endif /* 线程链表项 */ struct pthread *prev, *next; /* non-ABI */ /* 系统信息 */ uintptr_t sysinfo; #ifndef TLS_ABOVE_TP #ifdef CANARY_PAD uintptr_t canary_pad; #endif uintptr_t canary; #endif /* TLS_ABOVE_TP */ int tid; // 线程ID int errno_val; volatile int detach_state; // 分离状态 volatile int cancel; // cancle启动标志 volatile unsigned char canceldisable; // cancle控制 volatile unsigned char cancelasync; // cancle同步标志 unsigned char tsd_used:1; unsigned char dlerror_flag:1; unsigned char *map_base; // mmap size_t map_size; void *stack; // 堆栈 size_t stack_size; size_t guard_size; void *result; // 返回结果, /* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ struct __ptcb *cancelbuf; void **tsd; struct { volatile void *volatile head; long off; volatile void *volatile pending; } robust_list; int h_errno_val; volatile int timer_id; locale_t locale; volatile int killlock[1]; // 退出锁 char *dlerror_buf; void *stdio_locks; #ifdef TLS_ABOVE_TP uintptr_t canary; uintptr_t *dtv; #endif }; ","date":"2022-07-18","objectID":"/pthread_thread/:1:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#musl实现"},{"categories":["pthread"],"content":" 1.2 glibc实现 struct __pthread { /* 线程ID: typedef unsigned long int pthread_t; */ pthread_t thread; unsigned int nr_refs; /* Detached threads have a self reference only, while joinable threads have two references. These are used to keep the structure valid at thread destruction. Detaching/joining a thread drops a reference. */ /* Cancellation. */ pthread_mutex_t cancel_lock; /* Protect cancel_xxx members. */ void (*cancel_hook) (void *); /* Called to unblock a thread blocking in a cancellation point (namely, __pthread_cond_timedwait_internal). */ void *cancel_hook_arg; int cancel_state; int cancel_type; int cancel_pending; /* Thread stack. */ void *stackaddr; /* 堆栈地址 */ size_t stacksize; /* 堆栈大小 */ size_t guardsize; /* 预留用来保护堆栈大小的字节 */ int stack; /* Nonzero if the stack was allocated. */ /* Exit status. */ void *status; /* Thread state. */ enum pthread_state state; pthread_mutex_t state_lock; /* Locks the state. */ pthread_cond_t state_cond; /* Signalled when the state changes. */ bool terminated; /* Whether the kernel thread is over and we can reuse this structure. */ /* Resolver state. */ struct __res_state res_state; /* Indicates whether is a C11 thread created by thrd_creat. */ bool c11; /* Initial sigset for the thread. */ sigset_t init_sigset; /* Thread context. */ struct pthread_mcontext mcontext; PTHREAD_KEY_MEMBERS /* void **thread_specifics; // This is only resized by the thread, and always growing unsigned thread_specifics_size; // Number of entries in thread_specifics */ PTHREAD_SYSDEP_MEMBERS /* thread_t kernel_thread; mach_msg_header_t wakeupmsg; */ /* 线程控制块:与系统进行沟通 */ tcbhead_t *tcb; /* Queue links. Since PREVP is used to determine if a thread has been awaken, it must be protected by the queue lock. */ struct __pthread *next, **prevp; }; 但是在我们使用的时候发现与我们正常的使用不太一致,在用户层,我们一般认为pthread为线程ID，但是内部实现好像都是指针,因此出现了什么特殊的原因； 在musl中,直接抹掉了内部结构; // 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 #ifdef __cplusplus typedef unsigned long pthread_t; #else typedef struct __pthread* pthread_t; #endif 而在glibc中,线程ID仅仅是线程结构体中的一个成员,因此,glibc的处理更加安全, 下面分析一下id的实现, __pthread_create (pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine) (void *), void *arg) { int err; struct __pthread *pthread; err = __pthread_create_internal (\u0026pthread, attr, start_routine, arg); if (!err) *thread = pthread-\u003ethread; else if (err == ENOMEM) err = EAGAIN; return err; } /* 那么可以明白,线程ID */ int _dl_pthread_num_threads; struct __pthread **_dl_pthread_threads; __libc_rwlock_define_initialized (, _dl_pthread_threads_lock) /* 下面的代码实现线程ID的分配:只保留了成功的部分,没有考虑意外情况 */ __libc_rwlock_wrlock (GL(dl_pthread_threads_lock)); if (GL(dl_pthread_num_threads) \u003c __pthread_max_threads) { /* We have a free slot. Use the slot number plus one as the thread ID for the new thread. */ new-\u003ethread = 1 + GL(dl_pthread_num_threads)++; GL(dl_pthread_threads)[new-\u003ethread - 1] = NULL; __libc_rwlock_unlock (GL(dl_pthread_threads_lock)); *pthread = new; return 0; } 但是GL是什么呢?hehe #define GL(x) _##x ","date":"2022-07-18","objectID":"/pthread_thread/:1:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现"},{"categories":["pthread"],"content":" 2 所有的函数","date":"2022-07-18","objectID":"/pthread_thread/:2:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#所有的函数"},{"categories":["pthread"],"content":" 2.1 线程基础 // 线程创建 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict); // 线程退出 void pthread_exit(void *); // 线程属性 int pthread_attr_init(pthread_attr_t *); int pthread_attr_destroy(pthread_attr_t *); int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setguardsize(pthread_attr_t *, size_t); int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setstacksize(pthread_attr_t *, size_t); int pthread_attr_getdetachstate(const pthread_attr_t *, int *); int pthread_attr_setdetachstate(pthread_attr_t *, int); int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); int pthread_attr_setstack(pthread_attr_t *, void *, size_t); int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setscope(pthread_attr_t *, int); int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setschedpolicy(pthread_attr_t *, int); int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setinheritsched(pthread_attr_t *, int); ","date":"2022-07-18","objectID":"/pthread_thread/:2:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程基础"},{"categories":["pthread"],"content":" 2.2 线程分离 // 线程分离 int pthread_detach(pthread_t); // 线程等待 int pthread_join(pthread_t, void **); // 获取线程自己的ID pthread_t pthread_self(void); // 判断线程是否相等 int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 ","date":"2022-07-18","objectID":"/pthread_thread/:2:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离"},{"categories":["pthread"],"content":" 2.3 线程取消 int pthread_setcancelstate(int, int *); int pthread_setcanceltype(int, int *); void pthread_testcancel(void); int pthread_cancel(pthread_t); ","date":"2022-07-18","objectID":"/pthread_thread/:2:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程取消"},{"categories":["pthread"],"content":" 2.4 调度相关 int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param); __syscall(SYS_sched_getparam, pthread_t-\u003etid, sched_param); __syscall(SYS_sched_getscheduler, pthread_t-\u003etid); int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param); __syscall(SYS_sched_setscheduler, pthread_t-\u003etid, policy, sched_param); // sched_param保存着优先级参数 int pthread_setschedprio(pthread_t t, int prio); __syscall(SYS_sched_setparam, pthread_t-\u003etid, \u0026prio); ","date":"2022-07-18","objectID":"/pthread_thread/:2:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#调度相关"},{"categories":["pthread"],"content":" 3 补充知识","date":"2022-07-18","objectID":"/pthread_thread/:3:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#补充知识"},{"categories":["pthread"],"content":" 3.1 Linux线程实现","date":"2022-07-18","objectID":"/pthread_thread/:3:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#linux线程实现"},{"categories":["pthread"],"content":" 3.2 系统调用实现 #define __asm_syscall(...) do { __asm__ __volatile__ ( \"svc 0\" : \"=r\"(r0) : __VA_ARGS__ : \"memory\"); return r0; } while (0); #define R7_OPERAND \"r\"(r7) static inline long __syscall0(long n) { register long r7 __ASM____R7__ = n; //使用R7传递个数 register long r0 __asm__(\"r0\"); __asm_syscall(R7_OPERAND); } static inline long __syscall1(long n, long a) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; __asm_syscall(R7_OPERAND, \"0\"(r0)); } static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; register long r1 __asm__(\"r1\") = b; register long r2 __asm__(\"r2\") = c; register long r3 __asm__(\"r3\") = d; register long r4 __asm__(\"r4\") = e; register long r5 __asm__(\"r5\") = f; __asm_syscall(R7_OPERAND, \"0\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3), \"r\"(r4), \"r\"(r5)); } // 一个相当巧妙的宏定义的实现 #define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n #define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) // 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 // 拼装函数调用 #define __SYSCALL_CONCAT_X(a,b) a##b #define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) #define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) // __syscall_ret仅仅检查了系统调用号 #define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) #define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束 系统调用号实现 #ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H #define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 #define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) #define __NR_exit (__NR_SYSCALL_BASE + 1) #define __NR_fork (__NR_SYSCALL_BASE + 2) #define __NR_read (__NR_SYSCALL_BASE + 3) #define __NR_write (__NR_SYSCALL_BASE + 4) #define __NR_open (__NR_SYSCALL_BASE + 5) #define __NR_close (__NR_SYSCALL_BASE + 6) #define __NR_creat (__NR_SYSCALL_BASE + 8) ... #define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) #endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */ ","date":"2022-07-18","objectID":"/pthread_thread/:3:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用实现"},{"categories":["pthread"],"content":" 3.3 glibc系统调用同样的道理,可以分析一下glibc的系统调用时如何进行 但是在一般的情况下此时就可以明白,与musl相同的调用方式时一样的 INLINE_SYSCALL_CALL --\u003e __INLINE_SYSCALL_DISP __INLINE_SYSCALL_DISP --\u003e __SYSCALL_CONCAT 生成一条调用指令的语言 # define INTERNAL_SYSCALL_RAW(name, nr, args...) \\ ({ \\ register int _a1 asm (\"r0\"), _nr asm (\"r7\"); \\ LOAD_ARGS_##nr (args) \\ _nr = name; \\ asm volatile (\"swi 0x0 @ syscall \" #name \\ : \"=r\" (_a1) \\ : \"r\" (_nr) ASM_ARGS_##nr \\ : \"memory\"); \\ _a1; }) ","date":"2022-07-18","objectID":"/pthread_thread/:3:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc系统调用"},{"categories":["pthread"],"content":" 3.4 clone系统调用 int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...); // 但是实现的地方却存在着异常 __clone: stmfd sp!,{r4,r5,r6,r7} mov r7,#120 mov r6,r3 mov r5,r0 mov r0,r2 and r1,r1,#-16 ldr r2,[sp,#16] ldr r3,[sp,#20] ldr r4,[sp,#24] svc 0 tst r0,r0 beq 1f ldmfd sp!,{r4,r5,r6,r7} bx lr ","date":"2022-07-18","objectID":"/pthread_thread/:3:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#clone系统调用"},{"categories":["pthread"],"content":" 4 线程基础","date":"2022-07-18","objectID":"/pthread_thread/:4:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程基础-1"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程创建"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现的线程函数"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread管理单元申请与释放"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#内核线程创建"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#tls创建"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#设置启动参数"},{"categories":["pthread"],"content":" 4.2 ptrhead进程属性机制 int pthread_attr_init(pthread_attr_t *a); pthread_attr_t-\u003e_a_stacksize = __default_stacksize; pthread_attr_t-\u003e_a_guardsize = __default_guardsize; int pthread_attr_setdetachstate(pthread_attr_t *a, int state); pthread_attr_t-\u003e_a_detach = state; int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_guardsize = size; int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); pthread_attr_t-\u003e_a_sched = inherit; int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param); pthread_attr_t-\u003e_a_prio = param-\u003esched_priority; int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); pthread_attr_t-\u003e_a_policy = policy; int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); pthread_attr_t-\u003e_a_stackaddr = (size_t)addr + size; pthread_attr_t-\u003e_a_stacksize = size; int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_stackaddr = 0; pthread_attr_t-\u003e_a_stacksize = size; ","date":"2022-07-18","objectID":"/pthread_thread/:4:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#ptrhead进程属性机制"},{"categories":["pthread"],"content":" 4.3 自身线程ID // 在musl和glibc的实现上二者不太一样 static inline uintptr_t __get_tp() { uintptr_t tp; __asm__ ( \"mrc p15,0,%0,c13,c0,3\" : \"=r\"(tp) ); return tp; } // 获取线程自身的方法 #define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) // 二者实现不太一样 /* Return the thread descriptor for the current thread. */ # define THREAD_SELF ((struct pthread *)__builtin_thread_pointer () - 1) pthread_t __pthread_self (void) { return (pthread_t) THREAD_SELF; } ","date":"2022-07-18","objectID":"/pthread_thread/:4:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#自身线程id"},{"categories":["pthread"],"content":" 4.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 4.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:4:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程清理函数"},{"categories":["pthread"],"content":" 4.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 4.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:4:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#cancle设置"},{"categories":["pthread"],"content":" 4.5 线程分离 // 线程分离 int pthread_detach(pthread_t) --\u003e __pthread_join(pthread_t, 0) --\u003e __pthread_timedjoin_np(pthread_t, 0, 0) // 设置线程等待 int pthread_join(pthread_t, void **); --\u003e__pthread_timedjoin_np(pthread_t, res, 0) // 那么也就是说明都调用了相同的函数 static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { /* 设置线程分离状态 */ } ","date":"2022-07-18","objectID":"/pthread_thread/:4:5","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离-1"},{"categories":["编译原理"],"content":"编译原理","date":"2022-07-07","objectID":"/compiler_principle/","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/"},{"categories":["编译原理"],"content":" 1 词法分析","date":"2022-07-07","objectID":"/compiler_principle/:1:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#词法分析"},{"categories":["编译原理"],"content":" 1.1 概述 词法分析是编译原理的第一个阶段,词法分析的任务是读入源程序的输入字符,生成一个个的单词,其主要的功能是为语法分析提供词法单元 ","date":"2022-07-07","objectID":"/compiler_principle/:1:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#概述"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compiler_principle/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#正则表达式"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compiler_principle/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#flex正则表达式"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA) 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compiler_principle/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#有限状态自动机fa"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA) 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compiler_principle/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#数学描述"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA) 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compiler_principle/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#例子"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compiler_principle/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#自动生成"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compiler_principle/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#thompson算法"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compiler_principle/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#解释"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compiler_principle/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#例子-1"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compiler_principle/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#子集构造算法"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compiler_principle/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#hopcroft算法"},{"categories":["编译原理"],"content":" 2 语法分析","date":"2022-07-07","objectID":"/compiler_principle/:2:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#语法分析"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#自顶向下"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#ll1分析文法"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#ll1文法概述"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#ll1一般步骤"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#如何生成ll1分析表"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#first集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#follow集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#select集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compiler_principle/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#分析流程"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compiler_principle/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#自底向上"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compiler_principle/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#lr0分析算法"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compiler_principle/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#点记号"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compiler_principle/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#生成一个逆序的最右推导"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compiler_principle/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#构造分析表"},{"categories":["编译原理"],"content":" 3 语义分析","date":"2022-07-07","objectID":"/compiler_principle/:3:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compiler_principle/#语义分析"},{"categories":["编程语言"],"content":"C++高级编程","date":"2022-06-18","objectID":"/cxx_template_basic/","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/"},{"categories":["编程语言"],"content":" 1 相关知识gcc中typeof关键字用来检查变量类型,那么则可以用来判断魔板生成中的数据类型, 但是在C++中存在这另外的运算符typeid,但是我个人认为typeof更加优秀，但是二者并不相同, typeid返回类型对象,typeof只可以判断类型; 代码如下: #define __toStr(x) #x #define toStr(x) __toStr(x) #define check_type_item(_x, type) \\ if (typeid(_x) == typeid(type)) { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is \" \u003c\u003c toStr(type) \u003c\u003c std::endl; \\ } else #define check_type_tail(_x) \\ { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is unknow\" \u003c\u003c std::endl; \\ } #define check_type(_x) \\ ({ \\ check_type_item(_x, bool) \\ check_type_item(_x, char) \\ check_type_item(_x, short) \\ check_type_item(_x, int) \\ check_type_item(_x, long) \\ check_type_item(_x, wchar_t) \\ check_type_item(_x, unsigned char) \\ check_type_item(_x, unsigned short) \\ check_type_item(_x, unsigned int) \\ check_type_item(_x, unsigned long) \\ check_type_item(_x, float) \\ check_type_item(_x, double) \\ check_type_item(_x, std::string) \\ check_type_tail(_x) \\ }) 从内核中学到的一种用来编译期间校验的宏函数,用来确定推导过程是否正确 #define BUILD_BUG_ON(cond) ((void)sizeof(int[1-2*(!!(cond))])) C++还提供了一种运算符static_assert,用作编译期间静态静态检查; static_assert(true); // 正确: 编译通过 static_assert(false); // 错误: static assertion failed 那么就可以通过此工具来分析模板推导过程是否是正确的 ","date":"2022-06-18","objectID":"/cxx_template_basic/:1:0","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#相关知识"},{"categories":["编程语言"],"content":" 2 模板基础 模板和宏定义区别:模板在编译期进行,宏在预编译期间进行 建立通用的模板,提高复用率 C++提供两种模版机制:函数模版和类模板 ","date":"2022-06-18","objectID":"/cxx_template_basic/:2:0","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#模板基础"},{"categories":["编程语言"],"content":" 2.1 函数模版 template \u003ctypename T\u003e 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template \u003ctypename T\u003e void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template \u003ctypename T\u003e T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add\u003cint\u003e(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template\u003ctypename T\u003e T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max\u003cdouble\u003e(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template\u003ctypename T1, typename T2, typename RT = std::decay_t\u003cdecltype(true ? T1() : T2())\u003e \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template\u003ctypename T1, typename T2\u003e auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template\u003ctypename T1, typename T2\u003e std::common_type_t\u003cT1,T2\u003e max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template\u003ctypename T = std::string\u003e T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#函数模版"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#实例"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#注意事项"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#普通函数和函数模版的区别"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#普通函数和模版函数调用规则"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#变参模板"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#两阶段编译检查two-phase-translation"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#类型推断中的类型转换"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#多模板参数调用"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#显式指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#返回值指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#自动推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#公共类型推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#默认模板参数"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template_basic/:2:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#函数模板重载"},{"categories":["编程语言"],"content":" 2.2 类模板 template \u003cclass T\u003e 类 例子 template \u003cclass NameType, class AgeType\u003e class Person { public: Person(NameType Name, AgeType Age) { m_Name = Name; m_Age = Age; } NameType m_Name; AgeType m_Age; }; 实例化 Person\u003cstd::string, int\u003e p(\"Hello\", 99); ","date":"2022-06-18","objectID":"/cxx_template_basic/:2:2","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#类模板"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template\u003cint Val, typename T\u003e T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template\u003cdouble VAT\u003e // ERROR: floating-point values are not void process (double v){} template\u003cstd::string name\u003e // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template\u003ctypename T, auto Maxsize\u003e class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template_basic/:2:3","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#非类型模板参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template_basic/:2:3","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#函数模板非类型参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template_basic/:2:3","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#非类型模板参数的限制"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template\u003ctypename T, typename... Types\u003e void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template\u003cclass... T\u003e auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } 2.4.4 变参模板的使用","date":"2022-06-18","objectID":"/cxx_template_basic/:2:4","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#变参模板-1"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } 2.4.4 变参模板的使用","date":"2022-06-18","objectID":"/cxx_template_basic/:2:4","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#变参模板实例"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } 2.4.4 变参模板的使用","date":"2022-06-18","objectID":"/cxx_template_basic/:2:4","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#变参个运算符sizeof"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } 2.4.4 变参模板的使用","date":"2022-06-18","objectID":"/cxx_template_basic/:2:4","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#折叠表达式"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } 2.4.4 变参模板的使用","date":"2022-06-18","objectID":"/cxx_template_basic/:2:4","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#变参模板的使用"},{"categories":["编程语言"],"content":" 3 模板提高","date":"2022-06-18","objectID":"/cxx_template_basic/:3:0","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#模板提高"},{"categories":["编程语言"],"content":" 3.1 移动语义和enable_if\u003c\u003e","date":"2022-06-18","objectID":"/cxx_template_basic/:3:1","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#移动语义和enable_if"},{"categories":["编程语言"],"content":" 3.2 模板参数传递","date":"2022-06-18","objectID":"/cxx_template_basic/:3:2","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#模板参数传递"},{"categories":["编程语言"],"content":" 3.3 编译期编程","date":"2022-06-18","objectID":"/cxx_template_basic/:3:3","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#编译期编程"},{"categories":["编程语言"],"content":" 4 模板进阶","date":"2022-06-18","objectID":"/cxx_template_basic/:4:0","series":null,"tags":["C++"],"title":"C++模板基础","uri":"/cxx_template_basic/#模板进阶"},{"categories":["rootfs"],"content":" 1 下载buildroot git clone --depth=1 https://git.busybox.net/buildroot git branch -a [new branch] git checkout [new branch] ","date":"2022-03-13","objectID":"/buildroot/:1:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#下载buildroot"},{"categories":["rootfs"],"content":" 2 快速开始 可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026\u0026 make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh ","date":"2022-03-13","objectID":"/buildroot/:2:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#快速开始"},{"categories":["rootfs"],"content":" 3 基础配置","date":"2022-03-13","objectID":"/buildroot/:3:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#基础配置"},{"categories":["rootfs"],"content":" 3.1 使用自定义的内核在defconfig文件中添加下面的配置 BR2_LINUX_KERNEL=y # 是否编译内核 BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"git@github.com:mengdemao/kernel.git\" # kernel的地址 BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"master\" # 版本 BR2_LINUX_KERNEL_VERSION=\"master\" BR2_LINUX_KERNEL_USE_DEFCONFIG=y BR2_LINUX_KERNEL_DEFCONFIG=\"debian\" BR2_LINUX_KERNEL_ZIMAGE=y BR2_LINUX_KERNEL_GZIP=y ","date":"2022-03-13","objectID":"/buildroot/:3:1","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#使用自定义的内核"},{"categories":[],"content":" bsdiff bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u003e sorting (specifically, Larsson and Sadakane’s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) – 直接摘抄自官网 详情可以查看bsdiff官网,存在这个详细描述. ","date":"2021-10-30","objectID":"/bsdiff/:0:0","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#bsdiff"},{"categories":[],"content":" 1 测试新建立两个文件old.c与new.c,二者的差别是 // new.c #include \u003cstdio.h\u003e int main(void) { printf(\"Hello World\\r\\n\"); return 0; } #include \u003cstdio.h\u003e int main(void) { return 0; } 测试的情况 # 执行编译 gcc old.c -o old \u0026\u0026 ./old gcc new.c -o new \u0026\u0026 ./new 计算md5 md5sum old # d08fd167e74f279522fe8aa64d8e27dd old md5sum new # b0b4be993de61064a118d32a692bf795 new md5sum mid # b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试 # 生成diff bsdiff old new test.diff # 打入补丁--\u003emid bspatch old mid test.diff ","date":"2021-10-30","objectID":"/bsdiff/:1:0","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#测试"},{"categories":[],"content":" 2 分析","date":"2021-10-30","objectID":"/bsdiff/:2:0","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#分析"},{"categories":[],"content":" 2.1 接口分析 struct bsdiff_stream { void* opaque; /* bzip文件 */ void* (*malloc)(size_t size); /* 内存申请接口 */ void (*free)(void* ptr); /* 内存释放接口 */ int (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ const void* buffer, int size); }; struct bspatch_stream { void* opaque; /* bzip文件 */ int (*read)(const struct bspatch_stream* stream, /* 读取文件接口 */ void* buffer, int length); }; int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream); int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream); ","date":"2021-10-30","objectID":"/bsdiff/:2:1","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#接口分析"},{"categories":[],"content":" 2.2 diff算法核心bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 2.2.1 Header的结构: start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2021-10-30","objectID":"/bsdiff/:2:2","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#diff算法核心"},{"categories":[],"content":" 2.2 diff算法核心bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 2.2.1 Header的结构: start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2021-10-30","objectID":"/bsdiff/:2:2","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#header的结构"},{"categories":[],"content":" 2.3 代码分析 2.3.1 偏移信息与字符串信息相互转化 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } static void offtout(int64_t x,uint8_t *buf) { int64_t y; /* 保证 y = |x| */ if (x \u003c 0) { y = -x; } else { y = x; } buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2021-10-30","objectID":"/bsdiff/:2:3","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#代码分析"},{"categories":[],"content":" 2.3 代码分析 2.3.1 偏移信息与字符串信息相互转化 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } static void offtout(int64_t x,uint8_t *buf) { int64_t y; /* 保证 y = |x| */ if (x \u003c 0) { y = -x; } else { y = x; } buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2021-10-30","objectID":"/bsdiff/:2:3","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#偏移信息与字符串信息相互转化"},{"categories":[],"content":" 2.4 patch代码分析总体的执行路径 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i\u003cctrl[0];i++) if((oldpos+i\u003e=0) \u0026\u0026 (oldpos+i\u003coldsize)) new[newpos+i]+=old[oldpos+i]; /* Adjust pointers */ newpos+=ctrl[0]; oldpos+=ctrl[0]; /* Sanity-check */ if(newpos+ctrl[1]\u003enewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } 主要函数的调用路线 2.4.1 qsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解 参数分析: I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; for(i=0;i\u003c256;i++) buckets[i]=0; for(i=0;i\u003coldsize;i++) buckets[old[i]]++; for(i=1;i\u003c256;i++) buckets[i]+=buckets[i-1]; for(i=255;i\u003e0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i\u003coldsize;i++) I[++buckets[old[i]]]=i; I[0]=oldsize; for(i=0;i\u003coldsize;i++) V[i]=buckets[old[i]]; V[oldsize]=0; for(i=1;i\u003c256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; I[0]=-1; for(h=1;I[0]!=-(oldsize+1);h+=h) { len=0; for(i=0;i\u003coldsize+1;) { if(I[i]\u003c0) { len-=I[i]; i-=I[i]; } else { if(len) I[i-len]=-len; len=V[I[i]]+1-i; split(I,V,i,len,h); i+=len; len=0; }; }; if(len) I[i-len]=-len; }; for(i=0;i\u003coldsize+1;i++) I[V[i]]=i; } static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k\u003cstart+len;k+=j) { j=1;x=V[I[k]+h]; for(i=1;k+i\u003cstart+len;i++) { if(V[I[k+i]+h]\u003cx) { x=V[I[k+i]+h]; j=0; }; if(V[I[k+i]+h]==x) { tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; j++; }; }; for(i=0;i\u003cj;i++) V[I[k+i]]=k+j-1; if(j==1) I[k]=-1; }; return; }; x=V[I[start+len/2]+h]; jj=0;kk=0; for(i=start;i\u003cstart+len;i++) { if(V[I[i]+h]\u003cx) jj++; if(V[I[i]+h]==x) kk++; }; jj+=start;kk+=jj; i=start;j=0;k=0; while(i\u003cjj) { if(V[I[i]+h]\u003cx) { i++; } else if(V[I[i]+h]==x) { tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; j++; } else { tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; k++; }; }; while(jj+j\u003ckk) { if(V[I[jj+j]+h]==x) { j++; } else { tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; k++; }; }; if(jj\u003estart) split(I,V,start,jj-start,h); for(i=0;i\u003ckk-jj;i++) V[I[jj+i]]=kk-1; if(jj==kk-1) I[jj]=-1; if(start+len\u003ekk) split(I,V,kk,start+len-kk,h); } 2.4.2 search static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i\u003coldsize)\u0026\u0026(i\u003cnewsize);i++) if(old[i]!=new[i]) break; return i; } static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, const uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) { int64_t x,y; if(en-st\u003c2) { x=matchlen(old+I[st],oldsize-I[st],new,newsize); y=matchlen(old+I[en],oldsize-I[en],new,newsize); if(x\u003ey) { *pos=I[st]; return x; } else { *pos=I[en]; return y; } }; x=st+(en-st)/2; if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u003c0) { return search(I,old,oldsize,new,newsize,x,en,pos); } else { return search(I,old,oldsize,new,newsize,st,x,pos); }; } ","date":"2021-10-30","objectID":"/bsdiff/:2:4","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#patch代码分析"},{"categories":[],"content":" 2.4 patch代码分析总体的执行路径 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } 主要函数的调用路线 2.4.1 qsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解 参数分析: I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; for(i=0;i\u003c256;i++) buckets[i]=0; for(i=0;i0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i","date":"2021-10-30","objectID":"/bsdiff/:2:4","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#qsufsort"},{"categories":[],"content":" 2.4 patch代码分析总体的执行路径 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } 主要函数的调用路线 2.4.1 qsufsort 调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解 参数分析: I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小 static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; for(i=0;i\u003c256;i++) buckets[i]=0; for(i=0;i0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i","date":"2021-10-30","objectID":"/bsdiff/:2:4","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#search"},{"categories":[],"content":" 2.5 writedata static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { int64_t result = 0; while (length \u003e 0) { const int smallsize = (int)MIN(length, INT_MAX); const int writeresult = stream-\u003ewrite(stream, buffer, smallsize); if (writeresult == -1) { return -1; } result += writeresult; length -= smallsize; buffer = (uint8_t*)buffer + smallsize; } return result; } ","date":"2021-10-30","objectID":"/bsdiff/:2:5","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#writedata"},{"categories":[],"content":" 2.6 diff文件生成核心代码 struct bsdiff_request { const uint8_t* old; int64_t oldsize; const uint8_t* new; int64_t newsize; struct bsdiff_stream* stream; int64_t *I; uint8_t *buffer; }; static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I,V,req.old,req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan\u003creq.newsize) { oldscore=0; for(scsc=scan+=len;scan\u003creq.newsize;scan++) { len=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 0,req.oldsize,\u0026pos); for(;scsc\u003cscan+len;scsc++) if((scsc+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scsc+lastoffset] == req.new[scsc])) oldscore++; if(((len==oldscore) \u0026\u0026 (len!=0)) || (len\u003eoldscore+8)) break; if((scan+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scan+lastoffset] == req.new[scan])) oldscore--; }; if((len!=oldscore) || (scan==req.newsize)) { s=0;Sf=0;lenf=0; for(i=0;(lastscan+i\u003cscan)\u0026\u0026(lastpos+i\u003creq.oldsize);) { if(req.old[lastpos+i]==req.new[lastscan+i]) s++; i++; if(s*2-i\u003eSf*2-lenf) { Sf=s; lenf=i; }; }; lenb=0; if(scan\u003creq.newsize) { s=0;Sb=0; for(i=1;(scan\u003e=lastscan+i)\u0026\u0026(pos\u003e=i);i++) { if(req.old[pos-i]==req.new[scan-i]) s++; if(s*2-i\u003eSb*2-lenb) { Sb=s; lenb=i; }; }; }; if(lastscan+lenf\u003escan-lenb) { overlap=(lastscan+lenf)-(scan-lenb); s=0;Ss=0;lens=0; for(i=0;i\u003coverlap;i++) { if(req.new[lastscan+lenf-overlap+i]== req.old[lastpos+lenf-overlap+i]) s++; if(req.new[scan-lenb+i]== req.old[pos-lenb+i]) s--; if(s\u003eSs) { Ss=s; lens=i+1; }; }; lenf+=lens-overlap; lenb-=lens; }; offtout(lenf,buf); offtout((scan-lenb)-(lastscan+lenf),buf+8); offtout((pos-lenb)-(lastpos+lenf),buf+16); /* Write control data */ if (writedata(req.stream, buf, sizeof(buf))) return -1; /* Write diff data */ for(i=0;i\u003clenf;i++) buffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; if (writedata(req.stream, buffer, lenf)) return -1; /* Write extra data */ for(i=0;i\u003c(scan-lenb)-(lastscan+lenf);i++) buffer[i]=req.new[lastscan+lenf+i]; if (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) return -1; lastscan=scan-lenb; lastpos=pos-lenb; lastoffset=pos-scan; }; }; return 0; } ","date":"2021-10-30","objectID":"/bsdiff/:2:6","series":null,"tags":[],"title":"Bsdiff","uri":"/bsdiff/#diff文件生成核心代码"},{"categories":["linux"],"content":" 1 调度器类分析 const struct sched_class fair_sched_class = { .next = \u0026idle_sched_class, .enqueue_task = enqueue_task_fair, .dequeue_task = dequeue_task_fair, .yield_task = yield_task_fair, .yield_to_task = yield_to_task_fair, .check_preempt_curr = check_preempt_wakeup, .pick_next_task = pick_next_task_fair, .put_prev_task = put_prev_task_fair, #ifdef CONFIG_SMP .select_task_rq = select_task_rq_fair, .migrate_task_rq = migrate_task_rq_fair, .rq_online = rq_online_fair, .rq_offline = rq_offline_fair, .task_dead = task_dead_fair, .set_cpus_allowed = set_cpus_allowed_common, #endif .set_curr_task = set_curr_task_fair, .task_tick = task_tick_fair, .task_fork = task_fork_fair, .prio_changed = prio_changed_fair, .switched_from = switched_from_fair, .switched_to = switched_to_fair, .get_rr_interval = get_rr_interval_fair, .update_curr = update_curr_fair, #ifdef CONFIG_FAIR_GROUP_SCHED .task_change_group = task_change_group_fair, #endif }; 调度器类分析 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf); void (*put_prev_task)(struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int new_cpu); void (*task_woken)(struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task)(struct rq *rq); void (*task_tick)(struct rq *rq, struct task_struct *p, int queued); void (*task_fork)(struct task_struct *p); void (*task_dead)(struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from)(struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval)(struct rq *rq, struct task_struct *task); void (*update_curr)(struct rq *rq); #define TASK_SET_GROUP 0 #define TASK_MOVE_GROUP 1 #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_change_group)(struct task_struct *p, int type); #endif }; ","date":"2021-10-28","objectID":"/fair/:1:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/fair/#调度器类分析"},{"categories":["linux"],"content":" 2 enqueue_task_fair static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; /* * The code below (indirectly) updates schedutil which looks at * the cfs_rq utilization to select a frequency. * Let's add the task's estimated utilization to the cfs_rq's * estimated utilization, before we update schedutil. */ util_est_enqueue(\u0026rq-\u003ecfs, p); /* * If in_iowait is set, the code below may not trigger any cpufreq * utilization updates, so do it here explicitly with the IOWAIT flag * passed. */ if (p-\u003ein_iowait) cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); for_each_sched_entity(se) { if (se-\u003eon_rq) break; cfs_rq = cfs_rq_of(se); enqueue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running increment below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running++; flags = ENQUEUE_WAKEUP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running++; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) add_nr_running(rq, 1); if (cfs_bandwidth_used()) { /* * When bandwidth control is enabled; the cfs_rq_throttled() * breaks in the above iteration can result in incomplete * leaf list maintenance, resulting in triggering the assertion * below. */ for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); if (list_add_leaf_cfs_rq(cfs_rq)) break; } } assert_list_leaf_cfs_rq(rq); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/fair/:2:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/fair/#enqueue_task_fair"},{"categories":["linux"],"content":" 3 dequeue_task_fair static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; int task_sleep = flags \u0026 DEQUEUE_SLEEP; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); dequeue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running decrement below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running--; /* Don't dequeue parent if it has other entities besides us */ if (cfs_rq-\u003eload.weight) { /* Avoid re-evaluating load for this entity: */ se = parent_entity(se); /* * Bias pick_next to pick a task from this cfs_rq, as * p is sleeping when it is within its sched_slice. */ if (task_sleep \u0026\u0026 se \u0026\u0026 !throttled_hierarchy(cfs_rq)) set_next_buddy(se); break; } flags |= DEQUEUE_SLEEP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running--; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) sub_nr_running(rq, 1); util_est_dequeue(\u0026rq-\u003ecfs, p, task_sleep); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/fair/:3:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/fair/#dequeue_task_fair"},{"categories":["linux"],"content":" 4 yield_task_fair","date":"2021-10-28","objectID":"/fair/:4:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/fair/#yield_task_fair"},{"categories":["linux"],"content":" 5 yield_to_task_fair","date":"2021-10-28","objectID":"/fair/:5:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/fair/#yield_to_task_fair"},{"categories":["前端知识"],"content":"javascript基础教程","date":"2021-10-07","objectID":"/javascript/","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/"},{"categories":["前端知识"],"content":" 1 基础知识 JavaScript是一种运行在浏览器中的解释型的编程语言 在hugo中运行javacsript脚本,可以使用hugo的script shortcode在文章中插入Javascript脚本 {{\u003c script \u003e}} console.log('javascript基础教程!'); {{\u003c /script \u003e}} 可以在浏览器的后台中看到日志javascript基础教程! ","date":"2021-10-07","objectID":"/javascript/:1:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基础知识"},{"categories":["前端知识"],"content":" 2 javascript基础 JavaScript严格区分大小写 作为一个新的语言,我们学的第一个程序 打印hello world /* 打印弹窗 */ alert(\"hello world\"); /* 打印在html */ document.write(\"hello world\"); /* 打印在调试窗口 */ console.log(\"Hello world\") ","date":"2021-10-07","objectID":"/javascript/:2:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#javascript基础"},{"categories":["前端知识"],"content":" 2.1 基本语句 赋值语句 var x = 1; 注释语句 // 单行注释 /** * 多行注释 */ 变量 变量必须以字母开头 变量也能以$和_符号开头 变量名称对大小写敏感 ","date":"2021-10-07","objectID":"/javascript/:2:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基本语句"},{"categories":["前端知识"],"content":" 2.2 数据类型 2.2.1 值类型(基本类型) 字符串(String) 数字(Number) 布尔(Boolean) 空(Null) 未定义(Undefined) Symbol 2.2.2 引用数据类型(对象类型) 对象(Object) 数组(Array) 函数(Function) 正则(RegExp) 日期(Date) ","date":"2021-10-07","objectID":"/javascript/:2:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数据类型"},{"categories":["前端知识"],"content":" 2.2 数据类型 2.2.1 值类型(基本类型) 字符串(String) 数字(Number) 布尔(Boolean) 空(Null) 未定义(Undefined) Symbol 2.2.2 引用数据类型(对象类型) 对象(Object) 数组(Array) 函数(Function) 正则(RegExp) 日期(Date) ","date":"2021-10-07","objectID":"/javascript/:2:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#值类型基本类型"},{"categories":["前端知识"],"content":" 2.2 数据类型 2.2.1 值类型(基本类型) 字符串(String) 数字(Number) 布尔(Boolean) 空(Null) 未定义(Undefined) Symbol 2.2.2 引用数据类型(对象类型) 对象(Object) 数组(Array) 函数(Function) 正则(RegExp) 日期(Date) ","date":"2021-10-07","objectID":"/javascript/:2:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#引用数据类型对象类型"},{"categories":["前端知识"],"content":" 2.3 字符串 2.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 2.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 2.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:2:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串"},{"categories":["前端知识"],"content":" 2.3 字符串 2.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 2.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 2.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:2:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义字符串"},{"categories":["前端知识"],"content":" 2.3 字符串 2.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 2.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 2.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:2:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#拼接字符串"},{"categories":["前端知识"],"content":" 2.3 字符串 2.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 2.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 2.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:2:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串函数"},{"categories":["前端知识"],"content":" 2.4 数组JavaScript的数组可以包含任意数据类型;并通过索引来访问每个元素. var array = [1, 2, 'hello', \"world\", true]; // 定义一个数组 array.length; // 5 array[0]; // 打印 ","date":"2021-10-07","objectID":"/javascript/:2:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数组"},{"categories":["前端知识"],"content":" 2.5 对象 2.5.1 定义对象JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 2.5.2 访问成员 访问成员的方式存在两种 C方式:对象名.成员名 反射式:对象名['成员名'] 'use strict'; var student = { name: \"hello\", age: 18 }; console.log(student.name); // hello console.log(student['age']); // 18 ","date":"2021-10-07","objectID":"/javascript/:2:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#对象"},{"categories":["前端知识"],"content":" 2.5 对象 2.5.1 定义对象JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 2.5.2 访问成员 访问成员的方式存在两种 C方式:对象名.成员名 反射式:对象名['成员名'] 'use strict'; var student = { name: \"hello\", age: 18 }; console.log(student.name); // hello console.log(student['age']); // 18 ","date":"2021-10-07","objectID":"/javascript/:2:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义对象"},{"categories":["前端知识"],"content":" 2.5 对象 2.5.1 定义对象JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 2.5.2 访问成员 访问成员的方式存在两种 C方式:对象名.成员名 反射式:对象名['成员名'] 'use strict'; var student = { name: \"hello\", age: 18 }; console.log(student.name); // hello console.log(student['age']); // 18 ","date":"2021-10-07","objectID":"/javascript/:2:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#访问成员"},{"categories":["前端知识"],"content":" 2.6 条件判断 与C相似,此处就不过多赘述 if else else if ","date":"2021-10-07","objectID":"/javascript/:2:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#条件判断"},{"categories":["前端知识"],"content":" 2.7 循环语句 for for-in while do-while ","date":"2021-10-07","objectID":"/javascript/:2:7","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#循环语句"},{"categories":["前端知识"],"content":" 2.8 Map和Set","date":"2021-10-07","objectID":"/javascript/:2:8","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#map和set"},{"categories":["前端知识"],"content":" 2.9 遍历语句","date":"2021-10-07","objectID":"/javascript/:2:9","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#遍历语句"},{"categories":["前端知识"],"content":" 2.10 函数 2.10.1 函数模型 c语言类型 function functionName(args) { return retVal; } function:函数定义 functionName parameter retVal 一种完全等价的定义 var functionName = function(args) { return retVal; } ","date":"2021-10-07","objectID":"/javascript/:2:10","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数"},{"categories":["前端知识"],"content":" 2.10 函数 2.10.1 函数模型 c语言类型 function functionName(args) { return retVal; } function:函数定义 functionName parameter retVal 一种完全等价的定义 var functionName = function(args) { return retVal; } ","date":"2021-10-07","objectID":"/javascript/:2:10","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数模型"},{"categories":["前端知识"],"content":" 3 javascript提高","date":"2021-10-07","objectID":"/javascript/:3:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#javascript提高"},{"categories":["前端知识"],"content":" 3.1 标准对象 Date RegExp JSON ","date":"2021-10-07","objectID":"/javascript/:3:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#标准对象"},{"categories":["前端知识"],"content":" 3.2 面向对象编程","date":"2021-10-07","objectID":"/javascript/:3:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#面向对象编程"},{"categories":["前端知识"],"content":" 3.3 浏览器 window navigator location document history 3.3.1 浏览器对象 DOM 表单 文件 AJAX Promise Canvas ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#浏览器"},{"categories":["前端知识"],"content":" 3.3 浏览器 window navigator location document history 3.3.1 浏览器对象 DOM 表单 文件 AJAX Promise Canvas ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#浏览器对象"},{"categories":["前端知识"],"content":" 3.4 错误处理 程序有可能会出错,因此需要进行错误处理;高级语言try ... catch ... finally, 'use strict'; var r1, r2, s = null; try { r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行 } catch (e) { console.log('出错了：' + e); } finally { console.log('finally'); } console.log('r1 = ' + r1); // r1应为undefined console.log('r2 = ' + r2); // r2应为undefined // 下面的文件 // 出错了：TypeError: Cannot read properties of null (reading 'length') // finally // r1 = undefined // r2 = undefined 出错 先执行try { ... }的代码; 执行到出错的语句时,后续语句不再继续执行.转而执行catch (e) { ... }代码； 最后执行finally{ ... }代码。 无错 先执行try { … }的代码； 因为没有出错，catch (e) { … }代码不会被执行； 最后执行finally { … }代码。 ","date":"2021-10-07","objectID":"/javascript/:3:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#错误处理"},{"categories":["前端知识"],"content":" 4 javascript进阶","date":"2021-10-07","objectID":"/javascript/:4:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#javascript进阶"},{"categories":["前端知识"],"content":" 4.1 jQuery.js","date":"2021-10-07","objectID":"/javascript/:4:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#jqueryjs"},{"categories":["前端知识"],"content":" 4.2 underscore.js","date":"2021-10-07","objectID":"/javascript/:4:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#underscorejs"},{"categories":["前端知识"],"content":"CSS3基础教程","date":"2021-10-07","objectID":"/css/","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/"},{"categories":["前端知识"],"content":" 1 基础知识 Cascading Style Sheets(层叠样式表) HTML + CSS + JavaScript =\u003e 名词 + 形容词 + 动词 CSS可以认为对原始的HTML进行美化 ","date":"2021-10-07","objectID":"/css/:1:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#基础知识"},{"categories":["前端知识"],"content":" 1.1 快速入门 CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画 ","date":"2021-10-07","objectID":"/css/:1:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#快速入门"},{"categories":["前端知识"],"content":" 1.2 什么是CSS美化:字体, 颜色,高度,宽度, 背景图片 ","date":"2021-10-07","objectID":"/css/:1:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#什么是css"},{"categories":["前端知识"],"content":" 1.3 CSS的优势 内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件 ","date":"2021-10-07","objectID":"/css/:1:3","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#css的优势"},{"categories":["前端知识"],"content":" 1.4 CSS导入的方法 行内样式 \u003ch1 style=\"color: red\"\u003e一级标题\u003c/h1\u003e style标签 \u003cstyle\u003e\u003c/style\u003e 外部样式 链接方式 \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e 导入式 \u003cstyle\u003e @import url(\"css/style.css\"); \u003c/style\u003e ","date":"2021-10-07","objectID":"/css/:1:4","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#css导入的方法"},{"categories":["前端知识"],"content":" 1.5 基本语法 /* 注释语法 */ selector { /* 声明 */ attr:value; } 下面的代码可以直接修改背景颜色 \u003cstyle\u003e body { background-color:gray; } \u003c/style\u003e CSS基本操作 选中元素(选择某一类或者某一个) 属性修改(修改一个或者多个) ","date":"2021-10-07","objectID":"/css/:1:5","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#基本语法"},{"categories":["前端知识"],"content":" 2 选择器 选择某一类或者某一个元素 ","date":"2021-10-07","objectID":"/css/:2:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 \u003ch1 class=\"test\"\u003e测试\u003c/h1\u003e 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 \u003ch1 id=\"test\"\u003e测试\u003c/h1\u003e #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#基本选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#标签选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#类选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#id选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 \u003cp class=\"active\"\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp id=\"test\"\u003ep3\u003c/p\u003e \u003cp\u003ep4\u003c/p\u003e \u003cstyle\u003e .active+p { color: red; } #test+p { color: blue; } \u003c/style\u003e 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 \u003cp\u003ep1\u003c/p\u003e \u003cp class=\"hello\"\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cstyle\u003e .hello~{ color: red; } \u003c/style\u003e p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp id=\"test\"\u003ep7\u003c/p\u003e \u003cp\u003ep8\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#高级选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#层次选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#后代选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#子选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#相邻兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#通用兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#结构伪类选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#属性选择器"},{"categories":["前端知识"],"content":" 3 CSS属性 选中元素开始设置属性 ","date":"2021-10-07","objectID":"/css/:3:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#css属性"},{"categories":["前端知识"],"content":" 3.1 属性基础 字体样式 文本样式 文本阴影 超链接 列表样式 背景 span标签强调,这是一个标签, div标签,分块 \u003c!-- 字体样式 --\u003e \u003cstyle\u003e body { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-style: oblique; } \u003c/style\u003e font-family; 字体设置 font-size 字体大小 font-style 字体风格 ","date":"2021-10-07","objectID":"/css/:3:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#属性基础"},{"categories":["前端知识"],"content":" 3.2 属性提高 盒子模型与边框 ","date":"2021-10-07","objectID":"/css/:3:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css/#属性提高"},{"categories":["前端知识"],"content":"html5基础教程","date":"2021-10-07","objectID":"/html5/","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/"},{"categories":["前端知识"],"content":" 1 网页结构 hugo中markdown可以直接渲染html,可以直接得到效果 但是网页基础结构却不可以编写,这样会破坏渲染过程 \u003c!-- 告诉浏览器,需要使用的规范 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 网页标题 --\u003e \u003chead\u003e \u003c!-- 描述标签 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页标题 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 网页主体 --\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e www规范\r注释的写法 \u003c!-- 注释 --\u003e html: 网页 head: 标题标签 meta: 网站信息 body: 网页主题 meta标签处于head区,对用户不可见,用于对网页进行描述,一般SEO优化 \u003chead\u003e \u003cmeta name=\"description\" content=\"前端基础\"\u003e \u003cmeta name=\"keywords\" content=\"HTML,CSS,JavaScript\"\u003e \u003cmeta name=\"author\" content=\"孟德茂\"\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c/head\u003e ","date":"2021-10-07","objectID":"/html5/:1:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#网页结构"},{"categories":["前端知识"],"content":" 2 基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号标签 ","date":"2021-10-07","objectID":"/html5/:2:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#基本标签"},{"categories":["前端知识"],"content":" 2.1 标题标签 \u003ch1\u003e一级标签\u003c/h1\u003e 一级标签\r\u003ch2\u003e二级标签\u003c/h2\u003e 二级标签\r\u003ch3\u003e三级标签\u003c/h3\u003e 三级标签\r\u003ch4\u003e四级标签\u003c/h4\u003e 四级标签\r\u003ch5\u003e五级标签\u003c/h5\u003e 五级标签\r\u003ch6\u003e六级标签\u003c/h6\u003e 六级标签\r","date":"2021-10-07","objectID":"/html5/:2:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#标题标签"},{"categories":["前端知识"],"content":" 2.2 段落标签 \u003cp\u003e段落标签\u003c/p\u003e 显示如下: 我是一个段落 我又是一个段落 ","date":"2021-10-07","objectID":"/html5/:2:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#段落标签"},{"categories":["前端知识"],"content":" 2.3 换行标签 \u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:2:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#换行标签"},{"categories":["前端知识"],"content":" 2.4 水平线标签 \u003chr/\u003e 我在水平线标签上方 我在水平线标签下方 ","date":"2021-10-07","objectID":"/html5/:2:4","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#水平线标签"},{"categories":["前端知识"],"content":" 2.5 字体样式标签 \u003c!-- 字体样式标签 --\u003e 普通文本\u003cspan\u003e无效果\u003c/span\u003e\u003c/br\u003e 普通文本\u003cb\u003e加粗\u003c/b\u003e\u003c/br\u003e 普通文本\u003cstrong\u003e粗体\u003c/strong\u003e\u003c/br\u003e 普通文本\u003ci\u003e斜体\u003c/i\u003e\u003c/br\u003e 普通文本\u003cem\u003e斜体\u003c/em\u003e\u003c/br\u003e 普通文本\u003cu\u003e下划线\u003c/u\u003e\u003c/br\u003e 普通文本\u003cins\u003e下划线\u003c/ins\u003e\u003c/br\u003e 普通文本\u003cs\u003e删除线\u003c/s\u003e\u003c/br\u003e 普通文本\u003cdel\u003e删除线\u003c/del\u003e\u003c/br\u003e 普通文本\u003csub\u003e下标文本\u003c/sub\u003e\u003c/br\u003e 普通文本\u003csup\u003e上标文本\u003c/sup\u003e\u003c/br\u003e 普通文本无效果 普通文本加粗 普通文本粗体 普通文本斜体 普通文本斜体 普通文本下划线 普通文本下划线 普通文本删除线 普通文本删除线 普通文本下标文本 普通文本上标文本 ","date":"2021-10-07","objectID":"/html5/:2:5","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#字体样式标签"},{"categories":["前端知识"],"content":" 3 图片标签 \u003cimg src=\"测试.png\" alt=\"测试\" title=\"测试\"/\u003e ","date":"2021-10-07","objectID":"/html5/:3:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#图片标签"},{"categories":["前端知识"],"content":" 4 链接 \u003c!-- 当前页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_self\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e \u003c!-- 新建页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:4:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#链接"},{"categories":["前端知识"],"content":" 5 行内元素和块元素","date":"2021-10-07","objectID":"/html5/:5:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#行内元素和块元素"},{"categories":["前端知识"],"content":" 6 列表标签","date":"2021-10-07","objectID":"/html5/:6:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#列表标签"},{"categories":["前端知识"],"content":" 6.1 有序列表 \u003col\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ol\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:6:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#有序列表"},{"categories":["前端知识"],"content":" 6.2 无序列表 \u003cul\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ul\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:6:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#无序列表"},{"categories":["前端知识"],"content":" 6.3 定义列表 \u003cdl\u003e \u003cdt\u003e前端\u003c/dt\u003e \u003cdd\u003ehtml\u003c/dd\u003e \u003cdd\u003eCSS\u003c/dd\u003e \u003cdd\u003eJavaScript\u003c/dd\u003e \u003c/dl\u003e 前端\rhtml\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:6:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#定义列表"},{"categories":["前端知识"],"content":" 7 表格 \u003ctable border=\"1px\"\u003e \u003ctr\u003e \u003ctd\u003e1-1\u003c/td\u003e \u003ctd\u003e1-2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2-1\u003c/td\u003e \u003ctd\u003e2-2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 1-1\r1-2\r2-1\r2-2\r","date":"2021-10-07","objectID":"/html5/:7:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表格"},{"categories":["前端知识"],"content":" 8 页面结构分析 元素名 描述 header 标题头部区域 footer 标记尾部内容 section web页面中一块独立的区域 article 独立文章内容 aside 相关页面或者内容 nav 导航类辅助内容 ","date":"2021-10-07","objectID":"/html5/:8:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#页面结构分析"},{"categories":["前端知识"],"content":" 9 iframe内联框架 \u003ciframe src=\"path\" name=\"mainFrame\"\u003e\u003c/frame\u003e bilibili的例子 \u003ciframe src=\"//player.bilibili.com/player.html?aid=55631961\u0026bvid=BV1x4411V75C\u0026cid=97257967\u0026page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e \u003c/iframe\u003e ","date":"2021-10-07","objectID":"/html5/:9:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#iframe内联框架"},{"categories":["前端知识"],"content":" 10 表单 \u003cform action=\"submit.html\" method=\"GET/POST\"\u003e \u003cp\u003e名字: \u003cinput type=\"text\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003e密码: \u003cinput type=\"password\" name=\"password\"\u003e\u003c/p\u003e \u003cp\u003e \u003cinput type=\"submit\"\u003e \u003cinput type=\"reset\"\u003e \u003c/p\u003e \u003c/form\u003e 出入账户和密码,点击按钮会触发相应的 动作http://url/html5/submit.html?name=mengdemao\u0026password=1234, 但是此时会显示失败,因为没有处理函数. 名字: 密码: ","date":"2021-10-07","objectID":"/html5/:10:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表单"},{"categories":["操作系统"],"content":"进程创建","date":"2021-10-04","objectID":"/fork/","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/"},{"categories":["操作系统"],"content":" fork linux创建线程的函数 fork –\u003e do_fork do_fork的执行线路 do_fork函数原型 long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); clone_flags stack_start stack_size parent_tidptr child_tidptr tls ","date":"2021-10-04","objectID":"/fork/:0:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#fork"},{"categories":["操作系统"],"content":" 1 copy_process","date":"2021-10-04","objectID":"/fork/:1:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#copy_process"},{"categories":["操作系统"],"content":" 2 get_task_pid","date":"2021-10-04","objectID":"/fork/:2:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#get_task_pid"},{"categories":["操作系统"],"content":" 3 wake_up_new_task","date":"2021-10-04","objectID":"/fork/:3:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#wake_up_new_task"},{"categories":["linux"],"content":"系统调度","date":"2021-10-04","objectID":"/sched/","series":null,"tags":["kernel"],"title":"linux内核系统调度基础","uri":"/sched/"},{"categories":["linux"],"content":" 1 调度器实现 调度器分为主调度器和周期调度器 ","date":"2021-10-04","objectID":"/sched/:1:0","series":null,"tags":["kernel"],"title":"linux内核系统调度基础","uri":"/sched/#调度器实现"},{"categories":["linux"],"content":" 1.1 任务调度","date":"2021-10-04","objectID":"/sched/:1:1","series":null,"tags":["kernel"],"title":"linux内核系统调度基础","uri":"/sched/#任务调度"},{"categories":["linux"],"content":" 2 完全公平调度器","date":"2021-10-04","objectID":"/sched/:2:0","series":null,"tags":["kernel"],"title":"linux内核系统调度基础","uri":"/sched/#完全公平调度器"},{"categories":["linux"],"content":" 3 调度器增强","date":"2021-10-04","objectID":"/sched/:3:0","series":null,"tags":["kernel"],"title":"linux内核系统调度基础","uri":"/sched/#调度器增强"},{"categories":[],"content":" 1 简述 驱动模型 顶级kobject 解释 block 块设备链接–\u003e/sys/deives相关文件 bus 存放各种总线文件 class 各种设备类 dev 存放(字符/块)设备主副设备号链接文件–\u003e/sys/deives devices 设备的具体存放文件 firmware 固件存放 fs 文件类型 kernel kernel子系统 module 模块信息 power 能源管理 ","date":"2021-10-01","objectID":"/drivermodel/:1:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#简述"},{"categories":[],"content":" 2 底层机制","date":"2021-10-01","objectID":"/drivermodel/:2:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#底层机制"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\u003cNULL\u003e\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\u003cNULL\u003e\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kobject"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#初始化"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#添加"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#sysfs文件夹生成"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#删除"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#引用计数"},{"categories":[],"content":" 2.2 kset 2.2.1 数据结构 struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; } __randomize_layout; ","date":"2021-10-01","objectID":"/drivermodel/:2:2","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kset"},{"categories":[],"content":" 2.2 kset 2.2.1 数据结构 struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; } __randomize_layout; ","date":"2021-10-01","objectID":"/drivermodel/:2:2","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构-1"},{"categories":[],"content":" 2.3 ktype 2.3.1 数据结构 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ","date":"2021-10-01","objectID":"/drivermodel/:2:3","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#ktype"},{"categories":[],"content":" 2.3 ktype 2.3.1 数据结构 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ","date":"2021-10-01","objectID":"/drivermodel/:2:3","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构-2"},{"categories":[],"content":" 3 class 设备类描述 struct class { const char *name; struct module *owner; const struct attribute_group **class_groups; const struct attribute_group **dev_groups; struct kobject *dev_kobj; int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); char *(*devnode)(struct device *dev, umode_t *mode); void (*class_release)(struct class *class); void (*dev_release)(struct device *dev); int (*shutdown_pre)(struct device *dev); const struct kobj_ns_type_operations *ns_type; const void *(*namespace)(struct device *dev); void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid); const struct dev_pm_ops *pm; struct subsys_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:3:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#class"},{"categories":[],"content":" 4 bus 设备总线描述 ","date":"2021-10-01","objectID":"/drivermodel/:4:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#bus"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#总线类型"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#设备总线注册"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#设备总线卸载"},{"categories":[],"content":" 5 devices 设备文件具体描述: device(设备描述) device_driver(驱动描述) bus_type(总线信息) |-- breakpoint |-- kprobe |-- platform |-- software |-- system |-- tracepoint |-- uprobe `-- virtual ","date":"2021-10-01","objectID":"/drivermodel/:5:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#devices"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#heading"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#device"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#driver"},{"categories":[],"content":" 6 kernel kernel子系统 ","date":"2021-10-01","objectID":"/drivermodel/:6:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kernel"},{"categories":[],"content":" 7 module 模块信息 ","date":"2021-10-01","objectID":"/drivermodel/:7:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#module"},{"categories":null,"content":" 页面分配器核心函数: __alloc_pages_nodemask gfp_mask : 分配掩码 order : 分配阶数 preferred_nid nodemask ","date":"2021-05-09","objectID":"/page_allocator/:0:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#页面分配器"},{"categories":null,"content":" 1 核心函数 struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) { struct page *page; // 分配变量 unsigned int alloc_flags = ALLOC_WMARK_LOW; // 分配标志 gfp_t alloc_mask; // 真实分配掩码 struct alloc_context ac = { }; // 保存相关参数 /* * There are several places where we assume that the order value is sane * so bail out early if the request is out of bound. * 限制分配的大小 */ if (unlikely(order \u003e= MAX_ORDER)) { WARN_ON_ONCE(!(gfp_mask \u0026 __GFP_NOWARN)); return NULL; } gfp_mask \u0026= gfp_allowed_mask; alloc_mask = gfp_mask; if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026ac, \u0026alloc_mask, \u0026alloc_flags)) return NULL; finalise_ac(gfp_mask, \u0026ac); /* First allocation attempt */ page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026ac); if (likely(page)) goto out; /* * Apply scoped allocation constraints. This is mainly about GFP_NOFS * resp. GFP_NOIO which has to be inherited for all allocation requests * from a particular context which has been marked by * memalloc_no{fs,io}_{save,restore}. */ alloc_mask = current_gfp_context(gfp_mask); ac.spread_dirty_pages = false; /* * Restore the original nodemask if it was potentially replaced with * \u0026cpuset_current_mems_allowed to optimize the fast-path attempt. */ if (unlikely(ac.nodemask != nodemask)) ac.nodemask = nodemask; page = __alloc_pages_slowpath(alloc_mask, order, \u0026ac); out: if (memcg_kmem_enabled() \u0026\u0026 (gfp_mask \u0026 __GFP_ACCOUNT) \u0026\u0026 page \u0026\u0026 unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) { __free_pages(page, order); page = NULL; } trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); return page; } ","date":"2021-05-09","objectID":"/page_allocator/:1:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#核心函数"},{"categories":null,"content":" 2 prepare_alloc_pages static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask, struct alloc_context *ac, gfp_t *alloc_mask, unsigned int *alloc_flags) { ac-\u003ehigh_zoneidx = gfp_zone(gfp_mask); ac-\u003ezonelist = node_zonelist(preferred_nid, gfp_mask); ac-\u003enodemask = nodemask; ac-\u003emigratetype = gfpflags_to_migratetype(gfp_mask); if (cpusets_enabled()) { *alloc_mask |= __GFP_HARDWALL; if (!ac-\u003enodemask) ac-\u003enodemask = \u0026cpuset_current_mems_allowed; else *alloc_flags |= ALLOC_CPUSET; } fs_reclaim_acquire(gfp_mask); fs_reclaim_release(gfp_mask); might_sleep_if(gfp_mask \u0026 __GFP_DIRECT_RECLAIM); if (should_fail_alloc_page(gfp_mask, order)) return false; if (IS_ENABLED(CONFIG_CMA) \u0026\u0026 ac-\u003emigratetype == MIGRATE_MOVABLE) *alloc_flags |= ALLOC_CMA; return true; } ","date":"2021-05-09","objectID":"/page_allocator/:2:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#prepare_alloc_pages"},{"categories":null,"content":" 3 get_page_from_freelist static struct page * get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, const struct alloc_context *ac) { struct zoneref *z = ac-\u003epreferred_zoneref; struct zone *zone; struct pglist_data *last_pgdat_dirty_limit = NULL; /* * Scan zonelist, looking for a zone with enough free. * See also __cpuset_node_allowed() comment in kernel/cpuset.c. */ for_next_zone_zonelist_nodemask(zone, z, ac-\u003ezonelist, ac-\u003ehigh_zoneidx, ac-\u003enodemask) { struct page *page; unsigned long mark; if (cpusets_enabled() \u0026\u0026 (alloc_flags \u0026 ALLOC_CPUSET) \u0026\u0026 !__cpuset_zone_allowed(zone, gfp_mask)) continue; /* * When allocating a page cache page for writing, we * want to get it from a node that is within its dirty * limit, such that no single node holds more than its * proportional share of globally allowed dirty pages. * The dirty limits take into account the node's * lowmem reserves and high watermark so that kswapd * should be able to balance it without having to * write pages from its LRU list. * * XXX: For now, allow allocations to potentially * exceed the per-node dirty limit in the slowpath * (spread_dirty_pages unset) before going into reclaim, * which is important when on a NUMA setup the allowed * nodes are together not big enough to reach the * global limit. The proper fix for these situations * will require awareness of nodes in the * dirty-throttling and the flusher threads. */ if (ac-\u003espread_dirty_pages) { if (last_pgdat_dirty_limit == zone-\u003ezone_pgdat) continue; if (!node_dirty_ok(zone-\u003ezone_pgdat)) { last_pgdat_dirty_limit = zone-\u003ezone_pgdat; continue; } } mark = zone-\u003ewatermark[alloc_flags \u0026 ALLOC_WMARK_MASK]; if (!zone_watermark_fast(zone, order, mark, ac_classzone_idx(ac), alloc_flags)) { int ret; #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT /* * Watermark failed for this zone, but see if we can * grow this zone if it contains deferred pages. */ if (static_branch_unlikely(\u0026deferred_pages)) { if (_deferred_grow_zone(zone, order)) goto try_this_zone; } #endif /* Checked here to keep the fast path fast */ BUILD_BUG_ON(ALLOC_NO_WATERMARKS \u003c NR_WMARK); if (alloc_flags \u0026 ALLOC_NO_WATERMARKS) goto try_this_zone; if (node_reclaim_mode == 0 || !zone_allows_reclaim(ac-\u003epreferred_zoneref-\u003ezone, zone)) continue; ret = node_reclaim(zone-\u003ezone_pgdat, gfp_mask, order); switch (ret) { case NODE_RECLAIM_NOSCAN: /* did not scan */ continue; case NODE_RECLAIM_FULL: /* scanned but unreclaimable */ continue; default: /* did we reclaim enough */ if (zone_watermark_ok(zone, order, mark, ac_classzone_idx(ac), alloc_flags)) goto try_this_zone; continue; } } try_this_zone: page = rmqueue(ac-\u003epreferred_zoneref-\u003ezone, zone, order, gfp_mask, alloc_flags, ac-\u003emigratetype); if (page) { prep_new_page(page, order, gfp_mask, alloc_flags); /* * If this is a high-order atomic allocation then check * if the pageblock should be reserved for the future */ if (unlikely(order \u0026\u0026 (alloc_flags \u0026 ALLOC_HARDER))) reserve_highatomic_pageblock(page, zone, order); return page; } else { #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT /* Try again if zone has deferred pages */ if (static_branch_unlikely(\u0026deferred_pages)) { if (_deferred_grow_zone(zone, order)) goto try_this_zone; } #endif } } return NULL; } ","date":"2021-05-09","objectID":"/page_allocator/:3:0","series":null,"tags":null,"title":"Page_allocator","uri":"/page_allocator/#get_page_from_freelist"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制 ","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#"},{"categories":null,"content":" 使用","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#使用"},{"categories":null,"content":" 1 等待队列头 struct __wait_queue_head { wq_lock_t lock; struct list_head task_list; }; typedef struct __wait_queue_head wait_queue_head_t; ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列头"},{"categories":null,"content":" 2 等待队列实体 struct __wait_queue { unsigned int flags; struct task_struct * task; struct list_head task_list; }; typedef struct __wait_queue wait_queue_t; ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列实体"},{"categories":null,"content":" 3 初始化等待队列头 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *); void init_waitqueue_head(struct wait_queue_head *wq_head); ","date":"2021-05-04","objectID":"/wait_queue/:3:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列头"},{"categories":null,"content":" 4 初始化等待队列 #define __WAITQUEUE_INITIALIZER(name, tsk) \\ { \\ .private = tsk, \\ .func = default_wake_function, \\ .entry = { NULL, NULL } \\ } #define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) // 但是，一般直接 DECLARE_WAITQUEUE(wait, current); 等待队列入口 等待的任务 ","date":"2021-05-04","objectID":"/wait_queue/:4:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列"},{"categories":null,"content":" 5 等待队列操作 void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); 等待队列头 等待队列实体 ","date":"2021-05-04","objectID":"/wait_queue/:5:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列操作"},{"categories":null,"content":" 6 等待事件 void wait_event(wq, condition); void wait_event_interruptible(wq, condition); ","date":"2021-05-04","objectID":"/wait_queue/:6:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待事件"},{"categories":null,"content":" 7 唤醒队列 wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync ","date":"2021-05-04","objectID":"/wait_queue/:7:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#唤醒队列"},{"categories":null,"content":" 例子","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#例子"},{"categories":null,"content":" 1 写端 ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = -1; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_write; } add_wait_queue(\u0026wait_device.wait_w, \u0026wait); while (wait_device.wait_flag == true) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); pure_write: wait_device.wait_flag = true; pr_err(\"Write Successful\"); wake_up_interruptible(\u0026wait_device.wait_r); pr_err(\"Wakeup Read\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return ret; } ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#写端"},{"categories":null,"content":" 2 读端 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = 0; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_read; } add_wait_queue(\u0026wait_device.wait_r, \u0026wait); while (wait_device.wait_flag == false) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); pure_read: wait_device.wait_flag = false; pr_err(\"Read Successful\"); wake_up_interruptible(\u0026wait_device.wait_w); pr_err(\"Wakeup Write\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return 0; } ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#读端"},{"categories":null,"content":" 原理","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#原理"},{"categories":null,"content":" 1 基本操作","date":"2021-05-04","objectID":"/hugo/:1:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#基本操作"},{"categories":null,"content":" 1.1 安装hugo在linux/windows上只能通过直接release下载, ","date":"2021-05-04","objectID":"/hugo/:1:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#安装hugo"},{"categories":null,"content":" 1.2 创建网站 hugo new site 路径 ","date":"2021-05-04","objectID":"/hugo/:1:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建网站"},{"categories":null,"content":" 1.3 添加主题 将主题直接添加到theme文件下面 将主题作为一个submodule ","date":"2021-05-04","objectID":"/hugo/:1:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#添加主题"},{"categories":null,"content":" 1.4 创建文档 hugo new posts/hugo.md ","date":"2021-05-04","objectID":"/hugo/:1:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建文档"},{"categories":null,"content":" 1.5 设置预览 hugo server -D --disableFastRender ","date":"2021-05-04","objectID":"/hugo/:1:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#设置预览"},{"categories":null,"content":" 2 文件结构 . ├── archetypes ├── config ├── content ├── data ├── layouts ├── static ├── themes ├── static └── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。 ","date":"2021-05-04","objectID":"/hugo/:2:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#文件结构"},{"categories":null,"content":" 2.1 archetypeshugo模板,在创建文件时作为模板自动生成 ","date":"2021-05-04","objectID":"/hugo/:2:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#archetypes"},{"categories":null,"content":" 2.2 assets存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录 ","date":"2021-05-04","objectID":"/hugo/:2:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#assets"},{"categories":null,"content":" 2.3 configHugo配置目录 ","date":"2021-05-04","objectID":"/hugo/:2:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#config"},{"categories":null,"content":" 2.4 content此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分. ","date":"2021-05-04","objectID":"/hugo/:2:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#content"},{"categories":null,"content":" 2.5 data该目录用于存储 Hugo 在生成网站时可以使用的配置文件 ","date":"2021-05-04","objectID":"/hugo/:2:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#data"},{"categories":null,"content":" 2.6 layouts以 .html文件的形式存储模板. ","date":"2021-05-04","objectID":"/hugo/:2:6","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#layouts"},{"categories":null,"content":" 2.7 static存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制 ","date":"2021-05-04","objectID":"/hugo/:2:7","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#static"},{"categories":null,"content":" 3 编写工具","date":"2021-05-04","objectID":"/hugo/:3:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#编写工具"},{"categories":null,"content":" 3.1 typora使用typora作为markdown编写工具 ","date":"2021-05-04","objectID":"/hugo/:3:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#typora"},{"categories":null,"content":" 3.2 picgo ","date":"2021-05-04","objectID":"/hugo/:3:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#picgo"},{"categories":null,"content":" nfs服务","date":"2021-05-03","objectID":"/nfs/:0:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#nfs服务"},{"categories":null,"content":" 1 安装 sudo apt-get install nfs-kernel-server ","date":"2021-05-03","objectID":"/nfs/:1:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#安装"},{"categories":null,"content":" 2 设置导出 /home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) ","date":"2021-05-03","objectID":"/nfs/:2:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#设置导出"},{"categories":null,"content":" 3 开启服务 sudo /etc/init.d/nfs-kernel-server restart ","date":"2021-05-03","objectID":"/nfs/:3:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#开启服务"},{"categories":null,"content":" 4 测试 sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt ls /mnt ","date":"2021-05-03","objectID":"/nfs/:4:0","series":null,"tags":["nfs"],"title":"Nfs","uri":"/nfs/#测试"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线","uri":"/offline/#"}]
[{"categories":["编程语言"],"content":"Python学习笔记","date":"2023-12-07","objectID":"/python/","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/"},{"categories":["编程语言"],"content":"python学习笔记 ","date":"2023-12-07","objectID":"/python/:0:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#"},{"categories":["编程语言"],"content":" 1 开发环境安装 推荐Mambaforge,与anaconda相同功能,但是速度更加快; mamba是包管理器的重新实现,由C++重新实现,主页地址:miniforge, ","date":"2023-12-07","objectID":"/python/:1:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#开发环境安装"},{"categories":["编程语言"],"content":" 1.1 安装软件 $ curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-$(uname)-$(uname -m).sh\" $ bash Mambaforge-$(uname)-$(uname -m).sh ","date":"2023-12-07","objectID":"/python/:1:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#安装软件"},{"categories":["编程语言"],"content":" 1.2 配置环境 CONDA_EXE=mamba 配置虚拟环境 conda env list #查看虚拟环境 mamba create -n env_name -y #创建 conda activate env_name #激活 conda deactivate #退出 配置包下载镜像 mamba config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ mamba config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ mamba config --set show_channel_urls yes ","date":"2023-12-07","objectID":"/python/:1:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#配置环境"},{"categories":["编程语言"],"content":" 1.3 jupyter notebook/lab安装 1.3.1 1. 安装 $ mamaba install jupyter 1.3.2 2. 配置 ssh远程使用jupyter notebook # 远程服务器开启 jupyter notebook --no-browser --port=8889 # ssh forward端口 ssh -N -f -L localhost:8888:localhost:8889 username@serverIP 利用jupyter notebook自带的远程访问功能 # 1. 生成默认配置文件 jupyter notebook --generate-config # 2.1 自动生成访问密码(token) jupyter notebook password Enter password: Verify password: [NotebookPasswordApp] Wrote hashed password to ${HOME}/.jupyter/jupyter_notebook_config.json # 2.2 手动生成访问密码(token) In [1]: from notebook.auth import passwd # 2.2.1 官方教程默认情况下生成sha1,但实际情况生成了argon2 In [2]: passwd() Enter password: Verify password: Out[2]: 'argon2:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 2.2.2 输入sha1的生成算法,即可得到 In [3]: passwd(algorithm='sha1') Enter password: Verify password: Out[3]: 'sha1:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 3. 修改./jupyter/jupyter_notebook_config.py c.NotebookApp.ip='*' c.NotebookApp.password = u'sha:ce...刚才复制的那个密文' c.NotebookApp.open_browser = False c.NotebookApp.port =8888 #可自行指定一个端口, 访问时使用该端口 # 如果是自动的形式此时就可以直接访问 # 4. 配置相关 c.ServerApp.allow_remote_access = True c.LabApp.open_browser = False 1.3.3 安装扩展 jupyter_contrib_nbextensions， pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user Jupyter Nbextensions Configurator pip install jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user ","date":"2023-12-07","objectID":"/python/:1:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#jupyter-notebooklab安装"},{"categories":["编程语言"],"content":" 1.3 jupyter notebook/lab安装 1.3.1 1. 安装 $ mamaba install jupyter 1.3.2 2. 配置 ssh远程使用jupyter notebook # 远程服务器开启 jupyter notebook --no-browser --port=8889 # ssh forward端口 ssh -N -f -L localhost:8888:localhost:8889 username@serverIP 利用jupyter notebook自带的远程访问功能 # 1. 生成默认配置文件 jupyter notebook --generate-config # 2.1 自动生成访问密码(token) jupyter notebook password Enter password: Verify password: [NotebookPasswordApp] Wrote hashed password to ${HOME}/.jupyter/jupyter_notebook_config.json # 2.2 手动生成访问密码(token) In [1]: from notebook.auth import passwd # 2.2.1 官方教程默认情况下生成sha1,但实际情况生成了argon2 In [2]: passwd() Enter password: Verify password: Out[2]: 'argon2:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 2.2.2 输入sha1的生成算法,即可得到 In [3]: passwd(algorithm='sha1') Enter password: Verify password: Out[3]: 'sha1:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 3. 修改./jupyter/jupyter_notebook_config.py c.NotebookApp.ip='*' c.NotebookApp.password = u'sha:ce...刚才复制的那个密文' c.NotebookApp.open_browser = False c.NotebookApp.port =8888 #可自行指定一个端口, 访问时使用该端口 # 如果是自动的形式此时就可以直接访问 # 4. 配置相关 c.ServerApp.allow_remote_access = True c.LabApp.open_browser = False 1.3.3 安装扩展 jupyter_contrib_nbextensions， pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user Jupyter Nbextensions Configurator pip install jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user ","date":"2023-12-07","objectID":"/python/:1:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#1-安装"},{"categories":["编程语言"],"content":" 1.3 jupyter notebook/lab安装 1.3.1 1. 安装 $ mamaba install jupyter 1.3.2 2. 配置 ssh远程使用jupyter notebook # 远程服务器开启 jupyter notebook --no-browser --port=8889 # ssh forward端口 ssh -N -f -L localhost:8888:localhost:8889 username@serverIP 利用jupyter notebook自带的远程访问功能 # 1. 生成默认配置文件 jupyter notebook --generate-config # 2.1 自动生成访问密码(token) jupyter notebook password Enter password: Verify password: [NotebookPasswordApp] Wrote hashed password to ${HOME}/.jupyter/jupyter_notebook_config.json # 2.2 手动生成访问密码(token) In [1]: from notebook.auth import passwd # 2.2.1 官方教程默认情况下生成sha1,但实际情况生成了argon2 In [2]: passwd() Enter password: Verify password: Out[2]: 'argon2:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 2.2.2 输入sha1的生成算法,即可得到 In [3]: passwd(algorithm='sha1') Enter password: Verify password: Out[3]: 'sha1:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 3. 修改./jupyter/jupyter_notebook_config.py c.NotebookApp.ip='*' c.NotebookApp.password = u'sha:ce...刚才复制的那个密文' c.NotebookApp.open_browser = False c.NotebookApp.port =8888 #可自行指定一个端口, 访问时使用该端口 # 如果是自动的形式此时就可以直接访问 # 4. 配置相关 c.ServerApp.allow_remote_access = True c.LabApp.open_browser = False 1.3.3 安装扩展 jupyter_contrib_nbextensions， pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user Jupyter Nbextensions Configurator pip install jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user ","date":"2023-12-07","objectID":"/python/:1:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#2-配置"},{"categories":["编程语言"],"content":" 1.3 jupyter notebook/lab安装 1.3.1 1. 安装 $ mamaba install jupyter 1.3.2 2. 配置 ssh远程使用jupyter notebook # 远程服务器开启 jupyter notebook --no-browser --port=8889 # ssh forward端口 ssh -N -f -L localhost:8888:localhost:8889 username@serverIP 利用jupyter notebook自带的远程访问功能 # 1. 生成默认配置文件 jupyter notebook --generate-config # 2.1 自动生成访问密码(token) jupyter notebook password Enter password: Verify password: [NotebookPasswordApp] Wrote hashed password to ${HOME}/.jupyter/jupyter_notebook_config.json # 2.2 手动生成访问密码(token) In [1]: from notebook.auth import passwd # 2.2.1 官方教程默认情况下生成sha1,但实际情况生成了argon2 In [2]: passwd() Enter password: Verify password: Out[2]: 'argon2:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 2.2.2 输入sha1的生成算法,即可得到 In [3]: passwd(algorithm='sha1') Enter password: Verify password: Out[3]: 'sha1:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' # 3. 修改./jupyter/jupyter_notebook_config.py c.NotebookApp.ip='*' c.NotebookApp.password = u'sha:ce...刚才复制的那个密文' c.NotebookApp.open_browser = False c.NotebookApp.port =8888 #可自行指定一个端口, 访问时使用该端口 # 如果是自动的形式此时就可以直接访问 # 4. 配置相关 c.ServerApp.allow_remote_access = True c.LabApp.open_browser = False 1.3.3 安装扩展 jupyter_contrib_nbextensions， pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user Jupyter Nbextensions Configurator pip install jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user ","date":"2023-12-07","objectID":"/python/:1:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#安装扩展"},{"categories":["编程语言"],"content":" 1.4 安装C++ Kernel conda install xeus-cling -c conda-forge 安装结束,进行测试 可以看到新的几个kernel ","date":"2023-12-07","objectID":"/python/:1:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#安装c-kernel"},{"categories":["编程语言"],"content":" 2 python入门","date":"2023-12-07","objectID":"/python/:2:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#python入门"},{"categories":["编程语言"],"content":" 2.1 第一个程序 #!/bin/python3 from rich import print if __name__ == '__main__': print('Hello World') ","date":"2023-12-07","objectID":"/python/:2:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#第一个程序"},{"categories":["编程语言"],"content":" 2.2 打印一个彩蛋 import this # 打印结果 # The Zen of Python, by Tim Peters # Beautiful is better than ugly. # Explicit is better than implicit. # Simple is better than complex. # Complex is better than complicated. # Flat is better than nested. # Sparse is better than dense. # Readability counts. # Special cases aren't special enough to break the rules. # Although practicality beats purity. # Errors should never pass silently. # Unless explicitly silenced. # In the face of ambiguity, refuse the temptation to guess. # There should be one-- and preferably only one --obvious way to do it. # Although that way may not be obvious at first unless you're Dutch. # Now is better than never. # Although never is often better than *right* now. # If the implementation is hard to explain, it's a bad idea. # If the implementation is easy to explain, it may be a good idea. # Namespaces are one honking great idea -- let's do more of those! 添加一个打印函数 # 使用rich打印 from rich import print print(\"Rich Print\") Rich中的打印更加漂亮 ","date":"2023-12-07","objectID":"/python/:2:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#打印一个彩蛋"},{"categories":["编程语言"],"content":" 2.3 字符串格式化 使用 格式化字符串字面值 ，要在字符串开头的引号/三引号前添加 f 或 F 。在这种字符串中，可以在 { 和 } 字符之间输入引用的变量，或字面值的 Python 表达式。 \u003e\u003e\u003e year = 2016 \u003e\u003e\u003e event = 'Referendum' \u003e\u003e\u003e f'Results of the {year} {event}' 'Results of the 2016 Referendum' 字符串的 str.format() 方法需要更多手动操作。该方法也用 { 和 } 标记替换变量的位置，虽然这种方法支持详细的格式化指令，但需要提供格式化信息。 \u003e\u003e\u003e yes_votes = 42_572_654 \u003e\u003e\u003e no_votes = 43_132_495 \u003e\u003e\u003e percentage = yes_votes / (yes_votes + no_votes) \u003e\u003e\u003e '{:-9} YES votes {:2.2%}'.format(yes_votes, percentage) ' 42572654 YES votes 49.67%' 旧式字符串格式化方法 不在使用了,还是新的看着舒服 ","date":"2023-12-07","objectID":"/python/:2:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#字符串格式化"},{"categories":["编程语言"],"content":" 2.4 main函数python中并不会存在着main函数,当前只是模拟了一个入口函数 if __name__ == '__main__': main() ","date":"2023-12-07","objectID":"/python/:2:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#main函数"},{"categories":["编程语言"],"content":" 3 数据类型","date":"2023-12-07","objectID":"/python/:3:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#数据类型"},{"categories":["编程语言"],"content":" 3.1 Numbers(数字) int long float double intA = int(12) print(type(intA)) \u003cclass 'int'\u003e\rlongB = 0xDAEABEEF print(type(longB)) \u003cclass 'int'\u003e\rfloatC = 1.2 print(type(floatC)) \u003cclass 'float'\u003e\rdoubleD = 1.2 print(type(doubleD)) \u003cclass 'float'\u003e\r","date":"2023-12-07","objectID":"/python/:3:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#numbers数字"},{"categories":["编程语言"],"content":" 3.2 布尔类型 True False boolA = True boolB = False print(boolA, type(boolA)) print(boolB, type(boolB)) True \u003cclass 'bool'\u003e\rFalse \u003cclass 'bool'\u003e\r","date":"2023-12-07","objectID":"/python/:3:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#布尔类型"},{"categories":["编程语言"],"content":" 3.3 String(字符串) 使用\"“定义字符串 r在字符串表示禁止转义 使用”““作用长字符串 # 普通定义字符串 strA = \"Hello\" print(strA, type(strA)) # r禁止转义 strB = r\"Hello\\nWorld\" print(strB, type(strB)) # 长字符串 strC = \"\"\" The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! \"\"\" print(strC, str(strC)) Hello \u003cclass 'str'\u003e\rHello\\nWorld \u003cclass 'str'\u003e\rThe Zen of Python, by Tim Peters\rBeautiful is better than ugly.\rExplicit is better than implicit.\rSimple is better than complex.\rComplex is better than complicated.\rFlat is better than nested.\rSparse is better than dense.\rReadability counts.\rSpecial cases aren't special enough to break the rules.\rAlthough practicality beats purity.\rErrors should never pass silently.\rUnless explicitly silenced.\rIn the face of ambiguity, refuse the temptation to guess.\rThere should be one-- and preferably only one --obvious way to do it.\rAlthough that way may not be obvious at first unless you're Dutch.\rNow is better than never.\rAlthough never is often better than *right* now.\rIf the implementation is hard to explain, it's a bad idea.\rIf the implementation is easy to explain, it may be a good idea.\rNamespaces are one honking great idea -- let's do more of those!\rThe Zen of Python, by Tim Peters\rBeautiful is better than ugly.\rExplicit is better than implicit.\rSimple is better than complex.\rComplex is better than complicated.\rFlat is better than nested.\rSparse is better than dense.\rReadability counts.\rSpecial cases aren't special enough to break the rules.\rAlthough practicality beats purity.\rErrors should never pass silently.\rUnless explicitly silenced.\rIn the face of ambiguity, refuse the temptation to guess.\rThere should be one-- and preferably only one --obvious way to do it.\rAlthough that way may not be obvious at first unless you're Dutch.\rNow is better than never.\rAlthough never is often better than *right* now.\rIf the implementation is hard to explain, it's a bad idea.\rIf the implementation is easy to explain, it may be a good idea.\rNamespaces are one honking great idea -- let's do more of those!\r","date":"2023-12-07","objectID":"/python/:3:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#string字符串"},{"categories":["编程语言"],"content":" 3.4 List(列表) listC = [\"12\", 3, 4] print(listC) ","date":"2023-12-07","objectID":"/python/:3:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#list列表"},{"categories":["编程语言"],"content":" 3.5 Tuple(元组) tupleD = ('physics', 'chemistry', 1997, 2000) print(tupleD) ","date":"2023-12-07","objectID":"/python/:3:5","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#tuple元组"},{"categories":["编程语言"],"content":" 3.6 Dictionary(字典) DictE = {'a': 1, 'b': 2, 'b': '3'} print(DictE) ","date":"2023-12-07","objectID":"/python/:3:6","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#dictionary字典"},{"categories":["编程语言"],"content":" 3.7 set(集合) SetF = set([1, 2, 3, 3]) print(DictE) ","date":"2023-12-07","objectID":"/python/:3:7","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#set集合"},{"categories":["编程语言"],"content":" 4 运算符","date":"2023-12-07","objectID":"/python/:4:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#运算符"},{"categories":["编程语言"],"content":" 5 控制结构","date":"2023-12-07","objectID":"/python/:5:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#控制结构"},{"categories":["编程语言"],"content":" 5.1 单执行语句 if 判断条件： 执行语句 else： 执行语句 ","date":"2023-12-07","objectID":"/python/:5:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#单执行语句"},{"categories":["编程语言"],"content":" 5.2 多条件语句 if 判断条件1: 执行语句1…… elif 判断条件2: 执行语句2…… elif 判断条件3: 执行语句3…… else: 执行语句4…… ","date":"2023-12-07","objectID":"/python/:5:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#多条件语句"},{"categories":["编程语言"],"content":" 5.3 match语句 match语句类似于c的switch语句, match status: case 400: return \"Bad request\" case 404: return \"Not found\" case 418: return \"I'm a teapot\" case _: return \"Something's wrong with the internet\" ","date":"2023-12-07","objectID":"/python/:5:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#match语句"},{"categories":["编程语言"],"content":" 5.4 while循环 c = 0 while (c \u003c 10): print(c) c += 1 print(\"while Loop finish\") ","date":"2023-12-07","objectID":"/python/:5:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#while循环"},{"categories":["编程语言"],"content":" 5.5 for语句 python中的语句与C不同,python不进行数值的计算,而是 迭代列表或字符串等任意序列,元素的迭代顺序与在序列中出现的顺序一致 # 定义一个列表 words = [\"linux\", \"macos\", \"windows\"] # 遍历列表 for word in words: print(word, len(word)) 源码文件: 执行结果: ","date":"2023-12-07","objectID":"/python/:5:5","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#for语句"},{"categories":["编程语言"],"content":" 5.6 range函数 内置函数range()常用于遍历数字序列,该函数可以生成算术级数 range的语法 # start: 开始 # stop: 结束 # step: 步长 range(start, stop, step) 那么是如何排列的 只有一个参数下只会只存在stop for i in range(10): print(i) 源码文件: 执行结果: 两个参数下存在start和stop for i in range(1, 10): print(i) 源码文件: 执行结果: 三个参数全部填写 for i in range(1, 10, 2): print(i) 源码文件: 执行结果: 如果直接输出range会发生什么 range()返回对象的操作和列表很像,但其实这两种对象不是一回事. 迭代时,该对象基于所需序列返回连续项，并没有生成真正的列表，从而节省了空间。 这种对象称为可迭代对象 iterable，函数或程序结构可通过该对象获取连续项，直到所有元素全部迭代完毕 将range对象强转为其他类型的数据结构 字典是无法进行转换的 l = list(range(10)) t = tuple(range(10)) s = set(range(10)) ","date":"2023-12-07","objectID":"/python/:5:6","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#range函数"},{"categories":["编程语言"],"content":" 5.7 跳出语句break语句和C中的类似,用于跳出最近的for或while循环。 for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, 'equals', x, '*', n//x) break else: print(n, 'is a prime number') 但是与C不相同的是,else可以用于for语句,未执行break时执行 ","date":"2023-12-07","objectID":"/python/:5:7","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#跳出语句"},{"categories":["编程语言"],"content":" 5.8 pass语句pass语句不执行任何操作 ","date":"2023-12-07","objectID":"/python/:5:8","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#pass语句"},{"categories":["编程语言"],"content":" 6 函数 定义函数使用关键字def, 后跟函数名与括号内的形参列表.函数语句从下一行开始,并且必须缩进. 函数内的第一条语句是字符串时,该字符串就是文档字符串,也称为docstring,详见文档字符串。利用文档字符串可以自动生成在线文档或打印版文档,还可以让开发者在浏览代码时直接查阅文档;Python开发者最好养成在代码中加入文档字符串的好习惯. 函数在执行时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值(除非是global语句定义的全局变量,nonlocal语句定义的外层函数变量) ","date":"2023-12-07","objectID":"/python/:6:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#函数"},{"categories":["编程语言"],"content":" 6.1 函数参数从函数定义的角度来看，参数可以分为两种： 必选参数：调用函数时必须要指定的参数，在定义时没有等号 可选参数：也叫默认参数，调用函数时可以指定也可以不指定，不指定就默认的参数值来。 从函数调用的角度来看，参数可以分为两种： 关键字参数：调用时，使用 key=value 形式传参的，这样传递参数就可以不按定义顺序来。 位置参数：调用时，不使用关键字参数的 key-value 形式传参，这样传参要注意按照函数定义时参数的顺序来。 def func(a,b,c=0, d=1): pass a,b称为必选参数 c,d称为可选参数 可变参数,类似C语言的...参数 加了星号*的变量名会存放所有未命名的变量参数 # 定义函数 def hello(head, *args): for arg in args: print(f\"{head}:{arg}\") return True # 调用函数 hello(\"ERROR\", 1, 2, 3) $ ERROR:1 $ ERROR:2 $ ERROR:3 ","date":"2023-12-07","objectID":"/python/:6:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#函数参数"},{"categories":["编程语言"],"content":" 6.2 匿名函数lambda关键字用于创建小巧的匿名函数; lambda a, b: a+b 函数返回两个参数的和。Lambda 函数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量： \u003e\u003e\u003e pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] \u003e\u003e\u003e pairs.sort(key=lambda pair: pair[1]) \u003e\u003e\u003e pairs [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] ","date":"2023-12-07","objectID":"/python/:6:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#匿名函数"},{"categories":["编程语言"],"content":" 6.3 文档字符串对函数进行注释 \u003e\u003e\u003e def func(): ... \"\"\" ... Do Nothing ... 仅仅作为演示 ... \"\"\" ... pass ... \u003e\u003e\u003e print(func.__doc__) Do Nothing ","date":"2023-12-07","objectID":"/python/:6:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#文档字符串"},{"categories":["编程语言"],"content":" 6.4 函数注解函数注解是可选的用户自定义函数类型的元数据完整信息(详见PEP3107和PEP484) 标注 以字典的形式存放在函数的 annotations 属性中而对函数的其他部分没有影响 形参标注的定义方式是在形参名后加冒号，后面跟一个会被求值为标注的值的表达式。 返回值标注的定义方式是加组合符号 -\u003e，后面跟一个表达式，这样的校注位于形参列表和表示 def 语句结束的冒号 \u003e\u003e\u003e def f(ham: str, eggs: str = 'eggs') -\u003e str: ... return ham + ' and ' + eggs \u003e\u003e\u003e f('spam') 'spam and eggs' \u003e\u003e\u003e f.__annotations__ {'ham': \u003cclass 'str'\u003e, 'eggs': \u003cclass 'str'\u003e, 'return': \u003cclass 'str'\u003e} ","date":"2023-12-07","objectID":"/python/:6:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#函数注解"},{"categories":["编程语言"],"content":" 7 模块","date":"2023-12-07","objectID":"/python/:7:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#模块"},{"categories":["编程语言"],"content":" 8 异常处理 即使语句或表达式使用了正确的语法，执行时仍可能触发错误 while True: try: x = int(input(\"Please enter a number: \")) break except ValueError: print(\"Oops! That was no valid number. Try again...\") 执行结果: D:\\python\\异常处理\\.venv\\Scripts\\python.exe D:\\python\\异常处理\\main.py Please enter a number: a Oops! That was no valid number. Try again... Please enter a number: 12 Process finished with exit code 0 ","date":"2023-12-07","objectID":"/python/:8:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#异常处理"},{"categories":["编程语言"],"content":" 9 文件操作","date":"2023-12-07","objectID":"/python/:9:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#文件操作"},{"categories":["编程语言"],"content":" 9.1 文件打开模式打开文件获取文件描述符，打开文件时需要指定对文件的读写模式，和写追加模式。常见的文件模式如下： 模式 描述 ‘r’ 以只读方式打开文件（默认），不存在报错 FileNotFoundError ‘w’ 以写方式打开文件，如果文件存在，首先清空原内容，如果不存在先创建文件 ‘x’ 以写方式打开文件，如果文件存在，则报错 FileExistsError ‘a’ 以写方式打开文件，并追加内容到文件结尾，如果文件不能存在则先创建文件 ‘+’ 可同时读写 ","date":"2023-12-07","objectID":"/python/:9:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#文件打开模式"},{"categories":["编程语言"],"content":" 9.2 打开文件(open函数) open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) Open file and return a stream. Raise IOError upon failure. 测试代码 # shell echo \"Hello World\" \u003e\u003e test Python 3.11.6 (main, Nov 14 2023, 09:36:21) [GCC 13.2.1 20230801] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e f = open('test.txt', 'r', encoding='utf-8') \u003e\u003e\u003e print(f.read()) Hello World \u003e\u003e\u003e f.close() 但是这个写法不太好,如果文件打开出现异常,程序会出现崩溃(加上异常处理) f = None try: f = open('test.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') finally: if f: f.close() 加上with关键字,在正常的情况下我们不需要进行手动关闭 def main(): try: with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') if __name__ == '__main__': main() ","date":"2023-12-07","objectID":"/python/:9:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#打开文件open函数"},{"categories":["编程语言"],"content":" 9.3 文件描述符的属性在 Python 中，文件描述符就是一个文件对象，它具有如下属性： 属性 描述 file.closed 返回布尔值，True 已被关闭。 file.mode 返回被打开文件的访问模式。 file.name 返回文件的名称。 ","date":"2023-12-07","objectID":"/python/:9:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#文件描述符的属性"},{"categories":["编程语言"],"content":" 9.4 读取文件 \u003e\u003e\u003e f = open('test.txt', 'r', encoding='utf-8') \u003e\u003e\u003e f.read() 'Hello World\\n' \u003e\u003e\u003e f.readline() '' \u003e\u003e\u003e f.readlines() [] \u003e\u003e\u003e type(f.readline()) \u003cclass 'str'\u003e \u003e\u003e\u003e type(f.readlines()) \u003cclass 'list'\u003e \u003e\u003e\u003e type(f.read()) \u003cclass 'str'\u003e ","date":"2023-12-07","objectID":"/python/:9:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#读取文件"},{"categories":["编程语言"],"content":" 9.5 写入文件","date":"2023-12-07","objectID":"/python/:9:5","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#写入文件"},{"categories":["编程语言"],"content":" 10 正则表达式","date":"2023-12-07","objectID":"/python/:10:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#正则表达式"},{"categories":["编程语言"],"content":" 11 进程线程","date":"2023-12-07","objectID":"/python/:11:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#进程线程"},{"categories":["编程语言"],"content":" 12 面向对象 面向对象编程（Object Oriented Programming，OOP）是一种程序设计思想。它把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，相同属:性和操作方法的对象被抽象为类。类（Class）就类似上面所说的模具，而对象（Object）就是使用模具生产出的零件，对象就是类的实例(Instance) 继承和多态、封装是面向对象编程的三个基本特征 print(isinstance(object, type)) print(isinstance(type, object)) print(isinstance(type, type)) print(isinstance(object, object)) \u003e\u003e\u003e True True True True ","date":"2023-12-07","objectID":"/python/:12:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#面向对象"},{"categories":["编程语言"],"content":" 12.1 类和对象 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来\u003e 定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 # 1.1 定义类 class clsTest: clsNum = 0 def clsFunc(self): print(\"执行方法\") # 1.2 实例化对象 t = clsTest() t.clsFunc() 说明： 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 ","date":"2023-12-07","objectID":"/python/:12:1","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#类和对象"},{"categories":["编程语言"],"content":" 12.2 抽象/封装/继承/多态","date":"2023-12-07","objectID":"/python/:12:2","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#抽象封装继承多态"},{"categories":["编程语言"],"content":" 12.3 属性","date":"2023-12-07","objectID":"/python/:12:3","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#属性"},{"categories":["编程语言"],"content":" 12.4 方法","date":"2023-12-07","objectID":"/python/:12:4","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#方法"},{"categories":["编程语言"],"content":" 12.5 运算符重载","date":"2023-12-07","objectID":"/python/:12:5","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#运算符重载"},{"categories":["编程语言"],"content":" 12.6 类对象","date":"2023-12-07","objectID":"/python/:12:6","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#类对象"},{"categories":["编程语言"],"content":" 12.7 继承和多态","date":"2023-12-07","objectID":"/python/:12:7","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#继承和多态"},{"categories":["编程语言"],"content":" 13 标准库","date":"2023-12-07","objectID":"/python/:13:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#标准库"},{"categories":["编程语言"],"content":" 14 虚拟环境","date":"2023-12-07","objectID":"/python/:14:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#虚拟环境"},{"categories":["编程语言"],"content":" 15 GUI基础(tkinter)","date":"2023-12-07","objectID":"/python/:15:0","series":null,"tags":["Python学习笔记"],"title":"Python学习笔记","uri":"/python/#gui基础tkinter"},{"categories":["rust"],"content":"rust基础笔记","date":"2023-07-26","objectID":"/rust_basic/","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/"},{"categories":["rust"],"content":"Rust基础笔记 ","date":"2023-07-26","objectID":"/rust_basic/:0:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#"},{"categories":["rust"],"content":" 1 环境搭建","date":"2023-07-26","objectID":"/rust_basic/:1:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#环境搭建"},{"categories":["rust"],"content":" 1.1 安装rust软件rust官方网站 rust官方教程 ","date":"2023-07-26","objectID":"/rust_basic/:1:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#安装rust软件"},{"categories":["rust"],"content":" 1.2 hello world程序 创建hello_world程序 $ cargo new hello_world Created binary (application) `hello_world` package Cargo.toml: 配置文件 src文件夹: 存放rust源文件 构建 $ cargo build Compiling hello_world v0.1.0 (D:\\learn_rust\\hello_world) Finished dev [unoptimized + debuginfo] target(s) in 1.25s 运行 $ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.01s Running `target\\debug\\hello_world.exe` Hello, world! 至此,我们就可以运行进行rust程序的学习了; ","date":"2023-07-26","objectID":"/rust_basic/:1:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#hello-world程序"},{"categories":["rust"],"content":" 2 数据类型","date":"2023-07-26","objectID":"/rust_basic/:2:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#数据类型"},{"categories":["rust"],"content":" 2.1 变量 默认let定义的是不可变变量 使用mut创建可变变量 let _a = 12; // 不可变变量 let mut _b = 12; // 可变变量 _a = 13; // 编译报错: cannot assign twice to immutable variable _b = 13; // 编译成功 那为什么可以称之为不可变变量,为什么不可以称之为常量; 因为,虽然不可以修改,但是可以重新绑定 let _a = 13; // 不可变变量重新绑定13 let _a = 14; // 不可变变量重新绑定14 是否可以这样理解,let翻译为绑定, 一般let绑定到常量上 mut绑定到内存上 那么进行一下测试 let _c = 12; // 1. 首先绑定到12这个常量上 let mut _c = 14; // 2. 绑定到变量上 _c = 15; // 3. 可以修改 在进行分析,但是下面的这种绑定的概念出现了问题 fn main() { let mut _c = 12; let _d = _c; _d = 12; // 编译报错 println!(\"The value of x is: {_c}\"); println!(\"The value of x is: {_d}\"); } $ cargo build Compiling variables_mutability v0.1.0 (D:\\github.io\\static\\demo\\rust\\variable s_mutability) error[E0384]: cannot assign twice to immutable variable `_d` --\u003e src\\main.rs:4:5 | 3 | let _d = _c; | -- | | | first assignment to `_d` | help: consider making this binding mutable: `mut _d` 4 | _d = 12; // 编译报错 | ^^^^^^^ cannot assign twice to immutable variable For more information about this error, try `rustc --explain E0384`. error: could not compile `variables_mutability` due to previous error 当然,此时我还不了解什么概念,因此作出猜测 编译期间通过符号表的属性判断变量是否进行修改 但是可以重新绑定 fn main() { let mut _c = 12; let _d = _c; let _d = 12; // 编译报错 println!(\"The value of x is: {_c}\"); println!(\"The value of x is: {_d}\"); } ","date":"2023-07-26","objectID":"/rust_basic/:2:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#变量"},{"categories":["rust"],"content":" 2.2 常量类似于不可变变量, 常量 (constants) 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。 const HOURS_IN_SECONDS: u32 = 60 * 60; ","date":"2023-07-26","objectID":"/rust_basic/:2:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#常量"},{"categories":["rust"],"content":" 2.3 标量类型 2.3.1 整数类型 整数没有小数部分 无符号以u开头 有符号以i开头 Length Signed Unsigned 8-Bit i8 u8 16-Bit i16 u16 32-Bit i32 u32 64-Bit i64 u64 128-Bit i128 u128 arch iszie usize 2.3.2 浮点类型默认浮点为64 f32 –\u003e 32浮点 f64 –\u003e 64浮点 2.3.3 布尔类型 一个字节的大小 符号是bool 两个值true/false 2.3.4 字符类型 rust使用char描述 使用4个字节存储 ","date":"2023-07-26","objectID":"/rust_basic/:2:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#标量类型"},{"categories":["rust"],"content":" 2.3 标量类型 2.3.1 整数类型 整数没有小数部分 无符号以u开头 有符号以i开头 Length Signed Unsigned 8-Bit i8 u8 16-Bit i16 u16 32-Bit i32 u32 64-Bit i64 u64 128-Bit i128 u128 arch iszie usize 2.3.2 浮点类型默认浮点为64 f32 –\u003e 32浮点 f64 –\u003e 64浮点 2.3.3 布尔类型 一个字节的大小 符号是bool 两个值true/false 2.3.4 字符类型 rust使用char描述 使用4个字节存储 ","date":"2023-07-26","objectID":"/rust_basic/:2:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#整数类型"},{"categories":["rust"],"content":" 2.3 标量类型 2.3.1 整数类型 整数没有小数部分 无符号以u开头 有符号以i开头 Length Signed Unsigned 8-Bit i8 u8 16-Bit i16 u16 32-Bit i32 u32 64-Bit i64 u64 128-Bit i128 u128 arch iszie usize 2.3.2 浮点类型默认浮点为64 f32 –\u003e 32浮点 f64 –\u003e 64浮点 2.3.3 布尔类型 一个字节的大小 符号是bool 两个值true/false 2.3.4 字符类型 rust使用char描述 使用4个字节存储 ","date":"2023-07-26","objectID":"/rust_basic/:2:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#浮点类型"},{"categories":["rust"],"content":" 2.3 标量类型 2.3.1 整数类型 整数没有小数部分 无符号以u开头 有符号以i开头 Length Signed Unsigned 8-Bit i8 u8 16-Bit i16 u16 32-Bit i32 u32 64-Bit i64 u64 128-Bit i128 u128 arch iszie usize 2.3.2 浮点类型默认浮点为64 f32 –\u003e 32浮点 f64 –\u003e 64浮点 2.3.3 布尔类型 一个字节的大小 符号是bool 两个值true/false 2.3.4 字符类型 rust使用char描述 使用4个字节存储 ","date":"2023-07-26","objectID":"/rust_basic/:2:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#布尔类型"},{"categories":["rust"],"content":" 2.3 标量类型 2.3.1 整数类型 整数没有小数部分 无符号以u开头 有符号以i开头 Length Signed Unsigned 8-Bit i8 u8 16-Bit i16 u16 32-Bit i32 u32 64-Bit i64 u64 128-Bit i128 u128 arch iszie usize 2.3.2 浮点类型默认浮点为64 f32 –\u003e 32浮点 f64 –\u003e 64浮点 2.3.3 布尔类型 一个字节的大小 符号是bool 两个值true/false 2.3.4 字符类型 rust使用char描述 使用4个字节存储 ","date":"2023-07-26","objectID":"/rust_basic/:2:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#字符类型"},{"categories":["rust"],"content":" 2.4 复合类型 2.4.1 元组(tuple) Tuple可以将多个值放在一个数据类型里 Tuple长度是固定的 let tup:(i32, i64, i128) = (500, 1000, 1500); let (x, y, z) = tup; println!(\"{} {} {}\", x, y, z); 2.4.2 数组(array) 数组也可以将多个值放在一个类型里 数组的元素必须相同 数组的长度是固定的 let months = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Jun\", \"Jly\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]; let mount_1st = months[0]; let mount_2nd = months[2]; println!(\"mount_1st:{mount_1st} mount_2nd:{mount_2nd}\"); ","date":"2023-07-26","objectID":"/rust_basic/:2:4","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#复合类型"},{"categories":["rust"],"content":" 2.4 复合类型 2.4.1 元组(tuple) Tuple可以将多个值放在一个数据类型里 Tuple长度是固定的 let tup:(i32, i64, i128) = (500, 1000, 1500); let (x, y, z) = tup; println!(\"{} {} {}\", x, y, z); 2.4.2 数组(array) 数组也可以将多个值放在一个类型里 数组的元素必须相同 数组的长度是固定的 let months = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Jun\", \"Jly\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]; let mount_1st = months[0]; let mount_2nd = months[2]; println!(\"mount_1st:{mount_1st} mount_2nd:{mount_2nd}\"); ","date":"2023-07-26","objectID":"/rust_basic/:2:4","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#元组tuple"},{"categories":["rust"],"content":" 2.4 复合类型 2.4.1 元组(tuple) Tuple可以将多个值放在一个数据类型里 Tuple长度是固定的 let tup:(i32, i64, i128) = (500, 1000, 1500); let (x, y, z) = tup; println!(\"{} {} {}\", x, y, z); 2.4.2 数组(array) 数组也可以将多个值放在一个类型里 数组的元素必须相同 数组的长度是固定的 let months = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Jun\", \"Jly\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]; let mount_1st = months[0]; let mount_2nd = months[2]; println!(\"mount_1st:{mount_1st} mount_2nd:{mount_2nd}\"); ","date":"2023-07-26","objectID":"/rust_basic/:2:4","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#数组array"},{"categories":["rust"],"content":" 3 控制流","date":"2023-07-26","objectID":"/rust_basic/:3:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#控制流"},{"categories":["rust"],"content":" 3.1 条件语句 let number = 3; if number \u003c 5 { println!(\"condition was true\"); } else { println!(\"condition was false\"); } // condition was true let number = 5; if number \u003c 5 { println!(\"condition was true\"); } else if number \u003e 5 { println!(\"condition was false\"); } else { println!(\"condition was five\"); } // condition was five fn main() { // 1. if条件语句 let number = 3; if number \u003c 5 { println!(\"condition was true\"); } else { println!(\"condition was false\"); } // 2. 使用 else if 处理多重条件 if number % 4 == 0 { println!(\"number is divisible by 4\"); } else if number % 3 == 0 { println!(\"number is divisible by 3\"); } else if number % 2 == 0 { println!(\"number is divisible by 2\"); } else { println!(\"number is not divisible by 4, 3, or 2\"); } // 3.在 let 语句中使用 if let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {number}\"); // 4. 使用 loop 重复执行代码 let mut x = 0; loop { println!(\"again! {}\", x); x += 1; if x \u003e 12 { break; } } // 5. 从循环返回值 let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\"The result is {result}\"); // 如果存在嵌套循环，break 和 continue 应用于此时最内层的循环。 // 你可以选择在一个循环上指定一个 循环标签（loop label）， // 然后将标签与 break 或 continue 一起使用， // 使这些关键字应用于已标记的循环而不是最内层的循环 // 6. 循环标签：在多个循环之间消除歧义 let mut count = 0; 'counting_up: loop { println!(\"count = {count}\"); let mut remaining = 10; loop { println!(\"remaining = {remaining}\"); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1; } println!(\"End count = {count}\"); // 7. while 条件循环 let mut number = 3; while number != 0 { println!(\"{number}!\"); number -= 1; } println!(\"LIFTOFF!!!\"); // 8. 使用 for 遍历集合 let a = [10, 20, 30, 40, 50]; for element in a { println!(\"the value is: {element}\"); } } ","date":"2023-07-26","objectID":"/rust_basic/:3:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#条件语句"},{"categories":["rust"],"content":" 4 函数定义普通函数 fn \u003c函数名\u003e (\u003c参数\u003e) { \u003c函数体\u003e } fn another_function() { println!(\"Another function.\"); } 定义输入参数 参数必须指定类型 /// rust函数带参数 fn another_function_with_args(x: i32) { println!(\"The value of x is: {x}\"); } /// rust函数带两个参数 fn print_labeled_measurement(value: i32, unit_label: char) { println!(\"The measurement is: {value}{unit_label}\"); } 定义返回值 必须指定返回值 函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（-\u003e）后声明它的类型。 在Rust中，函数的返回值等同于函数体最后一个表达式的值。 使用return关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式. /// 带返回值的函数 fn function_with_return_value1() -\u003e i32 { println!(\"带返回值的函数\"); 5 } /// 带返回值的函数 fn function_with_return_value2() -\u003e i32 { println!(\"带返回值的函数在return之前\"); return 5; println!(\"带返回值的函数在return之后\"); } ","date":"2023-07-26","objectID":"/rust_basic/:4:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#函数"},{"categories":["rust"],"content":" 5 所有权 所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制， 在程序运行时有规律地寻找\u003e 不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。 Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。 如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序 所有权规则 Rust 中的每一个值都有一个 所有者（owner）。 值在任一时刻有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 首先， 我们需要看一个代码,并且执行编译; fn main() { let s1 = String::from(\"hello\"); let s2 = s1; println!(\"{} {}\", s1, s2); } error[E0382]: borrow of moved value: `s1` --\u003e src\\main.rs:5:23 | 2 | let s1 = String::from(\"hello\"); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 3 | let s2 = s1; | -- value moved here 4 | 5 | println!(\"{} {}\", s1, s2); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) help: consider cloning the value if the performance cost is acceptable | 3 | let s2 = s1.clone(); | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `ownship` due to previous error 在我们看来， 这个程序为啥编译失败了呢？ 不应该s2保留了s1的备份么？ 之前我们提到过当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。 为了确保内存安全，在 let s2 = s1; 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。看看在 s2 被创建之后尝试使用 s1 会发生什么；这段代码不能运行： 那么就可以知道，此时s1移动了s2上面，s1不在合法的运行. 但是， 我们确实需要一个保证两个变量都是有效的,那么 fn main() { let s1 = String::from(\"hello\"); let s2 = s1.clone(); println!(\"s1 = {}, s2 = {}\", s1, s2); } 此时编译的结果就可以通过了. 但是呢？ let x = 5; let y = x; println!(\"x = {}, y = {}\", x, y); 我们可以知道，上面的确实可以编译通过， 这个又是什么原因呢？ 从根本上来说， 我们可以这样理解，rust保护内存，防止泄露 x,y保存在栈上，不会泄露，因此可以直接拷贝 原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。 那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型： 所有整数类型，比如 u32。 布尔类型，bool，它的值是 true 和 false。 所有浮点数类型，比如 f64。 字符类型，char。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。 fn main() { let s = String::from(\"Test\"); // s 进入作用域 takes_ownership(s); println!(\"{}\", s); // value borrowed here after move } fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\"{}\", some_string); } // 这里，some_string 移出作用域并调用 `drop` 方法。 // 占用的内存被释放 $ cargo build Compiling ownship v0.1.0 (D:\\github.io\\static\\demo\\rust\\ownship) error[E0382]: borrow of moved value: `s` --\u003e src\\main.rs:14:20 | 12 | let s = String::from(\"Test\"); // s 进入作用域 | - move occurs because `s` has type `String`, which does not implement the `Copy` trait 13 | takes_ownership(s); | - value moved here 14 | println!(\"{}\", s); | ^ value borrowed here after move | note: consider changing this parameter type in function `takes_ownership` to borrow instead if owning the value isn't necessary --\u003e src\\main.rs:20:33 | 20 | fn takes_ownership(some_string: String) { // some_string 进入作用域 | --------------- ^^^^^^ this parameter takes ownership of the value | | | in this function = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) help: consider cloning the value if the performance cost is acceptable | 13 | takes_ownership(s.clone()); | ++++++++ For more information about this error, try `rustc --explain E0382`. error: could not compile `ownship` due to previous error 但是如果可以使用copy的话会造成大量的拷贝,因此需要使用引用与借用， fn main() { let s1 = String::from(\"hello\"); let len = calculate_length(\u0026s1); println!(\"The length of '{}' is {}.\", s1, len); } fn calculate_length(s: \u0026String) -\u003e usize { s.len() } 首先，注意变量声明和函数返回值中的所有元组代码都消失了。其次，注意我们传递 \u0026s1 给 calculate_length，同时在函数定义中，我们获取 \u0026String 而不是 String。这些 \u0026 符号就是 引用，它们允许你使用值但不获取其所有权。图 4-5 展示了一张示意图。 我们将创建一个引用的行为称为 借用（borrowing） 如果我们尝试修改借用的变量呢？ fn main() { let s = String::from(\"hello\"); change(\u0026s); } fn change(s","date":"2023-07-26","objectID":"/rust_basic/:5:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#所有权"},{"categories":["rust"],"content":" 6 枚举","date":"2023-07-26","objectID":"/rust_basic/:6:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#枚举"},{"categories":["rust"],"content":" 6.1 定义枚举 定义枚举 #[derive(Debug)] enum IpAddrKind { V4, V6, } // 实例化枚举 let addr1 = IpAddrKind::V4; let addr2 = IpAddrKind::V6; // 打印枚举值 println!(\"{:#?}\", addr1); println!(\"{:#?}\", addr2); ","date":"2023-07-26","objectID":"/rust_basic/:6:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#定义枚举"},{"categories":["rust"],"content":" 6.2 枚举值作为函数参数 fn route(ip_kind : IpAddrKind) { println!(\"{:#?}\", ip_kind); } route(addr1); route(addr2); ","date":"2023-07-26","objectID":"/rust_basic/:6:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#枚举值作为函数参数"},{"categories":["rust"],"content":" 6.3 枚举值作为结构体成员 #[derive(Debug)] struct IpAddr { kind : IpAddrKind, addr : String, } ","date":"2023-07-26","objectID":"/rust_basic/:6:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#枚举值作为结构体成员"},{"categories":["rust"],"content":" 6.4 match控制流结构 enum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -\u003e u8 { match coin { Coin::Penny =\u003e 1, Coin::Nickel =\u003e 5, Coin::Dime =\u003e 10, Coin::Quarter =\u003e 25, } } ","date":"2023-07-26","objectID":"/rust_basic/:6:4","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#match控制流结构"},{"categories":["rust"],"content":" 6.5 option匹配 fn main() { let x: i32 = 5; let y: Option\u003ci32\u003e = Some(5); let _z = x + y; } 但是此时会编译报错 error[E0277]: cannot add `Option\u003ci32\u003e` to `i32` --\u003e src\\main.rs:4:16 | 4 | let _z = x + y; | ^ no implementation for `i32 + Option\u003ci32\u003e` | = help: the trait `Add\u003cOption\u003ci32\u003e\u003e` is not implemented for `i32` = help: the following other types implement trait `Add\u003cRhs\u003e`: \u003c\u0026'a i32 as Add\u003ci32\u003e\u003e \u003c\u0026i32 as Add\u003c\u0026i32\u003e\u003e \u003ci32 as Add\u003c\u0026i32\u003e\u003e \u003ci32 as Add\u003e fn main() { let x: i32 = 5; let y: Option\u003ci32\u003e = Some(5); let _z = x + y.unwrap(); } ","date":"2023-07-26","objectID":"/rust_basic/:6:5","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#option匹配"},{"categories":["rust"],"content":" 6.6 if let语法糖 fn main() { let v = Some(8); // grammar sugar if let Some(3) = v { println!(\"Succ\"); } else { println!(\"Fail\") } } ","date":"2023-07-26","objectID":"/rust_basic/:6:6","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#if-let语法糖"},{"categories":["rust"],"content":" 7 工程管理 Package(包) Crate(单元包) Moule(模块) Path(路径) ","date":"2023-07-26","objectID":"/rust_basic/:7:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#工程管理"},{"categories":["rust"],"content":" 7.1 Package\u0026Crate # 创建package cargo new package_name ","date":"2023-07-26","objectID":"/rust_basic/:7:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#packagecrate"},{"categories":["rust"],"content":" 8 集合 vector 允许我们一个挨着一个地储存一系列数量可变的值 string 是字符的集合。我们之前见过 String 类型，不过在本章我们将深入了解。 Hashmap 允许我们将值与一个特定的键（key）相关联。这是一个叫做 map 的更通用的数据结构的特定实现。 ","date":"2023-07-26","objectID":"/rust_basic/:8:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#集合"},{"categories":["rust"],"content":" 8.1 Vector 8.1.1 新建 vector fn main() { // 1. 新建vector let _v: Vec\u003ci32\u003e = Vec::new(); // 2. 使用宏来初始化vector let _v = vec![1, 2, 3]; } 8.1.2 更新 vector 对于新建一个 vector 并向其增加元素，可以使用 push 方法，如示例 8-3 所示： fn main() { let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8); } 8.1.3 读取vector的元素 // 直接读取 println!(\"v[0] {}\", v[0]); // 5 println!(\"v[1] {}\", v[1]); // 5 // 引用数据 println!(\"v[0] {}\", \u0026v[0]); // 5 println!(\"v[1] {}\", \u0026v[1]); // 5 // get方法 println!(\"v[0] {:?}\", v.get(0)); // Some(5) println!(\"v[1] {:?}\", v.get(1)); // Some(6) // 遍历方法 for i in \u0026v { println!(\"{}\", i); } ","date":"2023-07-26","objectID":"/rust_basic/:8:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#vector"},{"categories":["rust"],"content":" 8.1 Vector 8.1.1 新建 vector fn main() { // 1. 新建vector let _v: Vec = Vec::new(); // 2. 使用宏来初始化vector let _v = vec![1, 2, 3]; } 8.1.2 更新 vector 对于新建一个 vector 并向其增加元素，可以使用 push 方法，如示例 8-3 所示： fn main() { let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8); } 8.1.3 读取vector的元素 // 直接读取 println!(\"v[0] {}\", v[0]); // 5 println!(\"v[1] {}\", v[1]); // 5 // 引用数据 println!(\"v[0] {}\", \u0026v[0]); // 5 println!(\"v[1] {}\", \u0026v[1]); // 5 // get方法 println!(\"v[0] {:?}\", v.get(0)); // Some(5) println!(\"v[1] {:?}\", v.get(1)); // Some(6) // 遍历方法 for i in \u0026v { println!(\"{}\", i); } ","date":"2023-07-26","objectID":"/rust_basic/:8:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#新建-vector"},{"categories":["rust"],"content":" 8.1 Vector 8.1.1 新建 vector fn main() { // 1. 新建vector let _v: Vec = Vec::new(); // 2. 使用宏来初始化vector let _v = vec![1, 2, 3]; } 8.1.2 更新 vector 对于新建一个 vector 并向其增加元素，可以使用 push 方法，如示例 8-3 所示： fn main() { let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8); } 8.1.3 读取vector的元素 // 直接读取 println!(\"v[0] {}\", v[0]); // 5 println!(\"v[1] {}\", v[1]); // 5 // 引用数据 println!(\"v[0] {}\", \u0026v[0]); // 5 println!(\"v[1] {}\", \u0026v[1]); // 5 // get方法 println!(\"v[0] {:?}\", v.get(0)); // Some(5) println!(\"v[1] {:?}\", v.get(1)); // Some(6) // 遍历方法 for i in \u0026v { println!(\"{}\", i); } ","date":"2023-07-26","objectID":"/rust_basic/:8:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#更新-vector"},{"categories":["rust"],"content":" 8.1 Vector 8.1.1 新建 vector fn main() { // 1. 新建vector let _v: Vec = Vec::new(); // 2. 使用宏来初始化vector let _v = vec![1, 2, 3]; } 8.1.2 更新 vector 对于新建一个 vector 并向其增加元素，可以使用 push 方法，如示例 8-3 所示： fn main() { let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8); } 8.1.3 读取vector的元素 // 直接读取 println!(\"v[0] {}\", v[0]); // 5 println!(\"v[1] {}\", v[1]); // 5 // 引用数据 println!(\"v[0] {}\", \u0026v[0]); // 5 println!(\"v[1] {}\", \u0026v[1]); // 5 // get方法 println!(\"v[0] {:?}\", v.get(0)); // Some(5) println!(\"v[1] {:?}\", v.get(1)); // Some(6) // 遍历方法 for i in \u0026v { println!(\"{}\", i); } ","date":"2023-07-26","objectID":"/rust_basic/:8:1","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#读取vector的元素"},{"categories":["rust"],"content":" 8.2 String 8.2.1 创建字符串 fn main() { // 1.创建字符串 let mut _s = String::new(); // 2.创建空字符串 let data = \"initial contents\"; let _s = data.to_string(); // 该方法也可直接用于字符串字面值： let _s = \"initial contents\".to_string(); // 直接对字符串进行转化 let _s = String::from(\"initial contents\"); } 8.2.2 更新字符串 // 1. 使用 push_str 和 push 附加字符串 let mut s = String::from(\"Hello\"); s.push_str(\"World\"); println!(\"{}\", s); s.push('!'); println!(\"{}\", s); 8.2.3 索引字符串编译报错 let _s1 = String::from(\"hello\"); let h = s1[0]; // error[E0277]: the type `String` cannot be indexed by `{integer} 但是可以直接进行遍历 for c in \"Зд\".chars() { println!(\"{c}\"); } 8.2.4 slice let hello = \"Здравствуйте\"; let s = \u0026hello[0..4]; println!(\"{}\", s); ","date":"2023-07-26","objectID":"/rust_basic/:8:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#string"},{"categories":["rust"],"content":" 8.2 String 8.2.1 创建字符串 fn main() { // 1.创建字符串 let mut _s = String::new(); // 2.创建空字符串 let data = \"initial contents\"; let _s = data.to_string(); // 该方法也可直接用于字符串字面值： let _s = \"initial contents\".to_string(); // 直接对字符串进行转化 let _s = String::from(\"initial contents\"); } 8.2.2 更新字符串 // 1. 使用 push_str 和 push 附加字符串 let mut s = String::from(\"Hello\"); s.push_str(\"World\"); println!(\"{}\", s); s.push('!'); println!(\"{}\", s); 8.2.3 索引字符串编译报错 let _s1 = String::from(\"hello\"); let h = s1[0]; // error[E0277]: the type `String` cannot be indexed by `{integer} 但是可以直接进行遍历 for c in \"Зд\".chars() { println!(\"{c}\"); } 8.2.4 slice let hello = \"Здравствуйте\"; let s = \u0026hello[0..4]; println!(\"{}\", s); ","date":"2023-07-26","objectID":"/rust_basic/:8:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#创建字符串"},{"categories":["rust"],"content":" 8.2 String 8.2.1 创建字符串 fn main() { // 1.创建字符串 let mut _s = String::new(); // 2.创建空字符串 let data = \"initial contents\"; let _s = data.to_string(); // 该方法也可直接用于字符串字面值： let _s = \"initial contents\".to_string(); // 直接对字符串进行转化 let _s = String::from(\"initial contents\"); } 8.2.2 更新字符串 // 1. 使用 push_str 和 push 附加字符串 let mut s = String::from(\"Hello\"); s.push_str(\"World\"); println!(\"{}\", s); s.push('!'); println!(\"{}\", s); 8.2.3 索引字符串编译报错 let _s1 = String::from(\"hello\"); let h = s1[0]; // error[E0277]: the type `String` cannot be indexed by `{integer} 但是可以直接进行遍历 for c in \"Зд\".chars() { println!(\"{c}\"); } 8.2.4 slice let hello = \"Здравствуйте\"; let s = \u0026hello[0..4]; println!(\"{}\", s); ","date":"2023-07-26","objectID":"/rust_basic/:8:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#更新字符串"},{"categories":["rust"],"content":" 8.2 String 8.2.1 创建字符串 fn main() { // 1.创建字符串 let mut _s = String::new(); // 2.创建空字符串 let data = \"initial contents\"; let _s = data.to_string(); // 该方法也可直接用于字符串字面值： let _s = \"initial contents\".to_string(); // 直接对字符串进行转化 let _s = String::from(\"initial contents\"); } 8.2.2 更新字符串 // 1. 使用 push_str 和 push 附加字符串 let mut s = String::from(\"Hello\"); s.push_str(\"World\"); println!(\"{}\", s); s.push('!'); println!(\"{}\", s); 8.2.3 索引字符串编译报错 let _s1 = String::from(\"hello\"); let h = s1[0]; // error[E0277]: the type `String` cannot be indexed by `{integer} 但是可以直接进行遍历 for c in \"Зд\".chars() { println!(\"{c}\"); } 8.2.4 slice let hello = \"Здравствуйте\"; let s = \u0026hello[0..4]; println!(\"{}\", s); ","date":"2023-07-26","objectID":"/rust_basic/:8:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#索引字符串"},{"categories":["rust"],"content":" 8.2 String 8.2.1 创建字符串 fn main() { // 1.创建字符串 let mut _s = String::new(); // 2.创建空字符串 let data = \"initial contents\"; let _s = data.to_string(); // 该方法也可直接用于字符串字面值： let _s = \"initial contents\".to_string(); // 直接对字符串进行转化 let _s = String::from(\"initial contents\"); } 8.2.2 更新字符串 // 1. 使用 push_str 和 push 附加字符串 let mut s = String::from(\"Hello\"); s.push_str(\"World\"); println!(\"{}\", s); s.push('!'); println!(\"{}\", s); 8.2.3 索引字符串编译报错 let _s1 = String::from(\"hello\"); let h = s1[0]; // error[E0277]: the type `String` cannot be indexed by `{integer} 但是可以直接进行遍历 for c in \"Зд\".chars() { println!(\"{c}\"); } 8.2.4 slice let hello = \"Здравствуйте\"; let s = \u0026hello[0..4]; println!(\"{}\", s); ","date":"2023-07-26","objectID":"/rust_basic/:8:2","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#slice"},{"categories":["rust"],"content":" 8.3 Hashmap 最后介绍的常用集合类型是 哈希 map（hash map）。HashMap\u003cK, V\u003e 类型储存了一个键类型 K 对应一个值类型 V 的映射。它通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中 8.3.1 创建hanshmapHashmap不是一个preload的包，需要手动导入 use std::collections::HashMap; let mut scores = HashMap::new(); 8.3.2 访问hashmap的值 let team_name = String::from(\"Blue\"); let score = scores.get(\u0026team_name).copied().unwrap_or(0); println!(\"{}\", score); for (key, value) in \u0026scores { println!(\"{key}: {value}\"); } 8.3.3 更新hashmap scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Blue\"), 25); println!(\"{:?}\", scores); scores.entry(String::from(\"Yellow\")).or_insert(50); scores.entry(String::from(\"Blue\")).or_insert(50); scores.entry(String::from(\"Green\")).or_insert(30); println!(\"{:?}\", scores); ","date":"2023-07-26","objectID":"/rust_basic/:8:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#hashmap"},{"categories":["rust"],"content":" 8.3 Hashmap 最后介绍的常用集合类型是 哈希 map（hash map）。HashMap 类型储存了一个键类型 K 对应一个值类型 V 的映射。它通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中 8.3.1 创建hanshmapHashmap不是一个preload的包，需要手动导入 use std::collections::HashMap; let mut scores = HashMap::new(); 8.3.2 访问hashmap的值 let team_name = String::from(\"Blue\"); let score = scores.get(\u0026team_name).copied().unwrap_or(0); println!(\"{}\", score); for (key, value) in \u0026scores { println!(\"{key}: {value}\"); } 8.3.3 更新hashmap scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Blue\"), 25); println!(\"{:?}\", scores); scores.entry(String::from(\"Yellow\")).or_insert(50); scores.entry(String::from(\"Blue\")).or_insert(50); scores.entry(String::from(\"Green\")).or_insert(30); println!(\"{:?}\", scores); ","date":"2023-07-26","objectID":"/rust_basic/:8:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#创建hanshmap"},{"categories":["rust"],"content":" 8.3 Hashmap 最后介绍的常用集合类型是 哈希 map（hash map）。HashMap 类型储存了一个键类型 K 对应一个值类型 V 的映射。它通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中 8.3.1 创建hanshmapHashmap不是一个preload的包，需要手动导入 use std::collections::HashMap; let mut scores = HashMap::new(); 8.3.2 访问hashmap的值 let team_name = String::from(\"Blue\"); let score = scores.get(\u0026team_name).copied().unwrap_or(0); println!(\"{}\", score); for (key, value) in \u0026scores { println!(\"{key}: {value}\"); } 8.3.3 更新hashmap scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Blue\"), 25); println!(\"{:?}\", scores); scores.entry(String::from(\"Yellow\")).or_insert(50); scores.entry(String::from(\"Blue\")).or_insert(50); scores.entry(String::from(\"Green\")).or_insert(30); println!(\"{:?}\", scores); ","date":"2023-07-26","objectID":"/rust_basic/:8:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#访问hashmap的值"},{"categories":["rust"],"content":" 8.3 Hashmap 最后介绍的常用集合类型是 哈希 map（hash map）。HashMap 类型储存了一个键类型 K 对应一个值类型 V 的映射。它通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中 8.3.1 创建hanshmapHashmap不是一个preload的包，需要手动导入 use std::collections::HashMap; let mut scores = HashMap::new(); 8.3.2 访问hashmap的值 let team_name = String::from(\"Blue\"); let score = scores.get(\u0026team_name).copied().unwrap_or(0); println!(\"{}\", score); for (key, value) in \u0026scores { println!(\"{key}: {value}\"); } 8.3.3 更新hashmap scores.insert(String::from(\"Blue\"), 10); scores.insert(String::from(\"Blue\"), 25); println!(\"{:?}\", scores); scores.entry(String::from(\"Yellow\")).or_insert(50); scores.entry(String::from(\"Blue\")).or_insert(50); scores.entry(String::from(\"Green\")).or_insert(30); println!(\"{:?}\", scores); ","date":"2023-07-26","objectID":"/rust_basic/:8:3","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#更新hashmap"},{"categories":["rust"],"content":" 9 错误处理 9.0.4 panic! 用 panic! 处理不可恢复的错误 fn main() { panic!(\"crash and burn\"); } 执行运行 Compiling error_handle v0.1.0 (D:\\github.io\\static\\demo\\rust\\error_handle) Finished dev [unoptimized + debuginfo] target(s) in 0.86s Running `target\\debug\\error_handle.exe` thread 'main' panicked at 'Hello, world!', src\\main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn't exit successfully: `target\\debug\\error_handle.exe` (exit code: 101) 9.0.5 Result枚举 用Result枚举处理可恢复的错误 enum Result\u003cT, E\u003e { OK(T), Err(E), } T和E是泛型类型参数: T代表成功时返回的Ok成员中的数据的类型, E代表失败时返回的Err成员中的错误的类型 9.0.6 match处理 use std::fs::File; fn main() { // 1. panic! 处理不可以恢复的错误 // 比较类似C/C++的assert语法 // panic!(\"Hello, world!\"); // 2. Result!可以恢复的错误 let f = File::open(\"Heelo.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e { panic!(\"Error opening file {:?}\", error); } }; } 尝试恢复某一错误 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e match error.kind() { ErrorKind::NotFound =\u003e match File::create(\"Hello.txt\") { Ok(fc) =\u003e fc, Err(e) =\u003e panic!(\"Error creating file {:?}\", e), }, oe =\u003e panic!(\"Error opening file {:?}\", oe), }, }; } 此时如果运行此程序就不会显示报错了，并且会创建一个新的文件 使用unwarp执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").unwrap(); } Result 值是成员 Ok，unwrap 会返回 Ok 中的值。 Result 是成员 Err，unwrap 会为我们调用 panic! 使用expect执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").expect(\"无法打开文件\"); } ","date":"2023-07-26","objectID":"/rust_basic/:9:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#错误处理"},{"categories":["rust"],"content":" 9 错误处理 9.0.4 panic! 用 panic! 处理不可恢复的错误 fn main() { panic!(\"crash and burn\"); } 执行运行 Compiling error_handle v0.1.0 (D:\\github.io\\static\\demo\\rust\\error_handle) Finished dev [unoptimized + debuginfo] target(s) in 0.86s Running `target\\debug\\error_handle.exe` thread 'main' panicked at 'Hello, world!', src\\main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn't exit successfully: `target\\debug\\error_handle.exe` (exit code: 101) 9.0.5 Result枚举 用Result枚举处理可恢复的错误 enum Result { OK(T), Err(E), } T和E是泛型类型参数: T代表成功时返回的Ok成员中的数据的类型, E代表失败时返回的Err成员中的错误的类型 9.0.6 match处理 use std::fs::File; fn main() { // 1. panic! 处理不可以恢复的错误 // 比较类似C/C++的assert语法 // panic!(\"Hello, world!\"); // 2. Result!可以恢复的错误 let f = File::open(\"Heelo.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e { panic!(\"Error opening file {:?}\", error); } }; } 尝试恢复某一错误 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e match error.kind() { ErrorKind::NotFound =\u003e match File::create(\"Hello.txt\") { Ok(fc) =\u003e fc, Err(e) =\u003e panic!(\"Error creating file {:?}\", e), }, oe =\u003e panic!(\"Error opening file {:?}\", oe), }, }; } 此时如果运行此程序就不会显示报错了，并且会创建一个新的文件 使用unwarp执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").unwrap(); } Result 值是成员 Ok，unwrap 会返回 Ok 中的值。 Result 是成员 Err，unwrap 会为我们调用 panic! 使用expect执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").expect(\"无法打开文件\"); } ","date":"2023-07-26","objectID":"/rust_basic/:9:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#panic"},{"categories":["rust"],"content":" 9 错误处理 9.0.4 panic! 用 panic! 处理不可恢复的错误 fn main() { panic!(\"crash and burn\"); } 执行运行 Compiling error_handle v0.1.0 (D:\\github.io\\static\\demo\\rust\\error_handle) Finished dev [unoptimized + debuginfo] target(s) in 0.86s Running `target\\debug\\error_handle.exe` thread 'main' panicked at 'Hello, world!', src\\main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn't exit successfully: `target\\debug\\error_handle.exe` (exit code: 101) 9.0.5 Result枚举 用Result枚举处理可恢复的错误 enum Result { OK(T), Err(E), } T和E是泛型类型参数: T代表成功时返回的Ok成员中的数据的类型, E代表失败时返回的Err成员中的错误的类型 9.0.6 match处理 use std::fs::File; fn main() { // 1. panic! 处理不可以恢复的错误 // 比较类似C/C++的assert语法 // panic!(\"Hello, world!\"); // 2. Result!可以恢复的错误 let f = File::open(\"Heelo.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e { panic!(\"Error opening file {:?}\", error); } }; } 尝试恢复某一错误 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e match error.kind() { ErrorKind::NotFound =\u003e match File::create(\"Hello.txt\") { Ok(fc) =\u003e fc, Err(e) =\u003e panic!(\"Error creating file {:?}\", e), }, oe =\u003e panic!(\"Error opening file {:?}\", oe), }, }; } 此时如果运行此程序就不会显示报错了，并且会创建一个新的文件 使用unwarp执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").unwrap(); } Result 值是成员 Ok，unwrap 会返回 Ok 中的值。 Result 是成员 Err，unwrap 会为我们调用 panic! 使用expect执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").expect(\"无法打开文件\"); } ","date":"2023-07-26","objectID":"/rust_basic/:9:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#result枚举"},{"categories":["rust"],"content":" 9 错误处理 9.0.4 panic! 用 panic! 处理不可恢复的错误 fn main() { panic!(\"crash and burn\"); } 执行运行 Compiling error_handle v0.1.0 (D:\\github.io\\static\\demo\\rust\\error_handle) Finished dev [unoptimized + debuginfo] target(s) in 0.86s Running `target\\debug\\error_handle.exe` thread 'main' panicked at 'Hello, world!', src\\main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn't exit successfully: `target\\debug\\error_handle.exe` (exit code: 101) 9.0.5 Result枚举 用Result枚举处理可恢复的错误 enum Result { OK(T), Err(E), } T和E是泛型类型参数: T代表成功时返回的Ok成员中的数据的类型, E代表失败时返回的Err成员中的错误的类型 9.0.6 match处理 use std::fs::File; fn main() { // 1. panic! 处理不可以恢复的错误 // 比较类似C/C++的assert语法 // panic!(\"Hello, world!\"); // 2. Result!可以恢复的错误 let f = File::open(\"Heelo.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e { panic!(\"Error opening file {:?}\", error); } }; } 尝试恢复某一错误 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\"); match f { Ok(file) =\u003e file, Err(error) =\u003e match error.kind() { ErrorKind::NotFound =\u003e match File::create(\"Hello.txt\") { Ok(fc) =\u003e fc, Err(e) =\u003e panic!(\"Error creating file {:?}\", e), }, oe =\u003e panic!(\"Error opening file {:?}\", oe), }, }; } 此时如果运行此程序就不会显示报错了，并且会创建一个新的文件 使用unwarp执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").unwrap(); } Result 值是成员 Ok，unwrap 会返回 Ok 中的值。 Result 是成员 Err，unwrap 会为我们调用 panic! 使用expect执行快捷操作 use std::fs::File; fn main() { let f = File::open(\"Hello.txt\").expect(\"无法打开文件\"); } ","date":"2023-07-26","objectID":"/rust_basic/:9:0","series":null,"tags":["rust"],"title":"rust基础笔记","uri":"/rust_basic/#match处理"},{"categories":["Linux"],"content":"Uboot","date":"2023-03-12","objectID":"/uboot/","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/"},{"categories":["Linux"],"content":"u-boot源码阅读 ","date":"2023-03-12","objectID":"/uboot/:0:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#"},{"categories":["Linux"],"content":" 1 构建源码 # 下载源码 $ git clone git@github.com:Embedfire/ebf_6ull_uboot.git # 清理编译信息 $ make ARCH=arm clean # 配置信息 make ARCH=arm mx6ull_14x14_evk_emmc_defconfig make ARCH=arm mx6ull_14x14_evk_nand_defconfig # 执行编译 make -j$(nproc) ARCH=arm CROSS_COMPILE=arm-none-eabi- ","date":"2023-03-12","objectID":"/uboot/:1:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#构建源码"},{"categories":["Linux"],"content":" 2 功能仿真如果没有开发板的情况下,我们执行执行仿真的时候 # 编译vexpress_ca9 u-boot make ARCH=arm vexpress_ca9x4_defconfig make ARCH=arm CROSS_COMPILE=arm-none-eabi- qemu-system-arm -M vexpress-a9 -kernel u-boot --nographic -m 512M -S -s # 编译内核 make ARCH=arm vexpress_defconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- # 创建sdcard.img dd if=/dev/zero of=sdcard.img bs=1024 count=102400 mkfs.fat sdcard.img mount -o loop sdcard.img /mnt cp zImage vexpress-v2p-ca9.dtb /mnt umount /mnt # 设置tftp启动 $ qemu-system-arm -M vexpress-a9 -m 256M -kernel u-boot -sd sdcard.img -nographic =\u003e mmcinfo =\u003e load mmc 0:0 0x60008000 zImage =\u003e load mmc 0:0 0x61000000 vexpress-v2p-ca9.dtb =\u003e setenv bootargs \"root=/dev/mmcblk0 rw console=ttyAMA0\" =\u003e bootz 0x60008000 - 0x61000000 # 启动程序 $ qemu-system-arm -M vexpress-a9 -m 256M -kernel u-boot -sd sdcard.img -nographic =\u003e mmcinfo =\u003e load mmc 0:0 0x60008000 zImage =\u003e load mmc 0:0 0x61000000 vexpress-v2p-ca9.dtb =\u003e setenv bootargs \"root=/dev/mmcblk0 rw console=ttyAMA0\" =\u003e bootz 0x60008000 - 0x61000000 # u-boot脚本 mkimage -C none -A arm -T script -d boot.cmd boot.scr $ qemu-system-arm -M vexpress-a9 -m 256M -kernel u-boot -sd sdcard.img -nographic =\u003e load mmc 0:0 0x62000000 boot.scr =\u003e source 0x62000000 # 多分区1 dd if=/dev/zero of=sdcard.img bs=1024 count=102400 fdisk sdcard.img # 简单起见这里只分一个区 losetup -f # 查询可用的块设备地址, 记下来如 /dev/loop16 losetup -P /dev/loop16 sdcard.img # 关联块设备 lsblk # 可以看到块设备已经关联, 并且看到分区信息 mkfs.fat /dev/loop16p1 # 格式化第一分区 mount /dev/loop16p1 /mnt # 挂载块设备的第一分区 cp boot.scr zImage vexpress-v2p-ca9.dtb /mnt # 复制到 第一分区 umount /mnt # 卸载设备 # 多分区的实现2 parted sdcard.img # u-boot打包 mkimage -A arm -C none -O linux -T kernel -d zImage -a 0x00010000 -e 0x00010000 zImage.uimg mkimage -A arm -C none -O linux -T ramdisk -d rootfs.img.gz -a 0x00800000 -e 0x00800000 rootfs.uimg dd if=/dev/zero of=flash.bin bs=1 count=6M dd if=u-boot.bin of=flash.bin conv=notrunc bs=1 dd if=zImage.uimg of=flash.bin conv=notrunc bs=1 seek=2M dd if=rootfs.uimg of=flash.bin conv=notrunc bs=1 seek=4M qemu-system-arm -M vexpress-a9 -device loader,file=flash.bin,addr=0x60800000,cpu-num=0,force-raw=on -nographic make qemu_arm_defconfig make ARCH=arm CROSS_COMPILE=arm-none-eabi- qemu-system-arm -machine virt -nographic -bios u-boot.bin make qemu_arm64_defconfig make ARCH=arm CROSS_COMPILE=aarch64-linux-gnu- qemu-system-aarch64 -machine virt -nographic -cpu cortex-a57 -bios u-boot.bin ","date":"2023-03-12","objectID":"/uboot/:2:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#功能仿真"},{"categories":["Linux"],"content":" 3 全局参数DECLARE_GLOBAL_DATA_PTR // 声明全局数据 DECLARE_GLOBAL_DATA_PTR; #ifdef CONFIG_ARM64 #define DECLARE_GLOBAL_DATA_PTR register volatile gd_t *gd asm (\"x18\") #else #define DECLARE_GLOBAL_DATA_PTR register volatile gd_t *gd asm (\"r9\") #endif #endif typedef struct global_data gd_t; 我们可以看出下面的数据基本上每一个架构各有一个 这个数据结构真是不小 struct global_data { /** * @bd: board information */ struct bd_info *bd; /** * @flags: global data flags * * See \u0026enum gd_flags */ unsigned long flags; /** * @baudrate: baud rate of the serial interface */ unsigned int baudrate; /** * @cpu_clk: CPU clock rate in Hz */ unsigned long cpu_clk; /** * @bus_clk: platform clock rate in Hz */ unsigned long bus_clk; /** * @pci_clk: PCI clock rate in Hz */ /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */ unsigned long pci_clk; /** * @mem_clk: memory clock rate in Hz */ unsigned long mem_clk; #if CONFIG_IS_ENABLED(VIDEO) /** * @fb_base: base address of frame buffer memory */ unsigned long fb_base; #endif #if defined(CONFIG_POST) /** * @post_log_word: active POST tests * * @post_log_word is a bit mask defining which POST tests are recorded * (see constants POST_*). */ unsigned long post_log_word; /** * @post_log_res: POST results * * @post_log_res is a bit mask with the POST results. A bit with value 1 * indicates successful execution. */ unsigned long post_log_res; /** * @post_init_f_time: time in ms when post_init_f() started */ unsigned long post_init_f_time; #endif #ifdef CONFIG_BOARD_TYPES /** * @board_type: board type * * If a U-Boot configuration supports multiple board types, the actual * board type may be stored in this field. */ unsigned long board_type; #endif /** * @have_console: console is available * * A value of 1 indicates that serial_init() was called and a console * is available. * A value of 0 indicates that console input and output drivers shall * not be called. */ unsigned long have_console; #if CONFIG_IS_ENABLED(PRE_CONSOLE_BUFFER) /** * @precon_buf_idx: pre-console buffer index * * @precon_buf_idx indicates the current position of the * buffer used to collect output before the console becomes * available. When negative, the pre-console buffer is * temporarily disabled (used when the pre-console buffer is * being written out, to prevent adding its contents to * itself). */ long precon_buf_idx; #endif /** * @env_addr: address of environment structure * * @env_addr contains the address of the structure holding the * environment variables. */ unsigned long env_addr; /** * @env_valid: environment is valid * * See \u0026enum env_valid */ unsigned long env_valid; /** * @env_has_init: bit mask indicating environment locations * * \u0026enum env_location defines which bit relates to which location */ unsigned long env_has_init; /** * @env_load_prio: priority of the loaded environment */ int env_load_prio; /** * @ram_base: base address of RAM used by U-Boot */ unsigned long ram_base; /** * @ram_top: top address of RAM used by U-Boot */ phys_addr_t ram_top; /** * @relocaddr: start address of U-Boot in RAM * * After relocation this field indicates the address to which U-Boot * has been relocated. It can be displayed using the bdinfo command. * Its value is needed to display the source code when debugging with * GDB using the 'add-symbol-file u-boot \u003crelocaddr\u003e' command. */ unsigned long relocaddr; /** * @ram_size: RAM size in bytes */ phys_size_t ram_size; /** * @mon_len: monitor length in bytes */ unsigned long mon_len; /** * @irq_sp: IRQ stack pointer */ unsigned long irq_sp; /** * @start_addr_sp: initial stack pointer address */ unsigned long start_addr_sp; /** * @reloc_off: relocation offset */ unsigned long reloc_off; /** * @new_gd: pointer to relocated global data */ struct global_data *new_gd; #ifdef CONFIG_DM /** * @dm_root: root instance for Driver Model */ struct udevice *dm_root; /** * @dm_root_f: pre-relocation root instance */ struct udevice *dm_root_f; /** * @uclass_root_s: * head of core tree when uclasses are not in read-only memory. * * When uclasses ","date":"2023-03-12","objectID":"/uboot/:3:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#全局参数"},{"categories":["Linux"],"content":" 4 辅助程序 #define SYMBOL_NAME(X) X #define ENTRY(name) \\ .globl SYMBOL_NAME(name) ASM_NL \\ LENTRY(name) #ifndef END #define END(name) \\ .size name, .-name #endif #ifndef ENDPROC #define ENDPROC(name) \\ .type name STT_FUNC ASM_NL \\ END(name) #endif ","date":"2023-03-12","objectID":"/uboot/:4:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#辅助程序"},{"categories":["Linux"],"content":" 5 启动前夕","date":"2023-03-12","objectID":"/uboot/:5:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#启动前夕"},{"categories":["Linux"],"content":" 5.1 分析头实现 $ arm-non-eabi-objdump -S u-boot \u003e u-boot.S ","date":"2023-03-12","objectID":"/uboot/:5:1","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#分析头实现"},{"categories":["Linux"],"content":" 5.2 中断向量表 .macro ARM_VECTORS #ifdef CONFIG_ARCH_K3 ldr pc, _reset #else b reset #endif #if !CONFIG_IS_ENABLED(SYS_NO_VECTOR_TABLE) ldr pc, _undefined_instruction ldr pc, _software_interrupt ldr pc, _prefetch_abort ldr pc, _data_abort ldr pc, _not_used ldr pc, _irq ldr pc, _fiq #endif .endm graph LR reset --\u003e _main _main --\u003e board_init_r board_init_r --\u003e initcall_run_list initcall_run_list --\u003e run_main_loop run_main_loop --\u003e main_loop [arch/arm/cpu/armv7/start.S] .globl reset .globl save_boot_params_ret reset: /* Allow the board to save important registers */ b save_boot_params save_boot_params_ret: /* * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode, * except if in HYP mode already */ mrs r0, cpsr and r1, r0, #0x1f @ mask mode bits teq r1, #0x1a @ test for HYP mode bicne r0, r0, #0x1f @ clear all mode bits orrne r0, r0, #0x13 @ set SVC mode orr r0, r0, #0xc0 @ disable FIQ and IRQ msr cpsr,r0 /* * Setup vector: * (OMAP4 spl TEXT_BASE is not 32 byte aligned. * Continue to use ROM code vector only in OMAP4 spl) */ #if !(defined(CONFIG_OMAP44XX) \u0026\u0026 defined(CONFIG_SPL_BUILD)) /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */ mrc p15, 0, r0, c1, c0, 0 @ Read CP15 SCTLR Register bic r0, #CR_V @ V = 0 mcr p15, 0, r0, c1, c0, 0 @ Write CP15 SCTLR Register /* Set vector address in CP15 VBAR register */ ldr r0, =_start mcr p15, 0, r0, c12, c0, 0 @Set VBAR #endif /* the mask ROM code should have PLL and others stable */ #ifndef CONFIG_SKIP_LOWLEVEL_INIT bl cpu_init_cp15 bl cpu_init_crit #endif bl _main ","date":"2023-03-12","objectID":"/uboot/:5:2","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#中断向量表"},{"categories":["Linux"],"content":" 5.3 save_boot_params函数实现 此函数什么也没有做 WEAK(save_boot_params) b save_boot_params_ret @ back to my caller ENDPROC(save_boot_params) ","date":"2023-03-12","objectID":"/uboot/:5:3","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#save_boot_params函数实现"},{"categories":["Linux"],"content":" 5.4 进入svc32模式 下面进入设置SVC32模式,并且关闭FIQ and IRQ /* * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode, * except if in HYP mode already */ mrs r0, cpsr and r1, r0, #0x1f @ mask mode bits teq r1, #0x1a @ test for HYP mode bicne r0, r0, #0x1f @ clear all mode bits orrne r0, r0, #0x13 @ set SVC mode orr r0, r0, #0xc0 @ disable FIQ and IRQ msr cpsr,r0 ","date":"2023-03-12","objectID":"/uboot/:5:4","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#进入svc32模式"},{"categories":["Linux"],"content":" 5.5 设置中断向量表_start标号指向 中断向量表 /* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */ mrc p15, 0, r0, c1, c0, 0 @ Read CP15 SCTLR Register bic r0, #CR_V @ V = 0 mcr p15, 0, r0, c1, c0, 0 @ Write CP15 SCTLR Register ldr r0, =_start mcr p15, 0, r0, c12, c0, 0 @Set VBAR ","date":"2023-03-12","objectID":"/uboot/:5:5","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#设置中断向量表"},{"categories":["Linux"],"content":" 5.6 cpu_init_cp15函数 ENTRY(cpu_init_cp15) #if CONFIG_IS_ENABLED(ARMV7_SET_CORTEX_SMPEN) /* * The Arm Cortex-A7 TRM says this bit must be enabled before * \"any cache or TLB maintenance operations are performed\". */ mrc p15, 0, r0, c1, c0, 1 @ read auxilary control register orr r0, r0, #1 \u003c\u003c 6 @ set SMP bit to enable coherency mcr p15, 0, r0, c1, c0, 1 @ write auxilary control register #endif /* * Invalidate L1 I/D */ mov r0, #0 @ set up for MCR mcr p15, 0, r0, c8, c7, 0 @ invalidate TLBs mcr p15, 0, r0, c7, c5, 0 @ invalidate icache mcr p15, 0, r0, c7, c5, 6 @ invalidate BP array dsb isb /* * disable MMU stuff and caches */ mrc p15, 0, r0, c1, c0, 0 bic r0, r0, #0x00002000 @ clear bits 13 (--V-) bic r0, r0, #0x00000007 @ clear bits 2:0 (-CAM) orr r0, r0, #0x00000002 @ set bit 1 (--A-) Align orr r0, r0, #0x00000800 @ set bit 11 (Z---) BTB #if CONFIG_IS_ENABLED(SYS_ICACHE_OFF) bic r0, r0, #0x00001000 @ clear bit 12 (I) I-cache #else orr r0, r0, #0x00001000 @ set bit 12 (I) I-cache #endif mcr p15, 0, r0, c1, c0, 0 #ifdef CONFIG_ARM_ERRATA_716044 mrc p15, 0, r0, c1, c0, 0 @ read system control register orr r0, r0, #1 \u003c\u003c 11 @ set bit #11 mcr p15, 0, r0, c1, c0, 0 @ write system control register #endif #if (defined(CONFIG_ARM_ERRATA_742230) || defined(CONFIG_ARM_ERRATA_794072)) mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 \u003c\u003c 4 @ set bit #4 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register #endif #ifdef CONFIG_ARM_ERRATA_743622 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 \u003c\u003c 6 @ set bit #6 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register #endif #ifdef CONFIG_ARM_ERRATA_751472 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 \u003c\u003c 11 @ set bit #11 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register #endif #ifdef CONFIG_ARM_ERRATA_761320 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 \u003c\u003c 21 @ set bit #21 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register #endif #ifdef CONFIG_ARM_ERRATA_845369 mrc p15, 0, r0, c15, c0, 1 @ read diagnostic register orr r0, r0, #1 \u003c\u003c 22 @ set bit #22 mcr p15, 0, r0, c15, c0, 1 @ write diagnostic register #endif mov r5, lr @ Store my Caller mrc p15, 0, r1, c0, c0, 0 @ r1 has Read Main ID Register (MIDR) mov r3, r1, lsr #20 @ get variant field and r3, r3, #0xf @ r3 has CPU variant and r4, r1, #0xf @ r4 has CPU revision mov r2, r3, lsl #4 @ shift variant field for combined value orr r2, r4, r2 @ r2 has combined CPU variant + revision /* Early stack for ERRATA that needs into call C code */ #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK) ldr r0, =(CONFIG_SPL_STACK) #else ldr r0, =(SYS_INIT_SP_ADDR) #endif bic r0, r0, #7 /* 8-byte alignment for ABI compliance */ mov sp, r0 #ifdef CONFIG_ARM_ERRATA_798870 cmp r2, #0x30 @ Applies to lower than R3p0 bge skip_errata_798870 @ skip if not affected rev cmp r2, #0x20 @ Applies to including and above R2p0 blt skip_errata_798870 @ skip if not affected rev mrc p15, 1, r0, c15, c0, 0 @ read l2 aux ctrl reg orr r0, r0, #1 \u003c\u003c 7 @ Enable hazard-detect timeout push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_l2aux_ctrl isb @ Recommended ISB after l2actlr update pop {r1-r5} @ Restore the cpu info - fall through skip_errata_798870: #endif #ifdef CONFIG_ARM_ERRATA_801819 cmp r2, #0x24 @ Applies to lt including R2p4 bgt skip_errata_801819 @ skip if not affected rev cmp r2, #0x20 @ Applies to including and above R2p0 blt skip_errata_801819 @ skip if not affected rev mrc p15, 0, r0, c0, c0, 6 @ pick up REVIDR reg and r0, r0, #1 \u003c\u003c 3 @ check REVIDR[3] cmp r0, #1 \u003c\u003c 3 beq skip_errata_801819 @ skip erratum if REVIDR[3] is set mrc p15, 0, r0, c1, c0, 1 @ read auxilary control register orr r0, r0, #3 \u003c\u003c 27 @ Disables streaming. All write-allocate @ lines allocate in the L1 or L2 cache. orr r0, r0, #3 \u003c\u003c 25 @ Disables streaming. All write-allocate @ lines allocate in the L1 cache. push {r1-r5} @ Save the cpu info registers bl v7_arch_cp15_set_acr pop {r1-r5} @ Re","date":"2023-03-12","objectID":"/uboot/:5:6","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#cpu_init_cp15函数"},{"categories":["Linux"],"content":" 5.7 cpu_init_crit函数 ENTRY(cpu_init_crit) /* * Jump to board specific initialization... * The Mask ROM will have already initialized * basic memory. Go here to bump up clock rate and handle * wake up conditions. */ b lowlevel_init @ go setup pll,mux,memory ENDPROC(cpu_init_crit) ","date":"2023-03-12","objectID":"/uboot/:5:7","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#cpu_init_crit函数"},{"categories":["Linux"],"content":" 5.8 lowlevel_init功能初始化进入了board/armltd/vexpress/vexpress_common.c 函数为空 void lowlevel_init(void) { } ","date":"2023-03-12","objectID":"/uboot/:5:8","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#lowlevel_init功能初始化"},{"categories":["Linux"],"content":" 5.9 C语言初始化[arch/arm/lib/crt0_64.S] ENTRY(_main) /* * Set up initial C runtime environment and call board_init_f(0). */ #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK) ldr sp, =(CONFIG_SPL_STACK) #else ldr sp, =(CONFIG_SYS_INIT_SP_ADDR) #endif #if defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination */ mov r3, sp bic r3, r3, #7 mov sp, r3 #else bic sp, sp, #7 /* 8-byte alignment for ABI compliance */ #endif mov r0, sp bl board_init_f_alloc_reserve mov sp, r0 /* set up gd here, outside any C code */ mov r9, r0 bl board_init_f_init_reserve mov r0, #0 bl board_init_f #if ! defined(CONFIG_SPL_BUILD) /* * Set up intermediate environment (new sp and gd) and call * relocate_code(addr_moni). Trick here is that we'll return * 'here' but relocated. */ ldr sp, [r9, #GD_START_ADDR_SP] /* sp = gd-\u003estart_addr_sp */ #if defined(CONFIG_CPU_V7M) /* v7M forbids using SP as BIC destination */ mov r3, sp bic r3, r3, #7 mov sp, r3 #else bic sp, sp, #7 /* 8-byte alignment for ABI compliance */ #endif ldr r9, [r9, #GD_BD] /* r9 = gd-\u003ebd */ sub r9, r9, #GD_SIZE /* new GD is below bd */ adr lr, here ldr r0, [r9, #GD_RELOC_OFF] /* r0 = gd-\u003ereloc_off */ add lr, lr, r0 #if defined(CONFIG_CPU_V7M) orr lr, #1 /* As required by Thumb-only */ #endif ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ b relocate_code here: /* * now relocate vectors */ bl relocate_vectors /* Set up final (full) environment */ bl c_runtime_cpu_setup /* we still call old routine here */ #endif #if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK) # ifdef CONFIG_SPL_BUILD /* Use a DRAM stack for the rest of SPL, if requested */ bl spl_relocate_stack_gd cmp r0, #0 movne sp, r0 movne r9, r0 # endif ldr r0, =__bss_start /* this is auto-relocated! */ #ifdef CONFIG_USE_ARCH_MEMSET ldr r3, =__bss_end /* this is auto-relocated! */ mov r1, #0x00000000 /* prepare zero to clear BSS */ subs r2, r3, r0 /* r2 = memset len */ bl memset #else ldr r1, =__bss_end /* this is auto-relocated! */ mov r2, #0x00000000 /* prepare zero to clear BSS */ clbss_l:cmp r0, r1 /* while not at end of BSS */ #if defined(CONFIG_CPU_V7M) itt lo #endif strlo r2, [r0] /* clear 32-bit BSS word */ addlo r0, r0, #4 /* move to next */ blo clbss_l #endif #if ! defined(CONFIG_SPL_BUILD) bl coloured_LED_init bl red_led_on #endif /* call board_init_r(gd_t *id, ulong dest_addr) */ mov r0, r9 /* gd_t */ ldr r1, [r9, #GD_RELOCADDR] /* dest_addr */ /* call board_init_r */ #if defined(CONFIG_SYS_THUMB_BUILD) ldr lr, =board_init_r /* this is auto-relocated! */ bx lr #else ldr pc, =board_init_r /* this is auto-relocated! */ #endif /* we should not return here. */ #endif ENDPROC(_main) ","date":"2023-03-12","objectID":"/uboot/:5:9","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#c语言初始化"},{"categories":["Linux"],"content":" 5.10 board_init_f函数 进入此文件common/board_f.c void board_init_f(ulong boot_flags) { gd-\u003eflags = boot_flags; gd-\u003ehave_console = 0; if (initcall_run_list(init_sequence_f)) hang(); #if !defined(CONFIG_ARM) \u0026\u0026 !defined(CONFIG_SANDBOX) \u0026\u0026 \\ !defined(CONFIG_EFI_APP) \u0026\u0026 !CONFIG_IS_ENABLED(X86_64) \u0026\u0026 \\ !defined(CONFIG_ARC) /* NOTREACHED - jump_to_copy() does not return */ hang(); #endif } ","date":"2023-03-12","objectID":"/uboot/:5:10","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#board_init_f函数"},{"categories":["Linux"],"content":" 5.11 board_init_r函数 void board_init_r(gd_t *new_gd, ulong dest_addr) { /* * The pre-relocation drivers may be using memory that has now gone * away. Mark serial as unavailable - this will fall back to the debug * UART if available. * * Do the same with log drivers since the memory may not be available. */ gd-\u003eflags \u0026= ~(GD_FLG_SERIAL_READY | GD_FLG_LOG_READY); /* * Set up the new global data pointer. So far only x86 does this * here. * TODO(sjg@chromium.org): Consider doing this for all archs, or * dropping the new_gd parameter. */ if (CONFIG_IS_ENABLED(X86_64) \u0026\u0026 !IS_ENABLED(CONFIG_EFI_APP)) arch_setup_gd(new_gd); #if !defined(CONFIG_X86) \u0026\u0026 !defined(CONFIG_ARM) \u0026\u0026 !defined(CONFIG_ARM64) gd = new_gd; #endif gd-\u003eflags \u0026= ~GD_FLG_LOG_READY; if (IS_ENABLED(CONFIG_NEEDS_MANUAL_RELOC)) { for (int i = 0; i \u003c ARRAY_SIZE(init_sequence_r); i++) MANUAL_RELOC(init_sequence_r[i]); } if (initcall_run_list(init_sequence_r)) hang(); /* NOTREACHED - run_main_loop() does not return */ hang(); } ","date":"2023-03-12","objectID":"/uboot/:5:11","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#board_init_r函数"},{"categories":["Linux"],"content":" 5.12 initcall_run_list 进入初始化列表 typedef int (*init_fnc_t)(void); static inline int initcall_run_list(const init_fnc_t init_sequence[]) { const init_fnc_t *init_fnc_ptr; for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) { unsigned long reloc_ofs = 0; int ret; /* * Sandbox is relocated by the OS, so symbols always appear at * the relocated address. */ if (IS_ENABLED(CONFIG_SANDBOX) || (gd-\u003eflags \u0026 GD_FLG_RELOC)) reloc_ofs = gd-\u003ereloc_off; #ifdef CONFIG_EFI_APP reloc_ofs = (unsigned long)image_base; #endif if (reloc_ofs) debug(\"initcall: %p (relocated to %p)\\n\", (char *)*init_fnc_ptr - reloc_ofs, (char *)*init_fnc_ptr); else debug(\"initcall: %p\\n\", (char *)*init_fnc_ptr - reloc_ofs); ret = (*init_fnc_ptr)(); if (ret) { printf(\"initcall sequence %p failed at call %p (err=%d)\\n\", init_sequence, (char *)*init_fnc_ptr - reloc_ofs, ret); return -1; } } return 0; } [arch/arm/cpu/armv8/start.S] .globl _start _start: b reset reset: #ifdef CONFIG_SYS_RESET_SCTRL bl reset_sctrl #endif /* * Could be EL3/EL2/EL1, Initial State: * Little Endian, MMU Disabled, i/dCache Disabled */ adr x0, vectors switch_el x1, 3f, 2f, 1f 3: msr vbar_el3, x0 mrs x0, scr_el3 orr x0, x0, #0xf /* SCR_EL3.NS|IRQ|FIQ|EA */ msr scr_el3, x0 msr cptr_el3, xzr /* Enable FP/SIMD */ #ifdef COUNTER_FREQUENCY ldr x0, =COUNTER_FREQUENCY msr cntfrq_el0, x0 /* Initialize CNTFRQ */ #endif b 0f 2: msr vbar_el2, x0 mov x0, #0x33ff msr cptr_el2, x0 /* Enable FP/SIMD */ b 0f 1: msr vbar_el1, x0 mov x0, #3 \u003c\u003c 20 msr cpacr_el1, x0 /* Enable FP/SIMD */ 0: /* Apply ARM core specific erratas */ bl apply_core_errata /* * Cache/BPB/TLB Invalidate * i-cache is invalidated before enabled in icache_enable() * tlb is invalidated before mmu is enabled in dcache_enable() * d-cache is invalidated before enabled in dcache_enable() */ /* Processor specific initialization */ bl lowlevel_init #ifdef CONFIG_ARMV8_MULTIENTRY branch_if_master x0, x1, master_cpu /* * Slave CPUs */ slave_cpu: wfe ldr x1, =CPU_RELEASE_ADDR ldr x0, [x1] cbz x0, slave_cpu br x0 /* branch to the given address */ master_cpu: /* On the master CPU */ #endif /* CONFIG_ARMV8_MULTIENTRY */ bl _main [arch/arm/lib/crt0_64.S] ENTRY(_main) /* * Set up initial C runtime environment and call board_init_f(0). */ #if defined(CONFIG_SPL_BUILD) \u0026\u0026 defined(CONFIG_SPL_STACK) ldr x0, =(CONFIG_SPL_STACK) #else ldr x0, =(CONFIG_SYS_INIT_SP_ADDR) #endif bic sp, x0, #0xf /* 16-byte alignment for ABI compliance */ mov x0, sp bl board_init_f_alloc_reserve mov sp, x0 /* set up gd here, outside any C code */ mov x18, x0 bl board_init_f_init_reserve mov x0, #0 bl board_init_f #if !defined(CONFIG_SPL_BUILD) /* * Set up intermediate environment (new sp and gd) and call * relocate_code(addr_moni). Trick here is that we'll return * 'here' but relocated. */ ldr x0, [x18, #GD_START_ADDR_SP] /* x0 \u003c- gd-\u003estart_addr_sp */ bic sp, x0, #0xf /* 16-byte alignment for ABI compliance */ ldr x18, [x18, #GD_BD] /* x18 \u003c- gd-\u003ebd */ sub x18, x18, #GD_SIZE /* new GD is below bd */ adr lr, relocation_return ldr x9, [x18, #GD_RELOC_OFF] /* x9 \u003c- gd-\u003ereloc_off */ add lr, lr, x9 /* new return address after relocation */ ldr x0, [x18, #GD_RELOCADDR] /* x0 \u003c- gd-\u003erelocaddr */ b relocate_code relocation_return: /* * Set up final (full) environment */ bl c_runtime_cpu_setup /* still call old routine */ /* TODO: For SPL, call spl_relocate_stack_gd() to alloc stack relocation */ /* * Clear BSS section */ ldr x0, =__bss_start /* this is auto-relocated! */ ldr x1, =__bss_end /* this is auto-relocated! */ mov x2, #0 clear_loop: str x2, [x0] add x0, x0, #8 cmp x0, x1 b.lo clear_loop /* call board_init_r(gd_t *id, ulong dest_addr) */ mov x0, x18 /* gd_t */ ldr x1, [x18, #GD_RELOCADDR] /* dest_addr */ b board_init_r /* PC relative jump */ /* NOTREACHED - board_init_r() does not return */ #endif /* !CONFIG_SPL_BUILD */ ENDPROC(_main) 无论32位还是64位最后进入board_init_r实现,分析实现; void board_init_r(gd_t *new_gd, ulong dest_addr) { #ifdef CONFIG_NEEDS_MANUAL_RELOC int i; #endif #ifdef ","date":"2023-03-12","objectID":"/uboot/:5:12","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#initcall_run_list"},{"categories":["Linux"],"content":" 5.13 DDR初始化","date":"2023-03-12","objectID":"/uboot/:5:13","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#ddr初始化"},{"categories":["Linux"],"content":" 5.14 UART初始化","date":"2023-03-12","objectID":"/uboot/:5:14","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#uart初始化"},{"categories":["Linux"],"content":" 5.15 代码重定位 编译时添加-fpie选项 链接添加pie选项 生成段名，用来修正代码位置 char __bss_start[0] __section(\".__bss_start\"); char __bss_end[0] __section(\".__bss_end\"); char __image_copy_start[0] __section(\".__image_copy_start\"); char __image_copy_end[0] __section(\".__image_copy_end\"); char __rel_dyn_start[0] __section(\".__rel_dyn_start\"); char __rel_dyn_end[0] __section(\".__rel_dyn_end\"); char __secure_start[0] __section(\".__secure_start\"); char __secure_end[0] __section(\".__secure_end\"); char __secure_stack_start[0] __section(\".__secure_stack_start\"); char __secure_stack_end[0] __section(\".__secure_stack_end\"); char __efi_runtime_start[0] __section(\".__efi_runtime_start\"); char __efi_runtime_stop[0] __section(\".__efi_runtime_stop\"); char __efi_runtime_rel_start[0] __section(\".__efi_runtime_rel_start\"); char __efi_runtime_rel_stop[0] __section(\".__efi_runtime_rel_stop\"); char _end[0] __section(\".__end\"); 5.15.1 relocate_code函数 进入arch/arm/lib/relocate.S 这个函数执行结束之后，后面的代码没法正常的跟踪gdb运行了 是否存在特殊的手段实现呢？ https://elixir.bootlin.com/u-boot/latest/source/arch/arm/lib/relocate.S#L79 指定-pie后编译生成的uboot中就会有一个rel.dyn段，uboot就是靠rel.dyn段实现了完美的relocation！ ENTRY(relocate_code) relocate_base: adr r3, relocate_base /* R3 = relocate_base - pc */ ldr r1, _image_copy_start_ofs /* R1 = _image_copy_start_ofs */ add r1, r3 /* r1 \u003c- Run \u0026__image_copy_start */ subs r4, r0, r1 /* r4 \u003c- Run to copy offset */ beq relocate_done /* skip relocation */ ldr r1, _image_copy_start_ofs add r1, r3 /* r1 \u003c- Run \u0026__image_copy_start */ ldr r2, _image_copy_end_ofs add r2, r3 /* r2 \u003c- Run \u0026__image_copy_end */ copy_loop: ldmia r1!, {r10-r11} /* copy from source address [r1] */ stmia r0!, {r10-r11} /* copy to target address [r0] */ cmp r1, r2 /* until source end address [r2] */ blo copy_loop /* * fix .rel.dyn relocations */ ldr r1, _rel_dyn_start_ofs add r2, r1, r3 /* r2 \u003c- Run \u0026__rel_dyn_start */ ldr r1, _rel_dyn_end_ofs add r3, r1, r3 /* r3 \u003c- Run \u0026__rel_dyn_end */ fixloop: ldmia r2!, {r0-r1} /* (r0,r1) \u003c- (SRC location,fixup) */ and r1, r1, #0xff cmp r1, #R_ARM_RELATIVE bne fixnext /* relative fix: increase location by offset */ add r0, r0, r4 ldr r1, [r0] add r1, r1, r4 str r1, [r0] fixnext: cmp r2, r3 blo fixloop relocate_done: ret lr /* set pc */ ENDPROC(relocate_code) _image_copy_start_ofs: .word __image_copy_start - relocate_code _image_copy_end_ofs: .word __image_copy_end - relocate_code _rel_dyn_start_ofs: .word __rel_dyn_start - relocate_code _rel_dyn_end_ofs: .word __rel_dyn_end - relocate_code 代码解析: (TODO) 那么代码现在运行到何处了呢？ 在进入代码搬移之前 ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ b relocate_code 5.15.2 relocate_vectors函数 迁移向量表 .section .text.relocate_vectors,\"ax\",%progbits WEAK(relocate_vectors) #ifdef CONFIG_CPU_V7M /* * On ARMv7-M we only have to write the new vector address * to VTOR register. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ ldr r1, =V7M_SCB_BASE str r0, [r1, V7M_SCB_VTOR] #else #ifdef CONFIG_HAS_VBAR /* * If the ARM processor has the security extensions, * use VBAR to relocate the exception vectors. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ mcr p15, 0, r0, c12, c0, 0 /* Set VBAR */ #else /* * Copy the relocated exception vectors to the * correct address * CP15 c1 V bit gives us the location of the vectors: * 0x00000000 or 0xFFFF0000. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ mrc p15, 0, r2, c1, c0, 0 /* V bit (bit[13]) in CP15 c1 */ ands r2, r2, #(1 \u003c\u003c 13) ldreq r1, =0x00000000 /* If V=0 */ ldrne r1, =0xFFFF0000 /* If V=1 */ ldmia r0!, {r2-r8,r10} stmia r1!, {r2-r8,r10} ldmia r0!, {r2-r8,r10} stmia r1!, {r2-r8,r10} #endif #endif ret lr ENDPROC(relocate_vectors) ","date":"2023-03-12","objectID":"/uboot/:5:15","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#代码重定位"},{"categories":["Linux"],"content":" 5.15 代码重定位 编译时添加-fpie选项 链接添加pie选项 生成段名，用来修正代码位置 char __bss_start[0] __section(\".__bss_start\"); char __bss_end[0] __section(\".__bss_end\"); char __image_copy_start[0] __section(\".__image_copy_start\"); char __image_copy_end[0] __section(\".__image_copy_end\"); char __rel_dyn_start[0] __section(\".__rel_dyn_start\"); char __rel_dyn_end[0] __section(\".__rel_dyn_end\"); char __secure_start[0] __section(\".__secure_start\"); char __secure_end[0] __section(\".__secure_end\"); char __secure_stack_start[0] __section(\".__secure_stack_start\"); char __secure_stack_end[0] __section(\".__secure_stack_end\"); char __efi_runtime_start[0] __section(\".__efi_runtime_start\"); char __efi_runtime_stop[0] __section(\".__efi_runtime_stop\"); char __efi_runtime_rel_start[0] __section(\".__efi_runtime_rel_start\"); char __efi_runtime_rel_stop[0] __section(\".__efi_runtime_rel_stop\"); char _end[0] __section(\".__end\"); 5.15.1 relocate_code函数 进入arch/arm/lib/relocate.S 这个函数执行结束之后，后面的代码没法正常的跟踪gdb运行了 是否存在特殊的手段实现呢？ https://elixir.bootlin.com/u-boot/latest/source/arch/arm/lib/relocate.S#L79 指定-pie后编译生成的uboot中就会有一个rel.dyn段，uboot就是靠rel.dyn段实现了完美的relocation！ ENTRY(relocate_code) relocate_base: adr r3, relocate_base /* R3 = relocate_base - pc */ ldr r1, _image_copy_start_ofs /* R1 = _image_copy_start_ofs */ add r1, r3 /* r1 \u003c- Run \u0026__image_copy_start */ subs r4, r0, r1 /* r4 \u003c- Run to copy offset */ beq relocate_done /* skip relocation */ ldr r1, _image_copy_start_ofs add r1, r3 /* r1 \u003c- Run \u0026__image_copy_start */ ldr r2, _image_copy_end_ofs add r2, r3 /* r2 \u003c- Run \u0026__image_copy_end */ copy_loop: ldmia r1!, {r10-r11} /* copy from source address [r1] */ stmia r0!, {r10-r11} /* copy to target address [r0] */ cmp r1, r2 /* until source end address [r2] */ blo copy_loop /* * fix .rel.dyn relocations */ ldr r1, _rel_dyn_start_ofs add r2, r1, r3 /* r2 \u003c- Run \u0026__rel_dyn_start */ ldr r1, _rel_dyn_end_ofs add r3, r1, r3 /* r3 \u003c- Run \u0026__rel_dyn_end */ fixloop: ldmia r2!, {r0-r1} /* (r0,r1) \u003c- (SRC location,fixup) */ and r1, r1, #0xff cmp r1, #R_ARM_RELATIVE bne fixnext /* relative fix: increase location by offset */ add r0, r0, r4 ldr r1, [r0] add r1, r1, r4 str r1, [r0] fixnext: cmp r2, r3 blo fixloop relocate_done: ret lr /* set pc */ ENDPROC(relocate_code) _image_copy_start_ofs: .word __image_copy_start - relocate_code _image_copy_end_ofs: .word __image_copy_end - relocate_code _rel_dyn_start_ofs: .word __rel_dyn_start - relocate_code _rel_dyn_end_ofs: .word __rel_dyn_end - relocate_code 代码解析: (TODO) 那么代码现在运行到何处了呢？ 在进入代码搬移之前 ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ b relocate_code 5.15.2 relocate_vectors函数 迁移向量表 .section .text.relocate_vectors,\"ax\",%progbits WEAK(relocate_vectors) #ifdef CONFIG_CPU_V7M /* * On ARMv7-M we only have to write the new vector address * to VTOR register. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ ldr r1, =V7M_SCB_BASE str r0, [r1, V7M_SCB_VTOR] #else #ifdef CONFIG_HAS_VBAR /* * If the ARM processor has the security extensions, * use VBAR to relocate the exception vectors. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ mcr p15, 0, r0, c12, c0, 0 /* Set VBAR */ #else /* * Copy the relocated exception vectors to the * correct address * CP15 c1 V bit gives us the location of the vectors: * 0x00000000 or 0xFFFF0000. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ mrc p15, 0, r2, c1, c0, 0 /* V bit (bit[13]) in CP15 c1 */ ands r2, r2, #(1 \u003c\u003c 13) ldreq r1, =0x00000000 /* If V=0 */ ldrne r1, =0xFFFF0000 /* If V=1 */ ldmia r0!, {r2-r8,r10} stmia r1!, {r2-r8,r10} ldmia r0!, {r2-r8,r10} stmia r1!, {r2-r8,r10} #endif #endif ret lr ENDPROC(relocate_vectors) ","date":"2023-03-12","objectID":"/uboot/:5:15","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#relocate_code函数"},{"categories":["Linux"],"content":" 5.15 代码重定位 编译时添加-fpie选项 链接添加pie选项 生成段名，用来修正代码位置 char __bss_start[0] __section(\".__bss_start\"); char __bss_end[0] __section(\".__bss_end\"); char __image_copy_start[0] __section(\".__image_copy_start\"); char __image_copy_end[0] __section(\".__image_copy_end\"); char __rel_dyn_start[0] __section(\".__rel_dyn_start\"); char __rel_dyn_end[0] __section(\".__rel_dyn_end\"); char __secure_start[0] __section(\".__secure_start\"); char __secure_end[0] __section(\".__secure_end\"); char __secure_stack_start[0] __section(\".__secure_stack_start\"); char __secure_stack_end[0] __section(\".__secure_stack_end\"); char __efi_runtime_start[0] __section(\".__efi_runtime_start\"); char __efi_runtime_stop[0] __section(\".__efi_runtime_stop\"); char __efi_runtime_rel_start[0] __section(\".__efi_runtime_rel_start\"); char __efi_runtime_rel_stop[0] __section(\".__efi_runtime_rel_stop\"); char _end[0] __section(\".__end\"); 5.15.1 relocate_code函数 进入arch/arm/lib/relocate.S 这个函数执行结束之后，后面的代码没法正常的跟踪gdb运行了 是否存在特殊的手段实现呢？ https://elixir.bootlin.com/u-boot/latest/source/arch/arm/lib/relocate.S#L79 指定-pie后编译生成的uboot中就会有一个rel.dyn段，uboot就是靠rel.dyn段实现了完美的relocation！ ENTRY(relocate_code) relocate_base: adr r3, relocate_base /* R3 = relocate_base - pc */ ldr r1, _image_copy_start_ofs /* R1 = _image_copy_start_ofs */ add r1, r3 /* r1 \u003c- Run \u0026__image_copy_start */ subs r4, r0, r1 /* r4 \u003c- Run to copy offset */ beq relocate_done /* skip relocation */ ldr r1, _image_copy_start_ofs add r1, r3 /* r1 \u003c- Run \u0026__image_copy_start */ ldr r2, _image_copy_end_ofs add r2, r3 /* r2 \u003c- Run \u0026__image_copy_end */ copy_loop: ldmia r1!, {r10-r11} /* copy from source address [r1] */ stmia r0!, {r10-r11} /* copy to target address [r0] */ cmp r1, r2 /* until source end address [r2] */ blo copy_loop /* * fix .rel.dyn relocations */ ldr r1, _rel_dyn_start_ofs add r2, r1, r3 /* r2 \u003c- Run \u0026__rel_dyn_start */ ldr r1, _rel_dyn_end_ofs add r3, r1, r3 /* r3 \u003c- Run \u0026__rel_dyn_end */ fixloop: ldmia r2!, {r0-r1} /* (r0,r1) \u003c- (SRC location,fixup) */ and r1, r1, #0xff cmp r1, #R_ARM_RELATIVE bne fixnext /* relative fix: increase location by offset */ add r0, r0, r4 ldr r1, [r0] add r1, r1, r4 str r1, [r0] fixnext: cmp r2, r3 blo fixloop relocate_done: ret lr /* set pc */ ENDPROC(relocate_code) _image_copy_start_ofs: .word __image_copy_start - relocate_code _image_copy_end_ofs: .word __image_copy_end - relocate_code _rel_dyn_start_ofs: .word __rel_dyn_start - relocate_code _rel_dyn_end_ofs: .word __rel_dyn_end - relocate_code 代码解析: (TODO) 那么代码现在运行到何处了呢？ 在进入代码搬移之前 ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ b relocate_code 5.15.2 relocate_vectors函数 迁移向量表 .section .text.relocate_vectors,\"ax\",%progbits WEAK(relocate_vectors) #ifdef CONFIG_CPU_V7M /* * On ARMv7-M we only have to write the new vector address * to VTOR register. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ ldr r1, =V7M_SCB_BASE str r0, [r1, V7M_SCB_VTOR] #else #ifdef CONFIG_HAS_VBAR /* * If the ARM processor has the security extensions, * use VBAR to relocate the exception vectors. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ mcr p15, 0, r0, c12, c0, 0 /* Set VBAR */ #else /* * Copy the relocated exception vectors to the * correct address * CP15 c1 V bit gives us the location of the vectors: * 0x00000000 or 0xFFFF0000. */ ldr r0, [r9, #GD_RELOCADDR] /* r0 = gd-\u003erelocaddr */ mrc p15, 0, r2, c1, c0, 0 /* V bit (bit[13]) in CP15 c1 */ ands r2, r2, #(1 \u003c\u003c 13) ldreq r1, =0x00000000 /* If V=0 */ ldrne r1, =0xFFFF0000 /* If V=1 */ ldmia r0!, {r2-r8,r10} stmia r1!, {r2-r8,r10} ldmia r0!, {r2-r8,r10} stmia r1!, {r2-r8,r10} #endif #endif ret lr ENDPROC(relocate_vectors) ","date":"2023-03-12","objectID":"/uboot/:5:15","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#relocate_vectors函数"},{"categories":["Linux"],"content":" 5.16 c_runtime_cpu_setup","date":"2023-03-12","objectID":"/uboot/:5:16","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#c_runtime_cpu_setup"},{"categories":["Linux"],"content":" 6 命令实现以version命令作为例子 #define U_BOOT_VERSION_STRING U_BOOT_VERSION \" (\" U_BOOT_DATE \" - \" \\ U_BOOT_TIME \" \" U_BOOT_TZ \")\" CONFIG_IDENT_STRING const char version_string[] = U_BOOT_VERSION_STRING; const unsigned short version_num = U_BOOT_VERSION_NUM; const unsigned char version_num_patch = U_BOOT_VERSION_NUM_PATCH; static int do_version(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) { char buf[DISPLAY_OPTIONS_BANNER_LENGTH]; printf(display_options_get_banner(false, buf, sizeof(buf))); #ifdef CC_VERSION_STRING puts(CC_VERSION_STRING \"\\n\"); #endif #ifdef LD_VERSION_STRING puts(LD_VERSION_STRING \"\\n\"); #endif #ifdef CONFIG_SYS_COREBOOT printf(\"coreboot-%s (%s)\\n\", lib_sysinfo.version, lib_sysinfo.build); #endif return 0; } U_BOOT_CMD( version, 1, 1, do_version, \"print monitor, compiler and linker version\", \"\" ); 展开U_BOOT_CMD #define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help) \\ U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL) #define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \\ ll_entry_declare(struct cmd_tbl, _name, cmd) = \\ U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd, \\ _usage, _help, _comp); cli_loop –\u003e parse_file_outer –\u003e ","date":"2023-03-12","objectID":"/uboot/:6:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#命令实现"},{"categories":["Linux"],"content":" 7 启动实现","date":"2023-03-12","objectID":"/uboot/:7:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#启动实现"},{"categories":["Linux"],"content":" 7.1 main_loopgraph TD main_loop --\u003e bootstage_mark_name bootstage_mark_name --\u003e bootdelay_process bootdelay_process --\u003e autoboot_command autoboot_command --\u003e run_command_list ","date":"2023-03-12","objectID":"/uboot/:7:1","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#main_loop"},{"categories":["Linux"],"content":" 7.2 do_bootm int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) { #ifdef CONFIG_NEEDS_MANUAL_RELOC static int relocated = 0; if (!relocated) { int i; /* relocate names of sub-command table */ for (i = 0; i \u003c ARRAY_SIZE(cmd_bootm_sub); i++) cmd_bootm_sub[i].name += gd-\u003ereloc_off; relocated = 1; } #endif /* determine if we have a sub command */ argc--; argv++; if (argc \u003e 0) { char *endp; simple_strtoul(argv[0], \u0026endp, 16); /* endp pointing to NULL means that argv[0] was just a * valid number, pass it along to the normal bootm processing * * If endp is ':' or '#' assume a FIT identifier so pass * along for normal processing. * * Right now we assume the first arg should never be '-' */ if ((*endp != 0) \u0026\u0026 (*endp != ':') \u0026\u0026 (*endp != '#')) return do_bootm_subcommand(cmdtp, flag, argc, argv); } #ifdef CONFIG_SECURE_BOOT extern uint32_t authenticate_image( uint32_t ddr_start, uint32_t image_size); switch (genimg_get_format((const void *)load_addr)) { #if defined(CONFIG_IMAGE_FORMAT_LEGACY) case IMAGE_FORMAT_LEGACY: if (authenticate_image(load_addr, image_get_image_size((image_header_t *)load_addr)) == 0) { printf(\"Authenticate uImage Fail, Please check\\n\"); return 1; } break; #endif #ifdef CONFIG_ANDROID_BOOT_IMAGE case IMAGE_FORMAT_ANDROID: /* Do this authentication in boota command */ break; #endif default: printf(\"Not valid image format for Authentication, Please check\\n\"); return 1; } #endif return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START | BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER | BOOTM_STATE_LOADOS | #if defined(CONFIG_PPC) || defined(CONFIG_MIPS) BOOTM_STATE_OS_CMDLINE | #endif BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO, \u0026images, 1); } ","date":"2023-03-12","objectID":"/uboot/:7:2","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#do_bootm"},{"categories":["Linux"],"content":" 7.3 boot_jump_linux static void boot_jump_linux(bootm_headers_t *images, int flag) { #ifdef CONFIG_ARM64 void (*kernel_entry)(void *fdt_addr, void *res0, void *res1, void *res2); int fake = (flag \u0026 BOOTM_STATE_OS_FAKE_GO); kernel_entry = (void (*)(void *fdt_addr, void *res0, void *res1, void *res2))images-\u003eep; debug(\"## Transferring control to Linux (at address %lx)...\\n\", (ulong) kernel_entry); bootstage_mark(BOOTSTAGE_ID_RUN_OS); announce_and_cleanup(fake); if (!fake) { do_nonsec_virt_switch(); kernel_entry(images-\u003eft_addr, NULL, NULL, NULL); } #else unsigned long machid = gd-\u003ebd-\u003ebi_arch_number; char *s; void (*kernel_entry)(int zero, int arch, uint params); unsigned long r2; int fake = (flag \u0026 BOOTM_STATE_OS_FAKE_GO); kernel_entry = (void (*)(int, int, uint))images-\u003eep; s = getenv(\"machid\"); if (s) { if (strict_strtoul(s, 16, \u0026machid) \u003c 0) { debug(\"strict_strtoul failed!\\n\"); return; } printf(\"Using machid 0x%lx from environment\\n\", machid); } debug(\"## Transferring control to Linux (at address %08lx)\" \\ \"...\\n\", (ulong) kernel_entry); bootstage_mark(BOOTSTAGE_ID_RUN_OS); announce_and_cleanup(fake); if (IMAGE_ENABLE_OF_LIBFDT \u0026\u0026 images-\u003eft_len) r2 = (unsigned long)images-\u003eft_addr; else r2 = gd-\u003ebd-\u003ebi_boot_params; if (!fake) { #ifdef CONFIG_ARMV7_NONSEC if (armv7_boot_nonsec()) { armv7_init_nonsec(); secure_ram_addr(_do_nonsec_entry)(kernel_entry, 0, machid, r2); } else #endif kernel_entry(0, machid, r2); } #endif } ","date":"2023-03-12","objectID":"/uboot/:7:3","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#boot_jump_linux"},{"categories":["Linux"],"content":" 8 环境变量 初始化功能 获取变量env_get 设置变量env_set char *env_get(const char *name) { if (gd-\u003eflags \u0026 GD_FLG_ENV_READY) { /* after import into hashtable */ struct env_entry e, *ep; schedule(); e.key = name; e.data = NULL; hsearch_r(e, ENV_FIND, \u0026ep, \u0026env_htab, 0); return ep ? ep-\u003edata : NULL; } /* restricted capabilities before import */ if (env_get_f(name, (char *)(gd-\u003eenv_buf), sizeof(gd-\u003eenv_buf)) \u003e= 0) return (char *)(gd-\u003eenv_buf); return NULL; } int env_set(const char *varname, const char *varvalue) { const char * const argv[4] = { \"setenv\", varname, varvalue, NULL }; /* before import into hashtable */ if (!(gd-\u003eflags \u0026 GD_FLG_ENV_READY)) return 1; if (varvalue == NULL || varvalue[0] == '\\0') return _do_env_set(0, 2, (char * const *)argv, H_PROGRAMMATIC); else return _do_env_set(0, 3, (char * const *)argv, H_PROGRAMMATIC); } ","date":"2023-03-12","objectID":"/uboot/:8:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#环境变量"},{"categories":["Linux"],"content":" 9 加载内核 static void do_nonsec_virt_switch(void) { smp_kick_all_cpus(); dcache_disable(); /* flush cache before swtiching to EL2 */ armv8_switch_to_el2(); #ifdef CONFIG_ARMV8_SWITCH_TO_EL1 armv8_switch_to_el1(); #endif } ENTRY(armv8_switch_to_el2) switch_el x0, 1f, 0f, 0f 0: ret 1: armv8_switch_to_el2_m x0 ENDPROC(armv8_switch_to_el2) ENTRY(armv8_switch_to_el1) switch_el x0, 0f, 1f, 0f 0: ret 1: armv8_switch_to_el1_m x0, x1 ENDPROC(armv8_switch_to_el1) .macro armv8_switch_to_el2_m, xreg1 /* 64bit EL2 | HCE | SMD | RES1 (Bits[5:4]) | Non-secure EL0/EL1 */ mov \\xreg1, #0x5b1 msr scr_el3, \\xreg1 msr cptr_el3, xzr /* Disable coprocessor traps to EL3 */ mov \\xreg1, #0x33ff msr cptr_el2, \\xreg1 /* Disable coprocessor traps to EL2 */ /* Initialize Generic Timers */ msr cntvoff_el2, xzr /* Initialize SCTLR_EL2 * * setting RES1 bits (29,28,23,22,18,16,11,5,4) to 1 * and RES0 bits (31,30,27,26,24,21,20,17,15-13,10-6) + * EE,WXN,I,SA,C,A,M to 0 */ mov \\xreg1, #0x0830 movk \\xreg1, #0x30C5, lsl #16 msr sctlr_el2, \\xreg1 /* Return to the EL2_SP2 mode from EL3 */ mov \\xreg1, sp msr sp_el2, \\xreg1 /* Migrate SP */ mrs \\xreg1, vbar_el3 msr vbar_el2, \\xreg1 /* Migrate VBAR */ mov \\xreg1, #0x3c9 msr spsr_el3, \\xreg1 /* EL2_SP2 | D | A | I | F */ msr elr_el3, lr eret .endm ","date":"2023-03-12","objectID":"/uboot/:9:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#加载内核"},{"categories":["Linux"],"content":" 10 设备树解析","date":"2023-03-12","objectID":"/uboot/:10:0","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#设备树解析"},{"categories":["Linux"],"content":" 10.1 加载设备树设备树地址会设置到gd-\u003efdt_blob变量中，设置方法如下 graph LR fdtdec_setup --\u003e fdtdec_prepare_fdt fdtdec_prepare_fdt --\u003e fdtdec_board_setup fdtdec_board_setup --\u003e reserve_fdt reserve_fdt --\u003e reloc_fdt int fdtdec_setup(void) { int ret; /* The devicetree is typically appended to U-Boot */ if (IS_ENABLED(CONFIG_OF_SEPARATE)) { gd-\u003efdt_blob = fdt_find_separate(); gd-\u003efdt_src = FDTSRC_SEPARATE; } else { /* embed dtb in ELF file for testing / development */ gd-\u003efdt_blob = dtb_dt_embedded(); gd-\u003efdt_src = FDTSRC_EMBED; } /* Allow the board to override the fdt address. */ if (IS_ENABLED(CONFIG_OF_BOARD)) { gd-\u003efdt_blob = board_fdt_blob_setup(\u0026ret); if (ret) return ret; gd-\u003efdt_src = FDTSRC_BOARD; } /* Allow the early environment to override the fdt address */ if (!IS_ENABLED(CONFIG_SPL_BUILD)) { ulong addr; addr = env_get_hex(\"fdtcontroladdr\", 0); if (addr) { gd-\u003efdt_blob = map_sysmem(addr, 0); gd-\u003efdt_src = FDTSRC_ENV; } } if (CONFIG_IS_ENABLED(MULTI_DTB_FIT)) setup_multi_dtb_fit(); ret = fdtdec_prepare_fdt(gd-\u003efdt_blob); if (!ret) ret = fdtdec_board_setup(gd-\u003efdt_blob); oftree_reset(); return ret; } 预留地址空间 static int reserve_fdt(void) { if (!IS_ENABLED(CONFIG_OF_EMBED)) { /* * If the device tree is sitting immediately above our image * then we must relocate it. If it is embedded in the data * section, then it will be relocated with other data. */ if (gd-\u003efdt_blob) { gd-\u003efdt_size = ALIGN(fdt_totalsize(gd-\u003efdt_blob), 32); gd-\u003estart_addr_sp = reserve_stack_aligned(gd-\u003efdt_size); gd-\u003enew_fdt = map_sysmem(gd-\u003estart_addr_sp, gd-\u003efdt_size); debug(\"Reserving %lu Bytes for FDT at: %08lx\\n\", gd-\u003efdt_size, gd-\u003estart_addr_sp); } } return 0; } 重新设置fdt static int reloc_fdt(void) { if (!IS_ENABLED(CONFIG_OF_EMBED)) { if (gd-\u003enew_fdt) { memcpy(gd-\u003enew_fdt, gd-\u003efdt_blob, fdt_totalsize(gd-\u003efdt_blob)); gd-\u003efdt_blob = gd-\u003enew_fdt; } } return 0; } ","date":"2023-03-12","objectID":"/uboot/:10:1","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#加载设备树"},{"categories":["Linux"],"content":" 10.2 设备树解析 解析接口定义在libfdt文件夹下面 int fdt_path_offset(const void *fdt, const char *path); const char *fdt_get_name(const void *fdt, int nodeoffset, int *lenp); ","date":"2023-03-12","objectID":"/uboot/:10:2","series":["boot"],"tags":["uboot"],"title":"Uboot","uri":"/uboot/#设备树解析-1"},{"categories":["Linux Kernel"],"content":"Linux内核源码阅读","date":"2023-02-12","objectID":"/read_linux/","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/"},{"categories":["Linux Kernel"],"content":"内核源码阅读 源码版本: Linux 4.0.0 参考书籍: « 奔跑吧Linux内核 » « 深度探索linux系统虚拟化:原理与实现 » ","date":"2023-02-12","objectID":"/read_linux/:0:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#"},{"categories":["Linux Kernel"],"content":" 1 建立环境","date":"2023-02-12","objectID":"/read_linux/:1:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#建立环境"},{"categories":["Linux Kernel"],"content":" 1.1 崩溃内核参考文档 1.1.1 安装拯救内核下载内核稳定版,修改构建脚本为了和主线内核区分即可 修改配置脚本config CONFIG_DEBUG_INFO=y CONFIG_CRASH_DUMP=y CONFIG_PROC_VMCORE=y 构建此内核 # 更新校验值 updpkgsums # 构建内核 makepkg -s --skippgpcheck # 安装程序 修改/etc/default/grub,为crash kernel配置空间 - GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7\" + GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7 crashkernel=256M@16M\" 更新grub配置grub-mkconfig 1.1.2 启动kdump服务 /etc/systemd/system/kdump.service [Unit] Description=Load dump capture kernel After=local-fs.target [Service] ExecStart=/usr/bin/kexec -p [/boot/vmlinuz-linux-kdump] --initrd=[/boot/initramfs-linux-kdump.img] --append=\"root=[root-device] single irqpoll maxcpus=1 reset_devices\" Type=oneshot [Install] WantedBy=multi-user.target ","date":"2023-02-12","objectID":"/read_linux/:1:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#崩溃内核"},{"categories":["Linux Kernel"],"content":" 1.1 崩溃内核参考文档 1.1.1 安装拯救内核下载内核稳定版,修改构建脚本为了和主线内核区分即可 修改配置脚本config CONFIG_DEBUG_INFO=y CONFIG_CRASH_DUMP=y CONFIG_PROC_VMCORE=y 构建此内核 # 更新校验值 updpkgsums # 构建内核 makepkg -s --skippgpcheck # 安装程序 修改/etc/default/grub,为crash kernel配置空间 - GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7\" + GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7 crashkernel=256M@16M\" 更新grub配置grub-mkconfig 1.1.2 启动kdump服务 /etc/systemd/system/kdump.service [Unit] Description=Load dump capture kernel After=local-fs.target [Service] ExecStart=/usr/bin/kexec -p [/boot/vmlinuz-linux-kdump] --initrd=[/boot/initramfs-linux-kdump.img] --append=\"root=[root-device] single irqpoll maxcpus=1 reset_devices\" Type=oneshot [Install] WantedBy=multi-user.target ","date":"2023-02-12","objectID":"/read_linux/:1:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#安装拯救内核"},{"categories":["Linux Kernel"],"content":" 1.1 崩溃内核参考文档 1.1.1 安装拯救内核下载内核稳定版,修改构建脚本为了和主线内核区分即可 修改配置脚本config CONFIG_DEBUG_INFO=y CONFIG_CRASH_DUMP=y CONFIG_PROC_VMCORE=y 构建此内核 # 更新校验值 updpkgsums # 构建内核 makepkg -s --skippgpcheck # 安装程序 修改/etc/default/grub,为crash kernel配置空间 - GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7\" + GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7 crashkernel=256M@16M\" 更新grub配置grub-mkconfig 1.1.2 启动kdump服务 /etc/systemd/system/kdump.service [Unit] Description=Load dump capture kernel After=local-fs.target [Service] ExecStart=/usr/bin/kexec -p [/boot/vmlinuz-linux-kdump] --initrd=[/boot/initramfs-linux-kdump.img] --append=\"root=[root-device] single irqpoll maxcpus=1 reset_devices\" Type=oneshot [Install] WantedBy=multi-user.target ","date":"2023-02-12","objectID":"/read_linux/:1:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#启动kdump服务"},{"categories":["Linux Kernel"],"content":" 1.2 基础环境 安装软件 $ sudo apt install qemu $ sudo apt install gcc-arm-none-eabi 下载源码 $ git clone https://github.com/figozhang/runninglinuxkernel_4.0.git 构建运行 编译32位arm qemu-system-arm -m 1024 -M virt\\ -nographic -smp 4 -kernel arch/arm/boot/zImage \\ -append \"crashkernel=128M root=/dev/vda rootfstype=ext4 rw\"\\ -drive if=none,file=rootfs_debian_arm32.ext4,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ -netdev user,id=mynet\\ -device virtio-net-device,netdev=mynet\\ --fsdev local,id=kmod_dev,path=./kmodules,security_model=none\\ -device virtio-9p-device,fsdev=kmod_dev,mount_tag=kmod_mount\\ -S -s 编译64位arm qemu-system-aarch64 -m 1024 -cpu cortex-a57 -M virt\\ -nographic -smp 4 -kernel arch/arm64/boot/Image \\ -append \"noinintrd root=/dev/vda rootfstype=ext4 rw loglevel=8\" \\ -drive if=none,file=rootfs_debian_arm64.ext4,id=hd0 \\ -device virtio-blk-device,drive=hd0 \\ --fsdev local,id=kmod_dev,path=./kmodules,security_model=none \\ -device virtio-9p-device,fsdev=kmod_dev,mount_tag=kmod_mount\\ -netdev user,id=mynet\\ -device virtio-net-device,netdev=mynet\\ -S -s 安装gdb-multiarch 参考资料:Archlinux gdb-multiarch构建 # 下载代码 git clone --branch gdb-13-branch https://sourceware.org/git/binutils-gdb.git # 执行构建 mkdir build \u0026\u0026 cd build ../configure \\ --enable-targets=all \\ --prefix=/build \\ --enable-languages=all \\ --enable-multilib \\ --enable-interwork \\ --with-system-readline \\ --disable-nls \\ --with-python=/usr/bin/python \\ --with-system-gdbinit=/etc/gdb/gdbinit make -j`nproc` make install # 修改文件名 mv /usr/bin/gdb /usr/bin/gdb-multiarch 运行gdb-multiarch # 加载执行文件 $ file vmlinux # 设置架构 $ set architecture arm # 远程连接 $ target remote localhost:1234 ","date":"2023-02-12","objectID":"/read_linux/:1:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#基础环境"},{"categories":["Linux Kernel"],"content":" 1.3 调试环境(eclipse) 安装eclipse 安装jdk $ sudo apt update $ sudo apt install default-jre 下载eclipse C/C++ 配置调试 ","date":"2023-02-12","objectID":"/read_linux/:1:3","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#调试环境eclipse"},{"categories":["Linux Kernel"],"content":" 1.4 调试环境(vscode)当然vscode也是相当好用的,作为调试程序 在当前工程中添加配置文件launch.json { \"configurations\": [ { \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"Linux Gdb Server\", \"program\": \"${workspaceRoot}/vmlinux\", \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb-multiarch\", \"miDebuggerServerAddress\": \"localhost:1234\", \"cwd\": \"${workspaceRoot}\", \"externalConsole\": false } ] } 安装调试器 yay -S gdb-multiarch 启动调试器 ","date":"2023-02-12","objectID":"/read_linux/:1:4","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#调试环境vscode"},{"categories":["Linux Kernel"],"content":" 1.5 调试环境(原始gdb) 安装gdbgui # 安装 pip install gdbgui # 设计 pip install --upgrade gdbgui # 卸载 $ pip uninstall gdbgui 运行gdbgui gdbgui -g arm-multiarch ","date":"2023-02-12","objectID":"/read_linux/:1:5","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#调试环境原始gdb"},{"categories":["Linux Kernel"],"content":" 2 系统构建镜像文件的整体过程 构建vmlinux,objcopy生成vmlinux.bin,然后将其压缩为vmlinux.bin.gz 添加操作,生成vmlinux.bin 构造setup.bin 将setup.bin与vmlinux.bin进行合成,生成bzImage ","date":"2023-02-12","objectID":"/read_linux/:2:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#系统构建"},{"categories":["Linux Kernel"],"content":" 2.1 vmlinux生成过程 # x86_64架构链接过程 ld -m elf_x86_64 --no-ld-generated-unwind-info -pie --no-dynamic-linker --orphan-handling=error -z noexecstack --no-warn-rwx-segments -T arch/x86/boot/compressed/vmlinux.lds arch/x86/boot/compressed/kernel_info.o arch/x86/boot/compressed/head_64.o arch/x86/boot/compressed/misc.o arch/x86/boot/compressed/string.o arch/x86/boot/compressed/cmdline.o arch/x86/boot/compressed/error.o arch/x86/boot/compressed/piggy.o arch/x86/boot/compressed/cpuflags.o arch/x86/boot/compressed/early_serial_console.o arch/x86/boot/compressed/kaslr.o arch/x86/boot/compressed/ident_map_64.o arch/x86/boot/compressed/idt_64.o arch/x86/boot/compressed/idt_handlers_64.o arch/x86/boot/compressed/pgtable_64.o arch/x86/boot/compressed/acpi.o arch/x86/boot/compressed/efi.o arch/x86/boot/compressed/efi_mixed.o drivers/firmware/efi/libstub/lib.a -o arch/x86/boot/compressed/vmlinux # arm32链接过程 ","date":"2023-02-12","objectID":"/read_linux/:2:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#vmlinux生成过程"},{"categories":["Linux Kernel"],"content":" 2.2 vmlinux.bin生成过程 objcopy -O binary -R .note -R .comment -S arch/x86/boot/compressed/vmlinux arch/x86/boot/vmlinux.bin ","date":"2023-02-12","objectID":"/read_linux/:2:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#vmlinuxbin生成过程"},{"categories":["Linux Kernel"],"content":" 2.3 header.o gcc -Wp,-MMD,arch/x86/boot/.header.o.d -nostdinc -I./arch/x86/include -I./arch/x86/include/generated -I./include -I./arch/x86/include/uapi -I./arch/x86/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/compiler-version.h -include ./include/linux/kconfig.h -D__KERNEL__ -Werror -fmacro-prefix-map=./= -m16 -g -Os -DDISABLE_BRANCH_PROFILING -D__DISABLE_EXPORTS -Wall -Wstrict-prototypes -march=i386 -mregparm=3 -fno-strict-aliasing -fomit-frame-pointer -fno-pic -mno-mmx -mno-sse -fcf-protection=none -ffreestanding -fno-stack-protector -Wno-address-of-packed-member -mpreferred-stack-boundary=2 -D_SETUP -D__ASSEMBLY__ -DSVGA_MODE=NORMAL_VGA -I./arch/x86/boot -c -o arch/x86/boot/header.o arch/x86/boot/header.S ","date":"2023-02-12","objectID":"/read_linux/:2:3","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#headero"},{"categories":["Linux Kernel"],"content":" 2.4 setup.bin生成过程 ld -m elf_x86_64 -z noexecstack --no-warn-rwx-segments -m elf_i386 -z noexecstack -T arch/x86/boot/setup.ld arch/x86/boot/a20.o arch/x86/boot/bioscall.o arch/x86/boot/cmdline.o arch/x86/boot/copy.o arch/x86/boot/cpu.o arch/x86/boot/cpuflags.o arch/x86/boot/cpucheck.o arch/x86/boot/early_serial_console.o arch/x86/boot/edd.o arch/x86/boot/header.o arch/x86/boot/main.o arch/x86/boot/memory.o arch/x86/boot/pm.o arch/x86/boot/pmjump.o arch/x86/boot/printf.o arch/x86/boot/regs.o arch/x86/boot/string.o arch/x86/boot/tty.o arch/x86/boot/video.o arch/x86/boot/video-mode.o arch/x86/boot/version.o arch/x86/boot/video-vga.o arch/x86/boot/video-vesa.o arch/x86/boot/video-bios.o -o arch/x86/boot/setup.elf objcopy -O binary arch/x86/boot/setup.elf arch/x86/boot/setup.bin ","date":"2023-02-12","objectID":"/read_linux/:2:4","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#setupbin生成过程"},{"categories":["Linux Kernel"],"content":" 2.5 最后生成 arch/x86/boot/tools/build arch/x86/boot/setup.bin arch/x86/boot/vmlinux.bin arch/x86/boot/zoffset.h arch/x86/boot/bzImag ","date":"2023-02-12","objectID":"/read_linux/:2:5","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#最后生成"},{"categories":["Linux Kernel"],"content":" 3 根文件系统linux系统在启动之后需要加载根文件系统 ","date":"2023-02-12","objectID":"/read_linux/:3:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#根文件系统"},{"categories":["Linux Kernel"],"content":" 3.1 编译busybox","date":"2023-02-12","objectID":"/read_linux/:3:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#编译busybox"},{"categories":["Linux Kernel"],"content":" 3.2 安装C库从交叉编译器中拷贝即可 ","date":"2023-02-12","objectID":"/read_linux/:3:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#安装c库"},{"categories":["Linux Kernel"],"content":" 4 initramfs","date":"2023-02-12","objectID":"/read_linux/:4:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#initramfs"},{"categories":["Linux Kernel"],"content":" 4.1 Hello initramfs #include \u003cstdio.h\u003e void main(int argc, char *argv[]) { printf(\"Hello initramfs\\n\"); fflush(stdout); while(1); } 执行构建 gcc -static -o init init.c echo init | cpio -o --format=newc \u003e initramfs 启动测试 qemu-system-x86_64 -kernel linux/arch/x86_64/boot/bzImage -initrd initramfs -append \"console=ttyS0 rdinit=init\" -nographic 然后就可以发现打印的数据 ","date":"2023-02-12","objectID":"/read_linux/:4:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#hello-initramfs"},{"categories":["Linux Kernel"],"content":" 5 启动分析一般情况下，我们都会讲断点打在start_kernel上,但是在进入C语言之前会存在一段汇编代码; 入口地址,我们可以通过链接脚本分析得到 链接头文件,那么真正的链接文件在**[arch/arm/kernel/vmlinux.lds]**,但是这个文件是生成的; 这个链接脚本用来描述vmlinux的生成 但是aarch64入口地址就是 graph LR stext --\u003e __mmap_switched __mmap_switched --\u003e start_kernel ","date":"2023-02-12","objectID":"/read_linux/:5:0","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#启动分析"},{"categories":["Linux Kernel"],"content":" 5.1 启动前夕启动前夕(ARM32) __mmap_switched: adr r3, __mmap_switched_data ldmia r3!, {r4, r5, r6, r7} cmp r4, r5 @ Copy data segment if needed 1: cmpne r5, r6 ldrne fp, [r4], #4 strne fp, [r5], #4 bne 1b mov fp, #0 @ Clear BSS (and zero fp) 1: cmp r6, r7 strcc fp, [r6],#4 bcc 1b ARM( ldmia r3, {r4, r5, r6, r7, sp}) THUMB( ldmia r3, {r4, r5, r6, r7} ) THUMB( ldr sp, [r3, #16] ) str r9, [r4] @ Save processor ID str r1, [r5] @ Save machine type str r2, [r6] @ Save atags pointer cmp r7, #0 strne r0, [r7] @ Save control register values b start_kernel ENDPROC(__mmap_switched) 启动前夕(ARM64) __mmap_switched: adr x3, __switch_data + 8 ldp x6, x7, [x3], #16 1: cmp x6, x7 b.hs 2f str xzr, [x6], #8 // Clear BSS b 1b 2: ldp x4, x5, [x3], #16 ldr x6, [x3], #8 ldr x16, [x3] mov sp, x16 str x22, [x4] // Save processor ID str x21, [x5] // Save FDT pointer str x24, [x6] // Save PHYS_OFFSET mov x29, #0 b start_kernel ENDPROC(__mmap_switched) .align 3 .type __switch_data, %object __switch_data: .quad __mmap_switched .quad __bss_start // x6 .quad __bss_stop // x7 .quad processor_id // x4 .quad __fdt_pointer // x5 .quad memstart_addr // x6 .quad init_thread_union + THREAD_START_SP // sp ENTRY(stext) mov x21, x0 // x21=FDT bl el2_setup // Drop to EL1, w20=cpu_boot_mode bl __calc_phys_offset // x24=PHYS_OFFSET, x28=PHYS_OFFSET-PAGE_OFFSET bl set_cpu_boot_mode_flag mrs x22, midr_el1 // x22=cpuid mov x0, x22 bl lookup_processor_type mov x23, x0 // x23=current cpu_table /* * __error_p may end up out of range for cbz if text areas are * aligned up to section sizes. */ cbnz x23, 1f // invalid processor (x23=0)? b __error_p 1: bl __vet_fdt bl __create_page_tables // x25=TTBR0, x26=TTBR1 /* * The following calls CPU specific code in a position independent * manner. See arch/arm64/mm/proc.S for details. x23 = base of * cpu_info structure selected by lookup_processor_type above. * On return, the CPU will be ready for the MMU to be turned on and * the TCR will have been set. */ ldr x27, __switch_data // address to jump to after // MMU has been enabled adrp lr, __enable_mmu // return (PIC) address add lr, lr, #:lo12:__enable_mmu ldr x12, [x23, #CPU_INFO_SETUP] add x12, x12, x28 // __virt_to_phys br x12 // initialise processor ENDPROC(stext) 上面的汇编函数都是由head.s跳入继续向下分析,谁开启了汇编,如何执行到这个函数vmlinux.lds决定，分析实现; 需要分析bootloader的实现; 下面我们开始分析 ","date":"2023-02-12","objectID":"/read_linux/:5:1","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#启动前夕"},{"categories":["Linux Kernel"],"content":" 5.2 start_kernel进入内核中第一个C语言启动函数;源码位置 asmlinkage __visible void __init start_kernel(void) { char *command_line; char *after_dashes; // 死锁检测 lockdep_init(); // 设置启动任务的结束磨数 set_task_stack_end_magic(\u0026init_task); // 设置smp id smp_setup_processor_id(); // debug debug_objects_early_init(); // 堆栈保护机制 boot_init_stack_canary(); // cgroup初始化 cgroup_init_early(); // irq中断停止，设置标志位 local_irq_disable(); early_boot_irqs_disabled = true; // 激活启动CPU boot_cpu_init(); // 单独章节分析 page_address_init(); pr_notice(\"%s\", linux_banner); // 设置架构 setup_arch(\u0026command_line); mm_init_cpumask(\u0026init_mm); setup_command_line(command_line); setup_nr_cpu_ids(); setup_per_cpu_areas(); smp_prepare_boot_cpu(); /* arch-specific boot-cpu hooks */ build_all_zonelists(NULL, NULL); page_alloc_init(); pr_notice(\"Kernel command line: %s\\n\", boot_command_line); parse_early_param(); after_dashes = parse_args(\"Booting kernel\", static_command_line, __start___param, __stop___param - __start___param, -1, -1, \u0026unknown_bootoption); if (!IS_ERR_OR_NULL(after_dashes)) parse_args(\"Setting init args\", after_dashes, NULL, 0, -1, -1, set_init_arg); jump_label_init(); /* * These use large bootmem allocations and must precede * kmem_cache_init() */ setup_log_buf(0); pidhash_init(); vfs_caches_init_early(); sort_main_extable(); trap_init(); mm_init(); /* * Set up the scheduler prior starting any interrupts (such as the * timer interrupt). Full topology setup happens at smp_init() * time - but meanwhile we still have a functioning scheduler. */ sched_init(); /* * Disable preemption - early bootup scheduling is extremely * fragile until we cpu_idle() for the first time. */ preempt_disable(); if (WARN(!irqs_disabled(), \"Interrupts were enabled *very* early, fixing it\\n\")) local_irq_disable(); idr_init_cache(); rcu_init(); /* trace_printk() and trace points may be used after this */ trace_init(); context_tracking_init(); radix_tree_init(); /* init some links before init_ISA_irqs() */ early_irq_init(); init_IRQ(); tick_init(); rcu_init_nohz(); init_timers(); hrtimers_init(); softirq_init(); timekeeping_init(); time_init(); sched_clock_postinit(); perf_event_init(); profile_init(); call_function_init(); WARN(!irqs_disabled(), \"Interrupts were enabled early\\n\"); early_boot_irqs_disabled = false; local_irq_enable(); kmem_cache_init_late(); /* * HACK ALERT! This is early. We're enabling the console before * we've done PCI setups etc, and console_init() must be aware of * this. But we do want output early, in case something goes wrong. */ console_init(); if (panic_later) panic(\"Too many boot %s vars at `%s'\", panic_later, panic_param); lockdep_info(); /* * Need to run this when irqs are enabled, because it wants * to self-test [hard/soft]-irqs on/off lock inversion bugs * too: */ locking_selftest(); #ifdef CONFIG_BLK_DEV_INITRD if (initrd_start \u0026\u0026 !initrd_below_start_ok \u0026\u0026 page_to_pfn(virt_to_page((void *)initrd_start)) \u003c min_low_pfn) { pr_crit(\"initrd overwritten (0x%08lx \u003c 0x%08lx) - disabling it.\\n\", page_to_pfn(virt_to_page((void *)initrd_start)), min_low_pfn); initrd_start = 0; } #endif page_ext_init(); debug_objects_mem_init(); kmemleak_init(); setup_per_cpu_pageset(); numa_policy_init(); if (late_time_init) late_time_init(); sched_clock_init(); calibrate_delay(); pidmap_init(); anon_vma_init(); acpi_early_init(); #ifdef CONFIG_X86 if (efi_enabled(EFI_RUNTIME_SERVICES)) efi_enter_virtual_mode(); #endif #ifdef CONFIG_X86_ESPFIX64 /* Should be run before the first non-init thread is created */ init_espfix_bsp(); #endif thread_info_cache_init(); cred_init(); fork_init(totalram_pages); proc_caches_init(); buffer_init(); key_init(); security_init(); dbg_late_init(); vfs_caches_init(totalram_pages); signals_init(); /* rootfs populating might need page-writeback */ page_writeback_init(); proc_root_init(); nsfs_init(); cgroup_init(); cpuset_init(); taskstats_init_early(); delayacct_init(); check_bugs(); sfi_init_late(); if (efi_enabled(EFI_RUNTIME_SERVICES)) { efi_late_init(); efi_free_boot_services(); ","date":"2023-02-12","objectID":"/read_linux/:5:2","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#start_kernel"},{"categories":["Linux Kernel"],"content":" 5.3 reset_init这个是系统调用的最后一个函数,调用结束后不会返回 static noinline void __init_refok rest_init(void) { int pid; rcu_scheduler_starting(); /* * We need to spawn init first so that it obtains pid 1, however * the init task will end up wanting to create kthreads, which, if * we schedule it before we create kthreadd, will OOPS. */ kernel_thread(kernel_init, NULL, CLONE_FS); numa_default_policy(); pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); rcu_read_lock(); kthreadd_task = find_task_by_pid_ns(pid, \u0026init_pid_ns); rcu_read_unlock(); complete(\u0026kthreadd_done); /* * The boot idle thread must execute schedule() * at least once to get things moving: */ init_idle_bootup_task(current); schedule_preempt_disabled(); /* Call into cpu_idle with preempt disabled */ cpu_startup_entry(CPUHP_ONLINE); } ","date":"2023-02-12","objectID":"/read_linux/:5:3","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#reset_init"},{"categories":["Linux Kernel"],"content":" 5.4 设置init任务堆栈 set_task_stack_end_magic(\u0026init_task); void set_task_stack_end_magic(struct task_struct *tsk) { unsigned long *stackend; stackend = end_of_stack(tsk); *stackend = STACK_END_MAGIC; /* for overflow detection */ } 此处可以得知: static inline unsigned long *end_of_stack(struct task_struct *p) { #ifdef CONFIG_STACK_GROWSUP return (unsigned long *)((unsigned long)task_thread_info(p) + THREAD_SIZE) - 1; #else return (unsigned long *)(task_thread_info(p) + 1); #endif } ","date":"2023-02-12","objectID":"/read_linux/:5:4","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置init任务堆栈"},{"categories":["Linux Kernel"],"content":" 5.5 设置smp的CPU ID int nr_cpu_ids __read_mostly = NR_CPUS; // 此参数通过配置文件得到 EXPORT_SYMBOL(nr_cpu_ids); u32 __cpu_logical_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID }; #define cpu_logical_map(cpu) __cpu_logical_map[cpu] // 1. 设置cpu_logical_map // 2. 设置线程ID // 3. 打印日志 void __init smp_setup_processor_id(void) { int i; u32 mpidr = is_smp() ? read_cpuid_mpidr() \u0026 MPIDR_HWID_BITMASK : 0; u32 cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0); cpu_logical_map(0) = cpu; for (i = 1; i \u003c nr_cpu_ids; ++i) cpu_logical_map(i) = i == cpu ? 0 : i; /* * clear __my_cpu_offset on boot CPU to avoid hang caused by * using percpu variable early, for example, lockdep will * access percpu variable inside lock_release */ set_my_cpu_offset(0); pr_info(\"Booting Linux on physical CPU 0x%x\\n\", mpidr); } // 设置线程ID static inline void set_my_cpu_offset(unsigned long off) { /* Set TPIDRPRW */ // off=0x0 asm volatile(\"mcr p15, 0, %0, c13, c0, 4\" : : \"r\" (off) : \"memory\"); } ","date":"2023-02-12","objectID":"/read_linux/:5:5","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置smp的cpu-id"},{"categories":["Linux Kernel"],"content":" 5.6 激活启动CPU static void __init boot_cpu_init(void) { int cpu = smp_processor_id(); /* Mark the boot cpu \"present\", \"online\" etc for SMP and UP case */ set_cpu_online(cpu, true); set_cpu_active(cpu, true); set_cpu_present(cpu, true); set_cpu_possible(cpu, true); } ","date":"2023-02-12","objectID":"/read_linux/:5:6","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#激活启动cpu"},{"categories":["Linux Kernel"],"content":" 5.7 设置架构读取配置文件(设置树),设置内存信息 在设备树一章节中会详细分析 void __init setup_arch(char **cmdline_p) { // 机器描述符 const struct machine_desc *mdesc; // 设置处理器相关信息 setup_processor(); // 读取设备树信息 mdesc = setup_machine_fdt(__atags_pointer); if (!mdesc) mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type); // 设置到全局变量 machine_desc = mdesc; machine_name = mdesc-\u003ename; dump_stack_set_arch_desc(\"%s\", mdesc-\u003ename); if (mdesc-\u003ereboot_mode != REBOOT_HARD) reboot_mode = mdesc-\u003ereboot_mode; // 设置init任务 init_mm.start_code = (unsigned long) _text; init_mm.end_code = (unsigned long) _etext; init_mm.end_data = (unsigned long) _edata; init_mm.brk = (unsigned long) _end; /* populate cmd_line too for later use, preserving boot_command_line */ strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE); *cmdline_p = cmd_line; parse_early_param(); // 读取设备树 early_paging_init(mdesc, lookup_processor_type(read_cpuid_id())); setup_dma_zone(mdesc); sanity_check_meminfo(); arm_memblock_init(mdesc); paging_init(mdesc); request_standard_resources(mdesc); if (mdesc-\u003erestart) arm_pm_restart = mdesc-\u003erestart; unflatten_device_tree(); arm_dt_init_cpu_maps(); psci_init(); #ifdef CONFIG_SMP if (is_smp()) { if (!mdesc-\u003esmp_init || !mdesc-\u003esmp_init()) { if (psci_smp_available()) smp_set_ops(\u0026psci_smp_ops); else if (mdesc-\u003esmp) smp_set_ops(mdesc-\u003esmp); } smp_init_cpus(); smp_build_mpidr_hash(); } #endif if (!is_smp()) hyp_mode_check(); reserve_crashkernel(); #ifdef CONFIG_MULTI_IRQ_HANDLER handle_arch_irq = mdesc-\u003ehandle_irq; #endif #ifdef CONFIG_VT #if defined(CONFIG_VGA_CONSOLE) conswitchp = \u0026vga_con; #elif defined(CONFIG_DUMMY_CONSOLE) conswitchp = \u0026dummy_con; #endif #endif if (mdesc-\u003einit_early) mdesc-\u003einit_early(); } ","date":"2023-02-12","objectID":"/read_linux/:5:7","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置架构"},{"categories":["Linux Kernel"],"content":" 5.8 mm_init_cpumask清理内存管理系统的init_mm-\u003ecpu_vm_mask_var static inline void mm_init_cpumask(struct mm_struct *mm) { #ifdef CONFIG_CPUMASK_OFFSTACK mm-\u003ecpu_vm_mask_var = \u0026mm-\u003ecpumask_allocation; #endif cpumask_clear(mm-\u003ecpu_vm_mask_var); } ","date":"2023-02-12","objectID":"/read_linux/:5:8","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#mm_init_cpumask"},{"categories":["Linux Kernel"],"content":" 5.9 设置命令行command_line申请内存， 保存命令行参数 /* Untouched saved command line (eg. for /proc) */ char *saved_command_line; /* Command line for parameter parsing */ static char *static_command_line; /* Command line for per-initcall parameter parsing */ static char *initcall_command_line; static void __init setup_command_line(char *command_line) { saved_command_line = memblock_virt_alloc(strlen(boot_command_line) + 1, 0); initcall_command_line = memblock_virt_alloc(strlen(boot_command_line) + 1, 0); static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0); strcpy(saved_command_line, boot_command_line); strcpy(static_command_line, command_line); } ","date":"2023-02-12","objectID":"/read_linux/:5:9","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置命令行command_line"},{"categories":["Linux Kernel"],"content":" 5.10 设置CPU setup_nr_cpu_ids setup_per_cpu_areas /* Setup number of possible processor ids */ int nr_cpu_ids __read_mostly = NR_CPUS; EXPORT_SYMBOL(nr_cpu_ids); /* An arch may set nr_cpu_ids earlier if needed, so this would be redundant */ void __init setup_nr_cpu_ids(void) { nr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1; } ","date":"2023-02-12","objectID":"/read_linux/:5:10","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#设置cpu"},{"categories":["Linux Kernel"],"content":" 5.11 smp_prepare_boot_cpu static inline void set_my_cpu_offset(unsigned long off) { /* Set TPIDRPRW */ asm volatile(\"mcr p15, 0, %0, c13, c0, 4\" : : \"r\" (off) : \"memory\"); } void __init smp_prepare_boot_cpu(void) { set_my_cpu_offset(per_cpu_offset(smp_processor_id())); } ","date":"2023-02-12","objectID":"/read_linux/:5:11","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#smp_prepare_boot_cpu"},{"categories":["Linux Kernel"],"content":" 5.12 build_all_zonelists启动期间构建zone, [build_all_zonelists –\u003e build_all_zonelists_init] /* * zonelist_order: * 0 = automatic detection of better ordering. * 1 = order by ([node] distance, -zonetype) * 2 = order by (-zonetype, [node] distance) * * If not NUMA, ZONELIST_ORDER_ZONE and ZONELIST_ORDER_NODE will create * the same zonelist. So only NUMA can configure this param. */ #define ZONELIST_ORDER_DEFAULT 0 #define ZONELIST_ORDER_NODE 1 #define ZONELIST_ORDER_ZONE 2 /* zonelist order in the kernel. * set_zonelist_order() will set this to NODE or ZONE. */ static int current_zonelist_order = ZONELIST_ORDER_DEFAULT; static char zonelist_order_name[3][8] = {\"Default\", \"Node\", \"Zone\"}; static void set_zonelist_order(void) { current_zonelist_order = ZONELIST_ORDER_ZONE; } 最终调用到build_all_zonelists_init static noinline void __init build_all_zonelists_init(void) { __build_all_zonelists(NULL); mminit_verify_zonelist(); cpuset_init_current_mems_allowed(); } ","date":"2023-02-12","objectID":"/read_linux/:5:12","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#build_all_zonelists"},{"categories":["Linux Kernel"],"content":" 5.13 page_alloc_init void __init page_alloc_init(void) { hotcpu_notifier(page_alloc_cpu_notify, 0); } ","date":"2023-02-12","objectID":"/read_linux/:5:13","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#page_alloc_init"},{"categories":["Linux Kernel"],"content":" 5.14 jump_label_init /* * Used to generate warnings if static_key manipulation functions are used * before jump_label_init is called. */ bool static_key_initialized __read_mostly; EXPORT_SYMBOL_GPL(static_key_initialized); static __always_inline void jump_label_init(void) { static_key_initialized = true; } ","date":"2023-02-12","objectID":"/read_linux/:5:14","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#jump_label_init"},{"categories":["Linux Kernel"],"content":" 5.15 setup_log_buf设置日志buf ","date":"2023-02-12","objectID":"/read_linux/:5:15","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#setup_log_buf"},{"categories":["Linux Kernel"],"content":" 5.16 pidhash_init struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; }; static struct hlist_head *pid_hash; static unsigned int pidhash_shift = 4; void __init pidhash_init(void) { unsigned int i, pidhash_size; pid_hash = alloc_large_system_hash(\"PID\", sizeof(*pid_hash), 0, 18, HASH_EARLY | HASH_SMALL, \u0026pidhash_shift, NULL, 0, 4096); pidhash_size = 1U \u003c\u003c pidhash_shift; for (i = 0; i \u003c pidhash_size; i++) INIT_HLIST_HEAD(\u0026pid_hash[i]); } ","date":"2023-02-12","objectID":"/read_linux/:5:16","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#pidhash_init"},{"categories":["Linux Kernel"],"content":" 5.17 vfs_caches_init_early void __init vfs_caches_init_early(void) { dcache_init_early(); inode_init_early(); } ","date":"2023-02-12","objectID":"/read_linux/:5:17","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#vfs_caches_init_early"},{"categories":["Linux Kernel"],"content":" 5.18 sort_main_extable异常修复表 struct exception_table_entry { unsigned long insn, fixup; }; extern struct exception_table_entry __start___ex_table[]; extern struct exception_table_entry __stop___ex_table[]; void __init sort_main_extable(void) { if (main_extable_sort_needed \u0026\u0026 __stop___ex_table \u003e __start___ex_table) { pr_notice(\"Sorting __ex_table...\\n\"); sort_extable(__start___ex_table, __stop___ex_table); } } static int cmp_ex(const void *a, const void *b) { const struct exception_table_entry *x = a, *y = b; /* avoid overflow */ if (x-\u003einsn \u003e y-\u003einsn) return 1; if (x-\u003einsn \u003c y-\u003einsn) return -1; return 0; } void sort_extable(struct exception_table_entry *start, struct exception_table_entry *finish) { sort(start, finish - start, sizeof(struct exception_table_entry), cmp_ex, NULL); } 但是这个表定义在什么位置内? . = ALIGN(4); __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) { __start___ex_table = .; #ifdef CONFIG_MMU *(__ex_table) #endif __stop___ex_table = .; } 在链接脚本中定义,代表着什么呢？如何定义这个表呢？ 大部分都是汇编实现的，当前不进行分析了 # define _ASM_EXTABLE_TYPE(from, to, type) \\ .pushsection \"__ex_table\",\"a\" ; \\ .balign 4 ; \\ .long (from) - . ; \\ .long (to) - . ; \\ .long type ; \\ .popsection 如何调用这个异常修复表呢? int fixup_exception(struct pt_regs *regs) { const struct exception_table_entry *fixup; fixup = search_exception_tables(instruction_pointer(regs)); if (fixup) { regs-\u003eARM_pc = fixup-\u003efixup; #ifdef CONFIG_THUMB2_KERNEL /* Clear the IT state to avoid nasty surprises in the fixup */ regs-\u003eARM_cpsr \u0026= ~PSR_IT_MASK; #endif } return fixup != NULL; } 调用线路 graph LR fixup_exception --\u003e search_exception_tables --\u003e search_extable --\u003e search_module_extables ","date":"2023-02-12","objectID":"/read_linux/:5:18","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#sort_main_extable"},{"categories":["Linux Kernel"],"content":" 5.19 trap_init中断描述符初始化，但是在arm上初始化好像不是这样进行的 arm上此选项无效 ","date":"2023-02-12","objectID":"/read_linux/:5:19","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#trap_init"},{"categories":["Linux Kernel"],"content":" 5.20 mm_init内存分配器初始化(单独分析) static void __init mm_init(void) { /* * page_ext requires contiguous pages, * bigger than MAX_ORDER unless SPARSEMEM. */ page_ext_init_flatmem(); mem_init(); kmem_cache_init(); percpu_init_late(); pgtable_init(); vmalloc_init(); } ","date":"2023-02-12","objectID":"/read_linux/:5:20","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#mm_init"},{"categories":["Linux Kernel"],"content":" 5.21 sched_init调度器初始化(单独分析) ","date":"2023-02-12","objectID":"/read_linux/:5:21","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#sched_init"},{"categories":["Linux Kernel"],"content":" 5.22 idr_init_cache整数ID管理机制 void __init idr_init_cache(void) { idr_layer_cache = kmem_cache_create(\"idr_layer_cache\", sizeof(struct idr_layer), 0, SLAB_PANIC, NULL); } ","date":"2023-02-12","objectID":"/read_linux/:5:22","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#idr_init_cache"},{"categories":["Linux Kernel"],"content":" 5.23 rcu_init void __init rcu_init(void) { int cpu; rcu_bootup_announce(); rcu_init_geometry(); rcu_init_one(\u0026rcu_bh_state, \u0026rcu_bh_data); rcu_init_one(\u0026rcu_sched_state, \u0026rcu_sched_data); __rcu_init_preempt(); open_softirq(RCU_SOFTIRQ, rcu_process_callbacks); /* * We don't need protection against CPU-hotplug here because * this is called early in boot, before either interrupts * or the scheduler are operational. */ cpu_notifier(rcu_cpu_notify, 0); pm_notifier(rcu_pm_notify, 0); for_each_online_cpu(cpu) rcu_cpu_notify(NULL, CPU_UP_PREPARE, (void *)(long)cpu); rcu_early_boot_tests(); } ","date":"2023-02-12","objectID":"/read_linux/:5:23","series":null,"tags":["Linux Kernel"],"title":"Linux内核源码阅读","uri":"/read_linux/#rcu_init"},{"categories":["前端知识"],"content":"nodejs基础教程","date":"2023-01-02","objectID":"/nodejs/","series":null,"tags":["前端知识"],"title":"Nodejs笔记","uri":"/nodejs/"},{"categories":["前端知识"],"content":" 1 Nodejs安装","date":"2023-01-02","objectID":"/nodejs/:1:0","series":null,"tags":["前端知识"],"title":"Nodejs笔记","uri":"/nodejs/#nodejs安装"},{"categories":["前端知识"],"content":" 2 Nodejs教程","date":"2023-01-02","objectID":"/nodejs/:2:0","series":null,"tags":["前端知识"],"title":"Nodejs笔记","uri":"/nodejs/#nodejs教程"},{"categories":["RTOS"],"content":"RTOS","date":"2022-10-30","objectID":"/freertos/","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/"},{"categories":["RTOS"],"content":" 1 基本概念","date":"2022-10-30","objectID":"/freertos/:1:0","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#基本概念"},{"categories":["RTOS"],"content":" 1.1 任务 一个死循环的函数运行(在RTOS中) ","date":"2022-10-30","objectID":"/freertos/:1:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务"},{"categories":["RTOS"],"content":" 1.2 函数运行环境(context) 寄存器 堆栈信息 ","date":"2022-10-30","objectID":"/freertos/:1:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#函数运行环境context"},{"categories":["RTOS"],"content":" 1.3 函数执行原理 pc/lr push/pop 下面写一个简单的函数,测试一下 函数是如何尽心调用的; int test(int a, int b) { return 0; } void main(void) { test(1, 2); } main –\u003e test 下面是程序编译后得到的汇编源码 test: push {r7} @ r7 --\u003e stack sub sp, sp, #12 @ sp = sp + 12 // 三个局部变量 add r7, sp, #0 @ r7 = sp str r0, [r7, #4] @ 保存第一个变量 str r1, [r7] @ 保存第二个变量 movs r3, #0 @ r3 = 0 mov r0, r3 @ r0 = r3 adds r7, r7, #12 @ r7 = r7 + 12 mov sp, r7 @ sp = r7 (销毁堆栈) ldr r7, [sp], #4 @ 恢复r7 bx lr @ 执行返回 main: push {r7, lr} @ 保存r7, lr add r7, sp, #0 @ r7 = sp movs r1, #2 @ r1 = 2 movs r0, #1 @ r0 = 1 bl test @ call test nop @ nop pop {r7, pc} @ lr_r = pc_v @ r7_r = r7_v ","date":"2022-10-30","objectID":"/freertos/:1:3","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#函数执行原理"},{"categories":["RTOS"],"content":" 1.4 总结那么,多任务就可以任务是从一个函数切换到另外一个函数; 但是此种切换对于任务来说是不可见的; 任务切换需要特权(定时器中断) 任务切换需要时停(开关中断) ","date":"2022-10-30","objectID":"/freertos/:1:4","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#总结"},{"categories":["RTOS"],"content":" 2 任务","date":"2022-10-30","objectID":"/freertos/:2:0","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务-1"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务创建"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#分配tcb结构体"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#初始化tcb成员变量"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#加入就绪列表"},{"categories":["RTOS"],"content":" 2.2 任务调度 任务调度的基础 可调用中断(可选) 定时器中断 2.2.1 调度器核心 void vTaskSwitchContext(void) { if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) { /* The scheduler is currently suspended - do not allow a context * switch. */ xYieldPending = pdTRUE; } else { xYieldPending = pdFALSE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations - which * are provided by the application, not the kernel. */ if( ulTotalRunTime \u003e ulTaskSwitchedInTime ) { pxCurrentTCB-\u003eulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime ); } else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime = ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskCHECK_FOR_STACK_OVERFLOW(); /* Before the currently running task is switched out, save its errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { pxCurrentTCB-\u003eiTaskErrno = FreeRTOS_errno; } #endif /* Select a new task to run using either the generic C or port * optimised asm code. */ taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ traceTASK_SWITCHED_IN(); /* After the new task is switched in, update the global errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { FreeRTOS_errno = pxCurrentTCB-\u003eiTaskErrno; } #endif #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) { /* Switch C-Runtime's TLS Block to point to the TLS * Block specific to this task. */ configSET_TLS_BLOCK( pxCurrentTCB-\u003exTLSBlock ); } #endif } } 分析M3的调度实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } 分析A9实现 vTaskSwitchContextConst: .word vTaskSwitchContext .macro portSAVE_CONTEXT /* Save the LR and SPSR onto the system mode stack before switching to system mode to save the remaining system mode registers. */ SRSDB sp!, #SYS_MODE CPS #SYS_MODE PUSH {R0-R12, R14} /* Push the critical nesting count. */ LDR R2, ulCriticalNestingConst LDR R1, [R2] PUSH {R1} /* Does the task have a floating point context that needs saving? If ulPortTaskHasFPUContext is 0 then no. */ LDR R2, ulPortTaskHasFPUContextConst LDR R3, [R2] CMP R3, #0 /* Save the floating point context, if any. */ FMRXNE R1, FPSCR VPUSHNE {D0-D15} VPUSHNE {D16-D31} PUSHNE {R1} /* Save ulPortTaskHasFPUContext itself. */ PUSH {R3} /* Save the stack pointer in the TCB. */ LDR R0, pxCurrentTCBConst LDR R1, [R0] STR SP, [R1] .endm ; /**********************************************************************/ .macro portRESTORE_CONTEXT /* Set the SP to point to the stack of the task being","date":"2022-10-30","objectID":"/freertos/:2:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务调度"},{"categories":["RTOS"],"content":" 2.2 任务调度 任务调度的基础 可调用中断(可选) 定时器中断 2.2.1 调度器核心 void vTaskSwitchContext(void) { if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) { /* The scheduler is currently suspended - do not allow a context * switch. */ xYieldPending = pdTRUE; } else { xYieldPending = pdFALSE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations - which * are provided by the application, not the kernel. */ if( ulTotalRunTime \u003e ulTaskSwitchedInTime ) { pxCurrentTCB-\u003eulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime ); } else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime = ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskCHECK_FOR_STACK_OVERFLOW(); /* Before the currently running task is switched out, save its errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { pxCurrentTCB-\u003eiTaskErrno = FreeRTOS_errno; } #endif /* Select a new task to run using either the generic C or port * optimised asm code. */ taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ traceTASK_SWITCHED_IN(); /* After the new task is switched in, update the global errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { FreeRTOS_errno = pxCurrentTCB-\u003eiTaskErrno; } #endif #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) { /* Switch C-Runtime's TLS Block to point to the TLS * Block specific to this task. */ configSET_TLS_BLOCK( pxCurrentTCB-\u003exTLSBlock ); } #endif } } 分析M3的调度实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } 分析A9实现 vTaskSwitchContextConst: .word vTaskSwitchContext .macro portSAVE_CONTEXT /* Save the LR and SPSR onto the system mode stack before switching to system mode to save the remaining system mode registers. */ SRSDB sp!, #SYS_MODE CPS #SYS_MODE PUSH {R0-R12, R14} /* Push the critical nesting count. */ LDR R2, ulCriticalNestingConst LDR R1, [R2] PUSH {R1} /* Does the task have a floating point context that needs saving? If ulPortTaskHasFPUContext is 0 then no. */ LDR R2, ulPortTaskHasFPUContextConst LDR R3, [R2] CMP R3, #0 /* Save the floating point context, if any. */ FMRXNE R1, FPSCR VPUSHNE {D0-D15} VPUSHNE {D16-D31} PUSHNE {R1} /* Save ulPortTaskHasFPUContext itself. */ PUSH {R3} /* Save the stack pointer in the TCB. */ LDR R0, pxCurrentTCBConst LDR R1, [R0] STR SP, [R1] .endm ; /**********************************************************************/ .macro portRESTORE_CONTEXT /* Set the SP to point to the stack of the task being","date":"2022-10-30","objectID":"/freertos/:2:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#调度器核心"},{"categories":["RTOS"],"content":" 2.3 任务状态 心跳实现 M3实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } A9实现 .align 4 .type FreeRTOS_IRQ_Handler, %function FreeRTOS_IRQ_Handler: /* Return to the interrupted instruction. */ SUB lr, lr, #4 /* Push the return address and SPSR. */ PUSH {lr} MRS lr, SPSR PUSH {lr} /* Change to supervisor mode to allow reentry. */ CPS #SVC_MODE /* Push used registers. */ PUSH {r0-r4, r12} /* Increment nesting count. r3 holds the address of ulPortInterruptNesting for future use. r1 holds the original ulPortInterruptNesting value for future use. */ LDR r3, ulPortInterruptNestingConst LDR r1, [r3] ADD r4, r1, #1 STR r4, [r3] /* Read value from the interrupt acknowledge register, which is stored in r0 for future parameter and interrupt clearing use. */ LDR r2, ulICCIARConst LDR r2, [r2] LDR r0, [r2] /* Ensure bit 2 of the stack pointer is clear. r2 holds the bit 2 value for future use. _RB_ Does this ever actually need to be done provided the start of the stack is 8-byte aligned? */ MOV r2, sp AND r2, r2, #4 SUB sp, sp, r2 /* Call the interrupt handler. r4 pushed to maintain alignment. */ PUSH {r0-r4, lr} LDR r1, vApplicationIRQHandlerConst BLX r1 POP {r0-r4, lr} ADD sp, sp, r2 CPSID i DSB ISB /* Write the value read from ICCIAR to ICCEOIR. */ LDR r4, ulICCEOIRConst LDR r4, [r4] STR r0, [r4] /* Restore the old nesting count. */ STR r1, [r3] /* A context switch is never performed if the nesting count is not 0. */ CMP r1, #0 BNE exit_without_switch /* Did the interrupt request a context switch? r1 holds the address of ulPortYieldRequired and r0 the value of ulPortYieldRequired for future use. */ LDR r1, =ulPortYieldRequired LDR r0, [r1] CMP r0, #0 BNE switch_before_exit exit_without_switch: /* No context switch. Restore used registers, LR_irq and SPSR before returning. */ POP {r0-r4, r12} CPS #IRQ_MODE POP {LR} MSR SPSR_cxsf, LR POP {LR} MOVS PC, LR switch_before_exit: /* A context swtich is to be performed. Clear the context switch pending flag. */ MOV r0, #0 STR r0, [r1] /* Restore used registers, LR-irq and SPSR before saving the context to the task stack. */ POP {r0-r4, r12} CPS #IRQ_MODE POP {LR} MSR SPSR_cxsf, LR POP {LR} portSAVE_CONTEXT /* Call the function that selects the new task to execute. vTaskSwitchContext() if vTaskSwitchContext() uses LDRD or STRD instructions, or 8 byte aligned stack allocated data. LR does not need saving as a new LR will be loaded by portRESTORE_CONTEXT anyway. */ LDR R0, vTaskSwitchContextConst BLX R0 /* Restore the context of, and branch to, the task selected to execute next. */ portRESTORE_CONTEXT ","date":"2022-10-30","objectID":"/freertos/:2:3","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务状态"},{"categories":["arm"],"content":"arm汇编","date":"2022-09-24","objectID":"/arm/","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/"},{"categories":["arm"],"content":" 1 体系结构参考文件 arm指令手册1 arm指令手册2 arm指令手册3 ","date":"2022-09-24","objectID":"/arm/:1:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#体系结构"},{"categories":["arm"],"content":" 1.1 相关术语 流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE ","date":"2022-09-24","objectID":"/arm/:1:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#相关术语"},{"categories":["arm"],"content":" 1.2 工具链 文件名 详解 addr2line 把程序地址转化为文件名和行号 ar 建立、修改和提取归档文件 as 汇编编译器 ld 链接器 nm 列出文件的符号 objcopy 文件个数格式转换 objdump 反汇编 ranlib 产生索引,并且保存进入文件中 readelf 显示elf文件信息 size 列出文件大小 string 打印文件可打印字符串 strip 丢弃文件符号 交叉工具链测试 arm-none-eabi-addr2line arm-none-eabi-gdb arm-none-eabi-ar arm-none-eabi-gdb-add-index arm-none-eabi-as arm-none-eabi-gfortran arm-none-eabi-c++ arm-none-eabi-gprof arm-none-eabi-c++filt arm-none-eabi-ld arm-none-eabi-cpp arm-none-eabi-ld.bfd arm-none-eabi-dwp arm-none-eabi-ld.gold arm-none-eabi-elfedit arm-none-eabi-lto-dump arm-none-eabi-g++ arm-none-eabi-nm arm-none-eabi-gcc arm-none-eabi-objcopy arm-none-eabi-gcc-10.2.1 arm-none-eabi-objdump arm-none-eabi-gcc-ar arm-none-eabi-ranlib arm-none-eabi-gcc-nm arm-none-eabi-readelf arm-none-eabi-gcc-ranlib arm-none-eabi-size arm-none-eabi-gcov arm-none-eabi-strings arm-none-eabi-gcov-dump arm-none-eabi-strip arm-none-eabi-gcov-tool ","date":"2022-09-24","objectID":"/arm/:1:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#工具链"},{"categories":["arm"],"content":" 1.3 ARMv7处理器模式 模式 编码 功能 安全 优先级 User (USR) 10000 大多数运行的非特权模式 Both PL0 FIQ 10001 FIQ中断 Both PL1 IRQ 10010 IRQ中断 Both PL1 Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1 Monitor (MON) 10110 安全扩展实现 only PL1 Abort (ABT) 10111 内存权限异常 Both PL1 Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2 Undef (UND) 11011 未定义指令调用 Both PL1 System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1 不同的处理器模式上寄存器共享的情况 ","date":"2022-09-24","objectID":"/arm/:1:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#armv7处理器模式"},{"categories":["arm"],"content":" 1.4 指令条件码指令条件码由CPSR/SPSR同时确定 ","date":"2022-09-24","objectID":"/arm/:1:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#指令条件码"},{"categories":["arm"],"content":" 2 寻址方式 立即数寻址 寄存器寻址 寄存器间接寻址 寄存器偏移寻址 寄存器基址变址寻址 批量寄存器寻址 相对寻址 堆栈寻址 块拷贝寻址 ","date":"2022-09-24","objectID":"/arm/:2:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寻址方式"},{"categories":["arm"],"content":" 2.1 立即数寻址立即数为操作数,其中立即数前面加上# ;; 立即数寻址 mov r0, #0 ; r0 = 0 mov r1, #64 ; r1 = 64 ","date":"2022-09-24","objectID":"/arm/:2:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#立即数寻址"},{"categories":["arm"],"content":" 2.2 寄存器寻址","date":"2022-09-24","objectID":"/arm/:2:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器寻址"},{"categories":["arm"],"content":" 2.3 寄存器偏移寻址寄存器寻址就是直接将寄存器中的数值作为操作数 指令 作用 LSL Logical Shift Left by 1-31 bits. LSR Logical Shift Right by 1-32 bits. ASR Arithmetic Shift Right by 1-32 bits. ROR Rotate Right by 1-31 bits. RRX Rotate Right with Extend. mov r0, r1 ; r0 = r1 mov r1, #12 ; r1 = 12; mov r0, r1, LSL #3 ; r0 = r1 \u003c\u003c 3 = 512 mov r0, r1, LSR #3 ; r0 = r1 \u003e\u003e 3 = 8 mov r0, r1, ASR #3 ; r0 = r1 \u003e\u003e 3 = 8 不改写符号位 mov r0, r1, ROR #3 ; r1 = 0x80000001 mov r0, r1, RRX ; r0 = r1 \u003e\u003e 1 | 空位 = C ","date":"2022-09-24","objectID":"/arm/:2:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器偏移寻址"},{"categories":["arm"],"content":" 2.4 寄存器间接寻址获取内存地址中的数据,需要使用LDR/STR操作符; 首先确定,RAM的地址范围; 打开simulator-\u003eMemory Configuration 可以得到RAM的地址0x00900000 –\u003e 0x0097FFFF, ldr r0, =0x123 ;; r0 = 0x123 ldr r1, =0x900000 ;; r1 = 0x900000 str r0, [r1] ;; *((unsigned long *)r1) = r0; mov r0, 0 ;; r0 = 0 ldr r0, [r1] ;; r0 = *((unsigned long *)r1) 但是此时只能得到一些奇怪的数据,那如何确定程序是运行正常的? ;; 读取异常地址,看看是否会崩溃 ;; 如果获取一个异常的地址, ;; 看看会发生什么? ldr r1, =0x00980000 ldr r0, [r1] 程序立即崩溃, 我们的测试是正确的; ","date":"2022-09-24","objectID":"/arm/:2:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器间接寻址"},{"categories":["arm"],"content":" 2.5 寄存器基址变址寻址 LDR R0, [R1,#0X0F] ;; R0 = *(unsigned long *)(R1 + 0x0f) LDR R0, [R1],#4 ;; R0 = *(unsigned long *)(R1 + 0x04) LDR R0, [R1,R2] ;; R0 = *(unsigned long *)(R1 + R2) ","date":"2022-09-24","objectID":"/arm/:2:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器基址变址寻址"},{"categories":["arm"],"content":" 2.6 批量寄存器寻址批量寻址来自于批量操作符STM/LDM, LDMIA R0,{R1,R2,R3,R4} STMIA R0,{R3-R5,R10} ","date":"2022-09-24","objectID":"/arm/:2:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#批量寄存器寻址"},{"categories":["arm"],"content":" 2.7 堆栈寻址 LDMFD SP!,{R1-R7,LR} STMFD SP!,{R1-R7,LR} ","date":"2022-09-24","objectID":"/arm/:2:7","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#堆栈寻址"},{"categories":["arm"],"content":" 3 指令集","date":"2022-09-24","objectID":"/arm/:3:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#指令集"},{"categories":["arm"],"content":" 3.1 跳转指令 跳转指令可以向前后32M地址跳转 跳转为24位长有符号数据 B: 绝对跳转 BL: 带返回的跳转 BLX: 带返回和状态切换的跳转 BX: 状态切换的跳转 B(跳转) L(设置链接寄存器) X(切换arm/thumb状态) 跳转指令的详细解释: add pc, pc, #跳转地址 ;; 跳转指令 B label_jump_B label_jump_B: mov pc, lr ;; 但是此时编译会报错,需要状态切换 BX label_jump_BX label_jump_BX: BL label_jump_BL label_jump_BL: BLX label_jump_BLX label_jump_BLX: ","date":"2022-09-24","objectID":"/arm/:3:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#跳转指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据处理指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据传送指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#比较指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#加减法"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#逻辑运算"},{"categories":["arm"],"content":" 3.3 乘法指令 mul mla smull umull umlal ","date":"2022-09-24","objectID":"/arm/:3:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#乘法指令"},{"categories":["arm"],"content":" 3.4 杂项算数指令 clz ","date":"2022-09-24","objectID":"/arm/:3:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#杂项算数指令"},{"categories":["arm"],"content":" 3.5 状态寄存器 mrs: 状态寄存器到通用寄存器 msr: 通用寄存器到状态寄存器 ","date":"2022-09-24","objectID":"/arm/:3:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#状态寄存器"},{"categories":["arm"],"content":" 3.6 内存操作指令 ldr/str ldm/stm ","date":"2022-09-24","objectID":"/arm/:3:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#内存操作指令"},{"categories":["arm"],"content":" 3.7 信号量操作指令 原子操作指令 swp swpb ","date":"2022-09-24","objectID":"/arm/:3:7","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#信号量操作指令"},{"categories":["arm"],"content":" 3.8 异常与中端指令 swi bkpt ","date":"2022-09-24","objectID":"/arm/:3:8","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#异常与中端指令"},{"categories":["arm"],"content":" 3.9 协处理器指令 cdp ldc stc mcr mrc ","date":"2022-09-24","objectID":"/arm/:3:9","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#协处理器指令"},{"categories":["arm"],"content":" 3.10 NEON指令 16个NEON寄存器(128bit), Q0-Q15(同时也可以被视为32个64bit的寄存器,D0-D31) ","date":"2022-09-24","objectID":"/arm/:3:10","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#neon指令"},{"categories":["arm"],"content":" 3.11 VFP指令 16个VFP寄存器(32bit),S0-S15 ","date":"2022-09-24","objectID":"/arm/:3:11","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#vfp指令"},{"categories":["arm"],"content":" 4 伪指令","date":"2022-09-24","objectID":"/arm/:4:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#伪指令"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#启动符号"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#符号定义"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-1"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-1"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据定义"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-2"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-2"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#汇编控制"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-3"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-3"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#段定义"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-4"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-4"},{"categories":["arm"],"content":" 4.6 杂项指令 GCC armasm 描述信息 @ ; Comment #\u0026 #0x An immediate hex value .if IFDEF, IF 条件编译 .else ELSE .elseif ELSEIF .endif ENDIF .ltorg LTORG ` ` :OR: \u0026 :AND: AND « :SHL: Shift Left » :SHR: Shift Right .macro MACRO Start macro definition .endm ENDM End macro definition .include INCLUDE GNU Assembler requires “filename” .word DCD A data word .short DCW .long DCD .byte DCB .req RN .global IMPORT, EXPORT .equ EQU ","date":"2022-09-24","objectID":"/arm/:4:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#杂项指令"},{"categories":["arm"],"content":" 5 程序设计","date":"2022-09-24","objectID":"/arm/:5:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#程序设计"},{"categories":["arm"],"content":" 5.1 条件语句","date":"2022-09-24","objectID":"/arm/:5:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#条件语句"},{"categories":["arm"],"content":" 5.2 循环语句","date":"2022-09-24","objectID":"/arm/:5:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#循环语句"},{"categories":["arm"],"content":" 5.3 函数定义","date":"2022-09-24","objectID":"/arm/:5:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#函数定义"},{"categories":["arm"],"content":" 6 混合编程","date":"2022-09-24","objectID":"/arm/:6:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#混合编程"},{"categories":["arm"],"content":" 6.1 C与汇编","date":"2022-09-24","objectID":"/arm/:6:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#c与汇编"},{"categories":["arm"],"content":" 6.2 C与thumb","date":"2022-09-24","objectID":"/arm/:6:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#c与thumb"},{"categories":["arm"],"content":" 7 存储系统","date":"2022-09-24","objectID":"/arm/:7:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#存储系统"},{"categories":["arm"],"content":" 7.1 MMU","date":"2022-09-24","objectID":"/arm/:7:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#mmu"},{"categories":["arm"],"content":" 7.2 cache","date":"2022-09-24","objectID":"/arm/:7:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#cache"},{"categories":["arm"],"content":" 8 仿真工具","date":"2022-09-24","objectID":"/arm/:8:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#仿真工具"},{"categories":["arm"],"content":" 8.1 IAR仿真设置新建工程 设置仿真 构建仿真 ","date":"2022-09-24","objectID":"/arm/:8:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar仿真设置"},{"categories":["arm"],"content":" 8.2 eclipse仿真设置 arm-none-eabi-gcc: 编译器 openocd: 调试器 qemu: 仿真器 ","date":"2022-09-24","objectID":"/arm/:8:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#eclipse仿真设置"},{"categories":["Bsdiff"],"content":"Bsdiff","date":"2022-08-17","objectID":"/bsdiff/","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/"},{"categories":["Bsdiff"],"content":" 1 引言 bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u003e sorting (specifically, Larsson and Sadakane’s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) – 直接摘抄自官网 详情可以查看bsdiff官网,存在这个详细描述. bsdiff基本原理： 存在差异的数据: diff 不存在的数据: extra 最后生成的文件 = diff + extra; ","date":"2022-08-17","objectID":"/bsdiff/:1:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#引言"},{"categories":["Bsdiff"],"content":" 2 测试新建立两个文件old.c与new.c,二者的差别是 // new.c #include \u003cstdio.h\u003e int main(void) { printf(\"Hello World\\r\\n\"); return 0; } // old.c #include \u003cstdio.h\u003e int main(void) { return 0; } 测试的情况 # 执行编译 gcc old.c -o old \u0026\u0026 ./old gcc new.c -o new \u0026\u0026 ./new 计算md5 md5sum old # d08fd167e74f279522fe8aa64d8e27dd old md5sum new # b0b4be993de61064a118d32a692bf795 new md5sum mid # b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试 # 生成diff bsdiff old new test.diff # 打入补丁--\u003emid bspatch old mid test.diff ","date":"2022-08-17","objectID":"/bsdiff/:2:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#测试"},{"categories":["Bsdiff"],"content":" 3 原理 后缀数组实现 ","date":"2022-08-17","objectID":"/bsdiff/:3:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#原理"},{"categories":["Bsdiff"],"content":" 3.1 后缀数组定义","date":"2022-08-17","objectID":"/bsdiff/:3:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#后缀数组定义"},{"categories":["Bsdiff"],"content":" 3.2 后缀数组计算 倍增法和桶排序 倍增法的时间复杂度是O(NlogN)的,程序简单,算法过程易于理解. 桶排序时间复杂度是O(N),数据量大的时候,效率比倍增算法有显著提升,但是缺点在于DC3算法原理较难理解,代码冗长. ","date":"2022-08-17","objectID":"/bsdiff/:3:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#后缀数组计算"},{"categories":["Bsdiff"],"content":" 4 补丁文件bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2022-08-17","objectID":"/bsdiff/:4:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#补丁文件"},{"categories":["Bsdiff"],"content":" 5 生成补丁 bsdiff bspatch ","date":"2022-08-17","objectID":"/bsdiff/:5:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#生成补丁"},{"categories":["Bsdiff"],"content":" 5.1 数据结构 struct bsdiff_stream { void* opaque; /* bzip文件 */ void* (*malloc)(size_t size); /* 内存申请接口 */ void (*free)(void* ptr); /* 内存释放接口 */ int (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ const void* buffer, int size); }; struct bsdiff_request { const uint8_t* old; int64_t oldsize; const uint8_t* new; int64_t newsize; struct bsdiff_stream* stream; int64_t *I; uint8_t *buffer; }; ","date":"2022-08-17","objectID":"/bsdiff/:5:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#数据结构"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行graph LR bsdiff --\u003e bsdiff_internal 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#接口分析"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行graph LR bsdiff --\u003e bsdiff_internal 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行graph LR bsdiff --\u003e bsdiff_internal 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行graph LR bsdiff --\u003e bsdiff_internal bsdiff_internal --\u003e offout bsdiff_internal --\u003e qsufsort bsdiff_internal --\u003e search bsdiff_internal --\u003e writedata qsufsort --\u003e split search --\u003e matchlen 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan\u003creq.newsize) { oldscore=0; for(scsc=scan+=len;scan\u003creq.newsize;scan++) { len=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 0,req.oldsize,\u0026pos); for(;scsc\u003cscan+len;scsc++) if((scsc+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scsc+lastoffset] == req.new[scsc])) oldscore++; if(((len==oldscore) \u0026\u0026 (len!=0)) || (len\u003eoldscore+8)) break; if((scan+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scan+lastoffset] == req.new[scan])) oldscore--; }; if((len!=oldscore) || (scan==req.newsize)) { s=0;Sf=0;lenf=0; for(i=0;(lastscan+i\u003cscan)\u0026\u0026(lastpos+i\u003creq.oldsize);) { if(req.old[lastpos+i]==req.new[lastscan+i]) s++; i++; if(s*2-i\u003eSf*2-lenf) { Sf=s; lenf=i; }; }; lenb=0; if(scan\u003creq.newsize) { s=0;Sb=0; for(i=1;(scan\u003e=lastscan+i)\u0026\u0026(pos\u003e=i);i++) { if(req.old[pos-i]==req.new[scan-i]) s++; if(s*2-i\u003eSb*2-lenb) { Sb=s; lenb=i; }; }; }; if(lastscan+lenf\u003escan-lenb) { overlap=(lastscan+lenf)-(scan-lenb); s=0;Ss=0;lens=0; for(i=0;i\u003coverlap;i++) { if(req.new[lastscan+lenf-overlap+i]== req.old[lastpos+lenf-overlap+i]) s++; if(req.new[scan-lenb+i]== req.old[pos-lenb+i]) s--; if(s\u003eSs) { Ss=s; lens=i+1; }; }; lenf+=lens-overlap; lenb-=lens; }; offtout(lenf,buf); offtout((scan-lenb)-(lastscan+lenf),buf+8); offtout((pos-lenb)-(lastpos+lenf),buf+16); /* Write control data */ if (writedata(req.stream, buf, sizeof(buf))) return -1; /* Write diff data */ for(i=0;i\u003clenf;i++) buffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; if (writedata(req.stream, buffer, lenf)) return -1; /* Write extra data */ for(i=0;i\u003c(scan-lenb)-(lastscan+lenf);i++) buffer[i]=req.new[lastscan+lenf+i]; if (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) return -1; lastscan=scan-lenb; lastpos=pos-lenb; lastoffset=pos-scan; }; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#核心处理"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行graph LR bsdiff --\u003e bsdiff_internal bsdiff_internal --\u003e offout bsdiff_internal --\u003e qsufsort bsdiff_internal --\u003e search bsdiff_internal --\u003e writedata qsufsort --\u003e split search --\u003e matchlen 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-1"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行graph LR bsdiff --\u003e bsdiff_internal bsdiff_internal --\u003e offout bsdiff_internal --\u003e qsufsort bsdiff_internal --\u003e search bsdiff_internal --\u003e writedata qsufsort --\u003e split search --\u003e matchlen 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-1"},{"categories":["Bsdiff"],"content":" 5.4 偏移转缓存 偏移转缓存 缓存转偏移 static void offtout(int64_t x, uint8_t *buf) { int64_t y; if(x\u003c0) y=-x; else y=x; buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2022-08-17","objectID":"/bsdiff/:5:4","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#偏移转缓存"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行graph LR search --\u003e matchlen search --\u003e search 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i\u003coldsize)\u0026\u0026(i\u003cnewsize);i++) if(old[i]!=new[i]) break; return i; } static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, const uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) { int64_t x,y; if(en-st\u003c2) { x=matchlen(old+I[st],oldsize-I[st],new,newsize); y=matchlen(old+I[en],oldsize-I[en],new,newsize); if(x\u003ey) { *pos=I[st]; return x; } else { *pos=I[en]; return y; } }; x=st+(en-st)/2; if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u003c0) { return search(I,old,oldsize,new,newsize,x,en,pos); } else { return search(I,old,oldsize,new,newsize,st,x,pos); }; } ","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#搜索"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行graph LR search --\u003e matchlen search --\u003e search 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-2"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行graph LR search --\u003e matchlen search --\u003e search 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-2"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行graph LR qsufsort --\u003e split split --\u003e split 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k\u003cstart+len;k+=j) { j=1;x=V[I[k]+h]; for(i=1;k+i\u003cstart+len;i++) { if(V[I[k+i]+h]\u003cx) { x=V[I[k+i]+h]; j=0; }; if(V[I[k+i]+h]==x) { tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; j++; }; }; for(i=0;i\u003cj;i++) V[I[k+i]]=k+j-1; if(j==1) I[k]=-1; }; return; }; x=V[I[start+len/2]+h]; jj=0;kk=0; for(i=start;i\u003cstart+len;i++) { if(V[I[i]+h]\u003cx) jj++; if(V[I[i]+h]==x) kk++; }; jj+=start;kk+=jj; i=start;j=0;k=0; while(i\u003cjj) { if(V[I[i]+h]\u003cx) { i++; } else if(V[I[i]+h]==x) { tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; j++; } else { tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; k++; }; }; while(jj+j\u003ckk) { if(V[I[jj+j]+h]==x) { j++; } else { tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; k++; }; }; if(jj\u003estart) split(I,V,start,jj-start,h); for(i=0;i\u003ckk-jj;i++) V[I[jj+i]]=kk-1; if(jj==kk-1) I[jj]=-1; if(start+len\u003ekk) split(I,V,kk,start+len-kk,h); } static void qsufsort(int64_t *I, const uint8_t *old, int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; int64_t *V; if ((V = req.stream-\u003emalloc((req.oldsize+1) * sizeof(int64_t))) == NULL) { return -1; } for (i=0; i\u003c256; i++) { buckets[i]=0; } for(i=0;i\u003coldsize;i++) buckets[old[i]]++; for(i=1;i\u003c256;i++) buckets[i]+=buckets[i-1]; for(i=255;i\u003e0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i\u003coldsize;i++) I[++buckets[old[i]]]=i; I[0]=oldsize; for(i=0;i\u003coldsize;i++) V[i]=buckets[old[i]]; V[oldsize]=0; for(i=1;i\u003c256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; I[0]=-1; for(h=1;I[0]!=-(oldsize+1);h+=h) { len=0; for(i=0;i\u003coldsize+1;) { if(I[i]\u003c0) { len-=I[i]; i-=I[i]; } else { if(len) I[i-len]=-len; len=V[I[i]]+1-i; split(I,V,i,len,h); i+=len; len=0; }; }; if(len) I[i-len]=-len; }; for(i=0;i\u003coldsize+1;i++) I[V[i]]=i; free(V); } ","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#排序"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行graph LR qsufsort --\u003e split split --\u003e split 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-3"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行graph LR qsufsort --\u003e split split --\u003e split 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-3"},{"categories":["Bsdiff"],"content":" 5.7 保存文件 简要写法 主要的操作就是将buffer直接写到文件中 static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { const int writeresult = stream-\u003ewrite(stream, buffer, length); return writeresult; } 原始写法 为了保证大小不超过API的大小 static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { int64_t result = 0; while (length \u003e 0) { const int smallsize = (int)MIN(length, INT_MAX); const int writeresult = stream-\u003ewrite(stream, buffer, smallsize); if (writeresult == -1) { return -1; } result += writeresult; length -= smallsize; buffer = (uint8_t*)buffer + smallsize; } return result; } ","date":"2022-08-17","objectID":"/bsdiff/:5:7","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#保存文件"},{"categories":["Bsdiff"],"content":" 6 打入补丁 bsdiff bspatch ","date":"2022-08-17","objectID":"/bsdiff/:6:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#打入补丁"},{"categories":["Bsdiff"],"content":" 6.1 缓存转偏移 偏移转缓存 缓存转偏移 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } ","date":"2022-08-17","objectID":"/bsdiff/:6:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#缓存转偏移"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i\u003cctrl[0];i++) if((oldpos+i\u003e=0) \u0026\u0026 (oldpos+i\u003coldsize)) new[newpos+i]+=old[oldpos+i]; /* Adjust pointers */ newpos+=ctrl[0]; oldpos+=ctrl[0]; /* Sanity-check */ if(newpos+ctrl[1]\u003enewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#核心功能"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#执行路线"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-4"},{"categories":["编程语言"],"content":"C++基础笔记","date":"2022-07-28","objectID":"/cxx_basic/","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 C++模板笔记 ","date":"2022-07-28","objectID":"/cxx_basic/:0:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#"},{"categories":["编程语言"],"content":" 1 第一个程序 #include \u003ciostream\u003e using namespace std; int main(int argc, char *argv[]) { cout \u003c\u003c \"Hello World\" \u003c\u003c endl; return 0; } 编译指令 从生成的汇编指令来看,复杂不少 __cxx_global_var_init: push {r11, lr} mov r11, sp sub sp, sp, #8 ldr r0, .LCPI0_0 .LPC0_0: add r0, pc, r0 str r0, [sp, #4] @ 4-byte Spill bl std::ios_base::Init::Init() [complete object constructor] ldr r1, [sp, #4] @ 4-byte Reload ldr r0, .LCPI0_1 .LPC0_1: ldr r0, [pc, r0] ldr r2, .LCPI0_2 .LPC0_2: add r2, pc, r2 bl __cxa_atexit mov sp, r11 pop {r11, lr} bx lr .LCPI0_0: .long _ZStL8__ioinit-(.LPC0_0+8) .LCPI0_1: .Ltmp2: .long _ZNSt8ios_base4InitD1Ev(GOT_PREL)-((.LPC0_1+8)-.Ltmp2) .LCPI0_2: .long __dso_handle-(.LPC0_2+8) main: push {r11, lr} mov r11, sp sub sp, sp, #16 mov r2, #0 str r2, [sp] @ 4-byte Spill str r2, [r11, #-4] str r0, [sp, #8] str r1, [sp, #4] ldr r0, .LCPI1_0 .LPC1_0: ldr r0, [pc, r0] ldr r1, .LCPI1_1 .LPC1_1: add r1, pc, r1 bl std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::operator\u003c\u003c \u003cstd::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026, char const*) ldr r1, .LCPI1_2 .LPC1_2: ldr r1, [pc, r1] bl std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e::operator\u003c\u003c(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 (*)(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026)) ldr r0, [sp] @ 4-byte Reload mov sp, r11 pop {r11, lr} bx lr .LCPI1_0: .Ltmp5: .long _ZSt4cout(GOT_PREL)-((.LPC1_0+8)-.Ltmp5) .LCPI1_1: .long .L.str-(.LPC1_1+8) .LCPI1_2: .Ltmp6: .long _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(GOT_PREL)-((.LPC1_2+8)-.Ltmp6) _GLOBAL__sub_I_example.cpp: push {r11, lr} mov r11, sp bl __cxx_global_var_init pop {r11, lr} bx lr .L.str: .asciz \"Hello World\" ","date":"2022-07-28","objectID":"/cxx_basic/:1:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#第一个程序"},{"categories":["编程语言"],"content":" 2 注释","date":"2022-07-28","objectID":"/cxx_basic/:2:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#注释"},{"categories":["编程语言"],"content":" 2.1 C++注释 // 这个是一个单行注释 ","date":"2022-07-28","objectID":"/cxx_basic/:2:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c注释"},{"categories":["编程语言"],"content":" 2.2 C注释 /* 这个里面是一个注释 */ 在C/C++中两种注释都是可以使用的 并不是绝对的,只因为提出者是C或者C++ 注释不影响程序的编译–\u003e(预编译删除所有注释) 推荐使用doxygen–\u003e(使用doxygen漂亮的注释) ","date":"2022-07-28","objectID":"/cxx_basic/:2:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c注释-1"},{"categories":["编程语言"],"content":" 3 标识符","date":"2022-07-28","objectID":"/cxx_basic/:3:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#标识符"},{"categories":["编程语言"],"content":" 3.1 变量变量的存在意义:方便我们管理内存 变量创建的语法 存储类型 数据类型 变量名 = 变量初始化; 自动,不使用标识符 寄存器(register) 静态static 外部extern /* auto */ int a = 0; // C++不在添加自动变量标识符 static int a = 0; // 静态 register int a = 0; // 寄存器 extern int a = 0; // 外部 总结 存储类型 持续性 作用域 链接性 定义 自动变量 自动 函数内 ❎ 无标志符,定义在函数内 寄存器 自动 函数内 ❎ register 静态 全局 函数内|文件内 ❎ static 外部 全局 文件内 ✅ 无标志符,定义在文件内 ","date":"2022-07-28","objectID":"/cxx_basic/:3:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#变量"},{"categories":["编程语言"],"content":" 3.2 常量作用: 记录程序中不可以改变的数据 define 宏常量(预编译期) const 修饰变量(编译期) ","date":"2022-07-28","objectID":"/cxx_basic/:3:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#常量"},{"categories":["编程语言"],"content":" 3.3 关键字 关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template ","date":"2022-07-28","objectID":"/cxx_basic/:3:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#关键字"},{"categories":["编程语言"],"content":" 3.4 命名规则 标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写 ","date":"2022-07-28","objectID":"/cxx_basic/:3:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#命名规则"},{"categories":["编程语言"],"content":" 4 数据类型指定类型,分配内存 ","date":"2022-07-28","objectID":"/cxx_basic/:4:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#数据类型"},{"categories":["编程语言"],"content":" 4.1 整形","date":"2022-07-28","objectID":"/cxx_basic/:4:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#整形"},{"categories":["编程语言"],"content":" 4.2 浮点型 单精度float 双精度double ","date":"2022-07-28","objectID":"/cxx_basic/:4:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#浮点型"},{"categories":["编程语言"],"content":" 4.3 字符型","date":"2022-07-28","objectID":"/cxx_basic/:4:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#字符型"},{"categories":["编程语言"],"content":" 4.4 转义字符","date":"2022-07-28","objectID":"/cxx_basic/:4:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#转义字符"},{"categories":["编程语言"],"content":" 4.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; ","date":"2022-07-28","objectID":"/cxx_basic/:4:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#字符串"},{"categories":["编程语言"],"content":" 4.6 布尔类型 bool A = true; bool B = false; ","date":"2022-07-28","objectID":"/cxx_basic/:4:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#布尔类型"},{"categories":["编程语言"],"content":" 5 运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#运算符"},{"categories":["编程语言"],"content":" 5.1 基本运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#基本运算符"},{"categories":["编程语言"],"content":" 5.2 取模运算就是取余数 ","date":"2022-07-28","objectID":"/cxx_basic/:5:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#取模运算"},{"categories":["编程语言"],"content":" 5.3 自增自减运算 a1++; a2--; ","date":"2022-07-28","objectID":"/cxx_basic/:5:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#自增自减运算"},{"categories":["编程语言"],"content":" 5.4 赋值运算 运算符 术语 示例 结果 = += -= *= /= %= ","date":"2022-07-28","objectID":"/cxx_basic/:5:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#赋值运算"},{"categories":["编程语言"],"content":" 5.5 比较运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#比较运算符"},{"categories":["编程语言"],"content":" 5.6 逻辑运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#逻辑运算符"},{"categories":["编程语言"],"content":" 6 流程控制","date":"2022-07-28","objectID":"/cxx_basic/:6:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#流程控制"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#顺序结构"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#if语句"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#三目运算符"},{"categories":["编程语言"],"content":" 6.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } ","date":"2022-07-28","objectID":"/cxx_basic/:6:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#选择结构"},{"categories":["编程语言"],"content":" 6.3 循环结构","date":"2022-07-28","objectID":"/cxx_basic/:6:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#循环结构"},{"categories":["编程语言"],"content":" 6.4 while循环 while(条件) { 循环体; } ###do...while循环 do { } while(条件) ","date":"2022-07-28","objectID":"/cxx_basic/:6:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#while循环"},{"categories":["编程语言"],"content":" 6.5 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } ","date":"2022-07-28","objectID":"/cxx_basic/:6:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#for循环"},{"categories":["编程语言"],"content":" 6.6 跳转语句 break continue 6.6.1 goto 绝对跳转语句 ","date":"2022-07-28","objectID":"/cxx_basic/:6:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#跳转语句"},{"categories":["编程语言"],"content":" 6.6 跳转语句 break continue 6.6.1 goto 绝对跳转语句 ","date":"2022-07-28","objectID":"/cxx_basic/:6:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#goto"},{"categories":["编程语言"],"content":" 7 函数定义 返回值类型 函数名 参数列表 函数体语句 return表达式 返回值类型 函数名字(参数列表) { 函数体语句; return 表达式; } ","date":"2022-07-28","objectID":"/cxx_basic/:7:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数定义"},{"categories":["编程语言"],"content":" 7.1 值传递 类似数值拷贝 ","date":"2022-07-28","objectID":"/cxx_basic/:7:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#值传递"},{"categories":["编程语言"],"content":" 7.2 函数的常见样式 无参无返 有参无返 无参有反 有参有返 ","date":"2022-07-28","objectID":"/cxx_basic/:7:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数的常见样式"},{"categories":["编程语言"],"content":" 7.3 声明作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现; ","date":"2022-07-28","objectID":"/cxx_basic/:7:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#声明"},{"categories":["编程语言"],"content":" 7.4 多文件","date":"2022-07-28","objectID":"/cxx_basic/:7:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#多文件"},{"categories":["编程语言"],"content":" 8 复合数据结构","date":"2022-07-28","objectID":"/cxx_basic/:8:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#复合数据结构"},{"categories":["编程语言"],"content":" 8.1 数组","date":"2022-07-28","objectID":"/cxx_basic/:8:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#数组"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针的定义和使用"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针所占用空间"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#空指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#野指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#const与指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针与数组"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针与函数"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体数组"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体指针"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体嵌套"},{"categories":["编程语言"],"content":" 8.4 枚举","date":"2022-07-28","objectID":"/cxx_basic/:8:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#枚举"},{"categories":["编程语言"],"content":" 8.5 联合","date":"2022-07-28","objectID":"/cxx_basic/:8:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#联合"},{"categories":["编程语言"],"content":" 8.6 位域","date":"2022-07-28","objectID":"/cxx_basic/:8:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#位域"},{"categories":["编程语言"],"content":" 9 C++内存分区c++程序在运行时,将内存分为4个区域 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放 ","date":"2022-07-28","objectID":"/cxx_basic/:9:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c内存分区"},{"categories":["编程语言"],"content":" 10 new/delete操作符 new操作符在堆区开辟内存 delete释放内存对象 ","date":"2022-07-28","objectID":"/cxx_basic/:10:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#newdelete操作符"},{"categories":["编程语言"],"content":" 11 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; ","date":"2022-07-28","objectID":"/cxx_basic/:11:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用"},{"categories":["编程语言"],"content":" 11.1 引用做参数 #include \u003ciostream\u003e void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 ","date":"2022-07-28","objectID":"/cxx_basic/:11:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用做参数"},{"categories":["编程语言"],"content":" 11.2 引用做返回值","date":"2022-07-28","objectID":"/cxx_basic/:11:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用做返回值"},{"categories":["编程语言"],"content":" 11.3 引用的本质引用的本质是C++内部实现的一个指针常量 ","date":"2022-07-28","objectID":"/cxx_basic/:11:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用的本质"},{"categories":["编程语言"],"content":" 11.4 常量引用 const int \u0026ref = 10; ","date":"2022-07-28","objectID":"/cxx_basic/:11:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#常量引用"},{"categories":["编程语言"],"content":" 12 函数提高","date":"2022-07-28","objectID":"/cxx_basic/:12:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数提高"},{"categories":["编程语言"],"content":" 12.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/cxx_basic/:12:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数默认值"},{"categories":["编程语言"],"content":" 12.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/cxx_basic/:12:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数的占位参数"},{"categories":["编程语言"],"content":" 12.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2022-07-28","objectID":"/cxx_basic/:12:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数重载"},{"categories":["编程语言"],"content":" 13 命名空间 namespace/using关键字 命名空间（Namespace）是一种用于避免命名冲突的机制，它能够将众多的全局变量、函数和类组织在一起，形成一个独立的命名空间，从而避免不同代码块中的同名标识符发生冲突。下面是C++命名空间的详解： 命名空间的定义 命名空间可以通过使用关键字\"namespace\"来定义，其语法格式如下： namespace namespace_name { // namespace body } 其中，namespace_name表示命名空间的名称，花括号内的部分为命名空间的主体，可以包含变量、函数和类等。 命名空间的使用 命名空间可以通过两种方式进行使用： （1）使用命名空间前缀 可以通过加上命名空间前缀的方式访问该命名空间中的元素。例如： namespace ns { void func() { ... } } int main() { ns::func(); // 调用ns命名空间中的函数func() } （2）using声明 也可以通过using声明的方式引入指定命名空间中的元素，以便于直接使用。例如： namespace ns { void func() { ... } } using ns::func; // 引入ns命名空间中的函数func() int main() { func(); // 直接调用func() } 需要注意的是，using声明污染了当前命名空间的作用域，可能会导致命名冲突。 命名空间的嵌套 C++中，命名空间可以进行嵌套，从而形成多级命名空间。例如： namespace ns1 { namespace ns2 { void func() { ... } } } int main() { ns1::ns2::func(); // 调用ns1::ns2命名空间中的函数func() } 匿名命名空间 C++还支持匿名命名空间，它定义在全局命名空间内，但是该命名空间的名称为空。在匿名命名空间内定义的变量、函数和类等被视为静态的，只能在当前文件内使用。例如： namespace { int x; // 定义一个静态变量x } int main() { x = 10; // 错误：无法访问匿名命名空间内的变量x return 0; } 以上就是C++命名空间的详细介绍，通过合理使用命名空间可以避免不同代码块中的同名标识符发生冲突，提高程序的可读性和可维护性。 using关键字用法分析 using声明 using声明可以用于将指定的命名空间或名称引入当前作用域，以便于直接使用。例如： #include \u003ciostream\u003e // 引入std命名空间中的cout和endl using std::cout; using std::endl; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 在上面的例子中，使用了using声明将std命名空间中的cout和endl引入到了main函数的作用域中，从而可以直接使用它们输出文本信息。 需要注意的是，using声明可能会导致命名冲突，因此应当谨慎使用。 using指令 using指令可以用于将所指向的命名空间中的所有名称都引入当前作用域，以便于直接使用。例如： #include \u003ciostream\u003e // 引入std命名空间中的所有名称 using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 在上面的例子中，使用了using指令将std命名空间中的所有名称都引入到了main函数的作用域中，从而可以直接使用其中的cout和endl等标准库函数。 需要注意的是，使用using指令会将整个命名空间的所有名称都引入到当前作用域中，可能会导致命名冲突和名称重定义等问题。因此，建议在较小的作用域内使用using声明，而尽量避免使用using指令。 using别名 using别名可以用于为一个类型或值定义一个新的名称，以便于更加方便地使用它们。例如： #include \u003ciostream\u003e // 定义int型别名myInt using myInt = int; int main() { myInt x = 10; std::cout \u003c\u003c x \u003c\u003c std::endl; return 0; } 在上面的例子中，使用了using别名将int型定义为了myInt的别名，从而可以在程序中使用myInt来代替int类型。 需要注意的是，使用using别名会增加代码的可读性，但也可能导致代码可读性下降。因此，在定义别名时应当保持适度，避免过多使用。 ","date":"2022-07-28","objectID":"/cxx_basic/:13:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#命名空间"},{"categories":["编程语言"],"content":" 14 异常处理C++ 异常是一种程序运行时可能发生的错误，它们通常是程序中的逻辑或者数据错误，例如除以零、访问空指针、数组越界等。当这些错误发生时，程序会抛出异常，并且执行相应的异常处理代码。 C++ 中的异常处理机制有三个关键字：try、catch 和 throw。其中，try 块中包含可能会抛出异常的代码，catch 块用于捕获并处理异常，throw 关键字用于在代码中显式地抛出异常。 下面是一个简单的 C++ 异常处理示例： #include \u003ciostream\u003e using namespace std; int main() { try { int x = 10, y = 0; if (y == 0) { throw \"Divide by zero exception\"; } int z = x / y; cout \u003c\u003c \"Result: \" \u003c\u003c z \u003c\u003c endl; } catch (const char* msg) { cerr \u003c\u003c \"Error: \" \u003c\u003c msg \u003c\u003c endl; } return 0; } 在上面的代码中，我们使用 try 块来包含可能会抛出异常的代码，如果 y 的值为 0，则使用 throw 关键字抛出一个字符串类型的异常信息；catch 块用于捕获并处理异常，这里我们捕获了一个 const char* 类型的异常信息，并将其打印到标准错误流中。 除了字符串类型的异常信息，C++ 还支持其他类型的异常信息，例如整型、浮点型和自定义类型等。在 catch 块中，我们可以根据异常类型来选择不同的处理方式。 需要注意的是，C++ 异常处理机制虽然可以帮助我们处理程序运行时的错误，但是过度使用异常处理机制也会对程序的性能和可维护性产生影响。因此，在使用异常处理机制时，我们应该尽量避免频繁抛出和捕获异常，并尽可能地将异常处理代码集中到一个地方，以提高程序的可读性和可维护性。 C++异常处理的底层原理主要涉及3个方面：抛出异常、捕获异常和栈展开。 当程序执行过程中发生错误时，会通过throw语句抛出一个异常。throw语句将异常对象传递到栈上，然后继续往上传递直到被捕获或者到达程序的最外层。 当异常被抛出后，程序会在调用栈上查找符合类型匹配的catch子句。如果找到匹配的catch子句，则程序会跳转到该catch子句的代码块中继续执行，并且执行完成后不会再返回到抛出异常的位置。 如果没有找到符合类型匹配的catch子句，则程序会沿着调用栈继续查找，直到到达程序的最外层。如果在整个调用栈上都没有找到合适的catch子句，则程序会终止并输出未处理的异常信息。 栈展开是指当异常被抛出时，程序会回溯调用栈，并且在每个函数中查找是否存在try-catch块。如果存在，则程序会在该try-catch块中查找是否有匹配的catch子句，并且执行相应的操作。如果不存在，则程序会继续向上回溯调用栈，直到找到匹配的catch子句或者到达程序的最外层。 总之，C++异常处理的底层原理是通过在调用栈上传递和捕获异常对象，并且执行栈展开来实现的。这种机制使得程序可以在发生错误时，及时地停止当前操作，并且提供一种机制来处理和恢复执行过程中出现的错误。 ","date":"2022-07-28","objectID":"/cxx_basic/:14:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#异常处理"},{"categories":["编程语言"],"content":"C++提高笔记","date":"2022-07-28","objectID":"/cxx_enhance/","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 C++模板笔记 ","date":"2022-07-28","objectID":"/cxx_enhance/:0:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#"},{"categories":["编程语言"],"content":" 1 类和对象 类的访问属性 类的继承属性 public(公共) 公共成员变量和方法可以被类的任何对象访问，也可以被其他类的对象访问。 protected(受保护的) 受保护的成员变量和方法可以被同一个类内的其他成员访问，也可以被该类的子类访问，但不能被其他类的对象访问。受保护的成员变量和方法可以被同一个类内的其他成员访问，也可以被该类的子类访问，但不能被其他类的对象访问。 private (私有) 私有成员变量和方法只能被同一个类内的其他成员（包括其他方法和构造函数）访问，而不能被类的对象或其他类的对象访问。 继承属性\\访问属性 public protected private public public protected private protected private private private private #include \u003ciostream\u003e class BaseClass { private: int BaseClassPrivate; public: int BaseClassPublic; void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } protected: int BaseClassProtected; }; class DerivedClassPublic : public BaseClass { void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } }; class DerivedClassPrivate : private BaseClass { void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } }; class DerivedClassProtected: protected BaseClass { void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } }; class DerivedClassPublicPublic : public DerivedClassPublic{ void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } }; class DerivedClassPrivatePublic : public DerivedClassPrivate{ void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } }; class DerivedClassProtectedPublic : public DerivedClassProtected { void read() { BaseClassPrivate = 1; BaseClassPublic = 1; BaseClassProtected = 1; } }; int main(int argc, char* argv[]) { BaseClass O0; DerivedClassPublic O1; DerivedClassPrivate O2; DerivedClassProtected O3; DerivedClassPublicPublic O4; DerivedClassPrivatePublic O5; DerivedClassProtectedPublic O6; O0.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O0.BaseClassPublic = 1; // 正确: O0.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context O1.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O1.BaseClassPublic = 1; // 正确: O1.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context O2.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O2.BaseClassPublic = 1; // 正确: O2.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context O3.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O3.BaseClassPublic = 1; // 正确: O3.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context O4.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O4.BaseClassPublic = 1; // 正确: O4.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context O5.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O5.BaseClassPublic = 1; // 正确: O5.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context O6.BaseClassPrivate = 1; // 错误: 'int BaseClass::BaseClassPrivate' is private within this context O6.BaseClassPublic = 1; // 正确: O6.BaseClassProtected = 1; // 错误: 'int BaseClass::BaseClassProtected' is protected within this context return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:1:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类和对象"},{"categories":["编程语言"],"content":" 1.1 成员函数 成员函数 + delete表示删除此函数 成员函数 + default表示默认函数 explicit: 关闭隐式类型转换 关键字只能作用域类构造函数 只作用单个参数的构造函数 final: 第一个用在类，用于说明该类是继承体系下最后的一个类，不要其他类继承我，当继承时就会报错。 第二个用在虚函数，表示这个虚函数不能再被override了，再override就会报错 数据成员强化 在 C++ 中，mutable 是一个关键字，它用于修饰某些类成员变量。mutable 的作用是允许在 const 成员函数中修改被 mutable 修饰的成员变量。 如果一个成员变量被声明为 mutable，那么即使在一个const成员函数中，也可以修改该成员变量的值。这个特性在一些特殊情况下非常有用，例如在维护缓存、统计调用次数或者记录日志时。 例如： class MyClass { public: int get_value() const { ++call_count; // 可以修改 call_count 值 return value; } private: int value; mutable int call_count = 0; // 被 mutable 修饰的成员变量 }; 在上面的例子中，call_count 成员变量被声明为 mutable，因此即使在 get_value() 函数中，也可以对它进行修改。 需要注意的是，只有被声明为 mutable 的成员变量才能在 const 成员函数中修改，其他成员变量则不能被修改。这也符合 const 成员函数的语义，即不能修改对象状态。 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员函数"},{"categories":["编程语言"],"content":" 1.2 虚函数与虚函数表虚函数是一种特殊的成员函数，它允许派生类覆盖基类中的同名函数，并通过基类指针或引用调用派生类中的实现。具体来说，当通过基类指针或引用调用一个虚函数时，编译器会根据对象的实际类型（即运行时类型）来确定要调用哪个版本的函数。 在类定义中，可以将成员函数声明为虚函数，如下所示： class Base { public: virtual void foo() { std::cout \u003c\u003c \"Base::foo()\" \u003c\u003c std::endl; } }; class Derived : public Base { public: void foo() override { std::cout \u003c\u003c \"Derived::foo()\" \u003c\u003c std::endl; } }; 这里，Base 类定义了一个名为 foo() 的虚函数，在 Derived 中进行了重写。注意到在 Derived 中，我们使用了 override 关键字，这是 C++11 中的新特性，用于明确表示我们正在重写一个虚函数。如果基类中并没有该函数，则编译器会给出错误提示。 对于一个虚函数，有以下几个注意点： 虚函数必须通过指针或引用调用才能实现动态多态。 构造函数不能是虚函数，因为在对象构造期间虚表还未建立。 静态函数和成员函数不能是虚函数，因为它们不属于对象，不存在多态。 虚函数是实现 C++ 运行时多态的关键机制之一，它使得基类指针或引用在运行时能够调用派生类中的函数，从而实现基于实际对象类型的动态绑定。 总结: override用于虚函数,上面的virtual void func(int)实际上不是重写父类的虚函数,而是定义一个新的虚函数; 我们的本意是重写虚函数,当不加overrride的时候,这样写编译器不会报错 那如果像下面加上override的话，则会报错，表示告诉了编译器，我确实要重写，但写错了，没有重写，于是就报错了 这样就能给我们对虚函数的重写做检查! 虚函数表（Virtual Table），也称为 V-Table，是实现 C++ 运行时多态的关键机制之一。每个包含虚函数的类都有一个与之对应的虚函数表。 虚函数表是一个指向虚函数地址的指针数组，其中存储了该类及其所有派生类中的所有虚函数的地址。通常情况下，虚函数表位于类对象实例的内存布局末尾，因此可以通过类对象的地址来访问。 class Base { public: virtual void func1() { std::cout \u003c\u003c \"Base::func1()\" \u003c\u003c std::endl; } virtual void func2() { std::cout \u003c\u003c \"Base::func2()\" \u003c\u003c std::endl; } }; class Derived : public Base { public: void func1() override { std::cout \u003c\u003c \"Derived::func1()\" \u003c\u003c std::endl; } void func3() { std::cout \u003c\u003c \"Derived::func3()\" \u003c\u003c std::endl; } }; 在上述代码中，虚函数表会包含两个指针，分别指向 Base::func1() 和 Base::func2() 的实现。由于 Derived 重写了 Base::func1()，因此它需要自己的虚函数表，并在第一个指针中存储 Derived::func1() 的地址。另外，由于 Derived 中定义了一个非虚函数 func3()，因此它不会出现在虚函数表中。 当我们使用基类指针或引用调用虚函数时，编译器会在运行时根据对象的实际类型（即运行时类型）查找正确的虚函数地址，并进行动态绑定。 g++ -fdump-lang-class test.cpp cl /d1 reportSingleClassLayoutDerived \"test.cpp\" 下面是msvc表现 cl /d1 reportSingleClassLayoutDerived \"test.cpp\" 用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.30.30709 版 版权所有(C) Microsoft Corporation。保留所有权利。 test.cpp class Derived size(4): +--- 0 | +--- (base class Base) 0 | | {vfptr} | +--- +--- Derived::$vftable@: | \u0026Derived_meta | 0 0 | \u0026Derived::func1 1 | \u0026Base::func2 Derived::func1 this adjustor: 0 C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.30.30705\\include\\ostream(743): warning C4530: 使用了 C++ 异常处理程序，但未启用展开语义。请指定 /EHsc test.cpp(4): note: 查看对正在编译的函数 模板 实例化“std::basic_ostream\u003cchar,std::char_traits\u003cchar\u003e\u003e \u0026std::operator \u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(std::basic_ostream\u003cchar,std::char_traits\u003cchar\u003e\u003e \u0026,const char *)”的引用 Microsoft (R) Incremental Linker Version 14.30.30709.0 Copyright (C) Microsoft Corporation. All rights reserved. /out:test.exe test.obj ","date":"2022-07-28","objectID":"/cxx_enhance/:1:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数与虚函数表"},{"categories":["编程语言"],"content":" 1.3 class与struct的区别 默认访问控制：对于类(class)来说，默认情况下成员是私有(private)的，而结构体(struct)的成员默认是公有(public)的。 成员函数：类(class)允许在内部声明成员函数，而结构体(struct)不允许。但是，在C++11标准后，结构体也可以定义成员函数了。 继承：类(class)和结构体(struct)都支持继承，但是类(class)默认是私有继承(private inheritance)，而结构体(struct)默认是公有继承(public inheritance)。 类型转换：类(class)可以定义类型转换操作符，而结构体(struct)不行。 使用习惯：通常情况下，当我们需要描述一个“轻量级”的数据类型时，用结构体(struct)更合适；而当我们需要描述一个“重量级”的数据类型时，用类(class)更为恰当。 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#class与struct的区别"},{"categories":["编程语言"],"content":" 1.4 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数和析构函数"},{"categories":["编程语言"],"content":" 1.5 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 构造函数强化 在 C++ 中，explicit 是一个关键字，它用于修饰构造函数，它的主要作用是防止编译器进行隐式转换。 具体来说，如果一个构造函数被声明为 explicit，那么它就只能用于显式地创建一个新对象，而不能被用于隐式地转换一个类型到另一个类型。这样可以避免一些不必要的类型转换导致的错误，同时也使代码更加易于理解和维护。 例如： class A { public: explicit A(int n) { /*...*/ } }; void func(A a) { /*...*/ } int main() { A a(10); // OK A b = 20; // 编译错误，禁止隐式转换 func(A(30)); // OK，显式创建一个 A 类型的对象 } 在上面的例子中，因为 A 的构造函数被声明为 explicit，所以只能通过显式地调用构造函数来创建一个 A 对象，而不能通过将一个 int 类型的值隐式地转换为 A 类型。 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数"},{"categories":["编程语言"],"content":" 1.6 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:6","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数的调用时机"},{"categories":["编程语言"],"content":" 1.7 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:7","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数的调用规则"},{"categories":["编程语言"],"content":" 1.8 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:8","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#深拷贝和浅拷贝"},{"categories":["编程语言"],"content":" 2 初始化列表作用:C++提供了初始化列表语法,用来初始化属性; 语法: 构造函数(): 属性1(值1),属性2(值2),属性3(值3) { /* 函数体 */ } ","date":"2022-07-28","objectID":"/cxx_enhance/:2:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#初始化列表"},{"categories":["编程语言"],"content":" 3 类对象作为类成员","date":"2022-07-28","objectID":"/cxx_enhance/:3:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类对象作为类成员"},{"categories":["编程语言"],"content":" 3.1 静态成员静态成员就是在静态成员变量和成员函数前加上static,称为静态成员; 静态成员变量 所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 class Person { public: static int age; static void func() { std::cout \u003c\u003c \"静态成员函数\" \u003c\u003c std::endl; } }; /* 通过对象访问 */ Person p; p.func(); /* 通过类访问 */ Person::func(); ","date":"2022-07-28","objectID":"/cxx_enhance/:3:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#静态成员"},{"categories":["编程语言"],"content":" 3.2 成员变量和成员函数分开存储 非静态成员, 属于类的对象 静态成员, 不属于类的对象 非静态成员函数, 不属于类的对象 静态成员函数, 不属于类的对象 空对象大小为1 ","date":"2022-07-28","objectID":"/cxx_enhance/:3:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员变量和成员函数分开存储"},{"categories":["编程语言"],"content":" 4 C++对象模型","date":"2022-07-28","objectID":"/cxx_enhance/:4:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#c对象模型"},{"categories":["编程语言"],"content":" 5 this指针this指针指向被调用成员函数所属的对象 this指针本质：指针常量 ","date":"2022-07-28","objectID":"/cxx_enhance/:5:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#this指针"},{"categories":["编程语言"],"content":" 6 空指针访问成员函数C++空指针也是可以访问成员函数的,但是要注意的this指针; ","date":"2022-07-28","objectID":"/cxx_enhance/:6:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#空指针访问成员函数"},{"categories":["编程语言"],"content":" 7 const修饰成员函数常函数: 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数 执行原理 this ==\u003e Person * const this; 后面新追加的const则会造成 const Person * const this; class Person { public: int m_A; mutable int m_B; void showPerson() const { m_A = 10; /* 错误,不可修改 */ m_B = 10; /* 正确,可以修改 */ } }; ","date":"2022-07-28","objectID":"/cxx_enhance/:7:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#const修饰成员函数"},{"categories":["编程语言"],"content":" 8 友元 全局函数 全局类 成员函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:8:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#友元"},{"categories":["编程语言"],"content":" 9 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; ","date":"2022-07-28","objectID":"/cxx_enhance/:9:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#运算符重载"},{"categories":["编程语言"],"content":" 9.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#通过成员函数重载运算符"},{"categories":["编程语言"],"content":" 9.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#通过全局函数重载"},{"categories":["编程语言"],"content":" 9.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#重载左移运算符"},{"categories":["编程语言"],"content":" 9.4 递增重载++注意: 前置递增 p++ 后置递增 ++p ","date":"2022-07-28","objectID":"/cxx_enhance/:9:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#递增重载"},{"categories":["编程语言"],"content":" 9.5 重载例子(复数) #include \u003ciostream\u003e class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#重载例子复数"},{"categories":["编程语言"],"content":" 10 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承"},{"categories":["编程语言"],"content":" 10.1 继承方式 公共继承 保护继承 私有继承 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承方式"},{"categories":["编程语言"],"content":" 10.2 继承中的对象模型","date":"2022-07-28","objectID":"/cxx_enhance/:10:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承中的对象模型"},{"categories":["编程语言"],"content":" 10.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造和析构的顺序"},{"categories":["编程语言"],"content":" 10.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A ","date":"2022-07-28","objectID":"/cxx_enhance/:10:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承中同名成员处理"},{"categories":["编程语言"],"content":" 11 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 ","date":"2022-07-28","objectID":"/cxx_enhance/:11:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#多重继承"},{"categories":["编程语言"],"content":" 11.1 菱形继承菱形继承是指一个派生类同时继承自两个直接或间接基类，而这两个基类又共同继承自同一个虚基类的情况。这样就会出现一个“菱形”继承结构，其中最顶层的虚基类在派生类中只存在一份实例，而不会被重复继承。 孙子类继承了子类1和子类2,但是继承了两次父类。 +---------+ | Shape | +---------+ | +---------+ | Point | +---------+ / \\ +------+ +------+ | Line | | Circle | +------+ +------+ | +---------+ | Draw | +---------+ 内存浪费：由于派生类继承了多个基类，如果这些基类中有相同的成员变量，则在最终的派生类中会存在多份相同的成员变量，从而导致内存浪费。 成员访问二义性：由于派生类同时继承了多个基类，因此可能会出现成员函数重名的情况，从而导致成员访问二义性。 为了解决这些问题，C++11 标准引入了关键字 final 和 override，可以在派生类中使用这两个关键字对继承关系进行限定和覆盖。此外，C++11 标准还引入了虚继承（virtual inheritance）的概念，可以避免多次继承同一个虚基类所带来的问题。 那么final与override是如何保证继承的 在C++中，final和override是两个关键字，用于控制虚函数的行为。 final: final可以修饰类、函数和变量。当final修饰一个类时，该类不能被继承；当final修饰一个虚函数时，该虚函数不能被派生类重写（即不能被覆盖）。 例如，下面的代码定义了一个基类Animal和一个派生类Cat。Cat中的meow()方法被声明成final，因此任何尝试对该方法进行覆盖的操作都会导致编译错误。 class Animal { public: virtual void make_sound() const = 0; }; class Cat : public Animal { public: void make_sound() const override { std::cout \u003c\u003c \"Meow\\n\"; } virtual void meow() const final { std::cout \u003c\u003c \"Meow Meow\\n\"; } }; class Garfield : public Cat { public: void make_sound() const override { std::cout \u003c\u003c \"Purr\\n\"; } // 下面这行会导致编译错误 // void meow() const override {} }; override: override也是一个关键字，用于指示当前的函数是一个重写父类中同名虚函数的函数，从而提高代码可读性和健壮性。 例如，上面的代码中，派生类Garfield重写了虚函数make_sound()，我们可以使用override关键字来明确表示这一点。 class Garfield : public Cat { public: void make_sound() const override { std::cout \u003c\u003c \"Purr\\n\"; } // 明确指示当前函数是重写父类中的虚函数 void meow() const override {} }; 总之，C++中的final和override关键字用于控制虚函数的行为，final表示一个虚函数不能再被重写，而override则用于明确表示一个函数是重写了父类中同名虚函数的函数。 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ ","date":"2022-07-28","objectID":"/cxx_enhance/:11:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#菱形继承"},{"categories":["编程语言"],"content":" 11.2 虚基类指针(vbptr)graph LR vbptr --\u003e vbtable ","date":"2022-07-28","objectID":"/cxx_enhance/:11:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚基类指针vbptr"},{"categories":["编程语言"],"content":" 12 多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数; 有继承关系 子类重写父类的虚函数 重写：函数完全一致 ","date":"2022-07-28","objectID":"/cxx_enhance/:12:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#多态"},{"categories":["编程语言"],"content":" 13 虚函数 只要有一个纯虚函数，就称为抽象类 抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 ","date":"2022-07-28","objectID":"/cxx_enhance/:13:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数"},{"categories":["编程语言"],"content":" 13.1 虚析构和纯虚析构虚析构函数是一个带有virtual关键字的类析构函数。它允许子类对象在被删除时调用它们自己的析构函数。这样可以确保在父类指针指向子类对象并且父类指针被delete时能正确地调用子类析构函数。 纯虚析构函数是一个虚析构函数，在其函数声明后面加上\"= 0\"来表示它是一个纯虚析构函数。它没有函数体，所有的派生类都必须实现自己的析构函数。纯虚析构函数使得基类成为了抽象类，不能直接被实例化。纯虚析构函数的作用是强制派生类实现自己的析构函数，以确保在对象被销毁时能正确地释放资源。 #include \u003ciostream\u003e class Base { public: virtual ~Base() { std::cout \u003c\u003c \"Base destructor called\" \u003c\u003c std::endl; } }; class Derived : public Base { public: ~Derived() { std::cout \u003c\u003c \"Derived destructor called\" \u003c\u003c std::endl; } }; class Abstract { public: virtual ~Abstract() = 0; }; Abstract::~Abstract() {} class Concrete : public Abstract { public: ~Concrete() { std::cout \u003c\u003c \"Concrete destructor called\" \u003c\u003c std::endl; } }; int main() { Base* b = new Derived(); delete b; Abstract* a = new Concrete(); delete a; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:13:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚析构和纯虚析构"},{"categories":["编程语言"],"content":" 14 C++对象模型(入门版) C++对象模型研究什么? 研究系统内部底层的各种实现,“继承性, 多态性”,更多的是围绕类和对象来讨论 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#c对象模型入门版"},{"categories":["编程语言"],"content":" 14.1 类对象所占的空间 14.1.1 最少也需要一个大小去保存地址在C++中，空类（即没有成员变量和成员函数的类）的大小不为零。这是因为C++要确保每个对象都有一个唯一的地址，即使是空类也不例外。 根据C++标准的规定，一个空类的大小至少为1字节。这是因为对于任何对象，它占用的内存空间至少应该是1字节，以便能够获得一个唯一的地址。 虽然空类本身不包含任何数据成员，但是编译器通常会为空类添加一个字节的额外内存来确保其大小不为零。这样做是为了满足对空类对象的唯一性要求。 需要注意的是，空类的大小可能会受到编译器的优化影响。某些编译器可能会使用更小的大小来表示空类对象，但至少会满足标准规定的最小大小为1字节。 #include \u003ciostream\u003e using namespace std; class A { public: }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.2 类的成员函数不占用类对象空间 #include \u003ciostream\u003e using namespace std; class A { public: void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.3 成员变量是占用内存空间的此时，如果新增一个变量 #include \u003ciostream\u003e using namespace std; class A { public: char a; void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 此时的结果还是1,那么，大小是谁呢? 类中的一个char成员 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类对象所占的空间"},{"categories":["编程语言"],"content":" 14.1 类对象所占的空间 14.1.1 最少也需要一个大小去保存地址在C++中，空类（即没有成员变量和成员函数的类）的大小不为零。这是因为C++要确保每个对象都有一个唯一的地址，即使是空类也不例外。 根据C++标准的规定，一个空类的大小至少为1字节。这是因为对于任何对象，它占用的内存空间至少应该是1字节，以便能够获得一个唯一的地址。 虽然空类本身不包含任何数据成员，但是编译器通常会为空类添加一个字节的额外内存来确保其大小不为零。这样做是为了满足对空类对象的唯一性要求。 需要注意的是，空类的大小可能会受到编译器的优化影响。某些编译器可能会使用更小的大小来表示空类对象，但至少会满足标准规定的最小大小为1字节。 #include using namespace std; class A { public: }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.2 类的成员函数不占用类对象空间 #include using namespace std; class A { public: void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.3 成员变量是占用内存空间的此时，如果新增一个变量 #include using namespace std; class A { public: char a; void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 此时的结果还是1,那么，大小是谁呢? 类中的一个char成员 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#最少也需要一个大小去保存地址"},{"categories":["编程语言"],"content":" 14.1 类对象所占的空间 14.1.1 最少也需要一个大小去保存地址在C++中，空类（即没有成员变量和成员函数的类）的大小不为零。这是因为C++要确保每个对象都有一个唯一的地址，即使是空类也不例外。 根据C++标准的规定，一个空类的大小至少为1字节。这是因为对于任何对象，它占用的内存空间至少应该是1字节，以便能够获得一个唯一的地址。 虽然空类本身不包含任何数据成员，但是编译器通常会为空类添加一个字节的额外内存来确保其大小不为零。这样做是为了满足对空类对象的唯一性要求。 需要注意的是，空类的大小可能会受到编译器的优化影响。某些编译器可能会使用更小的大小来表示空类对象，但至少会满足标准规定的最小大小为1字节。 #include using namespace std; class A { public: }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.2 类的成员函数不占用类对象空间 #include using namespace std; class A { public: void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.3 成员变量是占用内存空间的此时，如果新增一个变量 #include using namespace std; class A { public: char a; void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 此时的结果还是1,那么，大小是谁呢? 类中的一个char成员 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类的成员函数不占用类对象空间"},{"categories":["编程语言"],"content":" 14.1 类对象所占的空间 14.1.1 最少也需要一个大小去保存地址在C++中，空类（即没有成员变量和成员函数的类）的大小不为零。这是因为C++要确保每个对象都有一个唯一的地址，即使是空类也不例外。 根据C++标准的规定，一个空类的大小至少为1字节。这是因为对于任何对象，它占用的内存空间至少应该是1字节，以便能够获得一个唯一的地址。 虽然空类本身不包含任何数据成员，但是编译器通常会为空类添加一个字节的额外内存来确保其大小不为零。这样做是为了满足对空类对象的唯一性要求。 需要注意的是，空类的大小可能会受到编译器的优化影响。某些编译器可能会使用更小的大小来表示空类对象，但至少会满足标准规定的最小大小为1字节。 #include using namespace std; class A { public: }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.2 类的成员函数不占用类对象空间 #include using namespace std; class A { public: void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.1.3 成员变量是占用内存空间的此时，如果新增一个变量 #include using namespace std; class A { public: char a; void func1() {} void func2() {} void func3() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 此时的结果还是1,那么，大小是谁呢? 类中的一个char成员 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员变量是占用内存空间的"},{"categories":["编程语言"],"content":" 14.2 对象结构的发展和演化 14.2.1 非静态成员变量跟着对象走 #include \u003ciostream\u003e using namespace std; class A { public: int a; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.2 静态成员变量跟着类走 保存在类中， 对象外面 #include \u003ciostream\u003e using namespace std; class A { public: int a; static int b; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.3 成员函数成员函数: 无论是静态还是非静态都是保存在类上 14.2.4 虚函数 #include \u003ciostream\u003e using namespace std; class A { public: virtual void func1() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 只要存在一个虚函数，大小就会多8个字节； 类 –\u003e 虚函数表的指针 –\u003e 指向虚函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#对象结构的发展和演化"},{"categories":["编程语言"],"content":" 14.2 对象结构的发展和演化 14.2.1 非静态成员变量跟着对象走 #include using namespace std; class A { public: int a; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.2 静态成员变量跟着类走 保存在类中， 对象外面 #include using namespace std; class A { public: int a; static int b; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.3 成员函数成员函数: 无论是静态还是非静态都是保存在类上 14.2.4 虚函数 #include using namespace std; class A { public: virtual void func1() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 只要存在一个虚函数，大小就会多8个字节； 类 –\u003e 虚函数表的指针 –\u003e 指向虚函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#非静态成员变量跟着对象走"},{"categories":["编程语言"],"content":" 14.2 对象结构的发展和演化 14.2.1 非静态成员变量跟着对象走 #include using namespace std; class A { public: int a; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.2 静态成员变量跟着类走 保存在类中， 对象外面 #include using namespace std; class A { public: int a; static int b; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.3 成员函数成员函数: 无论是静态还是非静态都是保存在类上 14.2.4 虚函数 #include using namespace std; class A { public: virtual void func1() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 只要存在一个虚函数，大小就会多8个字节； 类 –\u003e 虚函数表的指针 –\u003e 指向虚函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#静态成员变量跟着类走"},{"categories":["编程语言"],"content":" 14.2 对象结构的发展和演化 14.2.1 非静态成员变量跟着对象走 #include using namespace std; class A { public: int a; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.2 静态成员变量跟着类走 保存在类中， 对象外面 #include using namespace std; class A { public: int a; static int b; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.3 成员函数成员函数: 无论是静态还是非静态都是保存在类上 14.2.4 虚函数 #include using namespace std; class A { public: virtual void func1() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 只要存在一个虚函数，大小就会多8个字节； 类 –\u003e 虚函数表的指针 –\u003e 指向虚函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员函数-1"},{"categories":["编程语言"],"content":" 14.2 对象结构的发展和演化 14.2.1 非静态成员变量跟着对象走 #include using namespace std; class A { public: int a; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.2 静态成员变量跟着类走 保存在类中， 对象外面 #include using namespace std; class A { public: int a; static int b; }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 14.2.3 成员函数成员函数: 无论是静态还是非静态都是保存在类上 14.2.4 虚函数 #include using namespace std; class A { public: virtual void func1() {} }; int main() { A obj_a; cout \u003c\u003c \"sizeof(A) = \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(obj_a) = \" \u003c\u003c sizeof(obj_a) \u003c\u003c endl; } 只要存在一个虚函数，大小就会多8个字节； 类 –\u003e 虚函数表的指针 –\u003e 指向虚函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数-1"},{"categories":["编程语言"],"content":" 14.3 this指针调整 #include \u003ciostream\u003e using namespace std; class A { public: int a; A() { printf(\"A:[%s]的this指针是: %p\\r\\n\", __func__, this); } void funcA() { printf(\"A:[%s]的this指针是: %p\\r\\n\", __func__, this); } }; class B { public: int b; B() { printf(\"A:[%s]的this指针是: %p\\r\\n\", __func__, this); } void funcB() { printf(\"A:[%s]的this指针是: %p\\r\\n\", __func__, this); } }; class C : public A, public B { public: int c; C() { printf(\"A:[%s]的this指针是: %p\\r\\n\", __func__, this); } void funcC() { printf(\"A:[%s]的this指针是: %p\\r\\n\", __func__, this); } }; int main() { cout \u003c\u003c \"sizeof(A) \" \u003c\u003c sizeof(A) \u003c\u003c endl; cout \u003c\u003c \"sizeof(B) \" \u003c\u003c sizeof(B) \u003c\u003c endl; cout \u003c\u003c \"sizeof(C) \" \u003c\u003c sizeof(C) \u003c\u003c endl; // this指针,多重继承 C myc; myc.funcA(); myc.funcB(); myc.funcC(); return EXIT_SUCCESS; } 当前执行的结果 sizeof(A) 4 # 一个成员变量 sizeof(B) 4 # 一个成员变量 sizeof(C) 12 # 一个成员变量 + 继承的两个成员变量 A:[A]的this指针是: 00000077968FF798 A:[B]的this指针是: 00000077968FF79C A:[C]的this指针是: 00000077968FF798 A:[funcA]的this指针是: 00000077968FF798 A:[funcB]的this指针是: 00000077968FF79C A:[funcC]的this指针是: 00000077968FF798 D:\\work\\test\\obj\\x64\\Debug\\obj.exe (进程 19444)已退出，代码为 0。 按任意键关闭此窗口. . . 可以看出类A和类C的起始地址相同,但是怎么理解呢? 派生类对象包含基类子对象的 如果派生类只有一个父对象，那么派生类和基类子对象地址相同 如果继承多个父对象，那么开始地址和第一个基类子对象相同 ","date":"2022-07-28","objectID":"/cxx_enhance/:14:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#this指针调整"},{"categories":["编程语言"],"content":" 14.4 构造函数语意","date":"2022-07-28","objectID":"/cxx_enhance/:14:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数语意"},{"categories":["编程语言"],"content":" 14.5 拷贝构造函数语意","date":"2022-07-28","objectID":"/cxx_enhance/:14:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数语意"},{"categories":["编程语言"],"content":" 14.6 程序转化语意","date":"2022-07-28","objectID":"/cxx_enhance/:14:6","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#程序转化语意"},{"categories":["编程语言"],"content":" 14.7 程序的优化","date":"2022-07-28","objectID":"/cxx_enhance/:14:7","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#程序的优化"},{"categories":["编程语言"],"content":" 14.8 成员初始化列表","date":"2022-07-28","objectID":"/cxx_enhance/:14:8","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员初始化列表"},{"categories":["编程语言"],"content":"C++增强笔记","date":"2022-07-28","objectID":"/cxx_advance/","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 C++模板笔记 ","date":"2022-07-28","objectID":"/cxx_advance/:0:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#"},{"categories":["编程语言"],"content":" 1 C++对象模型(深入版) 对象模型是一种描述计算机程序中的对象及其相互关系的方式。在面向对象编程中，每个对象都有一个类型、属性和方法。对象之间可以相互通信，从而实现特定的任务。 在对象模型中，对象类是描述对象的通用模板。每个类都有一组属性和方法，它们定义了该类的行为。当我们创建一个对象时，我们使用该类来生成该对象，并且该对象将具备该类所定义的属性和方法。 对象之间可以通过消息传递进行通信。消息包含了一个方法调用请求，接收者也就是被调用的对象会执行该方法，并将结果返回给发送者。这种方式实现了数据和操作的封装，使得程序的实现更加模块化和灵活。 总之，对象模型是一种以对象为基本单位的编程范式，通过对对象的抽象，实现了高度复用性、可扩展性和可维护性的程序设计。 ","date":"2022-07-28","objectID":"/cxx_advance/:1:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#c对象模型深入版"},{"categories":["编程语言"],"content":" 1.1 关于对象(Object Lessons)在C++中农, Point3d可以 使用独立的抽象数据类型(abstract data types ADT) class Point3d { public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : _x(x), _y(y), _z(z) {} float x() const { return _x; } float y() const { return _y; } float z() const { return _z; } private: float _x; float _y; float _z; }; inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 双层或者三层class体系 class Point { public: Point(float x = 0.0) : _x(x) {} float x() const { return _x; } void x(float val = 0.0) { _x = val; } protected: float _x; }; class Point2d : public Point { public: Point2d(float x = 0.0, float y = 0.0) : Point(x), _y(y) {} float y() const { return _y; } void y(float val = 0.0) { _y = val; } protected: float _y; }; class Point3d : public Point2d { public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), _z(z) {} float z() const { return _z; } void z(float val = 0.0) { _z = val; } protected: float _z; }; inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 更近一步，不管哪一种形式，他们都可以被参数化,也可以坐标参数化 template\u003cclass T\u003e class Point3d { public: Point3d(T x = 0.0, T y = 0.0, T z = 0.0) : _x(x), _y(y), _z(z) {} T x() const { return _x; } T y() const { return _y; } T z() const { return _z; } private: T _x; T _y; T _z; }; template\u003cclass T\u003e inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d\u003cT\u003e \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 也可以是坐标类型和坐标数目都参数化 template\u003cclass T, int dim\u003e class Point { public: Point(); Point(T coords[dim]) { for (int index = 0; index \u003c dim; index++) { _coords[index] = coords[index]; } } T\u0026 operator[](int index) { assert(index \u003c dim \u0026\u0026 index \u003e= 0); return _coords[index]; } T operator[](int index) const { assert(index \u003c dim \u0026\u0026 index \u003e= 0); return _coords[index]; } private: T _coords[dim]; }; template\u003cclass T, int dim\u003e inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point\u003cT, dim\u003e \u0026pt) { os \u003c\u003c '{'; for (int i = 0; i \u003c= dim - 1; i++) { os \u003c\u003c pt[i] \u003c\u003c \";\"; } os \u003c\u003c '}'; return os; } 加上封装后的布局成本 virtual function机制 virtual base class机制 1.1.1 C++对象模型在C++中,有两种class data member: static和nonstatic 有三种class function member: static,nonstatic与virtual 已知下面的class point的声明: class Point { public: Point(float val); virtual ~Point(); float x() const; static int PointCount(); protected: virtual ostream\u0026 print(ostream \u0026os) const; float _x; static int _point_count; } 那么这个class point在机器中将会怎么样表现呢?也就是说我们如何模型(modeling)出各种data member与function member呢? C++ 对象模型(The C++ Object Model ) C++之父的最终设想 Stroustrup 当初设计 （ 当前亦仍占有优势） 的 C＋＋ 对象模型是从简单对象 模 型派生而来的 ，并对内存空间和存取时间做了优化 ．在此模型中，Nonstatic data members 被配置于每一 个 class object 之内 ，static data members 则被存放在所有 的 class object 之外. Static 和 nonstatic function members 也被放在所有的 class object 之外. Virtual functions 则以两个步骤支持之 ： 每一 个 class 产 生 出一 堆 始 向 virtual functions 的指 针 ，放 在 表 格 之 中．这 个表格被称为 virtuaI table (vtbl） 每 一 个 class object 被添加一 个指针，指向相关 的 virtual table . 通 常 这个指针被 称为 vptr。 vptr的设定 （ setting ） 和重 置 （ resetting ） 都 由 每 一 个 class的 constructor, destructor和 copy assignment 运算符自动完成，每一个class 所关联 的 type_info object（ 用以支持 runtime type identification, RTTI) 经由virtualtable被指出来，通 常是放在表格的第一个slot 处 ． 图 1.3 说明 C＋＋ 对象模型如何应用于前面所说的 Point class 身上。这个模型的主要优点在于它的空间和存取时间的效率 ；主要缺点则是 ，如果应用程序代码本身未曾改变，但所用到的 class objects 的 nonstatic data members 有所修改（ 可能是增加、移除或更改 ）， 那么那些应用程序代码 同样得重新编译 ．关于这 点，前述的双表格模型就提供了较大的 弹性 ，因为它多提供了一 层间接性 。不过，它也因此付出空间和执行效率两方面的代价就是了。 加上继承（Adding Inheritance) C++支持的单一继承 class Libray_materials {...}; class Book : public Libray_materials {...}; class Rental_book : public Book {...}; C++也支持多重继承 // 原本iostream的实现方式 class iostream: public istream, public ostream {...}; 甚至，继承关系也可以指定为虚拟(virtaul,也就是共享的意思) class istream : virtual public ios {...}; class ostream : virtual public ios {...}; graph TD ios --\u003e ostream ios --\u003e istream ostream --\u003e iostream istream --\u003e iostream 在虚拟继承的情况下, base class 不管在继承串链中被派生 （ deri","date":"2022-07-28","objectID":"/cxx_advance/:1:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#关于对象object-lessons"},{"categories":["编程语言"],"content":" 1.1 关于对象(Object Lessons)在C++中农, Point3d可以 使用独立的抽象数据类型(abstract data types ADT) class Point3d { public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : _x(x), _y(y), _z(z) {} float x() const { return _x; } float y() const { return _y; } float z() const { return _z; } private: float _x; float _y; float _z; }; inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 双层或者三层class体系 class Point { public: Point(float x = 0.0) : _x(x) {} float x() const { return _x; } void x(float val = 0.0) { _x = val; } protected: float _x; }; class Point2d : public Point { public: Point2d(float x = 0.0, float y = 0.0) : Point(x), _y(y) {} float y() const { return _y; } void y(float val = 0.0) { _y = val; } protected: float _y; }; class Point3d : public Point2d { public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), _z(z) {} float z() const { return _z; } void z(float val = 0.0) { _z = val; } protected: float _z; }; inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 更近一步，不管哪一种形式，他们都可以被参数化,也可以坐标参数化 template class Point3d { public: Point3d(T x = 0.0, T y = 0.0, T z = 0.0) : _x(x), _y(y), _z(z) {} T x() const { return _x; } T y() const { return _y; } T z() const { return _z; } private: T _x; T _y; T _z; }; template inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 也可以是坐标类型和坐标数目都参数化 template class Point { public: Point(); Point(T coords[dim]) { for (int index = 0; index \u003c dim; index++) { _coords[index] = coords[index]; } } T\u0026 operator[](int index) { assert(index \u003c dim \u0026\u0026 index \u003e= 0); return _coords[index]; } T operator[](int index) const { assert(index \u003c dim \u0026\u0026 index \u003e= 0); return _coords[index]; } private: T _coords[dim]; }; template inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point \u0026pt) { os \u003c\u003c '{'; for (int i = 0; i \u003c= dim - 1; i++) { os \u003c\u003c pt[i] \u003c\u003c \";\"; } os \u003c\u003c '}'; return os; } 加上封装后的布局成本 virtual function机制 virtual base class机制 1.1.1 C++对象模型在C++中,有两种class data member: static和nonstatic 有三种class function member: static,nonstatic与virtual 已知下面的class point的声明: class Point { public: Point(float val); virtual ~Point(); float x() const; static int PointCount(); protected: virtual ostream\u0026 print(ostream \u0026os) const; float _x; static int _point_count; } 那么这个class point在机器中将会怎么样表现呢?也就是说我们如何模型(modeling)出各种data member与function member呢? C++ 对象模型(The C++ Object Model ) C++之父的最终设想 Stroustrup 当初设计 （ 当前亦仍占有优势） 的 C＋＋ 对象模型是从简单对象 模 型派生而来的 ，并对内存空间和存取时间做了优化 ．在此模型中，Nonstatic data members 被配置于每一 个 class object 之内 ，static data members 则被存放在所有 的 class object 之外. Static 和 nonstatic function members 也被放在所有的 class object 之外. Virtual functions 则以两个步骤支持之 ： 每一 个 class 产 生 出一 堆 始 向 virtual functions 的指 针 ，放 在 表 格 之 中．这 个表格被称为 virtuaI table (vtbl） 每 一 个 class object 被添加一 个指针，指向相关 的 virtual table . 通 常 这个指针被 称为 vptr。 vptr的设定 （ setting ） 和重 置 （ resetting ） 都 由 每 一 个 class的 constructor, destructor和 copy assignment 运算符自动完成，每一个class 所关联 的 type_info object（ 用以支持 runtime type identification, RTTI) 经由virtualtable被指出来，通 常是放在表格的第一个slot 处 ． 图 1.3 说明 C＋＋ 对象模型如何应用于前面所说的 Point class 身上。这个模型的主要优点在于它的空间和存取时间的效率 ；主要缺点则是 ，如果应用程序代码本身未曾改变，但所用到的 class objects 的 nonstatic data members 有所修改（ 可能是增加、移除或更改 ）， 那么那些应用程序代码 同样得重新编译 ．关于这 点，前述的双表格模型就提供了较大的 弹性 ，因为它多提供了一 层间接性 。不过，它也因此付出空间和执行效率两方面的代价就是了。 加上继承（Adding Inheritance) C++支持的单一继承 class Libray_materials {...}; class Book : public Libray_materials {...}; class Rental_book : public Book {...}; C++也支持多重继承 // 原本iostream的实现方式 class iostream: public istream, public ostream {...}; 甚至，继承关系也可以指定为虚拟(virtaul,也就是共享的意思) class istream : virtual public ios {...}; class ostream : virtual public ios {...}; graph TD ios --\u003e ostream ios --\u003e istream ostream --\u003e iostream istream --\u003e iostream 在虚拟继承的情况下, base class 不管在继承串链中被派生 （ deri","date":"2022-07-28","objectID":"/cxx_advance/:1:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#c对象模型"},{"categories":["编程语言"],"content":" 1.1 关于对象(Object Lessons)在C++中农, Point3d可以 使用独立的抽象数据类型(abstract data types ADT) class Point3d { public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : _x(x), _y(y), _z(z) {} float x() const { return _x; } float y() const { return _y; } float z() const { return _z; } private: float _x; float _y; float _z; }; inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 双层或者三层class体系 class Point { public: Point(float x = 0.0) : _x(x) {} float x() const { return _x; } void x(float val = 0.0) { _x = val; } protected: float _x; }; class Point2d : public Point { public: Point2d(float x = 0.0, float y = 0.0) : Point(x), _y(y) {} float y() const { return _y; } void y(float val = 0.0) { _y = val; } protected: float _y; }; class Point3d : public Point2d { public: Point3d(float x = 0.0, float y = 0.0, float z = 0.0) : Point2d(x, y), _z(z) {} float z() const { return _z; } void z(float val = 0.0) { _z = val; } protected: float _z; }; inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 更近一步，不管哪一种形式，他们都可以被参数化,也可以坐标参数化 template class Point3d { public: Point3d(T x = 0.0, T y = 0.0, T z = 0.0) : _x(x), _y(y), _z(z) {} T x() const { return _x; } T y() const { return _y; } T z() const { return _z; } private: T _x; T _y; T _z; }; template inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point3d \u0026pt) { os \u003c\u003c '{' \u003c\u003c pt.x() \u003c\u003c pt.y() \u003c\u003c pt.z() \u003c\u003c '}'; return os; } 也可以是坐标类型和坐标数目都参数化 template class Point { public: Point(); Point(T coords[dim]) { for (int index = 0; index \u003c dim; index++) { _coords[index] = coords[index]; } } T\u0026 operator[](int index) { assert(index \u003c dim \u0026\u0026 index \u003e= 0); return _coords[index]; } T operator[](int index) const { assert(index \u003c dim \u0026\u0026 index \u003e= 0); return _coords[index]; } private: T _coords[dim]; }; template inline std::ostream\u0026 operator \u003c\u003c (std::ostream \u0026os, const Point \u0026pt) { os \u003c\u003c '{'; for (int i = 0; i \u003c= dim - 1; i++) { os \u003c\u003c pt[i] \u003c\u003c \";\"; } os \u003c\u003c '}'; return os; } 加上封装后的布局成本 virtual function机制 virtual base class机制 1.1.1 C++对象模型在C++中,有两种class data member: static和nonstatic 有三种class function member: static,nonstatic与virtual 已知下面的class point的声明: class Point { public: Point(float val); virtual ~Point(); float x() const; static int PointCount(); protected: virtual ostream\u0026 print(ostream \u0026os) const; float _x; static int _point_count; } 那么这个class point在机器中将会怎么样表现呢?也就是说我们如何模型(modeling)出各种data member与function member呢? C++ 对象模型(The C++ Object Model ) C++之父的最终设想 Stroustrup 当初设计 （ 当前亦仍占有优势） 的 C＋＋ 对象模型是从简单对象 模 型派生而来的 ，并对内存空间和存取时间做了优化 ．在此模型中，Nonstatic data members 被配置于每一 个 class object 之内 ，static data members 则被存放在所有 的 class object 之外. Static 和 nonstatic function members 也被放在所有的 class object 之外. Virtual functions 则以两个步骤支持之 ： 每一 个 class 产 生 出一 堆 始 向 virtual functions 的指 针 ，放 在 表 格 之 中．这 个表格被称为 virtuaI table (vtbl） 每 一 个 class object 被添加一 个指针，指向相关 的 virtual table . 通 常 这个指针被 称为 vptr。 vptr的设定 （ setting ） 和重 置 （ resetting ） 都 由 每 一 个 class的 constructor, destructor和 copy assignment 运算符自动完成，每一个class 所关联 的 type_info object（ 用以支持 runtime type identification, RTTI) 经由virtualtable被指出来，通 常是放在表格的第一个slot 处 ． 图 1.3 说明 C＋＋ 对象模型如何应用于前面所说的 Point class 身上。这个模型的主要优点在于它的空间和存取时间的效率 ；主要缺点则是 ，如果应用程序代码本身未曾改变，但所用到的 class objects 的 nonstatic data members 有所修改（ 可能是增加、移除或更改 ）， 那么那些应用程序代码 同样得重新编译 ．关于这 点，前述的双表格模型就提供了较大的 弹性 ，因为它多提供了一 层间接性 。不过，它也因此付出空间和执行效率两方面的代价就是了。 加上继承（Adding Inheritance) C++支持的单一继承 class Libray_materials {...}; class Book : public Libray_materials {...}; class Rental_book : public Book {...}; C++也支持多重继承 // 原本iostream的实现方式 class iostream: public istream, public ostream {...}; 甚至，继承关系也可以指定为虚拟(virtaul,也就是共享的意思) class istream : virtual public ios {...}; class ostream : virtual public ios {...}; graph TD ios --\u003e ostream ios --\u003e istream ostream --\u003e iostream istream --\u003e iostream 在虚拟继承的情况下, base class 不管在继承串链中被派生 （ deri","date":"2022-07-28","objectID":"/cxx_advance/:1:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#对象的差异an-object-distinction"},{"categories":["编程语言"],"content":" 1.2 构造函数语意学(The Semantics of constructors) 1.2.1 Default Constructor的建构操作 1.2.2 Copy Constructor的建构操作 1.2.3 程序转换语意学(Program Transformation Semantics) 1.2.4 成员们的初始化队伍(Member Initialization List)","date":"2022-07-28","objectID":"/cxx_advance/:1:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#构造函数语意学the-semantics-of-constructors"},{"categories":["编程语言"],"content":" 1.2 构造函数语意学(The Semantics of constructors) 1.2.1 Default Constructor的建构操作 1.2.2 Copy Constructor的建构操作 1.2.3 程序转换语意学(Program Transformation Semantics) 1.2.4 成员们的初始化队伍(Member Initialization List)","date":"2022-07-28","objectID":"/cxx_advance/:1:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#default-constructor的建构操作"},{"categories":["编程语言"],"content":" 1.2 构造函数语意学(The Semantics of constructors) 1.2.1 Default Constructor的建构操作 1.2.2 Copy Constructor的建构操作 1.2.3 程序转换语意学(Program Transformation Semantics) 1.2.4 成员们的初始化队伍(Member Initialization List)","date":"2022-07-28","objectID":"/cxx_advance/:1:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#copy-constructor的建构操作"},{"categories":["编程语言"],"content":" 1.2 构造函数语意学(The Semantics of constructors) 1.2.1 Default Constructor的建构操作 1.2.2 Copy Constructor的建构操作 1.2.3 程序转换语意学(Program Transformation Semantics) 1.2.4 成员们的初始化队伍(Member Initialization List)","date":"2022-07-28","objectID":"/cxx_advance/:1:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#程序转换语意学program--transformation-semantics"},{"categories":["编程语言"],"content":" 1.2 构造函数语意学(The Semantics of constructors) 1.2.1 Default Constructor的建构操作 1.2.2 Copy Constructor的建构操作 1.2.3 程序转换语意学(Program Transformation Semantics) 1.2.4 成员们的初始化队伍(Member Initialization List)","date":"2022-07-28","objectID":"/cxx_advance/:1:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#成员们的初始化队伍member-initialization-list"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#data语意学the-semantics-of-data"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#data-member的绑定"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#data-member的布局"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#data-member的存取"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#继承与data-member"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#对象的效率"},{"categories":["编程语言"],"content":" 1.3 Data语意学(The Semantics of Data) 1.3.1 Data Member的绑定 1.3.2 Data Member的布局 1.3.3 Data Member的存取 1.3.4 “继承\"与Data Member 1.3.5 对象的效率 1.3.6 指向Data Member的指针","date":"2022-07-28","objectID":"/cxx_advance/:1:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#指向data-member的指针"},{"categories":["编程语言"],"content":" 1.4 Function语意学(The Semantics of Function) 1.4.1 纯虚函数的存在（Presence of a Pu re Virtual Function) 1.4.2 虚拟规格的存在 （Presence of a Virtual Specification ) 1.4.3 虚拟规格中const 的存在 1.4.4 重新考虑class的声明","date":"2022-07-28","objectID":"/cxx_advance/:1:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#function语意学the-semantics-of-function"},{"categories":["编程语言"],"content":" 1.4 Function语意学(The Semantics of Function) 1.4.1 纯虚函数的存在（Presence of a Pu re Virtual Function) 1.4.2 虚拟规格的存在 （Presence of a Virtual Specification ) 1.4.3 虚拟规格中const 的存在 1.4.4 重新考虑class的声明","date":"2022-07-28","objectID":"/cxx_advance/:1:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#纯虚函数的存在presence-of-a--pu-re-virtual-function"},{"categories":["编程语言"],"content":" 1.4 Function语意学(The Semantics of Function) 1.4.1 纯虚函数的存在（Presence of a Pu re Virtual Function) 1.4.2 虚拟规格的存在 （Presence of a Virtual Specification ) 1.4.3 虚拟规格中const 的存在 1.4.4 重新考虑class的声明","date":"2022-07-28","objectID":"/cxx_advance/:1:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#虚拟规格的存在-presence--of--a--virtual--specification-"},{"categories":["编程语言"],"content":" 1.4 Function语意学(The Semantics of Function) 1.4.1 纯虚函数的存在（Presence of a Pu re Virtual Function) 1.4.2 虚拟规格的存在 （Presence of a Virtual Specification ) 1.4.3 虚拟规格中const 的存在 1.4.4 重新考虑class的声明","date":"2022-07-28","objectID":"/cxx_advance/:1:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#虚拟规格中const-的存在"},{"categories":["编程语言"],"content":" 1.4 Function语意学(The Semantics of Function) 1.4.1 纯虚函数的存在（Presence of a Pu re Virtual Function) 1.4.2 虚拟规格的存在 （Presence of a Virtual Specification ) 1.4.3 虚拟规格中const 的存在 1.4.4 重新考虑class的声明","date":"2022-07-28","objectID":"/cxx_advance/:1:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#重新考虑class的声明"},{"categories":["编程语言"],"content":" 1.5 构造、析构、拷贝语意学","date":"2022-07-28","objectID":"/cxx_advance/:1:5","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#构造析构拷贝语意学"},{"categories":["编程语言"],"content":" 1.6 执行期语意学","date":"2022-07-28","objectID":"/cxx_advance/:1:6","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#执行期语意学"},{"categories":["编程语言"],"content":" 1.7 站在对象模型的类端","date":"2022-07-28","objectID":"/cxx_advance/:1:7","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#站在对象模型的类端"},{"categories":["编程语言"],"content":" 2 构造函数","date":"2022-07-28","objectID":"/cxx_advance/:2:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#构造函数"},{"categories":["编程语言"],"content":" 2.1 普通构造(默认构造函数)在C++中，构造函数是一种特殊的成员函数，其名称与类名称相同，用于初始化实例化的对象的成员变量。构造函数没有返回类型声明，并且通常被声明为公共成员函数。当创建一个对象时，构造函数被自动调用。 普通构造函数（也称为默认构造函数）是不带参数的构造函数。它可以通过一个空的参数列表来定义，如下所示： cpp class MyClass { public: MyClass() { // 构造函数代码 } }; 这个类的构造函数不需要任何参数，并且在创建对象时会自动调用。我们可以在构造函数中添加代码来初始化类的各种成员变量，例如： class MyClass { public: MyClass() { num = 0; str = \"\"; } private: int num; string str; }; 在上面的例子中，我们设置了两个私有成员变量num和str的初始值。 此外，如果您想初始化一个常量成员变量，您需要使用构造函数的成员初始化列表，如下所示： class MyClass { public: MyClass() : constVar(10) { // 构造函数代码 } private: const int constVar; }; 在上面的例子中，我们使用构造函数的成员初始化列表来初始化constVar常量成员变量。 总之，构造函数是用于初始化对象的重要部分。在设计类时，需要考虑到对象的初始化方式，以确保所有成员变量都被正确地初始化。 ","date":"2022-07-28","objectID":"/cxx_advance/:2:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#普通构造默认构造函数"},{"categories":["编程语言"],"content":" 2.2 拷贝构造在C++中，拷贝构造函数是一种特殊的构造函数，用于将一个对象复制到另一个对象。它通常用于按值传递参数或以值返回对象的情况下，从而创建一个新的独立对象。拷贝构造函数也可以用于初始化一个对象数组或在创建对象时调用默认构造函数。 拷贝构造函数有以下格式： class MyClass { public: MyClass(const MyClass\u0026 other) { // 拷贝构造函数代码 } }; 在上面的代码中，参数other是对同类对象的引用。我们可以使用other来访问它的成员变量，并将其复制到当前对象中。 以下是一个简单的拷贝构造函数示例： class MyClass { public: int num; // 普通构造函数 MyClass(int n) : num(n) {} // 拷贝构造函数 MyClass(const MyClass\u0026 other) : num(other.num) {} }; int main() { MyClass obj1(10); MyClass obj2 = obj1; // 调用拷贝构造函数 cout \u003c\u003c obj1.num \u003c\u003c endl; // 输出 10 cout \u003c\u003c obj2.num \u003c\u003c endl; // 输出 10 return 0; } 在上面的代码中，我们定义了一个MyClass类，它具有一个整数类型的成员变量num。我们定义了一个普通构造函数和一个拷贝构造函数来初始化num成员变量。在主函数中，我们创建了一个名为obj1的MyClass对象，并将其值设置为10。然后，我们使用obj1初始化了另一个MyClass对象obj2，这将调用拷贝构造函数。最后，我们输出obj1和obj2的num成员变量，结果均为10。 需要注意的是，默认情况下，C++会提供一个默认的拷贝构造函数，该函数执行浅拷贝。如果要实现深拷贝，则需要自定义拷贝构造函数来复制指向动态分配内存的指针或其他资源。 ","date":"2022-07-28","objectID":"/cxx_advance/:2:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#拷贝构造"},{"categories":["编程语言"],"content":" 2.3 移动构造在C++11之后，引入了移动语义的概念，也就是通过将资源所有权从一个对象转移到另一个对象，从而提高程序性能。移动构造函数是一种特殊的构造函数，用于实现移动语义。它通常用于将临时对象的值移动到新对象中。 移动构造函数有以下格式： class MyClass { public: MyClass(MyClass\u0026\u0026 other) noexcept { // 移动构造函数代码 } }; 在上面的代码中，参数other是对同类对象的右值引用。我们可以使用std::move(other)来访问其成员变量，并将其移动到当前对象中。需要注意的是，在移动构造函数中必须使用noexcept关键字进行标记，以确保不会抛出异常。 以下是一个简单的移动构造函数示例： class MyClass { public: int* data; size_t size; // 普通构造函数 MyClass(size_t s) : data(new int[s]), size(s) {} // 移动构造函数 MyClass(MyClass\u0026\u0026 other) noexcept : data(other.data), size(other.size) { other.data = nullptr; other.size = 0; } // 析构函数 ~MyClass() { delete[] data; } }; int main() { MyClass obj1(10); MyClass obj2(std::move(obj1)); // 调用移动构造函数 cout \u003c\u003c obj2.size \u003c\u003c endl; // 输出 10 cout \u003c\u003c obj1.size \u003c\u003c endl; // 输出 0 return 0; } 在上面的代码中，我们定义了一个MyClass类，它具有一个指向int类型的动态数组data和一个size_t类型的size成员变量。我们定义了一个普通构造函数来初始化data和size成员变量，并使用delete[]释放data内存。 然后，我们定义了一个移动构造函数，它将data和size成员变量从临时对象other中移动到当前对象中。在移动完之后，我们将临时对象other的data指针设置为nullptr，以确保不会删除已经释放的内存。 在主函数中，我们创建了一个名为obj1的MyClass对象，并将其大小设置为10。然后，我们使用std::move(obj1)将值移动到新的MyClass对象obj2中，这将调用移动构造函数。最后，我们输出obj1和obj2的size成员变量，结果分别为0和10。 需要注意的是，移动构造函数只能用于右值引用参数，不能用于左值引用或常量引用参数。 ","date":"2022-07-28","objectID":"/cxx_advance/:2:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#移动构造"},{"categories":["编程语言"],"content":" 2.4 委托构造在C++11之后，引入了委托构造函数的概念。委托构造函数是一种特殊的构造函数，可以在一个构造函数中调用另一个构造函数来完成对象的初始化。这使得代码更加简洁，减少了冗余代码的编写。 委托构造函数有以下格式： class MyClass { public: MyClass(int num, string str) : num(num), str(str) {} MyClass() : MyClass(0, \"\") {} }; 在上面的代码中，我们定义了一个MyClass类，具有两个私有成员变量num和str。我们定义了一个带参数的构造函数，以及一个不带参数的构造函数。在不带参数的构造函数中，我们通过调用带参数的构造函数并传递默认值来实现对象的初始化。这就是委托构造函数的应用。 需要注意的是，如果要在委托构造函数中使用成员初始化列表，则必须在委托构造函数调用前执行。例如： class MyClass { public: MyClass(int num, string str) : num(num), str(str) {} MyClass() : MyClass(0, \"\") { // 委托构造函数调用后，还可以添加其他构造函数代码 } }; 在上面的代码中，我们先调用委托构造函数，然后可以在构造函数中添加其他代码。 总之，委托构造函数是一种非常有用的C++11语言特性，可以使代码更加简洁和可读。 ","date":"2022-07-28","objectID":"/cxx_advance/:2:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#委托构造"},{"categories":["编程语言"],"content":" 3 移动语意 移动语义是C++11中引入的一种新特性，通过将资源的所有权从一个对象转移到另一个对象来提高程序的性能 ","date":"2022-07-28","objectID":"/cxx_advance/:3:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#移动语意"},{"categories":["编程语言"],"content":" 3.1 左值与右值 移动语意的前提: 右值引用 微软笔记 定义可以认为是赋值表达式的左右边; 左值 (lvalue): 处于赋值表达式左边 右值 (rvalue):处于赋值表达式右边 但是上面的定义也太粗糙了吧! int a = 0; // a 是左值 int b = 0; // b 是左值 int c = a + b; // c 是左值,但是a与b发生了一次右值转换 那么我们写一个例子,强行右值作为左值 int foo() { return 0; } int main() { foo() = 2; return 0; } 已启动生成… 1\u003e------ 已启动生成: 项目: obj, 配置: Debug x64 ------ 1\u003eobj.cpp 1\u003eC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Microsoft\\VC\\v170\\Microsoft.CppCommon.targets(693,5): error MSB6006: “CL.exe”已退出，代码为 2。 1\u003eD:\\work\\test\\obj\\obj.cpp(8,14): error C2106: “=”: 左操作数必须为左值 1\u003e已完成生成项目“obj.vcxproj”的操作 - 失败。 ========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ========== 我们可以清楚的明白,函数不可以赋值，但是下面的例子呢？ int\u0026 foo() { static int a = 10; return a; } int main() { foo() = 2; return 0; } 但是此时我们编译成功了？ 我们稍微读一下代码就可以明白, 我们并不是对函数进行赋值，而是对函数的返回值进行赋值 ","date":"2022-07-28","objectID":"/cxx_advance/:3:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#左值与右值"},{"categories":["编程语言"],"content":" 3.2 可修改的左值下面看一个例子 const int a = 1; a = 2; 那a是左值还是右值,很明显,左值; 为什么呢？ 于是定义需要继续精化。不是所有的左值都可以被赋值。可赋值的左值被称为 可修改左值 (modifiable lvalues) 。C99标准定义可修改左值为： […] 可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 struct 或 union，它的成员都（递归地）不应含有 const 修饰的类型。 (未完待续。。。) ","date":"2022-07-28","objectID":"/cxx_advance/:3:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#可修改的左值"},{"categories":["编程语言"],"content":" 3.3 完美转发提到完美转发，就有必要先说一下，什么是转发，什么样的转发才称得上是完美转发。 在 C++ 中，转发指的就是函数之间的参数传递（例如函数 f1 接收了一个参数 a，而后又将此参数 a 传递给了其函数体内调用的另一个函数 f2）。 而完美转发指的就是在函数之间传递参数的过程中，参数在传递后的属性保持不变（如左值仍是左值，右值仍是右值，const 修饰也会保留）。 ","date":"2022-07-28","objectID":"/cxx_advance/:3:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#完美转发"},{"categories":["编程语言"],"content":" 3.4 移动语意 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; template \u003cclass T\u003e void print_vector(vector\u003cT\u003e \u0026vec) { for (auto v : vec) { cout \u003c\u003c \"data: \" \u003c\u003c v \u003c\u003c endl; } } int main() { vector\u003cint\u003e A = {1, 2, 3, 4}; vector\u003cint\u003e B; cout \u003c\u003c \"A size: \" \u003c\u003c A.size() \u003c\u003c \"addr :\" \u003c\u003c \u0026A \u003c\u003c endl; print_vector(A); cout \u003c\u003c \"B size: \" \u003c\u003c B.size() \u003c\u003c \"addr :\" \u003c\u003c \u0026B \u003c\u003c endl; print_vector(B); B = move(A); cout \u003c\u003c \"移动之后\" \u003c\u003c endl; cout \u003c\u003c \"A size: \" \u003c\u003c A.size() \u003c\u003c \"addr :\" \u003c\u003c \u0026A \u003c\u003c endl; print_vector(A); cout \u003c\u003c \"B size: \" \u003c\u003c B.size() \u003c\u003c \"addr :\" \u003c\u003c \u0026B \u003c\u003c endl; print_vector(B); return 0; } ","date":"2022-07-28","objectID":"/cxx_advance/:3:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#移动语意-1"},{"categories":["编程语言"],"content":" 4 智能指针 智能指针是一种 C++ 的语言特性，用于管理动态分配内存的生命周期。它可以自动跟踪一个对象被多少个指针引用，并在不需要时释放对象占用的内存。 C++ 智能指针的实现一般采用 RAII（Resource Acquisition Is Initialization）技术，即资源获取即初始化。当一个智能指针对象被创建时，它会自动申请分配所需的内存空间，并将所指对象的指针保存在自己的成员变量中。当这个智能指针对象被销毁时，它会自动释放其所占用的内存空间。 ","date":"2022-07-28","objectID":"/cxx_advance/:4:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#智能指针"},{"categories":["编程语言"],"content":" 4.1 std::unique_ptr std::unique_ptr 是 C++ 11 标准中提供的一种智能指针，用于管理独占式所有权的资源。 它采用了 RAII 技术，可以自动管理资源的生命周期。 unique_ptr参考实现 std::unique_ptr 的最大特点是“独占性”，即同一时间内只能有一个 std::unique_ptr 指向一个资源（内存块、文件句柄等）。当 std::unique_ptr 对象被销毁时，它所管理的资源也会被自动释放，从而避免了内存泄漏和资源泄露等问题。 int main() { // 创建一个指向 int 类型的 unique_ptr std::unique_ptr\u003cint\u003e p1(new int(10)); std::cout \u003c\u003c *p1 \u003c\u003c std::endl; // 输出 10 // 将 p1 转移给 p2，并释放 p1 原本所管理的内存 std::unique_ptr\u003cint\u003e p2 = std::move(p1); std::cout \u003c\u003c *p2 \u003c\u003c std::endl; // 输出 10 std::cout \u003c\u003c *p1 \u003c\u003c std::endl; // 错误，p1 已不再指向有效内存,此时直接就会崩溃 // 使用 make_unique 创建一个指向数组的 unique_ptr std::unique_ptr\u003cint[]\u003e p3 = std::make_unique\u003cint[]\u003e(5); for (int i = 0; i \u003c 5; ++i) { p3[i] = i; } for (int i = 0; i \u003c 5; ++i) { std::cout \u003c\u003c p3[i] \u003c\u003c \" \"; } std::cout \u003c\u003c std::endl; // 输出 0 1 2 3 4 return 0; } ","date":"2022-07-28","objectID":"/cxx_advance/:4:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdunique_ptr"},{"categories":["编程语言"],"content":" 4.2 std::shared_ptrshared_ptr是C++11中的一种智能指针类型，可以用于管理动态分配的对象，以防止内存泄漏。 使用shared_ptr时需要注意以下几点： shared_ptr管理的对象必须是通过new关键字动态分配出来的。 如果多个shared_ptr指向同一个对象，那么该对象的引用计数会增加，当所有shared_ptr都销毁时，对象的引用计数会减少。当引用计数为0时，对象会被自动删除。这样保证了动态分配的对象不会发生内存泄漏。 shared_ptr参考实现 class MyClass { public: MyClass() { std::cout \u003c\u003c \"MyClass constructor\" \u003c\u003c std::endl; } ~MyClass() { std::cout \u003c\u003c \"MyClass destructor\" \u003c\u003c std::endl; } void sayHello() { std::cout \u003c\u003c \"Hello, world!\" \u003c\u003c std::endl; } }; int main() { std::shared_ptr\u003cMyClass\u003e ptr1(new MyClass); { std::shared_ptr\u003cMyClass\u003e ptr2 = ptr1; // 引用计数+1 std::shared_ptr\u003cMyClass\u003e ptr3(ptr1); // 引用计数+1 ptr2-\u003esayHello(); } // 引用计数-2 ptr1-\u003esayHello(); return 0; } ","date":"2022-07-28","objectID":"/cxx_advance/:4:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdshared_ptr"},{"categories":["编程语言"],"content":" 4.3 std::weak_ptrweak_ptr也是C++11中的一个智能指针类型，它可以被用来协助shared_ptr进行管理动态分配的对象。与shared_ptr不同的是，weak_ptr不会增加对象的引用计数，因此不会对对象的生命周期产生影响。 weak_ptr参考实现 weak_ptr通常用于需要访问shared_ptr所管理的对象，但又不希望影响该对象生命周期的情况，例如： 避免循环引用：当存在多个对象相互引用时，使用weak_ptr可以避免出现循环引用导致对象无法正确释放的问题。 延迟初始化：当对象的创建成本较高时，可以使用weak_ptr延迟初始化对象，只有在需要访问对象时才创建对象。这样可以提高程序的性能。 下面是一个使用weak_ptr的例子： #include \u003ciostream\u003e #include \u003cmemory\u003e class MyClass { public: MyClass() { std::cout \u003c\u003c \"MyClass constructor\" \u003c\u003c std::endl; } ~MyClass() { std::cout \u003c\u003c \"MyClass destructor\" \u003c\u003c std::endl; } void sayHello() { std::cout \u003c\u003c \"Hello, world!\" \u003c\u003c std::endl; } }; int main() { std::weak_ptr\u003cMyClass\u003e ptr1; { std::shared_ptr\u003cMyClass\u003e ptr2(new MyClass); ptr1 = ptr2; // 使用weak_ptr保存shared_ptr std::cout \u003c\u003c \"ptr2.use_count(): \" \u003c\u003c ptr2.use_count() \u003c\u003c std::endl; // 输出1 } if (!ptr1.expired()) { // 判断是否已经被释放 std::shared_ptr\u003cMyClass\u003e ptr3 = ptr1.lock(); // 获取shared_ptr ptr3-\u003esayHello(); std::cout \u003c\u003c \"ptr3.use_count(): \" \u003c\u003c ptr3.use_count() \u003c\u003c std::endl; // 输出1 } else { std::cout \u003c\u003c \"shared_ptr has been released.\" \u003c\u003c std::endl; } return 0; } 在上面的代码中，首先定义了一个名为MyClass的类，在main()函数中，使用weak_ptr对象ptr1保存了一个尚未创建的shared_ptr。接着，定义了一个名为ptr2的shared_ptr，并将其作为参数传递给了ptr1，此时该对象的引用计数为1。 在ptr2生命周期结束后，判断ptr1所指向的对象是否已经被释放，如果没有被释放，则使用lock()函数获取ptr1所指向的shared_ptr，然后调用sayHello()方法输出一条信息。 需要注意的是，由于这里是通过lock()函数获取shared_ptr，因此要确保在使用shared_ptr对象之前，要对expired()进行检查，以防止在lock()函数执行期间，shared_ptr对象已经被释放导致问题发生。 总之，weak_ptr可以有效地解决循环引用和延迟初始化等问题，同时还可以提供更为灵活的内存管理方式。 ","date":"2022-07-28","objectID":"/cxx_advance/:4:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdweak_ptr"},{"categories":["编程语言"],"content":" 5 强制类型转换","date":"2022-07-28","objectID":"/cxx_advance/:5:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#强制类型转换"},{"categories":["编程语言"],"content":" 5.1 C风格的强制转换 顾名思义，就是C强制类型转换 int main() { int i = 10; float j = (float)i; } ","date":"2022-07-28","objectID":"/cxx_advance/:5:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#c风格的强制转换"},{"categories":["编程语言"],"content":" 5.2 const_cast在 C++ 中，const_cast 是一种用于去除类型的 const 属性的强制类型转换。它可以用来将 const 变量转换为非 const 变量，或者将指向 const 对象的指针转换为指向非 const 对象的指针。 const_cast\u003ctype\u003e(expression) 其中，type 表示欲转换的目标类型，expression 表示要进行转换的表达式。需要注意的是，const_cast 只能用于去除 const 属性，如果尝试使用它来添加 const 属性或者将一种类型转换成另一种类型，则会导致未定义的行为。 一个常见的用途是通过 const_cast 去除 const 属性，以便修改对象的值。例如： const int i = 10; int\u0026 r = const_cast\u003cint\u0026\u003e(i); // 去除 i 的 const 属性 r = 20; // 修改 r 的值 需要注意的是，虽然 const_cast 可以让你去除 const 属性，但这并不意味着你可以随意修改原始对象的值。如果原始对象是 const 类型，则其值仍然不能被修改。 ","date":"2022-07-28","objectID":"/cxx_advance/:5:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#const_cast"},{"categories":["编程语言"],"content":" 5.3 static_caststatic_cast参考实现 在 C++ 中，static_cast 是一种用于进行静态类型转换的强制类型转换。它可以将一种类型转换为另一种类型，但是只能进行安全的转换，即编译器能够在编译时确定类型转换是有效的。 static_cast\u003ctype\u003e(expression) 其中，type 表示欲转换的目标类型，expression 表示要进行转换的表达式。 下面是 static_cast 常见的几种用法： 将一种算术类型转换为另一种算术类型。 例如，将一个 int 类型的变量转换成一个 float 类型的变量： int i = 10; float f = static_cast\u003cfloat\u003e(i); 将一个指针类型转换为另一个指针类型。 例如，将一个基类指针转换为派生类指针： class Base {}; class Derived : public Base {}; Base* b = new Derived; Derived* d = static_cast\u003cDerived*\u003e(b); 需要注意的是，在进行指针类型转换时，static_cast 并不能保证其结果是有效的。因此，在进行指针类型转换时应该格外谨慎，并尽可能避免使用 static_cast 进行指针类型的转换。 将一个对象转换成一个与之相关的类型。 例如，将一个结构体转换成一个 union： struct S { int i; }; union U { int i; float f; }; S s = {10}; U u = static_cast\u003cU\u003e(s); 需要注意的是，static_cast 并不能用于执行动态类型转换。如果要进行动态类型转换，则应该使用 dynamic_cast。 ","date":"2022-07-28","objectID":"/cxx_advance/:5:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#static_cast"},{"categories":["编程语言"],"content":" 5.4 dynamic_cast在 C++ 中，dynamic_cast 是一种用于进行动态类型转换的强制类型转换。它可以将一个指向基类的指针或引用转换为指向派生类的指针或引用，同时还提供了类型安全检查，避免了类型转换时出现错误。 dynamic_cast(expression) 其中，type 表示欲转换的目标类型，expression 表示要进行转换的表达式。需要注意的是，dynamic_cast 只能用于含有虚函数的类层次结构中，否则编译时会出错。 下面是 dynamic_cast 常见的几种用法： 将指向基类的指针或引用转换为指向派生类的指针或引用。 例如，将一个基类指针转换为派生类指针： class Base { public: virtual ~Base() {} }; class Derived : public Base {}; Base* b = new Derived; Derived* d = dynamic_cast\u003cDerived*\u003e(b); 需要注意的是，如果将一个指向基类的指针或引用转换为指向派生类的指针或引用失败，则 dynamic_cast 返回 nullptr（对于指针）或抛出 std::bad_cast 异常（对于引用）。 在类之间进行安全的向下转型。 例如，将一个基类指针或引用转换为指向某个派生类的指针或引用，以便访问派生类的成员函数或成员变量。 class Base { public: virtual ~Base() {} }; class Derived : public Base { public: void derivedFunc() {} }; Base* b = new Derived; Derived* d = dynamic_cast\u003cDerived*\u003e(b); if (d != nullptr) { d-\u003ederivedFunc(); } 需要注意的是，dynamic_cast 的使用应该尽可能地避免。它通常表明了不良的设计，因为它破坏了抽象基类的概念，并且会导致代码的可维护性下降。 ","date":"2022-07-28","objectID":"/cxx_advance/:5:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#dynamic_cast"},{"categories":["编程语言"],"content":" 5.5 reinterpret_cast在 C++ 中，reinterpret_cast 是一种用于进行底层类型转换的强制类型转换。它可以将一个指针或引用类型的值转换为另一种不同类型的指针或引用类型的值，而且转换是不安全的，因为它会取消类型之间的任何类型检查。 reinterpret_cast\u003ctype\u003e(expression) 其中，type 表示欲转换的目标类型，expression 表示要进行转换的表达式。需要注意的是，reinterpret_cast 可以在指针、引用、整数与指针之间进行转换，但是如果对不存在的类型使用 reinterpret_cast，则可能导致未定义的行为。 下面是 reinterpret_cast 常见的几种用法： 将一个指向某个类型的指针转换为指向另一种类型的指针。 例如，将一个 int 类型的指针转换成 char 类型的指针： int i = 10; char* p = reinterpret_cast\u003cchar*\u003e(\u0026i); 需要注意的是，由于 reinterpret_cast 取消了类型之间的任何类型检查，因此在进行指针类型转换时应该格外谨慎，并尽可能避免使用 reinterpret_cast 进行指针类型的转换。 将一个指针转换成一个整数类型。 例如，将一个指向 int 类型的指针转换为一个 unsigned long 类型的整数： int i = 10; unsigned long n = reinterpret_cast\u003cunsigned long\u003e(\u0026i); 需要注意的是，由于指针的大小和整数的大小可能不同，因此在进行指针与整数之间的转换时应该格外谨慎。 ","date":"2022-07-28","objectID":"/cxx_advance/:5:5","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#reinterpret_cast"},{"categories":["pthread"],"content":"线程局部存储分析","date":"2022-07-18","objectID":"/pthread_local_storage/","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/"},{"categories":["pthread"],"content":" 1 前言 在Linux C/C++编程时不可避免的会遇到以下的需求,全局变量线程共享;最为典型的功能则是errno,变量 在程序的任何地方都可以访问,但是不会影响到其他线程,这就是本文档说明的TLS(线程局部存储变量) 如何创建并且使用TLS? 存在下面两种方法 线程库函数 编译器提供 下面分别进行说明分析 ","date":"2022-07-18","objectID":"/pthread_local_storage/:1:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#前言"},{"categories":["pthread"],"content":" 2 线程库函数 pthread提供了函数用来处理TLS, 分别管理键值和数据 ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#线程库函数"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 j\u003cPTHREAD_DESTRUCTOR_ITERATIONS; j++) { self-\u003etsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#创建键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#销毁键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#析构调用"},{"categories":["pthread"],"content":" 2.2 数据 void *pthread_getspecific(pthread_key_t); int pthread_setspecific(pthread_key_t, const void *); // 设置 self-\u003etsd[k] = 私有数据; self-\u003etsd_used = 1; // 读取 return self-\u003etsd[k]; ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:2","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#数据"},{"categories":["pthread"],"content":" 3 编译器提供 musl线程库提供的私有数据还可以理解,但是GCC的__thread变量就比较难以分析了,因此此时只能通过 汇编文件进行分析 給出测试程序 __thread int num; int test(void) { return num; } GCC生成的汇编语言 num: test: push {r7} @ 进入函数,保存现场 add r7, sp, #0 @ R7 = SP mrc p15, 0, r3, c13, c0, 3 @ R3 = 线程号 ldr r2, .L3 @ R2 = \u0026num ldr r3, [r3, r2] @ R3 = *((int *)(R3 + R2)) mov r0, r3 @ R0 = R3 mov sp, r7 @ 恢复SP ldr r7, [sp], #4 @ 恢复R7 bx lr @ return .L3: .word num(tpoff) 但是到现在我们还是没有通过汇编理解原因,但是我们可以注意到一个可疑点.word num(tpoff),这个表达式中tpoff是什么?那么只好到GCC官网上看看是怎么处理的. GCC Thread-Local Storage 同时可以得到一份文档ELF Handling For Thread-Local Storage; 那么就开始分析此文档 ","date":"2022-07-18","objectID":"/pthread_local_storage/:3:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#编译器提供"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_lock/","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/"},{"categories":["pthread"],"content":" 1 futex原理 高级锁的实现都是与futex实现相关 Futex是Fast Userspace muTexes的缩写 常用的锁都是通过futex实现的 mutex (互斥锁) rwlock (读写锁) cond (条件变量) graph LR atom[原子操作] --\u003e spin[自旋锁] futex --\u003e mutex[互斥锁] futex --\u003e rwlock[读写锁] futex --\u003e cond[条件变量] #include \u003clinux/futex.h\u003e /* Definition of FUTEX_* constants */ #include \u003csys/syscall.h\u003e /* Definition of SYS_* constants */ #include \u003cunistd.h\u003e long syscall(SYS_futex, uint32_t *uaddr, int futex_op, uint32_t val, const struct timespec *timeout, /* or: uint32_t val2 */ uint32_t *uaddr2, uint32_t val3); uaddr futex_op val timeout uaddr2 val3 // 进入解析 long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout, u32 __user *uaddr2, u32 val2, u32 val3) { int cmd = op \u0026 FUTEX_CMD_MASK; unsigned int flags = 0; if (!(op \u0026 FUTEX_PRIVATE_FLAG)) flags |= FLAGS_SHARED; if (op \u0026 FUTEX_CLOCK_REALTIME) { flags |= FLAGS_CLOCKRT; if (cmd != FUTEX_WAIT_BITSET \u0026\u0026 cmd != FUTEX_WAIT_REQUEUE_PI) return -ENOSYS; } switch (cmd) { case FUTEX_LOCK_PI: case FUTEX_UNLOCK_PI: case FUTEX_TRYLOCK_PI: case FUTEX_WAIT_REQUEUE_PI: case FUTEX_CMP_REQUEUE_PI: if (!futex_cmpxchg_enabled) return -ENOSYS; } switch (cmd) { case FUTEX_WAIT: val3 = FUTEX_BITSET_MATCH_ANY; case FUTEX_WAIT_BITSET: return futex_wait(uaddr, flags, val, timeout, val3); case FUTEX_WAKE: val3 = FUTEX_BITSET_MATCH_ANY; case FUTEX_WAKE_BITSET: return futex_wake(uaddr, flags, val, val3); case FUTEX_REQUEUE: return futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0); case FUTEX_CMP_REQUEUE: return futex_requeue(uaddr, flags, uaddr2, val, val2, \u0026val3, 0); case FUTEX_WAKE_OP: return futex_wake_op(uaddr, flags, uaddr2, val, val2, val3); case FUTEX_LOCK_PI: return futex_lock_pi(uaddr, flags, timeout, 0); case FUTEX_UNLOCK_PI: return futex_unlock_pi(uaddr, flags); case FUTEX_TRYLOCK_PI: return futex_lock_pi(uaddr, flags, NULL, 1); case FUTEX_WAIT_REQUEUE_PI: val3 = FUTEX_BITSET_MATCH_ANY; return futex_wait_requeue_pi(uaddr, flags, val, timeout, val3, uaddr2); case FUTEX_CMP_REQUEUE_PI: return futex_requeue(uaddr, flags, uaddr2, val, val2, \u0026val3, 1); } return -ENOSYS; } 但是我并没有搞明白futex实现的原理,造成难以继续分析, 因此只能分析别人的文档(注:不分析原理,只进行使用) 主要存在文件futex-internal.c/futex-internal.h,lowlevellock-futex.h,lowlevellock.c 另外lll-\u003elowlevellock缩写形式 其中futex提供的最重要的两个操作wait和wake // 可以使用的op定义类型 #define FUTEX_WAIT 0 #define FUTEX_WAKE 1 #define FUTEX_REQUEUE 3 #define FUTEX_CMP_REQUEUE 4 #define FUTEX_WAKE_OP 5 #define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE ((4 \u003c\u003c 24) | 1) #define FUTEX_LOCK_PI 6 #define FUTEX_UNLOCK_PI 7 #define FUTEX_TRYLOCK_PI 8 #define FUTEX_WAIT_BITSET 9 #define FUTEX_WAKE_BITSET 10 #define FUTEX_WAIT_REQUEUE_PI 11 #define FUTEX_CMP_REQUEUE_PI 12 #define FUTEX_LOCK_PI2 13 #define FUTEX_PRIVATE_FLAG 128 #define FUTEX_CLOCK_REALTIME 256 futex管理结构 struct futex_hash_bucket { atomic_t waiters; spinlock_t lock; struct plist_head chain; } ____cacheline_aligned_in_smp; struct futex_q { struct plist_node list; struct task_struct *task; spinlock_t *lock_ptr; union futex_key key; struct futex_pi_state *pi_state; struct rt_mutex_waiter *rt_waiter; union futex_key *requeue_pi_key; u32 bitset; }; union futex_key { struct { unsigned long pgoff; struct inode *inode; int offset; } shared; struct { unsigned long address; struct mm_struct *mm; int offset; } private; struct { unsigned long word; void *ptr; int offset; } both; }; 进入内核层wait实现 static int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val, ktime_t *abs_time, u32 bitset) { struct hrtimer_sleeper timeout, *to = NULL; struct restart_block *restart; struct futex_hash_bucket *hb; struct futex_q q = futex_q_init; int ret; if (!bitset) return -EINVAL; q.bitset = bitset; if (abs_time) { to = \u0026timeout; hrtimer_init_on_stack(\u0026to-\u003etimer, (flags \u0026 FLAGS_CLOCKRT) ? CLOCK_REALTIME : CLOCK_MONOTONIC, HRTIMER_MODE_ABS); hrtimer_init_sleeper(to, current); hrtimer_set_expires_range_ns(\u0026to-\u003etimer, *abs_time, current-\u003etimer_slack_ns); } retry: /* * Prepare to wait on uaddr. On success, holds hb lock and increments * q.key refs. */ ret = futex_wait_setup(uaddr, val, fl","date":"2022-07-18","objectID":"/pthread_lock/:1:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#futex原理"},{"categories":["pthread"],"content":" 2 futex实现 futex接口的用户层界面封装 futex_wait futex_wake ","date":"2022-07-18","objectID":"/pthread_lock/:2:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#futex实现"},{"categories":["pthread"],"content":" 2.1 musl实现 #define lll_trylock(lock) 原子的(lock 0 --\u003e 1) // 不等待 #define lll_cond_trylock(lock) 原子的(lock 0 --\u003e 2) // 不等待 #define lll_lock(futex, private) 1. 原子的(futex 0 --\u003e 1) // 等待 2. __lll_lock_wait (futex, private) #define __lll_cond_lock(futex, private) 1. 原子的(futex 0 --\u003e 2) // 等待 2. __lll_lock_wait (futex, private) #define __lll_unlock(futex, private) 1. 原子的(futex ? --\u003e 0) // 等待 2. __lll_lock_wait (futex, private) void __lll_lock_wake_private (int *futex); void __lll_lock_wait_private (int *futex); void __lll_lock_wait (int *futex, int private); void __lll_lock_wake (int *futex, int private); int lll_futex_wake(int *futex, int nr, int private); int lll_futex_wait(int *futex, int val, int private); int futex_wait(unsigned int *futex_word, unsigned int expected, int private); void futex_wake(unsigned int* futex_word, int processes_to_wake, int private); // 进入系统调用阶段 int lll_futex_syscall(int nargs, int *futexp, int op, ...); 那么进入到最后可以得知,一般会进行一些原子操作,启动的操作都是INTERNAL_SYSCALL进行实现的,然后就是swi指令实现的原理 ","date":"2022-07-18","objectID":"/pthread_lock/:2:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现"},{"categories":["pthread"],"content":" 2.2 glibc实现graph TD futex_wake --\u003e lll_futex_wake futex_wait --\u003e lll_futex_timed_wait lll_futex_timed_wait --\u003e lll_futex_syscall lll_futex_wake --\u003e lll_futex_syscall 关于futex private标志位存在一个优化FUTEX : new PRIVATE futexes,如果futex不在进程间共享会更快,因此pthread操作的时候都是使用的private版本,除非设置了PTHREAD_PROCESS_SHARED属性;因此.pthread的几个操作可以暂时忽略掉此标志位. # define lll_futex_wake(futexp, nr, private) \\ lll_futex_syscall (4, futexp, \\ __lll_private_flag (FUTEX_WAKE, private), nr, 0) # define lll_futex_timed_wait(futexp, val, timeout, private) \\ lll_futex_syscall (4, futexp, \\ __lll_private_flag (FUTEX_WAIT, private), \\ val, timeout) 进入到INTERNAL_SYSCALL,详情可以查看[Linux系统调用] # define lll_futex_syscall(nargs, futexp, op, ...) \\ ({ \\ long int __ret = INTERNAL_SYSCALL (futex, nargs, futexp, op, \\ __VA_ARGS__); \\ (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (__ret)) \\ ? -INTERNAL_SYSCALL_ERRNO (__ret) : 0); \\ }) ","date":"2022-07-18","objectID":"/pthread_lock/:2:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现"},{"categories":["pthread"],"content":" 3 原子操作","date":"2022-07-18","objectID":"/pthread_lock/:3:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#原子操作"},{"categories":["pthread"],"content":" 3.1 musl实现 static inline int a_ll(volatile int *p) { int v; __asm__ __volatile__ (\"ldrex %0, %1\" : \"=r\"(v) : \"Q\"(*p)); return v; } static inline int a_sc(volatile int *p, int v) { int r; __asm__ __volatile__ (\"strex %0,%2,%1\" : \"=\u0026r\"(r), \"=Q\"(*p) : \"r\"(v) : \"memory\"); return !r; } static inline void a_barrier() { __asm__ __volatile__ (\"dmb ish\" : : : \"memory\"); } static inline int a_cas(volatile int *p, int t, int s) { for (;;) { register int r0 __asm__(\"r0\") = t; register int r1 __asm__(\"r1\") = s; register volatile int *r2 __asm__(\"r2\") = p; register uintptr_t r3 __asm__(\"r3\") = __a_cas_ptr; int old; __asm__ __volatile__ ( BLX \" r3\" : \"+r\"(r0), \"+r\"(r3) : \"r\"(r1), \"r\"(r2) : \"memory\", \"lr\", \"ip\", \"cc\" ); if (!r0) return t; if ((old=*p)!=t) return old; } } static inline void a_barrier() { register uintptr_t ip __asm__(\"ip\") = __a_barrier_ptr; __asm__ __volatile__( BLX \" ip\" : \"+r\"(ip) : : \"memory\", \"cc\", \"lr\" ); } ","date":"2022-07-18","objectID":"/pthread_lock/:3:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-1"},{"categories":["pthread"],"content":" 3.2 glibc实现主要是gcc是实现的__atomic开头的函数,参考GCC编译器手册 __atomic_load_n __atomic_load __atomic_store_n __atomic_store __atomic_exchange_n __atomic_exchange __atomic_compare_exchange_n __atomic_compare_exchange __atomic_add_fetch __atomic_sub_fetch __atomic_and_fetch __atomic_xor_fetch __atomic_or_fetch __atomic_nand_fetch __atomic_fetch_add __atomic_fetch_sub __atomic_fetch_and __atomic_fetch_xor __atomic_fetch_or __atomic_fetch_nand __atomic_test_and_set __atomic_clear __atomic_thread_fence __atomic_signal_fence __atomic_always_lock_free __atomic_is_lock_free #define atomic_load_relaxed(mem) \\ ({ __atomic_check_size_ls((mem)); \\ __atomic_load_n ((mem), __ATOMIC_RELAXED); }) #define atomic_load_acquire(mem) \\ ({ __atomic_check_size_ls((mem)); \\ __atomic_load_n ((mem), __ATOMIC_ACQUIRE); }) #define atomic_store_relaxed(mem, val) \\ do { \\ __atomic_check_size_ls((mem)); \\ __atomic_store_n ((mem), (val), __ATOMIC_RELAXED); \\ } while (0) #define atomic_store_release(mem, val) \\ do { \\ __atomic_check_size_ls((mem)); \\ __atomic_store_n ((mem), (val), __ATOMIC_RELEASE); \\ } while (0) ","date":"2022-07-18","objectID":"/pthread_lock/:3:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-1"},{"categories":["pthread"],"content":" 4 自旋锁 int pthread_spin_init(pthread_spinlock_t *, int); int pthread_spin_destroy(pthread_spinlock_t *); int pthread_spin_lock(pthread_spinlock_t *); int pthread_spin_trylock(pthread_spinlock_t *); int pthread_spin_unlock(pthread_spinlock_t *); ","date":"2022-07-18","objectID":"/pthread_lock/:4:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#自旋锁"},{"categories":["pthread"],"content":" 4.1 musl实现spinlock句柄就是一个32位的数; typedef int pthread_spinlock_t; 五种函数的实现 int pthread_spin_init(pthread_spinlock_t *s, int shared) { return *s = 0; } int pthread_spin_destroy(pthread_spinlock_t *s) { return 0; } int pthread_spin_lock(pthread_spinlock_t *s) { while (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin(); return 0; } int pthread_spin_trylock(pthread_spinlock_t *s) { return a_cas(s, 0, EBUSY); } int pthread_spin_unlock(pthread_spinlock_t *s) { a_store(s, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:4:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-2"},{"categories":["pthread"],"content":" 4.2 glibc实现glibc的实现就较为复杂了点 typedef __pthread_spinlock_t pthread_spinlock_t; typedef volatile int __pthread_spinlock_t; 加上__作为内部使用的句柄 volatile使编译器强行读取 int pthread_spin_init(pthread_spinlock_t *lock, int pshared) { /* Relaxed MO is fine because this is an initializing store. */ atomic_store_relaxed(lock, 0); return 0; } int pthread_spin_destroy (pthread_spinlock_t *lock) { /* Nothing to do. */ return 0; } int pthread_spin_lock (pthread_spinlock_t *lock) { int val = 0; #if ! ATOMIC_EXCHANGE_USES_CAS if (__glibc_likely(atomic_exchange_acquire(lock, 1) == 0)) { return 0; } #else if (__glibc_likely(atomic_compare_exchange_weak_acquire(lock, \u0026val, 1))) { return 0; } #endif do { do { atomic_spin_nop(); val = atomic_load_relaxed(lock); } while (val != 0); } while (!atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)); return 0; } int pthread_spin_trylock(pthread_spinlock_t *lock) { #if ! ATOMIC_EXCHANGE_USES_CAS if (atomic_exchange_acquire (lock, 1) == 0) { return 0; } #else do { int val = 0; if (atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)) return 0; } while (atomic_load_relaxed (lock) == 0); #endif return EBUSY; } int pthread_spin_unlock(pthread_spinlock_t *lock) { atomic_store_release(lock, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:4:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-2"},{"categories":["pthread"],"content":" 5 内存屏障 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); int pthread_barrierattr_destroy(pthread_barrierattr_t *); int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); int pthread_barrierattr_init(pthread_barrierattr_t *); int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); pthread_t p1, p2, p3; pthread_barrier_t test_barrier; void *test_thread(void *arg) { // make gcc happy unsigned int sleep_time = (unsigned int)((unsigned long)arg); sleep(sleep_time); printf(\"wait begin %d\\r\\n\", gettid()); pthread_barrier_wait(\u0026test_barrier); printf(\"wait finish\\r\\n\"); return NULL; } int main(int argc, char *argv[]) { pthread_barrier_init(\u0026test_barrier, NULL, 4); pthread_create(\u0026p1, NULL, \u0026test_thread, (void *)1); pthread_create(\u0026p2, NULL, \u0026test_thread, (void *)2); pthread_create(\u0026p3, NULL, \u0026test_thread, (void *)3); // 设置线程分离 pthread_detach(p1); pthread_detach(p2); pthread_detach(p3); printf(\"wait begin %d\\r\\n\", gettid()); pthread_barrier_wait(\u0026test_barrier); printf(\"wait finish\\r\\n\"); pthread_barrier_destroy(\u0026test_barrier); return 0; } 打印日志 wait begin 352789 wait begin 352790 wait begin 352791 wait begin 352792 wait finish 352792 wait finish 352791 wait finish 352790 wait finish 352789 ","date":"2022-07-18","objectID":"/pthread_lock/:5:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#内存屏障"},{"categories":["pthread"],"content":" 5.1 musl实现 // 初始化流程 int pthread_barrier_init(pthread_barrier_t *restrict b, const pthread_barrierattr_t *restrict a, unsigned count) { if (count-1 \u003e INT_MAX-1) return EINVAL; *b = (pthread_barrier_t){ ._b_limit = count-1 | (a?a-\u003e__attr:0) }; return 0; } int pthread_barrier_wait(pthread_barrier_t *b) { int limit = b-\u003e_b_limit; struct instance *inst; /* Trivial case: count was set at 1 */ if (!limit) return PTHREAD_BARRIER_SERIAL_THREAD; /* Process-shared barriers require a separate, inefficient wait */ if (limit \u003c 0) return pshared_barrier_wait(b); /* Otherwise we need a lock on the barrier object */ while (a_swap(\u0026b-\u003e_b_lock, 1)) __wait(\u0026b-\u003e_b_lock, \u0026b-\u003e_b_waiters, 1, 1); inst = b-\u003e_b_inst; /* First thread to enter the barrier becomes the \"instance owner\" */ if (!inst) { struct instance new_inst = { 0 }; int spins = 200; b-\u003e_b_inst = inst = \u0026new_inst; a_store(\u0026b-\u003e_b_lock, 0); if (b-\u003e_b_waiters) __wake(\u0026b-\u003e_b_lock, 1, 1); while (spins-- \u0026\u0026 !inst-\u003efinished) a_spin(); a_inc(\u0026inst-\u003efinished); while (inst-\u003efinished == 1) __syscall(SYS_futex,\u0026inst-\u003efinished,FUTEX_WAIT|FUTEX_PRIVATE,1,0) != -ENOSYS || __syscall(SYS_futex,\u0026inst-\u003efinished,FUTEX_WAIT,1,0); return PTHREAD_BARRIER_SERIAL_THREAD; } /* Last thread to enter the barrier wakes all non-instance-owners */ if (++inst-\u003ecount == limit) { b-\u003e_b_inst = 0; a_store(\u0026b-\u003e_b_lock, 0); if (b-\u003e_b_waiters) __wake(\u0026b-\u003e_b_lock, 1, 1); a_store(\u0026inst-\u003elast, 1); if (inst-\u003ewaiters) __wake(\u0026inst-\u003elast, -1, 1); } else { a_store(\u0026b-\u003e_b_lock, 0); if (b-\u003e_b_waiters) __wake(\u0026b-\u003e_b_lock, 1, 1); __wait(\u0026inst-\u003elast, \u0026inst-\u003ewaiters, 0, 1); } /* Last thread to exit the barrier wakes the instance owner */ if (a_fetch_add(\u0026inst-\u003ecount,-1)==1 \u0026\u0026 a_fetch_add(\u0026inst-\u003efinished,1)) __wake(\u0026inst-\u003efinished, 1, 1); return 0; } int pthread_barrier_destroy(pthread_barrier_t *b) { if (b-\u003e_b_limit \u003c 0) { if (b-\u003e_b_lock) { int v; a_or(\u0026b-\u003e_b_lock, INT_MIN); while ((v = b-\u003e_b_lock) \u0026 INT_MAX) __wait(\u0026b-\u003e_b_lock, 0, v, 0); } __vm_wait(); } return 0; } void __wait(volatile int *addr, volatile int *waiters, int val, int priv) { int spins=100; if (priv) priv = FUTEX_PRIVATE; while (spins-- \u0026\u0026 (!waiters || !*waiters)) { if (*addr==val) a_spin(); else return; } if (waiters) a_inc(waiters); while (*addr==val) { __syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS || __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0); } if (waiters) a_dec(waiters); } ","date":"2022-07-18","objectID":"/pthread_lock/:5:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-3"},{"categories":["pthread"],"content":" 5.2 glibc实现 int ___pthread_barrier_init (pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count) { ASSERT_TYPE_SIZE (pthread_barrier_t, __SIZEOF_PTHREAD_BARRIER_T); ASSERT_PTHREAD_INTERNAL_SIZE (pthread_barrier_t, struct pthread_barrier); struct pthread_barrier *ibarrier; /* XXX EINVAL is not specified by POSIX as a possible error code for COUNT being too large. See pthread_barrier_wait for the reason for the comparison with BARRIER_IN_THRESHOLD. */ if (__glibc_unlikely (count == 0 || count \u003e= BARRIER_IN_THRESHOLD)) return EINVAL; const struct pthread_barrierattr *iattr = (attr != NULL ? (struct pthread_barrierattr *) attr : \u0026default_barrierattr); ibarrier = (struct pthread_barrier *) barrier; /* Initialize the individual fields. */ ibarrier-\u003ein = 0; ibarrier-\u003eout = 0; ibarrier-\u003ecount = count; ibarrier-\u003ecurrent_round = 0; ibarrier-\u003eshared = (iattr-\u003epshared == PTHREAD_PROCESS_PRIVATE ? FUTEX_PRIVATE : FUTEX_SHARED); return 0; } int ___pthread_barrier_wait (pthread_barrier_t *barrier) { struct pthread_barrier *bar = (struct pthread_barrier *) barrier; /* How many threads entered so far, including ourself. */ unsigned int i; reset_restart: /* Try to enter the barrier. We need acquire MO to (1) ensure that if we observe that our round can be completed (see below for our attempt to do so), all pre-barrier-entry effects of all threads in our round happen before us completing the round, and (2) to make our use of the barrier happen after a potential reset. We need release MO to make sure that our pre-barrier-entry effects happen before threads in this round leaving the barrier. */ i = atomic_fetch_add_acq_rel (\u0026bar-\u003ein, 1) + 1; /* These loads are after the fetch_add so that we're less likely to first pull in the cache line as shared. */ unsigned int count = bar-\u003ecount; /* This is the number of threads that can enter before we need to reset. Always at the end of a round. */ unsigned int max_in_before_reset = BARRIER_IN_THRESHOLD - BARRIER_IN_THRESHOLD % count; if (i \u003e max_in_before_reset) { /* We're in a reset round. Just wait for a reset to finish; do not help finishing previous rounds because this could happen concurrently with a reset. */ while (i \u003e max_in_before_reset) { futex_wait_simple (\u0026bar-\u003ein, i, bar-\u003eshared); /* Relaxed MO is fine here because we just need an indication for when we should retry to enter (which will use acquire MO, see above). */ i = atomic_load_relaxed (\u0026bar-\u003ein); } goto reset_restart; } /* Look at the current round. At this point, we are just interested in whether we can complete rounds, based on the information we obtained through our acquire-MO load of IN. Nonetheless, if we notice that our round has been completed using this load, we use the acquire-MO fence below to make sure that all pre-barrier-entry effects of all threads in our round happen before us leaving the barrier. Therefore, relaxed MO is sufficient. */ unsigned cr = atomic_load_relaxed (\u0026bar-\u003ecurrent_round); /* Try to finish previous rounds and/or the current round. We simply consider just our position here and do not try to do the work of threads that entered more recently. */ while (cr + count \u003c= i) { /* Calculate the new current round based on how many threads entered. NEWCR must be larger than CR because CR+COUNT ends a round. */ unsigned int newcr = i - i % count; /* Try to complete previous and/or the current round. We need release MO to propagate the happens-before that we observed through reading with acquire MO from IN to other threads. If the CAS fails, it is like the relaxed-MO load of CURRENT_ROUND above. */ if (atomic_compare_exchange_weak_release (\u0026bar-\u003ecurrent_round, \u0026cr, newcr)) { /* Update CR with the modification we just did. */ cr = newcr; /* Wake threads belonging to the rounds we just finished. We may wake more threads than necessary if more than COUNT threads try to block concurrently on the barrier, but this is not a typical use of barriers. Note that we can still access SHARED because we h","date":"2022-07-18","objectID":"/pthread_lock/:5:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-3"},{"categories":["pthread"],"content":" 6 互斥锁 int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); int pthread_mutex_lock(pthread_mutex_t *); int pthread_mutex_unlock(pthread_mutex_t *); int pthread_mutex_trylock(pthread_mutex_t *); int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_mutex_destroy(pthread_mutex_t *); int pthread_mutex_consistent(pthread_mutex_t *); int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); int pthread_mutexattr_destroy(pthread_mutexattr_t *); int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); int pthread_mutexattr_init(pthread_mutexattr_t *); int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); int pthread_mutexattr_settype(pthread_mutexattr_t *, int); #define TEST_MUTEX pthread_t p1, p2; pthread_mutex_t test_mutex = PTHREAD_MUTEX_INITIALIZER; void *test_thread(void *arg) { // make gcc happy unsigned int sleep_time = (unsigned int)((unsigned long)arg); while (true) { #ifdef TEST_MUTEX pthread_mutex_lock(\u0026test_mutex); #endif printf(\"thread %p\\r\\n\", arg); sleep(sleep_time); #ifdef TEST_MUTEX pthread_mutex_unlock(\u0026test_mutex); #endif sleep(sleep_time); } return NULL; } int main(int argc, char *argv[]) { pthread_create(\u0026p1, NULL, \u0026test_thread, (void *)1); pthread_create(\u0026p2, NULL, \u0026test_thread, (void *)2); // 设置线程分离 pthread_detach(p1); pthread_detach(p2); while (true) { sleep(1); } return 0; } # 没有启动互斥锁 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x1 thread 0x2 thread 0x1 thread 0x1 thread 0x2 thread 0x1 thread 0x1 thread 0x2 thread 0x1 # 启动互斥锁 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 thread 0x1 thread 0x2 如果没有启动互斥锁,那么二者的运行时间是相同的概率,那么打印的个数2:1; 如果开始启动互斥锁,二者的运行时交替进行的; ","date":"2022-07-18","objectID":"/pthread_lock/:6:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#互斥锁"},{"categories":["pthread"],"content":" 6.1 musl实现在musl库上的互斥锁,但是我感觉musl的设计存在一些瑕疵,还是在去分析一下glibc的设计思路吧. typedef struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t; int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a) { *m = (pthread_mutex_t){0}; if (a) { m-\u003e_m_type = a-\u003e__attr; } return 0; } int pthread_mutex_destroy(pthread_mutex_t *mutex) { if (mutex-\u003e_m_type \u003e 128) { __vm_wait(); } return 0; } int pthread_mutex_lock(pthread_mutex_t *m) { if ((m-\u003e_m_type \u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; return __pthread_mutex_timedlock(m, 0); } int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at) { /* PTHREAD_MUTEX_NORMAL:死等 */ if ((m-\u003e_m_type\u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; int type = m-\u003e_m_type; int r, t, priv = (type \u0026 128) ^ 128; /* 尝试加锁 */ r = __pthread_mutex_trylock(m); if (r != EBUSY) { return r; } if (type\u00268) return pthread_mutex_timedlock_pi(m, at); int spins = 100; while (spins-- \u0026\u0026 m-\u003e_m_lock \u0026\u0026 !m-\u003e_m_waiters) a_spin(); while ((r=__pthread_mutex_trylock(m)) == EBUSY) { r = m-\u003e_m_lock; int own = r \u0026 0x3fffffff; if (!own \u0026\u0026 (!r || (type\u00264))) continue; if ((type\u00263) == PTHREAD_MUTEX_ERRORCHECK \u0026\u0026 own == __pthread_self()-\u003etid) return EDEADLK; a_inc(\u0026m-\u003e_m_waiters); t = r | 0x80000000; a_cas(\u0026m-\u003e_m_lock, r, t); r = __timedwait(\u0026m-\u003e_m_lock, t, CLOCK_REALTIME, at, priv); a_dec(\u0026m-\u003e_m_waiters); if (r \u0026\u0026 r != EINTR) break; } return r; } ","date":"2022-07-18","objectID":"/pthread_lock/:6:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-4"},{"categories":["pthread"],"content":" 6.2 glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) // 双向链表 typedef struct __pthread_internal_list { struct __pthread_internal_list *__prev; struct __pthread_internal_list *__next; } __pthread_list_t; struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; #define __SIZEOF_PTHREAD_MUTEX_T 40 typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 源代码经过改动，并不和Glibc源码一致 计算出type并且分析type的类型 enum { PTHREAD_MUTEX_KIND_MASK_NP = 3, PTHREAD_MUTEX_ELISION_NP = 256, PTHREAD_MUTEX_NO_ELISION_NP = 512, PTHREAD_MUTEX_ROBUST_NORMAL_NP = 16, PTHREAD_MUTEX_ROBUST_RECURSIVE_NP = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_RECURSIVE_NP, PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP = PTHREAD_MUTEX_ROBUST_NORMAL_NP | PTHREAD_MUTEX_ADAPTIVE_NP, PTHREAD_MUTEX_PRIO_INHERIT_NP = 32, PTHREAD_MUTEX_PI_NORMAL_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_PI_RECURSIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_RECURSIVE_NP, PTHREAD_MUTEX_PI_ERRORCHECK_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_PI_ADAPTIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ADAPTIVE_NP, PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_NORMAL_NP, PTHREAD_MUTEX_PI_ROBUST_RECURSIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_RECURSIVE_NP, PTHREAD_MUTEX_PI_ROBUST_ERRORCHECK_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP, PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP = PTHREAD_MUTEX_PRIO_INHERIT_NP | PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP, PTHREAD_MUTEX_PRIO_PROTECT_NP = 64, PTHREAD_MUTEX_PP_NORMAL_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_NORMAL, PTHREAD_MUTEX_PP_RECURSIVE_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_RECURSIVE_NP, PTHREAD_MUTEX_PP_ERRORCHECK_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_ERRORCHECK_NP, PTHREAD_MUTEX_PP_ADAPTIVE_NP = PTHREAD_MUTEX_PRIO_PROTECT_NP | PTHREAD_MUTEX_ADAPTIVE_NP, PTHREAD_MUTEX_ELISION_FLAGS_NP = PTHREAD_MUTEX_ELISION_NP | PTHREAD_MUTEX_NO_ELISION_NP, PTHREAD_MUTEX_TIMED_ELISION_NP = PTHREAD_MUTEX_TIMED_NP | PTHREAD_MUTEX_ELISION_NP, PTHREAD_MUTEX_TIMED_NO_ELISION_NP = PTHREAD_MUTEX_TIMED_NP | PTHREAD_MUTEX_NO_ELISION_NP, }; // 使用下面的宏提取类型信息 #define PTHREAD_MUTEX_TYPE_ELISION(m) \\ | ox100 (atomic_load_relaxed (\u0026((m)-\u003e__data.__kind)) \u0026 (0x7F | PTHREAD_MUTEX_ELISION_NP)) // ==\u003e \u0026((m)-\u003e__data.__kind \u0026 0x17F graph TD pthread_mutex_lock --\u003e ___pthread_mutex_lock ___pthread_mutex_lock --\u003e __pthread_mutex_lock_full ___pthread_mutex_lock --\u003e lll_mutex_lock_optimized futex封装函数 __lll_lock_wait_private __lll_lock_wait __lll_lock_wake_private __lll_lock_wake 继续深入的代码需要查看futex实现 void __lll_lock_wait_private (int *futex) { if (atomic_load_relaxed (futex) == 2) goto futex; while (atomic_exchange_acquire (futex, 2) != 0) { futex: LIBC_PROBE (lll_lock_wait_private, 1, futex); futex_wait ((unsigned int *) futex, 2, LLL_PRIVATE); /* Wait if *futex == 2. */ } } libc_hidden_def (__lll_lock_wait_private) void __lll_lock_wait (int *futex, int private) { if (atomic_load_relaxed (futex) == 2) goto futex; while (atomic_exchange_acquire (futex, 2) != 0) { futex: LIBC_PROBE (lll_lock_wait, 1, futex); futex_wait ((unsigned int *) futex, 2, private); /* Wait if *futex == 2. */ } } libc_hidden_def (__lll_lock_wait) # define lll_futex_wake(futexp, nr, private) \\ lll_futex_syscall (4, futexp, \\ __lll_private_flag (FUTEX_WAKE, private), nr, 0) void __lll_lock_wake_private (int *futex) { lll_futex_wake (futex, 1, LLL_PRIVATE); } libc_hidden_def (__lll_lock_wake_private) void __lll_lock_wake (int *futex, int private) { lll_futex_wake (futex, 1, private); } libc_hidden_def (__lll_lock_wake) 底层函数操作 # define LLL_MUTEX_LOCK(mutex) lll_lock ((mutex)-\u003e__data.__lock, PTHREAD_MUTEX_","date":"2022-07-18","objectID":"/pthread_lock/:6:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-4"},{"categories":["pthread"],"content":" 7 条件变量 int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); int pthread_cond_destroy(pthread_cond_t *); int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); int pthread_cond_broadcast(pthread_cond_t *); int pthread_cond_signal(pthread_cond_t *); int pthread_condattr_init(pthread_condattr_t *); int pthread_condattr_destroy(pthread_condattr_t *); int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); int pthread_condattr_setpshared(pthread_condattr_t *, int); int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); ","date":"2022-07-18","objectID":"/pthread_lock/:7:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#条件变量"},{"categories":["pthread"],"content":" 7.1 musl实现 ``` int pthread_cond_init(pthread_cond_t *restrict c, const pthread_condattr_t *restrict a) { *c = (pthread_cond_t){0}; if (a) { c-\u003e_c_clock = a-\u003e__attr \u0026 0x7fffffff; if (a-\u003e__attr\u003e\u003e31) c-\u003e_c_shared = (void *)-1; } return 0; } int pthread_cond_destroy(pthread_cond_t *c) { if (c-\u003e_c_shared \u0026\u0026 c-\u003e_c_waiters) { int cnt; a_or(\u0026c-\u003e_c_waiters, 0x80000000); a_inc(\u0026c-\u003e_c_seq); __wake(\u0026c-\u003e_c_seq, -1, 0); while ((cnt = c-\u003e_c_waiters) \u0026 0x7fffffff) __wait(\u0026c-\u003e_c_waiters, 0, cnt, 0); } return 0; } int pthread_cond_wait(pthread_cond_t *restrict c, pthread_mutex_t *restrict m) { return pthread_cond_timedwait(c, m, 0); } int __pthread_cond_timedwait(pthread_cond_t *restrict c, pthread_mutex_t *restrict m, const struct timespec *restrict ts) { struct waiter node = { 0 }; int e, seq, clock = c-\u003e_c_clock, cs, shared=0, oldstate, tmp; volatile int *fut; if ((m-\u003e_m_type\u002615) \u0026\u0026 (m-\u003e_m_lock\u0026INT_MAX) != __pthread_self()-\u003etid) return EPERM; if (ts \u0026\u0026 ts-\u003etv_nsec \u003e= 1000000000UL) return EINVAL; __pthread_testcancel(); if (c-\u003e_c_shared) { shared = 1; fut = \u0026c-\u003e_c_seq; seq = c-\u003e_c_seq; a_inc(\u0026c-\u003e_c_waiters); } else { lock(\u0026c-\u003e_c_lock); seq = node.barrier = 2; fut = \u0026node.barrier; node.state = WAITING; node.next = c-\u003e_c_head; c-\u003e_c_head = \u0026node; if (!c-\u003e_c_tail) c-\u003e_c_tail = \u0026node; else node.next-\u003eprev = \u0026node; unlock(\u0026c-\u003e_c_lock); } __pthread_mutex_unlock(m); __pthread_setcancelstate(PTHREAD_CANCEL_MASKED, \u0026cs); if (cs == PTHREAD_CANCEL_DISABLE) __pthread_setcancelstate(cs, 0); do e = __timedwait_cp(fut, seq, clock, ts, !shared); while (*fut==seq \u0026\u0026 (!e || e==EINTR)); if (e == EINTR) e = 0; if (shared) { /* Suppress cancellation if a signal was potentially * consumed; this is a legitimate form of spurious * wake even if not. */ if (e == ECANCELED \u0026\u0026 c-\u003e_c_seq != seq) e = 0; if (a_fetch_add(\u0026c-\u003e_c_waiters, -1) == -0x7fffffff) __wake(\u0026c-\u003e_c_waiters, 1, 0); oldstate = WAITING; goto relock; } oldstate = a_cas(\u0026node.state, WAITING, LEAVING); if (oldstate == WAITING) { /* Access to cv object is valid because this waiter was not * yet signaled and a new signal/broadcast cannot return * after seeing a LEAVING waiter without getting notified * via the futex notify below. */ lock(\u0026c-\u003e_c_lock); if (c-\u003e_c_head == \u0026node) c-\u003e_c_head = node.next; else if (node.prev) node.prev-\u003enext = node.next; if (c-\u003e_c_tail == \u0026node) c-\u003e_c_tail = node.prev; else if (node.next) node.next-\u003eprev = node.prev; unlock(\u0026c-\u003e_c_lock); if (node.notify) { if (a_fetch_add(node.notify, -1)==1) __wake(node.notify, 1, 1); } } else { /* Lock barrier first to control wake order. */ lock(\u0026node.barrier); } relock: /* Errors locking the mutex override any existing error or * cancellation, since the caller must see them to know the * state of the mutex. */ if ((tmp = pthread_mutex_lock(m))) e = tmp; if (oldstate == WAITING) goto done; if (!node.next \u0026\u0026 !(m-\u003e_m_type \u0026 8)) a_inc(\u0026m-\u003e_m_waiters); /* Unlock the barrier that's holding back the next waiter, and * either wake it or requeue it to the mutex. */ if (node.prev) { int val = m-\u003e_m_lock; if (val\u003e0) a_cas(\u0026m-\u003e_m_lock, val, val|0x80000000); unlock_requeue(\u0026node.prev-\u003ebarrier, \u0026m-\u003e_m_lock, m-\u003e_m_type \u0026 (8|128)); } else if (!(m-\u003e_m_type \u0026 8)) { a_dec(\u0026m-\u003e_m_waiters); } /* Since a signal was consumed, cancellation is not permitted. */ if (e == ECANCELED) e = 0; done: __pthread_setcancelstate(cs, 0); if (e == ECANCELED) { __pthread_testcancel(); __pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 0); } return e; } int pthread_cond_signal(pthread_cond_t *c) { if (!c-\u003e_c_shared) return __private_cond_signal(c, 1); if (!c-\u003e_c_waiters) return 0; a_inc(\u0026c-\u003e_c_seq); __wake(\u0026c-\u003e_c_seq, 1, 0); return 0; } int pthread_cond_broadcast(pthread_cond_t *c) { if (!c-\u003e_c_shared) return __private_cond_signal(c, -1); if (!c-\u003e_c_waiters) return 0; a_inc(\u0026c-\u003e_c_seq); __wake(\u0026c-\u003e_c_seq, -1, 0); return 0; } int __private_cond_signal(pthread_cond_t *c, int n) { struct waiter *p, *first=0; volatile int ref = 0; int cur; lock(\u0026c-\u003e_c_lock); for (p=c-\u003e_c_tail; n \u0026\u0026 p; p=p-\u003e","date":"2022-07-18","objectID":"/pthread_lock/:7:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-5"},{"categories":["pthread"],"content":" 7.2 glibc实现 ","date":"2022-07-18","objectID":"/pthread_lock/:7:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-5"},{"categories":["pthread"],"content":" 8 读写锁 int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); int pthread_rwlock_destroy(pthread_rwlock_t *); int pthread_rwlock_rdlock(pthread_rwlock_t *); int pthread_rwlock_tryrdlock(pthread_rwlock_t *); int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_wrlock(pthread_rwlock_t *); int pthread_rwlock_trywrlock(pthread_rwlock_t *); int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); int pthread_rwlock_unlock(pthread_rwlock_t *); int pthread_rwlockattr_init(pthread_rwlockattr_t *); int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); ","date":"2022-07-18","objectID":"/pthread_lock/:8:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#读写锁"},{"categories":["pthread"],"content":" 8.1 musl实现 ","date":"2022-07-18","objectID":"/pthread_lock/:8:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-6"},{"categories":["pthread"],"content":" 8.2 glibc实现 ","date":"2022-07-18","objectID":"/pthread_lock/:8:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-6"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_thread/","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/"},{"categories":["pthread"],"content":" 基于musl源码库与glibc库,其中musl提供分析的思路,glibc分析具体实现 ","date":"2022-07-18","objectID":"/pthread_thread/:0:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#"},{"categories":["pthread"],"content":" 1 调试环境搭建","date":"2022-07-18","objectID":"/pthread_thread/:1:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#调试环境搭建"},{"categories":["pthread"],"content":" 1.1 下载源码执行/usr/lib/libc.so.6,确定版本 /usr/lib/libc.so.6 GNU C Library (GNU libc) stable release version 2.37. Copyright (C) 2023 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Compiled by GNU CC version 12.2.1 20230201. libc ABIs: UNIQUE IFUNC ABSOLUTE Minimum supported kernel: 4.4.0 For bug reporting instructions, please see: \u003chttps://bugs.archlinux.org/\u003e. 清华源下载glibc2.37 ","date":"2022-07-18","objectID":"/pthread_thread/:1:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#下载源码"},{"categories":["pthread"],"content":" 1.2 编译glibc #!/bin/bash # shellcheck disable=SC2034 root_path=$(pwd) install_path=${root_path}/install/glibc glibc_path=${root_path}/glibc-2.37 pushd \"${glibc_path}\" \u003e\u003e /dev/null || exit mkdir build \u0026\u0026 pushd build \u003e\u003e /dev/null || exit CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" \\ CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -Og -Wno-error\" ../configure --prefix=\"${install_path}\" --disable-werror make -j\"$(nproc)\" make install popd \u003e\u003e /dev/null || exit popd \u003e\u003e /dev/null || exit 如果跳转异常，则可以将指令修改，调整编译优化等级,使用O0编译; CFLAGS=\"-g -g3 -ggdb -gdwarf-4 -O0 -Wno-error\" CXXFLAGS=\"-g -g3 -ggdb -gdwarf-4 -O0 -Wno-error\" ","date":"2022-07-18","objectID":"/pthread_thread/:1:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#编译glibc"},{"categories":["pthread"],"content":" 1.3 测试代码 gcc -g -L $(PWD)/../install/lib -Wl,--rpath=$(PWD)/../install/lib -Wl,-I $(PWD)/../install/lib/ld-linux-x86-64.so.2 test_main.c -o test_main 完美实现效果 ","date":"2022-07-18","objectID":"/pthread_thread/:1:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#测试代码"},{"categories":["pthread"],"content":" 2 pthread句柄","date":"2022-07-18","objectID":"/pthread_thread/:2:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread句柄"},{"categories":["pthread"],"content":" 2.1 musl实现 struct pthread { struct pthread *self; #ifndef TLS_ABOVE_TP uintptr_t *dtv; #endif /* 线程链表项 */ struct pthread *prev, *next; /* non-ABI */ /* 系统信息 */ uintptr_t sysinfo; #ifndef TLS_ABOVE_TP #ifdef CANARY_PAD uintptr_t canary_pad; #endif uintptr_t canary; #endif /* TLS_ABOVE_TP */ int tid; // 线程ID int errno_val; volatile int detach_state; // 分离状态 volatile int cancel; // cancle启动标志 volatile unsigned char canceldisable; // cancle控制 volatile unsigned char cancelasync; // cancle同步标志 unsigned char tsd_used:1; unsigned char dlerror_flag:1; unsigned char *map_base; // mmap size_t map_size; void *stack; // 堆栈 size_t stack_size; size_t guard_size; void *result; // 返回结果, /* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ struct __ptcb *cancelbuf; void **tsd; struct { volatile void *volatile head; long off; volatile void *volatile pending; } robust_list; int h_errno_val; volatile int timer_id; locale_t locale; volatile int killlock[1]; // 退出锁 char *dlerror_buf; void *stdio_locks; #ifdef TLS_ABOVE_TP uintptr_t canary; uintptr_t *dtv; #endif }; ","date":"2022-07-18","objectID":"/pthread_thread/:2:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#musl实现"},{"categories":["pthread"],"content":" 2.2 glibc实现 struct __pthread { /* 线程ID: typedef unsigned long int pthread_t; */ pthread_t thread; unsigned int nr_refs; /* Detached threads have a self reference only, while joinable threads have two references. These are used to keep the structure valid at thread destruction. Detaching/joining a thread drops a reference. */ /* Cancellation. */ pthread_mutex_t cancel_lock; /* Protect cancel_xxx members. */ void (*cancel_hook) (void *); /* Called to unblock a thread blocking in a cancellation point (namely, __pthread_cond_timedwait_internal). */ void *cancel_hook_arg; int cancel_state; int cancel_type; int cancel_pending; /* Thread stack. */ void *stackaddr; /* 堆栈地址 */ size_t stacksize; /* 堆栈大小 */ size_t guardsize; /* 预留用来保护堆栈大小的字节 */ int stack; /* Nonzero if the stack was allocated. */ /* Exit status. */ void *status; /* Thread state. */ enum pthread_state state; pthread_mutex_t state_lock; /* Locks the state. */ pthread_cond_t state_cond; /* Signalled when the state changes. */ bool terminated; /* Whether the kernel thread is over and we can reuse this structure. */ /* Resolver state. */ struct __res_state res_state; /* Indicates whether is a C11 thread created by thrd_creat. */ bool c11; /* Initial sigset for the thread. */ sigset_t init_sigset; /* Thread context. */ struct pthread_mcontext mcontext; PTHREAD_KEY_MEMBERS /* void **thread_specifics; // This is only resized by the thread, and always growing unsigned thread_specifics_size; // Number of entries in thread_specifics */ PTHREAD_SYSDEP_MEMBERS /* thread_t kernel_thread; mach_msg_header_t wakeupmsg; */ /* 线程控制块:与系统进行沟通 */ tcbhead_t *tcb; /* Queue links. Since PREVP is used to determine if a thread has been awaken, it must be protected by the queue lock. */ struct __pthread *next, **prevp; }; 但是在我们使用的时候发现与我们正常的使用不太一致,在用户层,我们一般认为pthread为线程ID，但是内部实现好像都是指针,因此出现了什么特殊的原因； 在musl中,直接抹掉了内部结构; // 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 #ifdef __cplusplus typedef unsigned long pthread_t; #else typedef struct __pthread* pthread_t; #endif 而在glibc中,线程ID仅仅是线程结构体中的一个成员,因此,glibc的处理更加安全, 下面分析一下id的实现, __pthread_create (pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine) (void *), void *arg) { int err; struct __pthread *pthread; err = __pthread_create_internal (\u0026pthread, attr, start_routine, arg); if (!err) *thread = pthread-\u003ethread; else if (err == ENOMEM) err = EAGAIN; return err; } /* 那么可以明白,线程ID */ int _dl_pthread_num_threads; struct __pthread **_dl_pthread_threads; __libc_rwlock_define_initialized (, _dl_pthread_threads_lock) /* 下面的代码实现线程ID的分配:只保留了成功的部分,没有考虑意外情况 */ __libc_rwlock_wrlock (GL(dl_pthread_threads_lock)); if (GL(dl_pthread_num_threads) \u003c __pthread_max_threads) { /* We have a free slot. Use the slot number plus one as the thread ID for the new thread. */ new-\u003ethread = 1 + GL(dl_pthread_num_threads)++; GL(dl_pthread_threads)[new-\u003ethread - 1] = NULL; __libc_rwlock_unlock (GL(dl_pthread_threads_lock)); *pthread = new; return 0; } 但是GL是什么呢?hehe #define GL(x) _##x ","date":"2022-07-18","objectID":"/pthread_thread/:2:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现"},{"categories":["pthread"],"content":" 3 所有的函数","date":"2022-07-18","objectID":"/pthread_thread/:3:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#所有的函数"},{"categories":["pthread"],"content":" 3.1 线程创建 // 线程创建 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict); // 线程退出 void pthread_exit(void *); ","date":"2022-07-18","objectID":"/pthread_thread/:3:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程创建"},{"categories":["pthread"],"content":" 3.2 线程属性 int pthread_attr_init(pthread_attr_t *); int pthread_attr_destroy(pthread_attr_t *); int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setguardsize(pthread_attr_t *, size_t); int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setstacksize(pthread_attr_t *, size_t); int pthread_attr_getdetachstate(const pthread_attr_t *, int *); int pthread_attr_setdetachstate(pthread_attr_t *, int); int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); int pthread_attr_setstack(pthread_attr_t *, void *, size_t); int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setscope(pthread_attr_t *, int); int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setschedpolicy(pthread_attr_t *, int); int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setinheritsched(pthread_attr_t *, int); ","date":"2022-07-18","objectID":"/pthread_thread/:3:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程属性"},{"categories":["pthread"],"content":" 3.3 线程分离 // 线程分离 int pthread_detach(pthread_t); // 线程等待 int pthread_join(pthread_t, void **); // 获取线程自己的ID pthread_t pthread_self(void); // 判断线程是否相等 int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 ","date":"2022-07-18","objectID":"/pthread_thread/:3:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离"},{"categories":["pthread"],"content":" 3.4 线程取消 int pthread_setcancelstate(int, int *); int pthread_setcanceltype(int, int *); void pthread_testcancel(void); int pthread_cancel(pthread_t); ","date":"2022-07-18","objectID":"/pthread_thread/:3:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程取消"},{"categories":["pthread"],"content":" 3.5 调度相关 int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param); __syscall(SYS_sched_getparam, pthread_t-\u003etid, sched_param); __syscall(SYS_sched_getscheduler, pthread_t-\u003etid); int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param); __syscall(SYS_sched_setscheduler, pthread_t-\u003etid, policy, sched_param); // sched_param保存着优先级参数 int pthread_setschedprio(pthread_t t, int prio); __syscall(SYS_sched_setparam, pthread_t-\u003etid, \u0026prio); ","date":"2022-07-18","objectID":"/pthread_thread/:3:5","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#调度相关"},{"categories":["pthread"],"content":" 4 Linux线程实现 ","date":"2022-07-18","objectID":"/pthread_thread/:4:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#linux线程实现"},{"categories":["pthread"],"content":" 5 系统调用","date":"2022-07-18","objectID":"/pthread_thread/:5:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用"},{"categories":["pthread"],"content":" 5.1 系统调用实现(musl) #define __asm_syscall(...) do { __asm__ __volatile__ ( \"svc 0\" : \"=r\"(r0) : __VA_ARGS__ : \"memory\"); return r0; } while (0); #define R7_OPERAND \"r\"(r7) static inline long __syscall0(long n) { register long r7 __ASM____R7__ = n; //使用R7传递个数 register long r0 __asm__(\"r0\"); __asm_syscall(R7_OPERAND); } static inline long __syscall1(long n, long a) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; __asm_syscall(R7_OPERAND, \"0\"(r0)); } static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; register long r1 __asm__(\"r1\") = b; register long r2 __asm__(\"r2\") = c; register long r3 __asm__(\"r3\") = d; register long r4 __asm__(\"r4\") = e; register long r5 __asm__(\"r5\") = f; __asm_syscall(R7_OPERAND, \"0\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3), \"r\"(r4), \"r\"(r5)); } // 一个相当巧妙的宏定义的实现 #define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n #define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) // 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 // 拼装函数调用 #define __SYSCALL_CONCAT_X(a,b) a##b #define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) #define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) // __syscall_ret仅仅检查了系统调用号 #define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) #define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束 系统调用号实现 #ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H #define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 #define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) #define __NR_exit (__NR_SYSCALL_BASE + 1) #define __NR_fork (__NR_SYSCALL_BASE + 2) #define __NR_read (__NR_SYSCALL_BASE + 3) #define __NR_write (__NR_SYSCALL_BASE + 4) #define __NR_open (__NR_SYSCALL_BASE + 5) #define __NR_close (__NR_SYSCALL_BASE + 6) #define __NR_creat (__NR_SYSCALL_BASE + 8) ... #define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) #endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */ ","date":"2022-07-18","objectID":"/pthread_thread/:5:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用实现musl"},{"categories":["pthread"],"content":" 5.2 系统调用实现(glibc)同样的道理,可以分析一下glibc的系统调用时如何进行 但是在一般的情况下此时就可以明白,与musl相同的调用方式时一样的 INLINE_SYSCALL_CALL --\u003e __INLINE_SYSCALL_DISP __INLINE_SYSCALL_DISP --\u003e __SYSCALL_CONCAT 生成一条调用指令的语言 # define INTERNAL_SYSCALL_RAW(name, nr, args...) \\ ({ \\ register int _a1 asm (\"r0\"), _nr asm (\"r7\"); \\ LOAD_ARGS_##nr (args) \\ _nr = name; \\ asm volatile (\"swi 0x0 @ syscall \" #name \\ : \"=r\" (_a1) \\ : \"r\" (_nr) ASM_ARGS_##nr \\ : \"memory\"); \\ _a1; }) ","date":"2022-07-18","objectID":"/pthread_thread/:5:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用实现glibc"},{"categories":["pthread"],"content":" 6 线程基础","date":"2022-07-18","objectID":"/pthread_thread/:6:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程基础"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程创建-1"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现的线程函数"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread管理单元申请与释放"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#内核线程创建"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#tls创建"},{"categories":["pthread"],"content":" 6.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:6:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#设置启动参数"},{"categories":["pthread"],"content":" 6.2 ptrhead进程属性机制 int pthread_attr_init(pthread_attr_t *a); pthread_attr_t-\u003e_a_stacksize = __default_stacksize; pthread_attr_t-\u003e_a_guardsize = __default_guardsize; int pthread_attr_setdetachstate(pthread_attr_t *a, int state); pthread_attr_t-\u003e_a_detach = state; int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_guardsize = size; int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); pthread_attr_t-\u003e_a_sched = inherit; int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param); pthread_attr_t-\u003e_a_prio = param-\u003esched_priority; int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); pthread_attr_t-\u003e_a_policy = policy; int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); pthread_attr_t-\u003e_a_stackaddr = (size_t)addr + size; pthread_attr_t-\u003e_a_stacksize = size; int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_stackaddr = 0; pthread_attr_t-\u003e_a_stacksize = size; ","date":"2022-07-18","objectID":"/pthread_thread/:6:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#ptrhead进程属性机制"},{"categories":["pthread"],"content":" 6.3 自身线程ID // 在musl和glibc的实现上二者不太一样 static inline uintptr_t __get_tp() { uintptr_t tp; __asm__ ( \"mrc p15,0,%0,c13,c0,3\" : \"=r\"(tp) ); return tp; } // 获取线程自身的方法 #define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) // 二者实现不太一样 /* Return the thread descriptor for the current thread. */ # define THREAD_SELF ((struct pthread *)__builtin_thread_pointer () - 1) pthread_t __pthread_self (void) { return (pthread_t) THREAD_SELF; } ","date":"2022-07-18","objectID":"/pthread_thread/:6:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#自身线程id"},{"categories":["pthread"],"content":" 6.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 6.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:6:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程清理函数"},{"categories":["pthread"],"content":" 6.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 6.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:6:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#cancle设置"},{"categories":["pthread"],"content":" 6.5 线程分离 // 线程分离 int pthread_detach(pthread_t) --\u003e __pthread_join(pthread_t, 0) --\u003e __pthread_timedjoin_np(pthread_t, 0, 0) // 设置线程等待 int pthread_join(pthread_t, void **); --\u003e__pthread_timedjoin_np(pthread_t, res, 0) // 那么也就是说明都调用了相同的函数 static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { /* 设置线程分离状态 */ } ","date":"2022-07-18","objectID":"/pthread_thread/:6:5","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离-1"},{"categories":["编译原理"],"content":"编译原理","date":"2022-07-07","objectID":"/compile/","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/"},{"categories":["编译原理"],"content":" 1 词法分析","date":"2022-07-07","objectID":"/compile/:1:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#词法分析"},{"categories":["编译原理"],"content":" 1.1 概述 词法分析是编译原理的第一个阶段,词法分析的任务是读入源程序的输入字符,生成一个个的单词,其主要的功能是为语法分析提供词法单元 graph LR S1((源程序)) S2[词法分析器] S3[语法分析器] S4((符号表)) S5[输出之语义分析] S1--\u003eS2--\u003eS3--\u003eS5 S3--\u003eS2 S2--\u003eS4 S4--\u003eS2 S3--\u003eS4 S4--\u003eS3 ","date":"2022-07-07","objectID":"/compile/:1:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#概述"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compile/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#正则表达式"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compile/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#flex正则表达式"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA)graph LR 输入的字符串 --\u003e 有限状态自动机 有限状态自动机 --\u003e 判断结果[\"{Yes, No}\"] 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 graph LR 状态1((0)) 状态2((1)) 状态3((2)) 状态1--b--\u003e状态1 状态1--a--\u003e状态2 状态2--b--\u003e状态2 状态2--a--\u003e状态3 状态3--a,b--\u003e状态3 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#有限状态自动机fa"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA)graph LR 输入的字符串 --\u003e 有限状态自动机 有限状态自动机 --\u003e 判断结果[\"{Yes, No}\"] 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 graph LR 状态1((0)) 状态2((1)) 状态3((2)) 状态1--b--\u003e状态1 状态1--a--\u003e状态2 状态2--b--\u003e状态2 状态2--a--\u003e状态3 状态3--a,b--\u003e状态3 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#数学描述"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA)graph LR 输入的字符串 --\u003e 有限状态自动机 有限状态自动机 --\u003e 判断结果[\"{Yes, No}\"] 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 graph LR 状态1((0)) 状态2((1)) 状态3((2)) 状态1--b--\u003e状态1 状态1--a--\u003e状态2 状态2--b--\u003e状态2 状态2--a--\u003e状态3 状态3--a,b--\u003e状态3 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#例子"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自动生成"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#thompson算法"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#解释"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#例子-1"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#子集构造算法"},{"categories":["编译原理"],"content":" 1.4 自动生成graph LR RE[正则表达式] NFA[非确定有限自动机] DFA[确定有限状态自动机] mDFA[最简有限状态自动机] RE--Thompson--\u003eNFA--子集构造--\u003eDFA--Hopcroft--\u003emDFA 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#hopcroft算法"},{"categories":["编译原理"],"content":" 2 语法分析","date":"2022-07-07","objectID":"/compile/:2:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#语法分析"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自顶向下"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1分析文法"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1文法概述"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1一般步骤"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#如何生成ll1分析表"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#first集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#follow集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#select集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 graph TB S0{判断是否是LL1文法} S1[消除文法左递归] S2[消除文法的回溯] S3[计算所有非终结符的FIRST集] S4[计算所有非终结符的FLLOW集] S5[根据FIRST和FLLOW集生成分析表] S6[进行LL1分析] SA((开始)) SS((结束)) SA--\u003eS0 S0--是--\u003eS1 S0--否--\u003eSS S1--\u003eS2--\u003eS3--\u003eS4--\u003eS5--\u003eS6--\u003eSS 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#分析流程"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自底向上"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#lr0分析算法"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#点记号"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#生成一个逆序的最右推导"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#构造分析表"},{"categories":["编译原理"],"content":" 3 语义分析","date":"2022-07-07","objectID":"/compile/:3:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#语义分析"},{"categories":["编程语言"],"content":"C++高级编程","date":"2022-06-18","objectID":"/cxx_template/","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/"},{"categories":["编程语言"],"content":" 1 相关知识gcc中typeof关键字用来检查变量类型,那么则可以用来判断魔板生成中的数据类型, 但是在C++中存在这另外的运算符typeid,但是我个人认为typeof更加优秀，但是二者并不相同, typeid返回类型对象,typeof只可以判断类型; 代码如下: #define __toStr(x) #x #define toStr(x) __toStr(x) #define check_type_item(_x, type) \\ if (typeid(_x) == typeid(type)) { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is \" \u003c\u003c toStr(type) \u003c\u003c std::endl; \\ } else #define check_type_tail(_x) \\ { \\ std::cout \u003c\u003c toStr(_x) \u003c\u003c \" is unknow\" \u003c\u003c std::endl; \\ } #define check_type(_x) \\ ({ \\ check_type_item(_x, bool) \\ check_type_item(_x, char) \\ check_type_item(_x, short) \\ check_type_item(_x, int) \\ check_type_item(_x, long) \\ check_type_item(_x, wchar_t) \\ check_type_item(_x, unsigned char) \\ check_type_item(_x, unsigned short) \\ check_type_item(_x, unsigned int) \\ check_type_item(_x, unsigned long) \\ check_type_item(_x, float) \\ check_type_item(_x, double) \\ check_type_item(_x, std::string) \\ check_type_tail(_x) \\ }) 从内核中学到的一种用来编译期间校验的宏函数,用来确定推导过程是否正确 #define BUILD_BUG_ON(cond) ((void)sizeof(int[1-2*(!!(cond))])) C++还提供了一种运算符static_assert,用作编译期间静态静态检查; static_assert(true); // 正确: 编译通过 static_assert(false); // 错误: static assertion failed 那么就可以通过此工具来分析模板推导过程是否是正确的 ","date":"2022-06-18","objectID":"/cxx_template/:1:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#相关知识"},{"categories":["编程语言"],"content":" 2 模板基础 模板和宏定义区别:模板在编译期进行,宏在预编译期间进行 建立通用的模板,提高复用率 C++提供两种模版机制:函数模版和类模板 ","date":"2022-06-18","objectID":"/cxx_template/:2:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板基础"},{"categories":["编程语言"],"content":" 2.1 函数模版 template \u003ctypename T\u003e 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template \u003ctypename T\u003e void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template \u003ctypename T\u003e T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add\u003cint\u003e(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template\u003ctypename T\u003e T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max\u003cdouble\u003e(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template\u003ctypename T1, typename T2, typename RT = std::decay_t\u003cdecltype(true ? T1() : T2())\u003e \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template\u003ctypename T1, typename T2\u003e auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template\u003ctypename T1, typename T2\u003e std::common_type_t\u003cT1,T2\u003e max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template\u003ctypename T = std::string\u003e T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模版"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#实例"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#注意事项"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#普通函数和函数模版的区别"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#普通函数和模版函数调用规则"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段编译检查two-phase-translation"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类型推断中的类型转换"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#多模板参数调用"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#显式指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#返回值指定"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#自动推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#公共类型推导"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#默认模板参数"},{"categories":["编程语言"],"content":" 2.1 函数模版 template 函数声明和定义 template – 声明创建模版 typename – 表明后面的符号是数据类型可以用class代替 T – 通用的数据类型 2.1.1 实例 /* 两个数据交换 */ template void swap(T \u0026a, T \u0026b) { T t= a; a = b; b = t; } 2.1.2 注意事项 自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用 2.1.3 普通函数和函数模版的区别 普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换 模版函数 template T add(T a, T b) { return a + b; } 调用方法 /* 自动推导 */ std::cout \u003c\u003c add(10, 20) \u003c\u003c std::endl; /* 显示指定 */ std::cout \u003c\u003c add(10, 3.14) \u003c\u003c std::endl; 2.1.4 普通函数和模版函数调用规则 普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u003c\u003e(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版 2.1.5 变参模板 2.1.5.1 两阶段编译检查(Two-Phase Translation) 在模板定义阶段，模板的检查并不包含类型参数的检查。只包含下面几个方面： 语法检查。比如少了分号。 使用了未定义的不依赖于模板参数的名称（类型名，函数名，……） 未使用模板参数的static assertions。 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。 总结来说 模板实例化(不同于预编译) 程序编译 2.1.6 类型推断中的类型转换在类型推断的时候自动的类型转换是受限制的： 如果调用参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T 定义的 两个参数，它们实参的类型必须完全一样。 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const 和volatile限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相 应的指针类型。通过模板类型参数T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。 2.1.7 多模板参数调用主要是为了完成max(1, 21),但是 template T max (T a, T b) { return b \u003c a ? a : b; } 如果直接调用`error: no matching function for call to ‘max(int, double)’,会报错,因此可以使用如下方法: 2.1.7.1 显式指定将模板显式指定,从而可以保证编译进行 std::cout \u003c\u003c max(1, 2.1) \u003c\u003c std::endl; 但是总感觉不太优雅,因此一定存在更加优秀的方案,但是此时也可以称之为一个方案 2.1.7.2 返回值指定 template \u003e RT max (T1 a, T2 b) { return b \u003c a ? a : b; } int main(int argc, char *argv[]) { float a = 12, b = 12; check_type(max(1, 2)); // int check_type(max(a, 2)); // float check_type(max(b, 2.0)); // double } 其结果满足我的基本知识 max(1, 2) is int max(a, 2) is float max(b, 2.0) is double 补充知识1 auto和decltype关键字都可以自动推导出变量的类型,但它们的用法是有区别的; auto是根据初始化的时候变量或者表达式的类型来处理,auto a = value decltype使用需要表达式,decltype(exp) varname = value;通过计算exp的类型来确定类型 因此,decltype可以没有初始化的参数,额auto则不可以 std::decay_t可以认为是剥离引用类型, T:某种类型. 当T是引用类型,decay::type返回T引用的元素类型; 当T是非引用类型,decay::type返回T的类型. 2.1.7.3 自动推导 不指定类型,而是由编译器自行判断,auto关键字判断 template auto max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.7.4 公共类型推导 类型萃取std::common_type\u003c\u003e作为返回类型的默认值 template std::common_type_t max(T1 a, T2 b) { return b \u003c a ? a : b; } 2.1.8 默认模板参数 你也可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板。它们甚至可以根据其前面的模板参数来决定自己的类型 简单执行默认参数,直接在T=类型即可,同时可以填入相同类型的默认参数 template T HelloWorld(T f = \"HelloWorld\") { return f; } int main(int argc, char *argv[]) { check_type(HelloWorld()); check_type(HelloWorld(123)); return 0; } 那么显式如下: HelloWorld() is std::string HelloWorld(123) is int 模板类型和默认参数必须是同一种类型 2.1.9 函数模板重载","date":"2022-06-18","objectID":"/cxx_template/:2:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板重载"},{"categories":["编程语言"],"content":" 2.2 类模板 template \u003cclass T\u003e 类 例子 template \u003cclass NameType, class AgeType\u003e class Person { public: Person(NameType Name, AgeType Age) { m_Name = Name; m_Age = Age; } NameType m_Name; AgeType m_Age; }; 实例化 Person\u003cstd::string, int\u003e p(\"Hello\", 99); ","date":"2022-06-18","objectID":"/cxx_template/:2:2","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类模板"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template\u003cint Val, typename T\u003e T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template\u003cdouble VAT\u003e // ERROR: floating-point values are not void process (double v){} template\u003cstd::string name\u003e // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template\u003ctypename T, auto Maxsize\u003e class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板非类型参数"},{"categories":["编程语言"],"content":" 2.3 非类型模板参数 对于之前介绍的函数模板和类模板,其模板参数不一定非得是某种具体的类型,也可以是常 规数值.和类模板使用类型作为参数类似,可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数,待定的不再是类型,而是某个数值.在使用这种模板时需要显式的 指出待定数值的具体值,之后代码会被实例化. 简言之 模板不仅可以作为类型,还可以作为数值 2.3.1 函数模板非类型参数 template T max(T x) { return std::max(x, Val); } int main(int argc, char *argv[]) { std::cout \u003c\u003c max\u003c5, int\u003e(2); return 0; } 2.3.2 非类型模板参数的限制 整形常量(包含枚举) 指针objects/functions/members objects或者functions的左值引用 std::nullptr_t 浮点型数值或者class类型的对象都不能作为非类型模板参数使用 template // ERROR: floating-point values are not void process (double v){} template // ERROR: class-type objects are not class MyClass {}; 使用auto作为变量类型, template class MyClass {}; 需要修改C++标准: c++98 –\u003e 无法编译 c++11 –\u003e 无法编译 c++14 –\u003e 无法编译 c++17 –\u003e 可以编译 c++20 –\u003e 可以编译 模板的参数不只可以是类型,也可以是数值. 不可以将浮点型或者class类型的对象用于非类型模板参数.使用指向字符串常量,临时变量和子对象的指针或引用也有一些限制. 通过使用关键字auto,可以使非类型模板参数的类型更为泛化 ","date":"2022-06-18","objectID":"/cxx_template/:2:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数的限制"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template\u003ctypename T, typename... Types\u003e void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template\u003cclass... T\u003e auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板-1"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板实例"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参个运算符sizeof"},{"categories":["编程语言"],"content":" 2.4 变参模板 类似于C语言可变参数相似,那么,C++也存在这个类似的功能. 可以将模板参数定义成能够接受任意多个模板参数的情况,这一类模板被称为变参模板. 通过使用参数包，模板可以有任意多个任意类型的参数。 为了处理这些参数，需要使用递归，而且需要一个非变参函数终结递归（如果使用编译 期判断，则不需要非变参函数来终结递归）。 运算符sizeof…用来计算参数包中模板参数的数目。 变参模板的一个典型应用是用来发送（forward）任意多个任意类型的模板参数。 通过使用折叠表达式,可以将某种运算应用于参数包中的所有参数. 2.4.1 变参模板实例 template void print_var_args(T firstArg, Types... args) { std::cout \u003c\u003c firstArg \u003c\u003c '\\n'; //print first argument print_var_args(args...); } 通过上面的实例我们可以得到,声明可变参数模板的方法 typename… Types或者class… Types,其中Types就可以用来声明可变参数 Types… args,但是为什么还需要在写一次...,我个人是不太理解的. 以args的剩余参数则称之为函数参数包; 但是只有上述的是编译不过的,因为存在参数消耗殆尽的情况,因此添加一个空的函数, 用作递归结束; 这就是编译期间编程的概念 void print_var_args() { std::cout \u003c\u003c \"变参模板结束\" \u003c\u003c std::endl; } 测试函数 int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = 3; print_var_args(a, b, c); return 0; } 最后运行情况的打印就是 # 1 # 2 # 3 # 变参模板结束 2.4.2 变参个运算符sizeof… C++11为变参模板引入了一种新的sizeof运算符:sizeof... 它会被扩展成参数包中所包含的参数数目 // void print_var_args(T firstArg, Types... args) std::cout \u003c\u003c \"sizeof...(Types)\\t\" \u003c\u003c sizeof...(Types) \u003c\u003c std::endl; // 模板参数包 std::cout \u003c\u003c \"sizeof...(args) \\t\" \u003c\u003c sizeof...(args) \u003c\u003c std::endl; // 函数参数包 运行结果 # sizeof...(Types) 2 # sizeof...(args) 2 因此,可以得出结论 sizeof…可以计算每一次展开的个数 既可以用于模板参数包,也可以用于函数参数包 2.4.3 折叠表达式 从C++17开始,提供了一种可以用来计算参数包(可以有初始值)中所有参数运算结果的二 元运算符. 测试程序 template auto foldSun(T... s) { // s1 + s2 + s3 + sn (其中n参数的个数) return (... + s); } ","date":"2022-06-18","objectID":"/cxx_template/:2:4","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#折叠表达式"},{"categories":["编程语言"],"content":" 3 函数模板 编写时不指定具体类型，直到使用时才能确定，这个概念就是泛型。模板，顾名思义，编写一次即可适用于任意类型。模板定义以关键词 template 开始，后跟一个模板参数列表，类型参数前必须使用关键字 typename 或 class，在模板参数列表中这两个关键字含义相同，可以互换使用。函数模板通常不用声明为 inline，唯一例外的是特定类型的全特化，因为编译器可能忽略 inline，函数模板是否内联取决于编译器的优化策略 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max\u003cint\u003e(1, 3) == 3); assert(jc::max\u003cdouble\u003e(1.0, 3.14) == 3.14); std::string s1 = \"down\"; std::string s2 = \"demo\"; assert(jc::max\u003cstd::string\u003e(s1, s2) == \"down\"); } ","date":"2022-06-18","objectID":"/cxx_template/:3:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板httpsencppreferencecomwcpplanguagefunction_template"},{"categories":["编程语言"],"content":" 4 两阶段编译（Two-Phase Translation） 模板编译分为实例化前检查和实例化两个阶段。实例化前检查模板代码本身，包括 检查语法是否正确，如是否遗漏分号 检查是否使用不依赖于模板参数的未知名称，如未声明的类型名、函数名 检查不依赖于模板参数的静态断言 template \u003ctypename T\u003e void f(T x) { undeclared(); // 一阶段编译错误，未声明的函数 static_assert(sizeof(int) \u003e 10); // 一阶段，sizeof(int) \u003c= 10，总会编译失败 } int main() {} 实例化期间保证代码有效，比如对不能解引用的类型进行解引用就会实例化出错，此外会再次检查依赖于模板参数的部分 template \u003ctypename T\u003e void f(T x) { undeclared(x); // 调用 undeclared(T) 才会出现函数未声明的实例化错误 static_assert(sizeof(T) \u003e 10); // 如果 sizeof(T) \u003c= 10 则实例化错误 } int main() { f(42); // 调用函数才会进行实例化，不调用则不会有实例化错误 } ","date":"2022-06-18","objectID":"/cxx_template/:4:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段编译two-phase-translation"},{"categories":["编程语言"],"content":" 5 模板实参推断（Template Argument Deduction） 调用模板时，如果不显式指定模板参数类型，则编译器会根据传入的实参推断模板参数类型 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3) == 3); // T 推断为 int assert(jc::max(1.0, 3.14) == 3.14); // T 推断为 double std::string s1 = \"down\"; std::string s2 = \"demo\"; assert(jc::max(s1, s2) == \"down\"); // T 推断为 std::string } 实参的推断要求一致，其本身不会为了编译通过自动做类型转换 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e T max(const T\u0026 a, const T\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { jc::max(1, 3.14); // 错误，T 分别推断出 int 和 double，类型不明确 } 字符串字面值传引用会推断为字符数组（传值则推断为 const char*，数组和函数会 decay 为指针） #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T, typename U\u003e T max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { std::string s = \"down\"; jc::max(\"down\", s); // 错误，T 推断为 char[5] 和 std::string } 对于推断不一致的情况，可以显式指定类型而不使用推断机制，或者强制转换实参为希望的类型使得推断结果一致 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T, typename U\u003e T max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { std::string s = \"demo\"; assert(jc::max\u003cstd::string\u003e(\"down\", \"demo\") == \"down\"); assert(jc::max(std::string{\"down\"}, s) == \"down\"); } 也可以增加一个模板参数，这样每个实参的推断都是独立的，不会出现矛盾 #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U\u003e T max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3.14) == 3); // T 推断为 int，返回值截断为 int assert(jc::max\u003cdouble\u003e(1, 3.14) == 3.14); } 模板实参不能推断返回类型，必须显式指定 #include \u003ccassert\u003e namespace jc { template \u003ctypename RT, typename T, typename U\u003e RT max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max\u003cdouble\u003e(1, 3.14) == 3.14); assert((jc::max\u003cdouble, int, int\u003e(1, 3.14) == 3)); } C++14 允许 auto 作为返回类型，它通过 return 语句推断返回类型，C++11 则需要额外指定尾置返回类型，对于三目运算符，其结果类型为两个操作数类型中更公用的类型，比如 int 和 double 的公用类型是 double #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U\u003e auto max(const T\u0026 a, const U\u0026 b) -\u003e decltype(true ? a : b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3.14) == 3.14); } 用 constexpr 函数可以生成编译期值 namespace jc { template \u003ctypename T, typename U\u003e constexpr auto max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { static_assert(jc::max(1, 3.14) == 3.14); } ","date":"2022-06-18","objectID":"/cxx_template/:5:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板实参推断template-argument-deductionhttpsencppreferencecomwcpplanguagetemplate_argument_deduction"},{"categories":["编程语言"],"content":" 6 type traits 对于类型进行计算的模板称为 type traits，也可以称为元函数，比如用 std::common_type 来计算不同类型中最通用的类型 #include \u003ccassert\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename U, typename RT = std::common_type_t\u003cT, U\u003e\u003e RT max(const T\u0026 a, const U\u0026 b) { return a \u003c b ? b : a; } } // namespace jc int main() { assert(jc::max(1, 3.14) == 3.14); } ","date":"2022-06-18","objectID":"/cxx_template/:6:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#type-traitshttpsencppreferencecomwcppheadertype_traits"},{"categories":["编程语言"],"content":" 7 重载 当类型同时匹配普通函数和模板时，优先匹配普通函数 #include \u003ccassert\u003e namespace jc { int f(int a, int b) { return 1; } template \u003ctypename T, typename U\u003e int f(const T\u0026, const U\u0026) { return 2; } } // namespace jc int main() { assert(jc::f(1, 3) == 1); assert(jc::f\u003cdouble\u003e(1, 3) == 2); assert(jc::f\u003c\u003e(1, 3) == 2); assert(jc::f(1, 3.14) == 2); assert(jc::f(3.14, 1) == 2); } 模板参数不同就会构成重载，如果对于给定的实参能同时匹配两个模板，重载解析会优先匹配更特殊的模板，如果同样特殊则产生二义性错误 #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U\u003e int f(const T\u0026, const U\u0026) { return 1; } template \u003ctypename RT, typename T, typename U\u003e int f(const T\u0026 a, const U\u0026 b) { return 2; } } // namespace jc int main() { assert(jc::f(1, 3.14) == 1); assert(jc::f\u003cdouble\u003e(1, 3.14) == 2); // jc::f\u003cint\u003e(1, 3.14); // 二义性错误 } C-style 字符串的重载 #include \u003ccassert\u003e #include \u003ccstring\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e T max(T a, T b) { return a \u003c b ? b : a; } template \u003ctypename T\u003e T* max(T* a, T* b) { return *a \u003c *b ? b : a; } const char* max(const char* a, const char* b) { return std::strcmp(a, b) \u003c 0 ? b : a; } } // namespace jc int main() { int a = 1; int b = 3; assert(jc::max(a, b) == b); assert(jc::max(\u0026a, \u0026b) == \u0026b); std::string s1 = \"down\"; std::string s2 = \"demo\"; assert(jc::max(s1, s2) == \"down\"); assert(std::strcmp(jc::max(\"down\", \"demo\"), \"down\") == 0); } 注意不能返回 C-style 字符串的引用 namespace jc { template \u003ctypename T\u003e const T\u0026 f(const char* s) { return s; } } // namespace jc int main() { const char* s = \"downdemo\"; jc::f\u003cconst char*\u003e(s); // 错误：返回临时对象的引用 } 这种错误可能在添加代码的过程中引入 #include \u003ccstring\u003e namespace jc { template \u003ctypename T\u003e const T\u0026 max(const T\u0026 a, const T\u0026 b) { return b \u003c a ? a : b; } // 新增函数来支持 C-style 参数 const char* max(const char* a, const char* b) { return std::strcmp(a, b) \u003c 0 ? b : a; } template \u003ctypename T\u003e const T\u0026 max(const T\u0026 a, const T\u0026 b, const T\u0026 c) { return max(max(a, b), c); // max(\"down\", \"de\") 返回临时对象的引用 } } // namespace jc int main() { const char* a = \"down\"; const char* b = \"de\"; const char* c = \"mo\"; jc::max\u003cconst char*\u003e(a, b, c); // 错误：返回临时对象的引用 } 只有在函数调用前声明的重载才会被匹配，即使后续有更优先的匹配，由于不可见也会被忽略 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { return 1; } template \u003ctypename T\u003e int g(T a) { return f(a); } int f(int) { return 2; } } // namespace jc int main() { assert(jc::g(0) == 1); } ","date":"2022-06-18","objectID":"/cxx_template/:7:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#重载"},{"categories":["编程语言"],"content":" 8 用于原始数组与字符串字面值（string literal）的模板 字符串字面值传引用会推断为字符数组，为此需要为原始数组和字符串字面值提供特定处理的模板 #include \u003ccassert\u003e #include \u003ccstddef\u003e namespace jc { template \u003ctypename T, typename U\u003e constexpr bool less(const T\u0026 a, const U\u0026 b) { return a \u003c b; } template \u003ctypename T, std::size_t M, std::size_t N\u003e constexpr bool less(T (\u0026a)[M], T (\u0026b)[N]) { for (std::size_t i = 0; i \u003c M \u0026\u0026 i \u003c N; ++i) { if (a[i] \u003c b[i]) { return true; } if (b[i] \u003c a[i]) { return false; } } return M \u003c N; } } // namespace jc static_assert(jc::less(0, 42)); static_assert(!jc::less(\"down\", \"demo\")); static_assert(jc::less(\"demo\", \"down\")); int main() {} 各种类型的数组参数对应的偏特化 #include \u003ccstddef\u003e namespace jc { template \u003ctypename T\u003e struct A; template \u003ctypename T, std::size_t N\u003e struct A\u003cT[N]\u003e { static constexpr int value = 1; }; template \u003ctypename T, std::size_t N\u003e struct A\u003cT (\u0026)[N]\u003e { static constexpr int value = 2; }; template \u003ctypename T\u003e struct A\u003cT[]\u003e { static constexpr int value = 3; }; template \u003ctypename T\u003e struct A\u003cT (\u0026)[]\u003e { static constexpr int value = 4; }; template \u003ctypename T\u003e struct A\u003cT*\u003e { static constexpr int value = 5; }; template \u003ctypename T1, typename T2, typename T3\u003e constexpr void test(int a1[7], int a2[], int (\u0026a3)[42], int (\u0026x0)[], T1 x1, T2\u0026 x2, T3\u0026\u0026 x3) { static_assert(A\u003cdecltype(a1)\u003e::value == 5); // A\u003cT*\u003e static_assert(A\u003cdecltype(a2)\u003e::value == 5); // A\u003cT*\u003e static_assert(A\u003cdecltype(a3)\u003e::value == 2); // A\u003cT(\u0026)[N]\u003e static_assert(A\u003cdecltype(x0)\u003e::value == 4); // A\u003cT(\u0026)[]\u003e static_assert(A\u003cdecltype(x1)\u003e::value == 5); // A\u003cT*\u003e static_assert(A\u003cdecltype(x2)\u003e::value == 4); // A\u003cT(\u0026)[]\u003e static_assert(A\u003cdecltype(x3)\u003e::value == 4); // A\u003cT(\u0026)[]\u003e } } // namespace jc int main() { int a[42]; static_assert(jc::A\u003cdecltype(a)\u003e::value == 1); extern int x[]; // 传引用时将变为 int(\u0026)[] static_assert(jc::A\u003cdecltype(x)\u003e::value == 3); // A\u003cT[]\u003e jc::test(a, a, a, x, x, x, x); } int x[] = {1, 2, 3}; // 定义前置声明的数组 ","date":"2022-06-18","objectID":"/cxx_template/:8:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#用于原始数组与字符串字面值string-literal的模板"},{"categories":["编程语言"],"content":" 9 零初始化（Zero Initialization） 使用模板时常希望模板类型的变量已经用默认值初始化，但内置类型无法满足要求。解决方法是显式调用内置类型的默认构造函数 namespace jc { template \u003ctypename T\u003e constexpr T default_value() { T x{}; return x; } template \u003ctypename T\u003e struct DefaultValue { constexpr DefaultValue() : value() {} T value; }; template \u003ctypename T\u003e struct DefaultValue2 { T value{}; }; static_assert(default_value\u003cbool\u003e() == false); static_assert(default_value\u003cchar\u003e() == 0); static_assert(default_value\u003cint\u003e() == 0); static_assert(default_value\u003cdouble\u003e() == 0); static_assert(DefaultValue\u003cbool\u003e{}.value == false); static_assert(DefaultValue\u003cchar\u003e{}.value == 0); static_assert(DefaultValue\u003cint\u003e{}.value == 0); static_assert(DefaultValue\u003cdouble\u003e{}.value == 0); static_assert(DefaultValue2\u003cbool\u003e{}.value == false); static_assert(DefaultValue2\u003cchar\u003e{}.value == 0); static_assert(DefaultValue2\u003cint\u003e{}.value == 0); static_assert(DefaultValue2\u003cdouble\u003e{}.value == 0); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:9:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#零初始化zero-initialization"},{"categories":["编程语言"],"content":" 10 类模板 和函数类似，类也支持泛型，比如实现一个基于拓扑排序遍历的有向无环图的森林 #include \u003calgorithm\u003e #include \u003ccassert\u003e #include \u003cfunctional\u003e #include \u003cmap\u003e #include \u003cmemory\u003e #include \u003cqueue\u003e #include \u003cset\u003e #include \u003cunordered_set\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename K, typename V\u003e struct DAGNode { K k; V v; std::set\u003cDAGNode\u003cK, V\u003e*\u003e in; std::set\u003cDAGNode\u003cK, V\u003e*\u003e out; }; template \u003ctypename K, typename V\u003e class DAGGraph { public: bool AddEdge(const K\u0026 from, const K\u0026 to); V\u0026 operator[](const K\u0026 key); bool Exist(const K\u0026 key) const; void Clear(); std::size_t Size() const; void Walk(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f, bool start_from_head = true); void WalkHeads(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f); void WalkTails(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f); std::unordered_set\u003cK\u003e NextKeys(); std::unordered_set\u003cK\u003e NextKeys(const K\u0026 key); private: bool IsCyclic(const DAGNode\u003cK, V\u003e\u0026 from, const DAGNode\u003cK, V\u003e\u0026 to) const; void RefreshWalkSequences(); std::vector\u003cstd::set\u003cK\u003e\u003e ConnectedComponents() const; void DFS(const K\u0026 k, std::unordered_set\u003cK\u003e* visited, std::set\u003cK\u003e* connected_components) const; std::vector\u003cK\u003e TopologicalSequence(const std::set\u003cK\u003e\u0026 connected_components, bool start_from_head) const; private: std::map\u003cK, DAGNode\u003cK, V\u003e\u003e bucket_; std::unordered_set\u003cK\u003e heads_; std::unordered_set\u003cK\u003e tails_; std::vector\u003cstd::vector\u003cK\u003e\u003e sequences_start_from_head_; std::vector\u003cstd::vector\u003cK\u003e\u003e sequences_start_from_tail_; private: bool allow_modify_ = true; std::vector\u003cstd::vector\u003cK\u003e\u003e sequences_start_from_head_for_next_; std::unordered_set\u003cK\u003e current_heads_for_next_; }; template \u003ctypename K, typename V\u003e inline bool DAGGraph\u003cK, V\u003e::AddEdge(const K\u0026 from, const K\u0026 to) { assert(allow_modify_); if (from == to || !bucket_.count(from) || !bucket_.count(to) || IsCyclic(bucket_.at(from), bucket_.at(to))) { return false; } bucket_.at(from).out.emplace(\u0026bucket_.at(to)); bucket_.at(to).in.emplace(\u0026bucket_.at(from)); heads_.erase(to); tails_.erase(from); sequences_start_from_head_.clear(); sequences_start_from_tail_.clear(); return true; } template \u003ctypename K, typename V\u003e inline V\u0026 DAGGraph\u003cK, V\u003e::operator[](const K\u0026 key) { if (!bucket_.count(key)) { assert(allow_modify_); bucket_[key].k = key; heads_.emplace(key); tails_.emplace(key); sequences_start_from_head_.clear(); sequences_start_from_tail_.clear(); } return bucket_.at(key).v; } template \u003ctypename K, typename V\u003e inline bool DAGGraph\u003cK, V\u003e::Exist(const K\u0026 key) const { return bucket_.count(key); } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::Clear() { allow_modify_ = true; bucket_.clear(); heads_.clear(); tails_.clear(); sequences_start_from_head_.clear(); sequences_start_from_tail_.clear(); } template \u003ctypename K, typename V\u003e inline std::size_t DAGGraph\u003cK, V\u003e::Size() const { return bucket_.size(); } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::Walk(std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f, bool start_from_head) { if (sequences_start_from_head_.empty()) { RefreshWalkSequences(); } const std::vector\u003cstd::vector\u003cK\u003e\u003e\u0026 seqs_to_walk = start_from_head ? sequences_start_from_head_ : sequences_start_from_tail_; for (const std::vector\u003cK\u003e\u0026 seq : seqs_to_walk) { std::for_each(std::begin(seq), std::end(seq), [\u0026](const K\u0026 key) { const DAGNode\u003cK, V\u003e\u0026 node = bucket_.at(key); f(node.k, node.v); }); } } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::WalkHeads( std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f) { if (sequences_start_from_head_.empty()) { RefreshWalkSequences(); } for (const std::vector\u003cK\u003e\u0026 seq : sequences_start_from_head_) { std::for_each(std::begin(seq), std::end(seq), [\u0026](const K\u0026 key) { if (heads_.count(key)) { const DAGNode\u003cK, V\u003e\u0026 node = bucket_.at(key); f(node.k, node.v); } }); } } template \u003ctypename K, typename V\u003e inline void DAGGraph\u003cK, V\u003e::WalkTails( std::function\u003cvoid(const K\u0026 k, const V\u0026 v)\u003e f) { if (sequences_start_from_head_.empty()) { RefreshWalkSequences(); } for (const std::vector\u003cK\u003e\u0026 seq : sequences_start_from_tail_) { std::for_each(s","date":"2022-06-18","objectID":"/cxx_template/:10:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类模板httpsencppreferencecomwcpplanguageclass_template"},{"categories":["编程语言"],"content":" 11 友元 类内定义友元可以省略模板参数，但友元函数在类模板实例化后才会实例化，如果类模板中的友元函数不包含模板参数，则会出现重定义的错误 #include \u003ciostream\u003e #include \u003ctypeinfo\u003e namespace jc { template \u003ctypename T\u003e class A { // 类作用域内的 A 是注入类名，等价于 A\u003cT\u003e friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u0026 rhs) { return os \u003c\u003c \"A\u003c\" \u003c\u003c typeid(T).name() \u003c\u003c \"\u003e = \" \u003c\u003c rhs.n; } friend void f() {} private: int n = 0; }; } // namespace jc int main() { jc::A\u003cvoid\u003e a; // 实例化 operator\u003c\u003c(std::ostream\u0026, const A\u003cvoid\u003e\u0026) 和 f() std::cout \u003c\u003c a; // A\u003cvoid\u003e = 0 // jc::A\u003cint\u003e b; // 错误：第二次实例化 f()，重定义 } 类外定义友元不会有重定义的问题，需要在类内声明处为类模板额外指定不同的模板参数 #include \u003ciostream\u003e #include \u003ctypeinfo\u003e namespace jc { template \u003ctypename T\u003e class A { template \u003ctypename U\u003e friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cU\u003e\u0026 rhs); friend void f(); private: int n = 0; }; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs) { return os \u003c\u003c \"A\u003c\" \u003c\u003c typeid(T).name() \u003c\u003c \"\u003e = \" \u003c\u003c rhs.n; } void f() {} } // namespace jc int main() { jc::A\u003cvoid\u003e a; std::cout \u003c\u003c a; // A\u003cvoid\u003e = 0 jc::A\u003cint\u003e b; std::cout \u003c\u003c b; // A\u003cint\u003e = 0 } 如果要在类外定义友元，又不想在类内声明额外指定模板参数，则可以将友元声明为函数模板，在类内使用模板实例作为友元 #include \u003ciostream\u003e #include \u003ctypeinfo\u003e namespace jc { template \u003ctypename T\u003e class A; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs); template \u003ctypename T\u003e class A { friend std::ostream\u0026 operator\u003c\u003c\u003cT\u003e(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs); private: int n = 0; }; template \u003ctypename T\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const A\u003cT\u003e\u0026 rhs) { return os \u003c\u003c \"A\u003c\" \u003c\u003c typeid(T).name() \u003c\u003c \"\u003e = \" \u003c\u003c rhs.n; } } // namespace jc int main() { jc::A\u003cvoid\u003e a; std::cout \u003c\u003c a; // A\u003cvoid\u003e = 0 } 如果将类模板实例声明为友元，则类模板必须已声明并可见 namespace jc { template \u003ctypename T\u003e struct Node; template \u003ctypename T\u003e struct Tree { friend class Node\u003cT\u003e; // 友元类模板必须已声明并可见 friend class A; // 友元类可以未声明 }; } // namespace jc int main() {} 模板参数可以是友元 namespace jc { template \u003ctypename T\u003e class A { friend T; // 如果 T 不是 class 则忽略 private: int n = 0; }; class B { public: static int f(const A\u003cB\u003e\u0026 a) { return a.n; } }; } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:11:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#友元"},{"categories":["编程语言"],"content":" 12 特化（Specialization） 特化一般指的是全特化，即为一种特定类型指定一个特定实现，该类型将不使用模板的实例化版本 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class A { public: int f() { return 1; } }; template \u003c\u003e class A\u003cint\u003e { public: int f() { return 2; } int g() { return 3; } }; } // namespace jc int main() { jc::A\u003cvoid\u003e a; assert(a.f() == 1); jc::A\u003cint\u003e b; assert(b.f() == 2); assert(b.g() == 3); } ","date":"2022-06-18","objectID":"/cxx_template/:12:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#特化specializationhttpsencppreferencecomwcpplanguagetemplate_specialization"},{"categories":["编程语言"],"content":" 13 偏特化（Partial Specialization） 偏特化是为一类类型指定特定实现，是一种更通用的特化 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class A { public: int f() { return 1; } }; template \u003ctypename T\u003e class A\u003cT*\u003e { public: int f() { return 2; } int g() { return 3; } }; } // namespace jc int main() { jc::A\u003cint\u003e a; assert(a.f() == 1); jc::A\u003cint*\u003e b; assert(b.f() == 2); assert(b.g() == 3); jc::A\u003cjc::A\u003cint\u003e*\u003e c; assert(c.f() == 2); assert(c.g() == 3); } 偏特化可以指定多个模板参数之间的关系，如果多个偏特化匹配程度相同，将产生二义性错误。如果模板声明是一个普通声明（没有在模板名称后添加尖括号），这个声明就是一个主模板（primary template），编写偏特化通常会有一个主模板和其他偏特化模板 namespace jc { template \u003ctypename T, typename U\u003e struct A; // primary template template \u003ctypename T\u003e struct A\u003cT, T\u003e { static constexpr int i = 1; }; template \u003ctypename T\u003e struct A\u003cT, int\u003e { static constexpr int j = 2; }; template \u003ctypename T, typename U\u003e struct A\u003cT*, U*\u003e { static constexpr int k = 3; }; } // namespace jc using namespace jc; static_assert(A\u003cdouble, double\u003e::i == 1); static_assert(A\u003cdouble, int\u003e::j == 2); static_assert(A\u003cint*, double*\u003e::k == 3); int main() { // A\u003cint, int\u003e{}; // 错误，匹配 A\u003cT, T\u003e 和 A\u003cT, int\u003e // A\u003cint*, int*\u003e{}; // 错误，匹配 A\u003cT, T\u003e 和 A\u003cT*, U*\u003e } 如果多个特化中，有一个匹配程度最高，则不会有二义性错误 namespace jc { template \u003ctypename T, typename U\u003e struct A; template \u003ctypename T\u003e struct A\u003cT, T\u003e { static constexpr int i = 1; }; template \u003ctypename T\u003e struct A\u003cT, int\u003e { static constexpr int j = 2; }; template \u003ctypename T, typename U\u003e struct A\u003cT*, U*\u003e { static constexpr int k = 3; }; template \u003ctypename T\u003e struct A\u003cT*, T*\u003e { static constexpr int k = 4; }; } // namespace jc static_assert(jc::A\u003cdouble, double\u003e::i == 1); static_assert(jc::A\u003cdouble, int\u003e::j == 2); static_assert(jc::A\u003cint*, double*\u003e::k == 3); static_assert(jc::A\u003cdouble*, int*\u003e::k == 3); static_assert(jc::A\u003cint*, int*\u003e::k == 4); static_assert(jc::A\u003cdouble*, double*\u003e::k == 4); int main() {} 偏特化常用于元编程 #include \u003ctuple\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename Tuple\u003e struct is_among; template \u003ctypename T, template \u003ctypename...\u003e class Tuple, typename... List\u003e struct is_among\u003cT, Tuple\u003cList...\u003e\u003e : std::disjunction\u003cstd::is_same\u003cT, List\u003e...\u003e {}; template \u003ctypename T, typename Tuple\u003e inline constexpr bool is_among_v = is_among\u003cT, Tuple\u003e::value; } // namespace jc static_assert(jc::is_among_v\u003cint, std::tuple\u003cchar, int, double\u003e\u003e); static_assert(!jc::is_among_v\u003cfloat, std::tuple\u003cchar, int, double\u003e\u003e); int main() {} 偏特化遍历 std::tuple #include \u003ccstddef\u003e #include \u003ciostream\u003e #include \u003ctuple\u003e namespace jc { template \u003cstd::size_t Index, std::size_t N, typename... List\u003e struct PrintImpl { static void impl(const std::tuple\u003cList...\u003e\u0026 t) { std::cout \u003c\u003c std::get\u003cIndex\u003e(t) \u003c\u003c \" \"; PrintImpl\u003cIndex + 1, N, List...\u003e::impl(t); } }; template \u003cstd::size_t N, typename... List\u003e struct PrintImpl\u003cN, N, List...\u003e { static void impl(const std::tuple\u003cList...\u003e\u0026 t) {} }; template \u003ctypename... List\u003e void Print(const std::tuple\u003cList...\u003e\u0026 t) { PrintImpl\u003c0, sizeof...(List), List...\u003e::impl(t); } } // namespace jc int main() { auto t = std::make_tuple(3.14, 42, \"hello world\"); jc::Print(t); // 3.14 42 hello world } 成员模板也能特化或偏特化 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { struct A { template \u003ctypename T = std::string\u003e T as() const { return s; } std::string s; }; template \u003c\u003e inline bool A::as\u003cbool\u003e() const { return s == \"true\"; } } // namespace jc int main() { jc::A a{\"hello\"}; assert(a.as() == \"hello\"); assert(!a.as\u003cbool\u003e()); jc::A b{\"true\"}; assert(b.as\u003cbool\u003e()); } 成员函数模板不能为虚函数，因为虚函数表的大小是固定的，而成员函数模板的实例化个数要编译完成后才能确定 namespace jc { template \u003ctypename T\u003e class Dynamic { public: virtual ~Dynamic() {} // OK，每个 Dynamic\u003cT\u003e 对应一个析构函数 template \u003ctypename U\u003e virtual void f(const U\u0026) {} // 错误，编译器不知道一个 Dynamic\u003cT\u003e 中 f() 个数 }; } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:13:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#偏特化partial-specializationhttpsencppreferencecomwcpplanguagepartial_specialization"},{"categories":["编程语言"],"content":" 14 模板的模板参数（Template Template Parameter） 如果模板参数的类型是类模板，则需要使用模板的模板参数。对于模板的模板参数，C++11 之前只能用 class 关键字修饰，C++11 及其之后可以用别名模板的名称来替代，C++17 可以用 typename 修饰 #include \u003cset\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T, template \u003ctypename...\u003e class Container\u003e void f(const Container\u003cT\u003e\u0026) {} } // namespace jc int main() { jc::f(std::vector\u003cint\u003e{}); jc::f(std::vector\u003cdouble\u003e{}); jc::f(std::set\u003cint\u003e{}); } 实际上容器还有一个模板参数，即内存分配器 allocator #include \u003ccassert\u003e #include \u003cdeque\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T, template \u003ctypename Elem, typename = std::allocator\u003cElem\u003e\u003e class Container = std::deque\u003e class Stack { public: using reference = T\u0026; using const_reference = const T\u0026; template \u003ctypename, template \u003ctypename, typename\u003e class\u003e friend class Stack; template \u003ctypename U, template \u003ctypename Elem2, typename = std::allocator\u003cElem2\u003e\u003e class Container2\u003e Stack\u003cT, Container\u003e\u0026 operator=(const Stack\u003cU, Container2\u003e\u0026); void push(const T\u0026); void pop(); reference top(); const_reference top() const; std::size_t size() const; bool empty() const; private: Container\u003cT\u003e container_; }; template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e template \u003ctypename U, template \u003ctypename, typename\u003e class Container2\u003e inline Stack\u003cT, Container\u003e\u0026 Stack\u003cT, Container\u003e::operator=( const Stack\u003cU, Container2\u003e\u0026 rhs) { container_.assign(rhs.container_.begin(), rhs.container_.end()); return *this; } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline void Stack\u003cT, Container\u003e::push(const T\u0026 x) { container_.emplace_back(x); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline void Stack\u003cT, Container\u003e::pop() { assert(!empty()); container_.pop_back(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline typename Stack\u003cT, Container\u003e::reference Stack\u003cT, Container\u003e::top() { assert(!empty()); return container_.back(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline typename Stack\u003cT, Container\u003e::const_reference Stack\u003cT, Container\u003e::top() const { assert(!empty()); return container_.back(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline std::size_t Stack\u003cT, Container\u003e::size() const { return container_.size(); } template \u003ctypename T, template \u003ctypename, typename\u003e class Container\u003e inline bool Stack\u003cT, Container\u003e::empty() const { return container_.empty(); } } // namespace jc int main() { jc::Stack\u003cstd::string\u003e s; s.push(\"hello\"); s.push(\"world\"); assert(s.size() == 2); assert(s.top() == \"world\"); s.pop(); assert(s.size() == 1); assert(s.top() == \"hello\"); s.pop(); assert(s.empty()); } ","date":"2022-06-18","objectID":"/cxx_template/:14:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板的模板参数template-template-parameter"},{"categories":["编程语言"],"content":" 15 非类型模板参数（Non-type Template Parameter） 非类型模板参数表示在编译期或链接期可以确定的常量值 #include \u003cbitset\u003e #include \u003ccassert\u003e namespace jc { template \u003cbool IsSet = true, std::size_t N\u003e std::size_t find_next(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { for (std::size_t i = cur + 1; i \u003c N; ++i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } template \u003cbool IsSet = true, std::size_t N\u003e std::size_t find_prev(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { if (cur \u003e N) { cur = N; } for (int i = static_cast\u003cint\u003e(cur) - 1; i \u003e= 0; --i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } template \u003cbool IsSet = true, std::size_t N\u003e std::size_t circular_find_next(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { if (cur \u003e N) { cur = N; } std::size_t res = find_next\u003cIsSet\u003e(b, cur); if (res != N) { return res; } for (std::size_t i = 0; i \u003c cur; ++i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } template \u003cbool IsSet = true, std::size_t N\u003e std::size_t circular_find_prev(const std::bitset\u003cN\u003e\u0026 b, std::size_t cur) { if constexpr (N == 0) { return N; } std::size_t res = find_prev\u003cIsSet\u003e(b, cur); if (res != N) { return res; } for (std::size_t i = N - 1; i \u003e cur; --i) { if (!(b.test(i) ^ IsSet)) { return i; } } return N; } } // namespace jc void test_find_next() { std::bitset\u003c8\u003e b{\"10010111\"}; static constexpr int _next_set[] = {1, 2, 4, 4, 7, 7, 7, 8, 8, 8}; static constexpr int _next_unset[] = {3, 3, 3, 5, 5, 6, 8, 8, 8, 8}; for (std::size_t i = 0; i \u003c std::size(_next_set); ++i) { assert(jc::find_next\u003ctrue\u003e(b, i) == _next_set[i]); assert(jc::find_next\u003cfalse\u003e(b, i) == _next_unset[i]); } } void test_find_prev() { std::bitset\u003c8\u003e b{\"10010110\"}; static constexpr int _prev_set[] = {8, 8, 1, 2, 2, 4, 4, 4, 7, 7}; static constexpr int _prev_unset[] = {8, 0, 0, 0, 3, 3, 5, 6, 6, 6}; for (std::size_t i = 0; i \u003c std::size(_prev_set); ++i) { assert(jc::find_prev\u003ctrue\u003e(b, i) == _prev_set[i]); assert(jc::find_prev\u003cfalse\u003e(b, i) == _prev_unset[i]); } } void test_circular_find_next() { std::bitset\u003c8\u003e b{\"01010111\"}; static constexpr int _next_set[] = {1, 2, 4, 4, 6, 6, 0, 0, 0, 0}; static constexpr int _next_unset[] = {3, 3, 3, 5, 5, 7, 7, 3, 3, 3}; for (std::size_t i = 0; i \u003c std::size(_next_set); ++i) { assert(jc::circular_find_next\u003ctrue\u003e(b, i) == _next_set[i]); assert(jc::circular_find_next\u003cfalse\u003e(b, i) == _next_unset[i]); } } void test_circular_find_prev() { std::bitset\u003c8\u003e b{\"10011001\"}; static constexpr int _prev_set[] = {7, 0, 0, 0, 3, 4, 4, 4, 7, 7}; static constexpr int _prev_unset[] = {6, 6, 1, 2, 2, 2, 5, 6, 6, 6}; for (std::size_t i = 0; i \u003c std::size(_prev_set); ++i) { assert(jc::circular_find_prev\u003ctrue\u003e(b, i) == _prev_set[i]); assert(jc::circular_find_prev\u003cfalse\u003e(b, i) == _prev_unset[i]); } } int main() { test_find_next(); test_find_prev(); test_circular_find_next(); test_circular_find_prev(); } 模板参数可以由之前的参数推断类型，C++17 允许将非类型模板参数定义为 auto 或 decltype(auto) #include \u003ccassert\u003e namespace jc { template \u003ctypename\u003e struct get_class; template \u003ctypename ClassType, typename MemberType\u003e struct get_class\u003cMemberType ClassType::*\u003e { using type = ClassType; }; template \u003ctypename T\u003e using get_class_t = typename get_class\u003cT\u003e::type; template \u003cauto ClassMember\u003e class Wrapper { public: Wrapper(get_class_t\u003cdecltype(ClassMember)\u003e\u0026 obj) : obj_(obj) {} void increase() { ++(obj_.*ClassMember); } private: get_class_t\u003cdecltype(ClassMember)\u003e\u0026 obj_; }; struct A { int i = 0; }; } // namespace jc int main() { jc::A a; jc::Wrapper\u003c\u0026jc::A::i\u003e{a}.increase(); assert(a.i == 1); } C++14 允许 auto 作返回类型 namespace jc { template \u003ctypename T, typename U\u003e constexpr auto add(const T\u0026 a, const U\u0026 b) { return a + b; } } // namespace jc static_assert(jc::add('A', 2) == 'C'); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:15:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非类型模板参数non-type-template-parameterhttpsencppreferencecomwcpplanguagetemplate_parametersnon-type_template_parameter"},{"categories":["编程语言"],"content":" 16 限制 C++20 之前，非类型模板参数不能是浮点数 namespace jc { template \u003cauto N\u003e struct A { static constexpr auto f() { return N; } }; } // namespace jc static_assert(jc::A\u003c42\u003e::f() == 42); static_assert(jc::A\u003c3.14\u003e::f() == 3.14); // C++20 int main() {} 不能用字符串字面值常量、临时对象、数据成员或其他子对象作模板实参。C++ 标准演进过程中逐渐放宽了对字符数组作为模板实参的限制，C++11 仅允许外链接（external linkage，不定义于单一的文件作用域，链接到全局符号表），C++14 允许外链接或内链接（internal linkage，只能在单个文件内部看到，不能被其他文件访问，不暴露给链接器），C++17 不要求链接 namespace jc { template \u003cconst char* s\u003e struct A {}; } // namespace jc constexpr const char* s1 = \"hello\"; // 内链接对象的指针 extern const char s2[] = \"world\"; // 外链接 const char s3[] = \"down\"; // 内链接 int main() { static const char s4[] = \"demo\"; // 无链接 jc::A\u003c\"downdemo\"\u003e{}; // 错误 jc::A\u003cs1\u003e{}; // 错误 jc::A\u003cs2\u003e{}; // C++11 允许 jc::A\u003cs3\u003e{}; // C++14 允许 jc::A\u003cs4\u003e{}; // C++17 允许 } 非类型模板参数可以是左值引用，此时实参必须是静态常量 #include \u003ccassert\u003e namespace jc { template \u003cint\u0026 N\u003e struct A { A() { ++N; } ~A() { --N; } }; void test() { static int n = 0; { A\u003cn\u003e a; assert(n == 1); } assert(n == 0); } } // namespace jc int main() { jc::test(); } 函数和数组类型作为非类型模板参数会退化为指针类型 namespace jc { template \u003cint buf[5]\u003e struct Lexer {}; // template \u003cint* buf\u003e // struct Lexer {}; // 错误：重定义 template \u003cint fun()\u003e struct FuncWrap {}; // template \u003cint (*)()\u003e // struct FuncWrap {}; // 错误：重定义 } // namespace jc int main() {} 如果模板实参的表达式有大于号，必须用小括号包裹表达式，否则大于号会被编译器视为表示参数列表终止的右尖括号，导致编译错误 namespace jc { template \u003cbool b\u003e struct A { inline static constexpr bool value = b; }; } // namespace jc int main() { static_assert(jc::A\u003c(sizeof(int) \u003e 0)\u003e::value); } ","date":"2022-06-18","objectID":"/cxx_template/:16:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#限制"},{"categories":["编程语言"],"content":" 17 变量模板（Variable Template） C++14 提供了变量模板 namespace jc { template \u003ctypename T = double\u003e constexpr T pi{static_cast\u003cT\u003e(3.1415926535897932385)}; static_assert(pi\u003cbool\u003e == true); static_assert(pi\u003cint\u003e == 3); static_assert(pi\u003cdouble\u003e == 3.1415926535897932385); static_assert(pi\u003c\u003e == 3.1415926535897932385); } // namespace jc int main() {} 变量模板可以由非类型参数参数化 #include \u003carray\u003e #include \u003ccassert\u003e namespace jc { template \u003cint N\u003e std::array\u003cint, N\u003e arr{}; template \u003cauto N\u003e constexpr decltype(N) x = N; } // namespace jc static_assert(jc::x\u003c'c'\u003e == 'c'); int main() { jc::arr\u003c10\u003e[0] = 42; assert(jc::arr\u003c10\u003e[0] == 42); } ","date":"2022-06-18","objectID":"/cxx_template/:17:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变量模板variable-templatehttpsencppreferencecomwcpplanguagevariable_template"},{"categories":["编程语言"],"content":" 18 变参模板（Variadic Template） 如果函数要接受任意数量任意类型的参数，没有模板时可以通过 std::va_list 实现 #include \u003ccassert\u003e #include \u003ccstdarg\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003cstring\u003e namespace jc { void test(int n, ...) { std::va_list args; va_start(args, n); assert(va_arg(args, double) == 3.14); assert(va_arg(args, int) == 42); assert(std::strcmp(va_arg(args, const char*), \"hello\") == 0); assert(std::strcmp(va_arg(args, const char*), \"world\") == 0); va_end(args); } void test(const char* fmt, ...) { char buf[256]; std::va_list args; va_start(args, fmt); std::vsnprintf(buf, 256, fmt, args); va_end(args); assert(std::strcmp(buf, \"3.14 42 hello world\") == 0); } } // namespace jc int main() { jc::test(4, 3.14, 42, std::string{\"hello\"}.c_str(), \"world\"); jc::test(\"%.2f %d %s %s\", 3.14, 42, std::string{\"hello\"}.c_str(), \"world\"); } C++11 引入了变参模板，用省略号表示一个参数包，类型名后接省略号表示任意数量给定类型的参数。在表达式后跟省略号，如果表达式中有参数包，就会把表达式应用到参数包中的每个参数。如果表达式中出现两次参数包，对整个表达式扩展，而不会做笛卡尔积计算 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctuple\u003e #include \u003cutility\u003e namespace jc { void print() {} // 参数包展开到零参数时调用 template \u003ctypename T, typename... Args\u003e void print(const T\u0026 t, Args\u0026\u0026... args) { std::cout \u003c\u003c t \u003c\u003c \",\"; print(std::forward\u003cArgs\u003e(args)...); } template \u003cint... Index\u003e struct A {}; template \u003ctypename... List, int... Index\u003e void test1(const std::tuple\u003cList...\u003e\u0026 t, A\u003cIndex...\u003e) { print(std::get\u003cIndex\u003e(t)...); // print(std::get\u003c2\u003e(t), std::get\u003c3\u003e(t)); } template \u003ctypename... List, int... Index\u003e void test2(const std::tuple\u003cList...\u003e\u0026 t, A\u003cIndex...\u003e) { print((std::get\u003cIndex\u003e(t) + std::get\u003cIndex\u003e(t))...); } } // namespace jc int main() { auto t = std::make_tuple(3.14, 42, std::string{\"hello\"}, \"world\"); jc::test1(t, jc::A\u003c2, 3\u003e{}); // hello,world jc::test2(t, jc::A\u003c0, 1, 2\u003e{}); // 6.28,84,hellohello, } 注意参数包的省略号不能直接接在数值字面值后 template \u003ctypename... Args\u003e void f(const Args\u0026... args) { print(args + 1...); // ERROR：1... 是带多个小数点的字面值，不合法 print(args + 1 ...); // OK print((args + 1)...); // OK } 可以直接用逗号运算符做参数包扩展，逗号左侧是对参数包每个元素做的操作，右侧是一个无关紧要的值，这样展开后对每个元素都做了操作，并形成了一个以无关值为元素的数组，这个数组无作用，只是为了满足扩展时省略号不能为表达式最后的 token 而引入 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename... Args\u003e void print(Args\u0026\u0026... args) { auto a = {(std::cout \u003c\u003c std::forward\u003cArgs\u003e(args) \u003c\u003c std::endl, 0)...}; } } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } C++11 引入了 sizeof… 在编译期计算参数包中的元素数，C++17 引入了 if constexpr 判断编译期值，编译期结果为 true 才会实例化代码 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T, typename... Args\u003e void print(const T\u0026 t, Args\u0026\u0026... args) { std::cout \u003c\u003c t \u003c\u003c std::endl; if constexpr (sizeof...(args) \u003e 0) { // 不能用 if，因为零长包也会实例化代码 print(std::forward\u003cArgs\u003e(args)...); // 当条件满足时才实例化 } } } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } 在 C++11 中可以利用偏特化来达到 if constexpr 的效果 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { template \u003cbool b\u003e struct A; template \u003ctypename T, typename... Args\u003e void print(const T\u0026 t, Args\u0026\u0026... args) { std::cout \u003c\u003c t \u003c\u003c std::endl; A\u003c(sizeof...(args) \u003e 0)\u003e::f(std::forward\u003cArgs\u003e(args)...); } template \u003cbool b\u003e struct A { template \u003ctypename... Args\u003e static void f(Args\u0026\u0026... args) { print(std::forward\u003cArgs\u003e(args)...); } }; template \u003c\u003e struct A\u003cfalse\u003e { static void f(...) {} }; } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } ","date":"2022-06-18","objectID":"/cxx_template/:18:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板variadic-template"},{"categories":["编程语言"],"content":" 19 折叠表达式（Fold Expression） C++17 引入了折叠表达式，用于获取对所有参数包实参使用二元运算符的计算结果 #include \u003ciostream\u003e #include \u003ctuple\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename... Args\u003e auto sum(Args\u0026\u0026... args) { auto a = (... + std::forward\u003cArgs\u003e(args)); // (((1 + 2) + 3) + 4) auto b = (std::forward\u003cArgs\u003e(args) + ...); // (1 + (2 + (3 + 4))) auto c = (5 + ... + std::forward\u003cArgs\u003e(args)); // ((((5 + 1) + 2) + 3) + 4) auto d = (std::forward\u003cArgs\u003e(args) + ... + 5); // (1 + (2 + (3 + (4 + 5)))) return std::make_tuple(a, b, c, d); } auto print1 = [](auto\u0026\u0026... args) { // operator\u003c\u003c 左折叠，std::cout 是初始值 (std::cout \u003c\u003c ... \u003c\u003c std::forward\u003cdecltype(args)\u003e(args)); }; auto print2 = [](auto\u0026\u0026... args) { // operator, 左折叠 ((std::cout \u003c\u003c std::forward\u003cdecltype(args)\u003e(args) \u003c\u003c \",\"), ...); }; } // namespace jc int main() { auto [a, b, c, d] = jc::sum(1, 2, 3, 4); jc::print1(a, b, c, d); // 10101515 jc::print2(a, b, c, d); // 10,10,15,15, } 对于空扩展需要决定类型和值，空的一元折叠表达式通常会产生错误，除了三种例外情况 一个 \u0026\u0026 的一元折叠的空扩展产生值 true 一个 || 的一元折叠的空扩展产生值 false 一个 , 的一元折叠空扩展产生一个 void 表达式 折叠表达式 计算结果 (… op pack) (((pack1 op pack2) op pack3) … op PackN) (pack op …) (pack1 op (… (packN-1 op packN))) (init op … op pack) (((init op pack1) op pack2) … op PackN) (pack op … op init) (pack1 op (… (packN op init))) 折叠表达式借鉴的是 Haskell 的 fold import Data.List (foldl') foldlList :: [Char] foldlList = foldl' (\\x y -\u003e concat [\"(\", x, \"+\", y, \")\"]) \"0\" (map show [1 .. 4]) foldrList :: [Char] foldrList = foldr ((\\x y -\u003e concat [\"(\", x, \"+\", y, \")\"]) . show) \"0\" [1 .. 4] main :: IO () main = do putStrLn foldlList -- ((((0+1)+2)+3)+4) putStrLn foldrList -- (1+(2+(3+(4+0)))) 实现与 Haskell 类似的左折叠和右折叠 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename F, typename T, typename... Args\u003e void foldlList(F\u0026\u0026 f, T\u0026\u0026 zero, Args\u0026\u0026... x) { ((std::invoke(std::forward\u003cF\u003e(f), (std::string(sizeof...(Args), '('))), std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cT\u003e(zero)))), ..., (std::invoke(std::forward\u003cF\u003e(f), ('+')), std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cArgs\u003e(x))), std::invoke(std::forward\u003cF\u003e(f), (')')))); } template \u003ctypename F, typename T, typename... Args\u003e void foldrList(F\u0026\u0026 f, T\u0026\u0026 zero, Args\u0026\u0026... x) { ((std::invoke(std::forward\u003cF\u003e(f), ('(')), std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cArgs\u003e(x))), std::invoke(std::forward\u003cF\u003e(f), ('+'))), ..., (std::invoke(std::forward\u003cF\u003e(f), (std::forward\u003cT\u003e(zero))), std::invoke(std::forward\u003cF\u003e(f), (std::string(sizeof...(Args), ')'))))); } } // namespace jc int main() { auto print = [](const auto\u0026 x) { std::cout \u003c\u003c x; }; jc::foldlList(print, 0, 1, 2, 3, 4); // ((((0+1)+2)+3)+4) jc::foldrList(print, 0, 1, 2, 3, 4); // (1+(2+(3+(4+0)))) } 折叠表达式几乎可以使用所有二元运算符 #include \u003ccassert\u003e namespace jc { struct Node { Node(int i) : val(i) {} int val = 0; Node* left = nullptr; Node* right = nullptr; }; // 使用 operator-\u003e* 的折叠表达式，用于遍历指定的二叉树路径 template \u003ctypename T, typename... Args\u003e Node* traverse(T root, Args... paths) { return (root-\u003e*...-\u003e*paths); // root -\u003e* paths1 -\u003e* paths2 ... } void test() { Node* root = new Node{0}; root-\u003eleft = new Node{1}; root-\u003eleft-\u003eright = new Node{2}; root-\u003eleft-\u003eright-\u003eleft = new Node{3}; auto left = \u0026Node::left; auto right = \u0026Node::right; Node* node1 = traverse(root, left); assert(node1-\u003eval == 1); Node* node2 = traverse(root, left, right); assert(node2-\u003eval == 2); Node* node3 = traverse(node2, left); assert(node3-\u003eval == 3); } } // namespace jc int main() { jc::test(); } 包扩展可以用于编译期表达式 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename... Args\u003e constexpr bool is_homogeneous(T, Args...) { return (std::is_same_v\u003cT, Args\u003e \u0026\u0026 ...); // operator\u0026\u0026 的折叠表达式 } } // namespace jc static_assert(!jc::is_homogeneous(3.14, 42, \"hello\", \"world\")); static_assert(jc::is_homogeneous(\"hello\", \"\", \"world\")); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:19:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#折叠表达式fold-expressionhttpsencppreferencecomwcpplanguagefold"},{"categories":["编程语言"],"content":" 20 变参模板的应用 无需指定类型，自动获取 std::variant 值 #include \u003carray\u003e #include \u003ccassert\u003e #include \u003cfunctional\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cvariant\u003e namespace jc { template \u003ctypename F, std::size_t... N\u003e constexpr auto make_array_impl(F f, std::index_sequence\u003cN...\u003e) -\u003e std::array\u003cstd::invoke_result_t\u003cF, std::size_t\u003e, sizeof...(N)\u003e { return {std::invoke(f, std::integral_constant\u003cdecltype(N), N\u003e{})...}; } template \u003cstd::size_t N, typename F\u003e constexpr auto make_array(F f) -\u003e std::array\u003cstd::invoke_result_t\u003cF, std::size_t\u003e, N\u003e { return make_array_impl(f, std::make_index_sequence\u003cN\u003e{}); } template \u003ctypename T, typename Dst, typename... List\u003e bool get_value_impl(const std::variant\u003cList...\u003e\u0026 v, Dst\u0026 dst) { if (std::holds_alternative\u003cT\u003e(v)) { if constexpr (std::is_convertible_v\u003cT, Dst\u003e) { dst = static_cast\u003cDst\u003e(std::get\u003cT\u003e(v)); return true; } } return false; } template \u003ctypename Dst, typename... List\u003e bool get_value(const std::variant\u003cList...\u003e\u0026 v, Dst\u0026 dst) { using Variant = std::variant\u003cList...\u003e; using F = std::function\u003cbool(const Variant\u0026, Dst\u0026)\u003e; static auto _list = make_array\u003csizeof...(List)\u003e([](auto i) -\u003e F { return \u0026get_value_impl\u003cstd::variant_alternative_t\u003ci, Variant\u003e, Dst, List...\u003e; }); return std::invoke(_list[v.index()], v, dst); } } // namespace jc int main() { std::variant\u003cint, std::string\u003e v = std::string{\"test\"}; std::string s; assert(jc::get_value(v, s)); assert(s == \"test\"); v = 42; int i; assert(jc::get_value(v, i)); assert(i == 42); } 字节序转换 // https://en.cppreference.com/w/cpp/language/fold #include \u003ccstdint\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T, size_t... N\u003e constexpr T bswap_impl(T t, std::index_sequence\u003cN...\u003e) { return (((t \u003e\u003e N * 8 \u0026 0xFF) \u003c\u003c (sizeof(T) - 1 - N) * 8) | ...); } template \u003ctypename T, typename U = std::make_unsigned_t\u003cT\u003e\u003e constexpr U bswap(T t) { return bswap_impl\u003cU\u003e(t, std::make_index_sequence\u003csizeof(T)\u003e{}); } } // namespace jc static_assert(jc::bswap\u003cstd::uint32_t\u003e(0x12345678u) == 0x78563412u); static_assert((0x12345678u \u003e\u003e 0) == 0x12345678u); static_assert((0x12345678u \u003e\u003e 8) == 0x00123456u); static_assert((0x12345678u \u003e\u003e 16) == 0x00001234u); static_assert((0x12345678u \u003e\u003e 24) == 0x00000012u); static_assert(jc::bswap\u003cstd::uint16_t\u003e(0x1234u) == 0x3412u); int main() {} 自定义字面值（User-defined literals） #include \u003calgorithm\u003e #include \u003carray\u003e #include \u003ccassert\u003e #include \u003cfunctional\u003e #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003cstring\u003e namespace jc { template \u003cchar... args\u003e std::string operator\"\" _dbg() { std::array\u003cchar, sizeof...(args)\u003e v{args...}; std::stringstream os; for (const auto\u0026 x : v) { os \u003c\u003c x; }; #ifndef NDEBUG std::cout \u003c\u003c os.str() \u003c\u003c std::endl; #endif return os.str(); } std::string operator\"\" _encrypt(const char* c, size_t) { std::string s{c}; std::string p{R\"(passwd: \")\"}; auto it = std::search(s.begin(), s.end(), std::boyer_moore_horspool_searcher{p.begin(), p.end()}); if (it != s.end()) { it += p.size(); while (it != s.end() \u0026\u0026 *it != '\\\"') { *it++ = '*'; } } #if !defined(NDEBUG) std::cout \u003c\u003c s \u003c\u003c std::endl; #endif return s; } } // namespace jc int main() { using namespace jc; assert(12.34_dbg == \"12.34\"); std::string s = R\"JSON({ data_dir: \"C:\\Users\\downdemo\\.data\\*.txt\", user: \"downdemo(accelerate rapidly)\", passwd: \"123456\" })JSON\"_encrypt; std::string s2 = R\"JSON({ data_dir: \"C:\\Users\\downdemo\\.data\\*.txt\", user: \"downdemo(accelerate rapidly)\", passwd: \"******\" })JSON\"; assert(s == s2); } 变参基类 #include \u003cstring\u003e #include \u003cunordered_set\u003e namespace jc { struct A { std::string s; }; struct A_EQ { bool operator()(const A\u0026 lhs, const A\u0026 rhs) const { return lhs.s == rhs.s; } }; struct A_Hash { std::size_t operator()(const A\u0026 a) const { return std::hash\u003cstd::string\u003e{}(a.s); } }; // 定义一个组合所有基类的 operator() 的派生类 template \u003ctypename... Bases\u003e struct Overloader : Bases... { using Bases::operator()...; // C++17 }; using A_OP = Overloader\u003cA_Hash, A_EQ\u003e; } // namespace jc int main() { // 将 A_EQ 和 A_Hash 组合到一个类型中 /* unordered_set 的声明 template\u003c class K","date":"2022-06-18","objectID":"/cxx_template/:20:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#变参模板的应用"},{"categories":["编程语言"],"content":" 21 移动语义（Move Semantics） C++11 的值类别包括左值（lvalue）、纯右值（prvalue）、亡值（xvalue），左值和亡值组成了泛左值（glvalue），纯右值和亡值组成了右值（rvalue）。为了让编译器识别接受右值作为参数的构造函数，则需要引入右值引用符号（\u0026\u0026），以区分移动构造函数和拷贝构造函数 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003cutility\u003e #include \u003cvector\u003e namespace jc { struct A { A() : data(new std::string) {} A(const A\u0026 rhs) : data(new std::string{*rhs.data}) {} A(A\u0026\u0026 rhs) noexcept : data(rhs.data) { rhs.data = nullptr; } ~A() { delete data; } std::string* data = nullptr; }; } // namespace jc int main() { std::vector\u003cjc::A\u003e v; v.emplace_back(jc::A{}); // 调用默认构造函数、移动构造函数、析构函数 jc::A a; v.emplace_back(a); // 调用拷贝构造函数 assert(a.data); v.emplace_back(std::move(a)); // 调用移动构造函数 assert(!a.data); } 右值引用即只能绑定到右值的引用，字面值（纯右值）和临时变量（亡值）就是常见的右值。如果把左值传递给右值引动参数，则需要强制类型转换，std::move 就是不需要显式指定类型的到右值引用的强制类型转换 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T\u003e constexpr std::remove_reference_t\u003cT\u003e\u0026\u0026 move(T\u0026\u0026 x) noexcept { return static_cast\u003cstd::remove_reference_t\u003cT\u003e\u0026\u0026\u003e(x); } constexpr int f(const std::string\u0026) { return 1; } constexpr int f(std::string\u0026\u0026) { return 2; } } // namespace jc int main() { std::string s; static_assert(jc::f(s) == 1); assert(jc::f(std::string{}) == 2); static_assert(jc::f(static_cast\u003cstd::string\u0026\u0026\u003e(s)) == 2); static_assert(jc::f(jc::move(s)) == 2); static_assert(jc::f(std::move(s)) == 2); } ","date":"2022-06-18","objectID":"/cxx_template/:21:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#移动语义move-semantics"},{"categories":["编程语言"],"content":" 22 完美转发（Perfect Forwarding） 右值引用是能接受右值的引用，引用可以取址，是左值，因此右值引用是左值。如果一个函数接受右值引用参数，把参数传递给其他函数时，会按左值传递，这样就丢失了原有的值类别 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { constexpr int f(const std::string\u0026) { return 1; } constexpr int f(std::string\u0026\u0026) { return 2; } constexpr int g(std::string\u0026\u0026 s) { return f(s); } void test() { std::string s; assert(f(std::string{}) == 2); assert(g(std::string{}) == 1); static_assert(f(std::move(s)) == 2); static_assert(g(std::move(s)) == 1); } } // namespace jc int main() { jc::test(); } 为了转发时保持值类别不丢失，需要手写多个重载版本 #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { constexpr int f(std::string\u0026) { return 1; } constexpr int f(const std::string\u0026) { return 2; } constexpr int f(std::string\u0026\u0026) { return 3; } constexpr int g(std::string\u0026 s) { return f(s); } constexpr int g(const std::string\u0026 s) { return f(s); } constexpr int g(std::string\u0026\u0026 s) { return f(std::move(s)); } void test() { std::string s; const std::string\u0026 s2 = s; static_assert(g(s) == 1); assert(g(s2) == 2); static_assert(g(std::move(s)) == 3); assert(g(std::string{}) == 3); } } // namespace jc int main() { jc::test(); } 模板参数中右值引用符号表示的是万能引用（universal reference），因为模板参数本身可以推断为引用，它可以匹配几乎任何类型（少部分特殊类型无法匹配，如位域），传入左值时推断为左值引用类型，传入右值时推断为右值引用类型。对万能引用参数使用 std::forward 则可以保持值类别不丢失，这种保留值类别的转发手法就叫完美转发，因此万能引用也叫转发引用（forwarding reference） #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e constexpr T\u0026\u0026 forward(std::remove_reference_t\u003cT\u003e\u0026 t) noexcept { return static_cast\u003cT\u0026\u0026\u003e(t); } constexpr int f(std::string\u0026) { return 1; } constexpr int f(const std::string\u0026) { return 2; } constexpr int f(std::string\u0026\u0026) { return 3; } template \u003ctypename T\u003e constexpr int g(T\u0026\u0026 s) { return f(jc::forward\u003cT\u003e(s)); // 等价于 std::forward } void test() { std::string s; const std::string\u0026 s2 = s; static_assert(g(s) == 1); // T = T\u0026\u0026 = std::string\u0026 assert(g(s2) == 2); // T = T\u0026\u0026 = const std::string\u0026 static_assert(g(std::move(s)) == 3); // T = std::string, T\u0026\u0026 = std::string\u0026\u0026 assert(g(std::string{}) == 3); // T = T\u0026\u0026 = std::string\u0026 assert(g(\"downdemo\") == 3); // T = T\u0026\u0026 = const char (\u0026)[9] } } // namespace jc int main() { jc::test(); } 结合变参模板完美转发转发任意数量的实参 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename F, typename... Args\u003e constexpr void constexpr_for(F\u0026\u0026 f, Args\u0026\u0026... args) { (std::invoke(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)), ...); } template \u003ctypename... Args\u003e void print(Args\u0026\u0026... args) { constexpr_for([](const auto\u0026 x) { std::cout \u003c\u003c x \u003c\u003c std::endl; }, std::forward\u003cArgs\u003e(args)...); } } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } Lambda 中使用完美转发需要借助 decltype 推断类型 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { constexpr auto constexpr_for = [](auto\u0026\u0026 f, auto\u0026\u0026... args) { (std::invoke(std::forward\u003cdecltype(f)\u003e(f), std::forward\u003cdecltype(args)\u003e(args)), ...); }; auto print = [](auto\u0026\u0026... args) { constexpr_for([](const auto\u0026 x) { std::cout \u003c\u003c x \u003c\u003c std::endl; }, std::forward\u003cdecltype(args)\u003e(args)...); }; } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } C++20 可以为 lambda 指定模板参数 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { constexpr auto constexpr_for = []\u003ctypename F, typename... Args\u003e(F\u0026\u0026 f, Args\u0026\u0026... args) { (std::invoke(std::forward\u003cF\u003e(f), std::forward\u003cArgs\u003e(args)), ...); }; auto print = []\u003ctypename... Args\u003e(Args\u0026\u0026 ... args) { constexpr_for([](const auto\u0026 x) { std::cout \u003c\u003c x \u003c\u003c std::endl; }, std::forward\u003cArgs\u003e(args)...); }; } // namespace jc int main() { jc::print(3.14, 42, std::string{\"hello\"}, \"world\"); } C++20 的 lambda 可以捕获参数包 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename... Args\u003e void print(Args\u0026\u0026... args) { [... args = std::forward\u003cArgs\u003e(args)]\u003ctypename F\u003e(F\u0026\u0026 f) { (std::invoke(std::forward\u003cF\u003e(f), args),","date":"2022-06-18","objectID":"/cxx_template/:22:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#完美转发perfect-forwarding"},{"categories":["编程语言"],"content":" 23 构造函数模板 模板也能用于构造函数，但它不是真正的构造函数，从函数模板实例化而来的函数不和普通函数等价，由成员函数模板实例化的函数不会重写虚函数，由构造函数模板实例化的构造函数不是拷贝或移动构造函数，但对一个 non-const 对象调用构造函数时，万能引用是更优先的匹配 #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { struct A { template \u003ctypename T\u003e explicit A(T\u0026\u0026 t) : s(std::forward\u003cT\u003e(t)) {} A(const A\u0026 rhs) : s(rhs.s) {} A(A\u0026\u0026 rhs) noexcept : s(std::move(rhs.s)) {} std::string s; }; } // namespace jc int main() { const jc::A a{\"downdemo\"}; jc::A b{a}; // OK，匹配拷贝构造函数 // jc::A c{b}; // 错误，匹配模板构造函数 } 为此可以用 std::enable_if 约束模板参数，在条件满足的情况下才会匹配模板 #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { struct A { template \u003ctypename T, // 要求 T 能转为 std::string typename = std::enable_if_t\u003cstd::is_convertible_v\u003cT, std::string\u003e\u003e\u003e explicit A(T\u0026\u0026 t) : s(std::forward\u003cT\u003e(t)) {} A(const A\u0026 rhs) : s(rhs.s) {} A(A\u0026\u0026 rhs) noexcept : s(std::move(rhs.s)) {} std::string s; }; } // namespace jc int main() { const jc::A a{\"downdemo\"}; jc::A b{a}; // OK，匹配拷贝构造函数 jc::A c{b}; // OK，匹配拷贝构造函数 } C++20 可以用 concepts 约束模板参数 #include \u003cconcepts\u003e #include \u003cstring\u003e #include \u003cutility\u003e namespace jc { struct A { template \u003ctypename T\u003e requires std::convertible_to\u003cT, std::string\u003e explicit A(T\u0026\u0026 t) : s(std::forward\u003cT\u003e(t)) {} A(const A\u0026 rhs) : s(rhs.s) {} A(A\u0026\u0026 rhs) noexcept : s(std::move(rhs.s)) {} std::string s; }; } // namespace jc int main() { const jc::A a{\"downdemo\"}; jc::A b{a}; // OK，匹配拷贝构造函数 jc::A c{b}; // OK，匹配拷贝构造函数 } ","date":"2022-06-18","objectID":"/cxx_template/:23:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#构造函数模板"},{"categories":["编程语言"],"content":" 24 ADL（Argument-Dependent Lookup，Koenig Lookup） Name lookup 是当程序中出现一个名称时，将其与引入它的声明联系起来的过程，它分为 qualified name lookup 和 unqualified name lookup，unqualified name lookup 对于函数名查找会使用 ADL namespace jc { struct A {}; struct B {}; void f1(int) {} void f2(A) {} } // namespace jc namespace jd { void f1(int i) { f1(i); // 调用 jd::f1()，造成无限递归 } void f2(jc::A t) { f2(t); // 通过 t 的类型 jc::A 看到 jc，通过 jc 看到 jc::f2() // 因为 jd::f2() 也可见，此处产生二义性调用错误 } void f3(jc::B t) { f3(t); // 通过 t 的类型 jc::B 看到 jc，但 jc 中无 jc::f3() // 此处调用 jd::f3()，造成无限递归 } } // namespace jd int main() {} Qualified name lookup 即对使用了作用域运算符的名称做查找，查找在受限的作用域内进行 namespace jc { int x; struct Base { int i; }; struct Derived : Base {}; void f(Derived* p) { p-\u003ei = 0; // 找到 Base::i Derived::x = 0; // 错误：在受限作用域中找不到 ::x } } // namespace jc int main() {} Unqualified name lookup 即对不指定作用域的名称做查找，先查找当前作用域，若找不到再继续查找外围作用域 namespace jc { extern int x; // 1 int f(int x) { // 2 if (x \u003c 0) { int x = 1; // 3 f(x); // 使用 3 } return x + ::x; // 分别使用 2、1 } } // namespace jc int main() {} ADL 即实参依赖查找，对于一个类，其成员函数与使用了它的非成员函数，都是该类的逻辑组成部分，如果函数接受一个类作为参数，编译器查找函数名时，不仅会查找局部作用域，还会查找类所在的命名空间 #include \u003ciostream\u003e #include \u003cstring\u003e namespace jc { struct A {}; void f(const A\u0026) {} // f() 是 A 的逻辑组成部分 } // namespace jc jc::A a; int main() { f(a); // 通过 ADL 找到 jc::f()，如果没有 ADL，就要写成 jc::f(a) std::string s; std::cout \u003c\u003c s; // std::operator\u003c\u003c() 是 std::string 的逻辑组成部分 // 如果没有 ADL，就要写成 std::operator\u003c\u003c(std::cout, s) } ADL 是通过实参查找，对于函数模板，查找前无法先得知其为函数，也就无法确定实参，因此不会使用 ADL namespace jc { class A {}; template \u003ctypename\u003e void f(A*) {} } // namespace jc void g(jc::A* p) { f\u003cint\u003e(p); // 错误，不知道 f\u003cint\u003e 是函数，所以不知道 p 是实参，不会用 ADL } int main() {} ADL 会忽略 using 声明 namespace jc { template \u003ctypename T\u003e constexpr int f(T) { return 1; } } // namespace jc namespace jd { using namespace jc; // 忽略 using 声明，不会调用 jc::f enum Color { red }; constexpr int f(Color) { return 2; } } // namespace jd constexpr int f(int) { return 3; } static_assert(::f(jd::red) == 3); // 受限的函数名称，不使用 ADL static_assert(f(jd::red) == 2); // 使用 ADL 找到 jd::f() int main() {} ADL 会查找实参关联的命名空间和类，关联的命名空间和类组成的集合定义如下 内置类型：集合为空 指针和数组类型：所引用类型关联的命名空间和类 枚举类型：关联枚举声明所在的命名空间 类成员：关联成员所在的类 类类型：关联的类包括该类本身、外围类型、直接和间接基类，关联的命名空间为每个关联类所在的命名空间，如果类是一个类模板实例则还包含模板实参本身类型、模板的模板实参所在的类和命名空间 函数类型：所有参数和返回类型关联的命名空间和类 类成员指针类型：成员和类关联的命名空间和类 友元声明在外围作用域不可见，因为如果可见的话，实例化类模板会使普通函数的声明可见，如果没有先实例化类就调用函数，将导致编译错误，但如果友元函数所在类属于 ADL 的关联类集合，则在外围作用域可以找到该友元声明，且调用时，未实例化的类会被实例化 namespace jc { template \u003ctypename T\u003e class A { friend void f() {} friend void f(A\u003cT\u003e) {} }; void g(const A\u003cint\u003e\u0026 a) { f(); // f() 无参数，不能使用 ADL，不可见 f(a); // f(A\u003cint\u003e) 关联类 A\u003cint\u003e 所以可见，若类 A\u003cint\u003e 未实例化则调用时实例化 } } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:24:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#adlargument-dependent-lookupkoenig-lookuphttpsencppreferencecomwcpplanguageadl"},{"categories":["编程语言"],"content":" 25 注入类名（Injected Class Name） 为了便于查找，在类作用域中，类名称是自身类型的 public 别名，该名称称为注入类名 namespace jc { int A; struct A { void f() { A* p; // OK：A 是注入类名 ::A* q; // 错误：查找到变量名 A，隐藏了 struct A 的名称 } }; } // namespace jc int main() {} 类模板的注入类名可以被用作模板名或类型名 namespace jc { template \u003ctemplate \u003ctypename\u003e class\u003e struct A {}; template \u003ctypename T\u003e struct B { B* a; // B 被当作类型名，等价于 B\u003cT\u003e B\u003cvoid\u003e* b; // B 被当作模板名 using c = A\u003cB\u003e; // B 被当作模板名 A\u003cjc::B\u003e d; // jc::B 不是注入类名，总会被当作模板名 }; } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:25:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#注入类名injected-class-namehttpsencppreferencecomwcpplanguageinjected-class-name"},{"categories":["编程语言"],"content":" 26 非模板中的上下文相关性 解析理论主要面向上下文无关语言，而 C++ 是上下文相关语言，为了解决这个问题，编译器使用一张符号表结合扫描器和解析器 解析某个声明时会把它添加到表中，扫描器找到一个标识符时，会在符号表中查找，如果发现该符号是一个类型就会注释这个标记，如编译器看见 x*，扫描器会查找 x，如果发现 x 是一个类型，解析器会看到标记如下，认为表达式是一个声明 identifier, type, x symbol, * 如果 x 不是类型，则解析器从扫描器获得标记如下，表达式被视为一个乘积 identifier, nontype, x symbol, * 对于 A\u003c1\u003e(0)，如果 A 是类模板，则表达式是把 0 转换成 A\u003c1\u003e 类型。如果不是类模板，表达式等价于 (A\u003c1)\u003e0，计算表达式 A 小于 1 的结果，再将结果与 0 比较大小。因此解析器先查找 \u003c 前的名称，如果名称是模板才会把 \u003c 看作左尖括号，其他情况则看作小于号 namespace jc { template \u003cbool B\u003e struct A { static const bool value = B; }; static_assert(A\u003c(1 \u003e 0)\u003e::value); // 必须使用小括号 } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:26:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#非模板中的上下文相关性"},{"categories":["编程语言"],"content":" 27 Dependent name","date":"2022-06-18","objectID":"/cxx_template/:27:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#dependent-namehttpsencppreferencecomwcpplanguagedependent_name"},{"categories":["编程语言"],"content":" 27.1 当前实例化（current instantiation）和未知特化（unknown specialization） Name lookup 对 dependent name 与 non-dependent name 有不同的查找规则，在模板定义中，依赖于模板参数的名称称为 dependent name，dependent name 包含当前实例化和未知特化。类模板的注入类名属于当前实例化，依赖于模板参数但不是当前实例化的为未知特化（unknown specialization） namespace jc { template \u003ctypename T\u003e struct A { using type = T; A* a; // A 是当前实例化 A\u003ctype\u003e* b; // A\u003ctype\u003e 是当前实例化 A\u003cT*\u003e* c; // A\u003cT*\u003e 是未知特化 struct B { A* a; // A 是当前实例化 A\u003ctype\u003e* b; // A\u003ctype\u003e 是当前实例化 B* c; // B 是当前实例化 }; struct C { A* a; // A 是当前实例化 A\u003ctype\u003e* b; // A\u003ctype\u003e 是当前实例化 B* c; // 不在 B 的作用域内，B 是未知特化 C* d; // C 是当前实例化 }; }; template \u003c\u003e struct A\u003cint\u003e::B { int i; }; } // namespace jc int main() { jc::A\u003cdouble\u003e::C{}.c-\u003ea; jc::A\u003cint\u003e::C{}.c-\u003ei; // 使用特化的 A\u003cint\u003e::B } ","date":"2022-06-18","objectID":"/cxx_template/:27:1","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#当前实例化current-instantiation和未知特化unknown-specialization"},{"categories":["编程语言"],"content":" 27.2 typename 消歧义符 模板名称的问题主要是不能有效确定名称，模板中不能引用其他模板的名称，因为其他模板可能有使原名称失效的特化 namespace jc { template \u003ctypename T\u003e struct A { static constexpr int x = 0; // x 是值 }; template \u003ctypename T\u003e struct B { int y; void f() { A\u003cT\u003e::x* y; // 默认被看作乘法表达式 } }; template \u003c\u003e struct A\u003cint\u003e { using x = int; // x 是类型 }; } // namespace jc int main() { jc::B\u003cint\u003e{}.f(); // A\u003cint\u003e::x* y 是声明，int* y jc::B\u003cvoid\u003e{}.f(); // A\u003cvoid\u003e::x* y 是乘法，0 * y } Dependent name 默认不会被看作类型，如果要表明是类型则需要加上 typename 消歧义符 namespace jc { template \u003ctypename T\u003e struct A { static constexpr int x = 0; // x 是值 }; template \u003ctypename T\u003e struct B { int y; void f() { typename A\u003cT\u003e::x* y; // 默认被看作声明 } }; template \u003c\u003e struct A\u003cint\u003e { using x = int; // x 是类型 }; } // namespace jc int main() { jc::B\u003cint\u003e{}.f(); // A\u003cint\u003e::x* y 是声明，int* y jc::B\u003cvoid\u003e{}.f(); // A\u003cvoid\u003e::x* y 是乘法，0 * y } typename 消歧义符只能用于不在基类列表和初始化列表中的 dependent name，用作用域运算符访问 dependent name 中的成员类型时，必须指定 typename 消歧义符 namespace jc { struct Base { int i; }; template \u003ctypename T\u003e struct A { using type = T; }; template \u003ctypename T\u003e struct Derived : A\u003cT\u003e::type { // 基类列表中不能加 typename 消歧义符 Derived() : A\u003cT\u003e::type // 初始化列表中不能加 typename 消歧义符 (typename A\u003cT\u003e::type{0}) // 必须加 typename 消歧义符 {} A\u003cT\u003e f() { typename A\u003cT\u003e::type* p; // 必须加 typename 消歧义符 return {}; } A\u003cint\u003e::type* s; // non-dependent name，typename 消歧义符可有可无 }; } // namespace jc int main() { jc::Derived\u003cjc::Base\u003e{}.f(); } ","date":"2022-06-18","objectID":"/cxx_template/:27:2","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#typename-消歧义符"},{"categories":["编程语言"],"content":" 27.3 template 消歧义符 访问模板参数的 dependent name 时，要在 dependent name 前加 template 消歧义符，才能让编译器知道引用的是一个模板，否则 \u003c 会被视为小于号 namespace jc { template \u003ctypename T\u003e struct A { template \u003ctypename U\u003e struct Impl { template \u003ctypename Y\u003e static void f() {} }; template \u003ctypename U\u003e static void f() {} }; } // namespace jc template \u003ctypename T\u003e void test() { T::template Impl\u003cT\u003e::template f\u003cT\u003e(); T::template f\u003cT\u003e(); } int main() { test\u003cjc::A\u003cint\u003e\u003e(); } ","date":"2022-06-18","objectID":"/cxx_template/:27:3","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#template-消歧义符"},{"categories":["编程语言"],"content":" 28 Non-dependent base Non-dependent base 是不用知道模板实参就可以推断类型的基类，派生类中查找 non-dependent name 时会先查找 non-dependent base，再查找模板参数列表 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename\u003e struct Base { using T = char; }; template \u003ctypename T\u003e struct Derived1 : Base\u003cvoid\u003e { // non-dependent base using type = T; // T 是 Base\u003cvoid\u003e::T }; template \u003ctypename T\u003e struct Derived2 : Base\u003cT\u003e { // dependent base using type = T; // T 是模板参数 }; static_assert(std::is_same_v\u003cDerived1\u003cint\u003e::type, char\u003e); static_assert(std::is_same_v\u003cDerived2\u003cint\u003e::type, int\u003e); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:28:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#non-dependent-base"},{"categories":["编程语言"],"content":" 29 Dependent base 对于 non-dependent name，不会在 dependent base 中做查找 namespace jc { template \u003ctypename\u003e struct Base { static constexpr int value = 1; }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base constexpr int get_value() const { return value; // 错误：不会在 dependent base 中查找 non-dependent name } }; } // namespace jc int main() {} 如果要在 dependent base 中查找，则可以使用 this-\u003e 或作用域运算符将 non-dependent name 变为 dependent name namespace jc { template \u003ctypename\u003e struct Base { static constexpr int value = 1; }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base constexpr int get_value() const { return this-\u003evalue; // dependent name，会在 dependent base 中查找 } }; template \u003c\u003e struct Base\u003cbool\u003e { static constexpr int value = 2; }; } // namespace jc int main() { static_assert(jc::Derived\u003cint\u003e{}.get_value() == 1); static_assert(jc::Derived\u003cbool\u003e{}.get_value() == 2); } 或者使用 using 声明，这样只需要引入一次 namespace jc { template \u003ctypename\u003e struct Base { static constexpr int value = 1; }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base using Base\u003cT\u003e::value; constexpr int get_value() const { return value; // dependent name，会在 dependent base 中查找 } }; template \u003c\u003e struct Base\u003cbool\u003e { static constexpr int value = 2; }; } // namespace jc int main() { static_assert(jc::Derived\u003cint\u003e{}.get_value() == 1); static_assert(jc::Derived\u003cbool\u003e{}.get_value() == 2); } 使用作用域运算符不会访问虚函数 #include \u003ccassert\u003e namespace jc { template \u003ctypename\u003e struct Base { virtual int f() const { return 1; } }; template \u003ctypename T\u003e struct Derived : Base\u003cT\u003e { // dependent base virtual int f() const { return 2; } int get_value() const { return Base\u003cT\u003e::f(); } }; template \u003c\u003e struct Base\u003cbool\u003e { virtual int f() const { return 3; } }; } // namespace jc int main() { assert(jc::Derived\u003cint\u003e{}.get_value() == 1); assert(jc::Derived\u003cbool\u003e{}.get_value() == 3); } 如果需要使用虚函数，则只能使用 this-\u003e 或 using 声明 #include \u003ccassert\u003e namespace jc { template \u003ctypename\u003e struct Base { virtual int f() const { return 1; } }; template \u003ctypename T\u003e struct Derived1 : Base\u003cT\u003e { // dependent base virtual int f() const { return 2; } int get_value() const { return this-\u003ef(); } }; template \u003ctypename T\u003e struct Derived2 : Base\u003cT\u003e { // dependent base using Base\u003cT\u003e::f; virtual int f() const { return 2; } int get_value() const { return f(); } }; template \u003c\u003e struct Base\u003cbool\u003e { virtual int f() const { return 3; } }; } // namespace jc int main() { assert(jc::Derived1\u003cint\u003e{}.get_value() == 2); assert(jc::Derived1\u003cbool\u003e{}.get_value() == 2); assert(jc::Derived2\u003cint\u003e{}.get_value() == 2); assert(jc::Derived2\u003cbool\u003e{}.get_value() == 2); } ","date":"2022-06-18","objectID":"/cxx_template/:29:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#dependent-base"},{"categories":["编程语言"],"content":" 30 隐式实例化 编译器遇到模板特化时会用所给的模板实参替换对应的模板参数，从而产生特化。如果声明类模板的指针或引用，不需要看到类模板定义，但如果要访问特化的成员或想知道模板特化的大小，就要先看到定义 namespace jc { template \u003ctypename T\u003e struct A; A\u003cint\u003e* p = 0; // OK：不需要类模板定义 template \u003ctypename T\u003e struct A { void f(); }; void g(A\u003cint\u003e\u0026 a) { // 只使用类模板声明 a.f(); // 使用了类模板定义，需要 A::f() 的定义 } template \u003ctypename T\u003e void A\u003cT\u003e::f() {} } // namespace jc int main() {} 函数重载时，如果候选函数的参数是类类型，则该类必须可见。如果重载函数的参数是类模板，为了检查重载匹配，就需要实例化类模板。通过 C++ Insights 或在 Visual Studio 中使用 /d1templateStats 命令行参数查看模板的实例化结果 namespace jc { template \u003ctypename T\u003e struct A { A(int); }; void f(A\u003cdouble\u003e) {} void f(int) {} } // namespace jc int main() { jc::f(42); // 两个函数声明都匹配，调用第二个，但仍会实例化第一个 } ","date":"2022-06-18","objectID":"/cxx_template/:30:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#隐式实例化"},{"categories":["编程语言"],"content":" 31 延迟实例化（Lazy Instantiation） 隐式实例化类模板时，也会实例化每个成员声明，但不会实例化定义。例外的是匿名 union 和虚函数，union 成员会被实例化，虚函数是否实例化依赖于具体实现 namespace jc { template \u003cint N\u003e struct A { int a[N]; // 编译器会假设 N 是正整数，实例化时 N \u003c= 0 则失败 }; template \u003ctypename T, int N\u003e struct B { void f() { A\u003cN\u003e a; // 如果 N \u003c= 0，调用时出错 } // void error() { // 即使不被调用也会引发错误 // A\u003c-1\u003e a; // 要求给出 A\u003c-1\u003e 的完整定义，定义 -1 大小的数组出错 // } // virtual void g(); // 虚函数只有声明没有定义会导致链接错误 struct Nested { // N \u003c= 0 时使用该定义出错 A\u003cN\u003e a; }; // union { // union 的所有成员声明都会被生成 // A\u003cN\u003e a; // N \u003c= 0 时出错 // }; }; } // namespace jc int main() { jc::B\u003cint, -1\u003e b; // b.f(); // 调用则出错 // jc::B\u003cint, -1\u003e::Nested{}; // 错误 } ","date":"2022-06-18","objectID":"/cxx_template/:31:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#延迟实例化lazy-instantiation"},{"categories":["编程语言"],"content":" 32 两阶段查找（Two-Phase Lookup） 编译器解析模板时，不能解析 dependent name，于是会在 POI（point of instantiation）再次查找 dependent name，而 non-dependent name 在首次看到模板时就会进行查找，因此就有了两阶段查找，第一阶段发生在模板解析阶段，第二阶段在模板实例化阶段 第一阶段使用 unqualified name lookup（对于函数名查找会使用 ADL）查找 non-dependent name 和非受限的 dependent name（如具有 dependent name 实参的函数名称），但后者的查找不完整，在实例化时还会再次查找 第二阶段发生的地点称为 POI，该阶段查找受限的 dependent name，并对非受限的 dependent name 再次进行 ADL ","date":"2022-06-18","objectID":"/cxx_template/:32:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#两阶段查找two-phase-lookup"},{"categories":["编程语言"],"content":" 33 POI（Points of Instantiation） 编译器会在模板中的某个位置访问模板实例的声明或定义，实例化相应的模板定义时就会产生 POI，POI 是代码中的一个点，在该点会插入替换后的模板实例 namespace jc { struct A { A(int i) : i(i) {} int i; }; A operator-(const A\u0026 a) { return A{-a.i}; } bool operator\u003c(const A\u0026 lhs, const A\u0026 rhs) { return lhs.i \u003c rhs.i; } using Int = A; // 若使用 int 而不使用 A 则无法使用 ADL 找到 g template \u003ctypename T\u003e void f(T i) { if (i \u003c 0) { g(-i); // POI 二阶段查找，T 为 A 可以使用 ADL，T 为 int 则找不到 g } } // 此处不能为 POI，因为 g() 不可见，无法解析 g(-i) void g(Int) { // 此处不能为 POI，不允许在此处插入 f\u003cInt\u003e(Int) 的定义 f\u003cInt\u003e(42); // 调用点 // 此处不能为 POI，不允许在此处插入 f\u003cInt\u003e(Int) 的定义 } // 是 POI，此时 g() 可见，实例化 f\u003cInt\u003e(Int) } // namespace jc int main() {} 类模板实例的 POI 位置只能定义在包含该实例的声明或定义前的最近作用域 namespace jc { template \u003ctypename T\u003e struct A { T x; }; // POI int f() { // 不能是 POI，A\u003cint\u003e 的定义不能出现在函数作用域内 return sizeof(A\u003cint\u003e); // 不能是 POI，A\u003cint\u003e 的定义不能出现在函数作用域内 } // 不能是 POI，如果是 POI 则 sizeof(A\u003cint\u003e) 无效，因为编译后才知道大小 } // namespace jc int main() {} 实例化一个模板时，可能附带实例化其他模板 namespace jc { template \u003ctypename T\u003e struct A { using type = int; }; // A\u003cchar\u003e 的 POI template \u003ctypename T\u003e void f() { A\u003cchar\u003e::type a = 0; typename A\u003cT\u003e::type b = 0; } } // namespace jc int main() { jc::f\u003cdouble\u003e(); // A\u003cdouble\u003e 的 POI // f\u003cdouble\u003e 的 POI // f 使用了 dependent name A\u003cT\u003e，需要一个二次 POI // 此处有两个 POI，对于类实例，二次 POI 位于主 POI 之前（函数实例则位置相同） } 一个编译单元通常会包含一个实例的多个 POI，对类模板实例，每个编译单元只保留首个 POI，忽略其他 POI（它们不会被真正认为是 POI），对函数模板和变量模板的实例，所有 POI 都会被保留 ","date":"2022-06-18","objectID":"/cxx_template/:33:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#poipoints-of-instantiation"},{"categories":["编程语言"],"content":" 34 模板的链接（Linkage of Template） 类模板不能和其他实例共用一个名称 namespace jc { int A; class A; // OK：两者名称在不同的空间 int B; template \u003ctypename T\u003e struct B; // 错误：名称冲突 struct C; template \u003ctypename T\u003e struct C; // 错误：名称冲突 } // namespace jc int main() {} 模板不能有 C linkage namespace jc { extern \"C++\" template \u003ctypename T\u003e void normal(); // 默认方式，链接规范可以省略不写 extern \"C\" template \u003ctypename T\u003e void invalid(); // 错误：不能使用 C 链接 extern \"Java\" template \u003ctypename T\u003e void java_link(); // 非标准链接，某些编译器可能支持 } // namespace jc int main() {} 模板通常具有外链接（external linkage），唯一例外的是 static 修饰的函数模板 template \u003ctypename T\u003e // 与其他文件中同名的声明指向相同的实例 void external(); template \u003ctypename T\u003e // 与其他文件中同名的模板无关 static void internal(); template \u003ctypename T\u003e // 重复声明 static void internal(); namespace { template \u003ctypename\u003e // 与其他文件中同名的模板无关 void other_internal(); } namespace { template \u003ctypename\u003e // 重复声明 void other_internal(); } struct { template \u003ctypename T\u003e void f(T) {} // 无链接：不能被重复声明 } x; int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:34:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#模板的链接linkage-of-template"},{"categories":["编程语言"],"content":" 35 链接错误 和普通的函数不同，如果将模板的声明和实现分离，将出现链接错误，原因是编译器在函数调用处未看到实例化的函数定义，只是假设在别处提供了定义，并产生一个指向该定义的引用，并让链接器利用该引用解决此问题 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; } // namespace jc // a.cpp #include \"a.hpp\" namespace jc { template \u003ctypename T\u003e void A\u003cT\u003e::f() {} } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); // 链接错误 } 推荐的做法是直接在头文件中实现模板 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; template \u003ctypename T\u003e inline void A\u003cT\u003e::f() {} } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); } ","date":"2022-06-18","objectID":"/cxx_template/:35:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#链接错误"},{"categories":["编程语言"],"content":" 36 显式实例化（Explicit Instantiation） 如果希望在头文件中不暴露模板实现，则可以使用显式实例化，显式实例化相当于为模板手动实例化指定的类型，但用户仅能使用已指定类型的模板，可以在头文件中使用 extern 声明显式实例化，告知用户支持的实例化类型 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; extern template class A\u003cint\u003e; // 声明 extern template void A\u003cdouble\u003e::f(); // 声明 } // namespace jc // a.cpp #include \"a.hpp\" namespace jc { template \u003ctypename T\u003e void A\u003cT\u003e::f() {} template class A\u003cint\u003e; // 实例化 A\u003cint\u003e，同时会实例化其所有成员 template void A\u003cdouble\u003e::f(); // 仅实例化该成员 } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); jc::A\u003cdouble\u003e{}.f(); } 可以把显式实例化可提取到一个单独的文件中，注意这个文件要包含定义模板的文件 // a.hpp #pragma once namespace jc { template \u003ctypename T\u003e class A { public: void f(); }; extern template class A\u003cint\u003e; extern template void A\u003cdouble\u003e::f(); } // namespace jc // a.cpp #include \"a.hpp\" namespace jc { template \u003ctypename T\u003e void A\u003cT\u003e::f() {} template class A\u003cint\u003e; template void A\u003cdouble\u003e::f(); } // namespace jc // a_init.cpp #include \"a.cpp\" namespace jc { template class A\u003cint\u003e; template void A\u003cdouble\u003e::f(); } // namespace jc // main.cpp #include \"a.hpp\" int main() { jc::A\u003cint\u003e{}.f(); jc::A\u003cdouble\u003e{}.f(); } 显式实例化不会影响类型推断规则，它只是实例化了一个实例，并不是一个可以优先匹配的非模板函数。从函数模板实例化而来的函数永远不和普通函数等价 namespace jc { template \u003ctypename T\u003e void f(T, T) {} template void f\u003cdouble\u003e(double, double); } // namespace jc int main() { jc::f\u003cdouble\u003e(1, 3.14); // OK jc::f(1, 3.14); // 错误：推断类型不一致，不存在普通函数 f(double, double) } 显式实例化的本质是创建一个特化的实例，因此显式实例化之后，不能定义同类型的特化 namespace jc { template \u003ctypename T\u003e struct A { void f(); }; template \u003ctypename T\u003e void A\u003cT\u003e::f() {} // template\u003c\u003e struct A\u003cint\u003e { void f() {} }; template struct A\u003cint\u003e; // 相当于创建如上实例 // template \u003c\u003e // struct A\u003cint\u003e {}; // 不允许重定义 } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:36:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#显式实例化explicit-instantiationhttpsencppreferencecomwcpplanguageclass_templateexplicit_instantiation"},{"categories":["编程语言"],"content":" 37 Deduced Context 复杂的类型声明的匹配过程从最顶层构造开始，然后不断递归子构造，即各种组成元素，这些构造被称为 deduced context，non-deduced context 不会参与推断，而是使用其他处推断的结果，受限类型名称如 A\u003cT\u003e::type 不能用来推断 T，非类型表达式如 A\u003cN + 1\u003e 不能用来推断 N namespace jc { template \u003cint N\u003e struct A { using T = int; void f(int) {} }; template \u003cint N\u003e // A\u003cN\u003e::T 是 non-deduced context，X\u003cN\u003e::*p 是 deduced context void f(void (A\u003cN\u003e::*p)(typename A\u003cN\u003e::T)) {} } // namespace jc int main() { using namespace jc; f(\u0026A\u003c0\u003e::f); // 由 A\u003cN\u003e::*p 推断 N 为 0，A\u003cN\u003e::T 则使用 N 变为 A\u003c0\u003e::T } 默认实参不能用于推断 namespace jc { template \u003ctypename T\u003e void f(T x = 42) {} } // namespace jc int main() { jc::f\u003cint\u003e(); // T = int jc::f(); // 错误：无法推断 T } ","date":"2022-06-18","objectID":"/cxx_template/:37:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#deduced-context"},{"categories":["编程语言"],"content":" 38 特殊的推断情况 成员函数的推断 namespace jc { struct A { void f(int*) const noexcept {} }; template \u003ctypename RT, typename T, typename... Args\u003e void f(RT (T::*)(Args...) const) {} } // namespace jc int main() { jc::f(\u0026jc::A::f); // RT = void，T = A，Args = int* } 取函数模板地址和调用转型运算符模板的推断 namespace jc { template \u003ctypename T\u003e void f(T) {} struct A { template \u003ctypename T\u003e operator T\u0026() { static T x; return x; } }; void g(int (\u0026)[3]) {} } // namespace jc int main() { void (*pf)(int) = \u0026jc::f; // 推断为 f\u003cint\u003e(int) jc::A a; jc::g(a); // a 要转为 int(\u0026)[3]，T 推断为 int[3] } 初始化列表作为实参没有具体类型，不能直接推断为初始化列表 #include \u003cinitializer_list\u003e namespace jc { template \u003ctypename T\u003e void f(T) {} template \u003ctypename T\u003e void g(std::initializer_list\u003cT\u003e) {} } // namespace jc int main() { // jc::f({1, 2, 3}); // 错误：不能推断出 T 为 initializer_list jc::g({1, 2, 3}); // OK：T 为 int } 参数包的推断 namespace jc { template \u003ctypename T, typename U\u003e struct A {}; template \u003ctypename T, typename... Args\u003e void f(const A\u003cT, Args\u003e\u0026...); template \u003ctypename... T, typename... U\u003e void g(const A\u003cT, U\u003e\u0026...); } // namespace jc int main() { using namespace jc; f(A\u003cint, bool\u003e{}, A\u003cint, char\u003e{}); // T = int, Args = [bool,char] g(A\u003cint, bool\u003e{}, A\u003cint, char\u003e{}); // T = [int, int], U = [bool, char] g(A\u003cint, bool\u003e{}, A\u003cchar, char\u003e{}); // T = [int, char], U = [bool, char] // f(A\u003cint, bool\u003e{}, A\u003cchar, char\u003e{}); // 错误，T 分别推断为 int 和 char } 完美转发处理空指针常量时，整型值会被当作常量值 0 #include \u003cutility\u003e namespace jc { constexpr int g(...) { return 1; } constexpr int g(int*) { return 2; } template \u003ctypename T\u003e constexpr int f(T\u0026\u0026 t) { return g(std::forward\u003cT\u003e(t)); } } // namespace jc static_assert(jc::f(0) == 1); static_assert(jc::g(0) == 2); static_assert(jc::f(nullptr) == 2); static_assert(jc::g(nullptr) == 2); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:38:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#特殊的推断情况"},{"categories":["编程语言"],"content":" 39 SFINAE（Substitution Failure Is Not An Error） SFINAE 用于禁止不相关函数模板在重载解析时造成错误，当替换返回类型无意义时，会忽略（SFINAE out）匹配而选择另一个更差的匹配 #include \u003cvector\u003e namespace jc { template \u003ctypename T, std::size_t N\u003e T* begin(T (\u0026a)[N]) { return a; } template \u003ctypename Container\u003e typename Container::iterator begin(Container\u0026 c) { return c.begin(); } } // namespace jc int main() { std::vector\u003cint\u003e v; int a[10] = {}; jc::begin(v); // OK：只匹配第二个，SFINAE out 第一个 jc::begin(a); // OK：只匹配第一个，SFINAE out 第二个 } SFINAE 只发生于函数模板替换的即时上下文中，对于模板定义中不合法的表达式，不会使用 SFINAE 机制 namespace jc { template \u003ctypename T, typename U\u003e auto f(T t, U u) -\u003e decltype(t + u) { return t + u; } void f(...) {} template \u003ctypename T, typename U\u003e auto g(T t, U u) -\u003e decltype(auto) { // 必须实例化 t 和 u 来确定返回类型 return t + u; // 不是即时上下文，不会使用 SFINAE } void g(...) {} struct X {}; using A = decltype(f(X{}, X{})); // OK：A 为 void using B = decltype(g(X{}, X{})); // 错误：g\u003cX, X\u003e 的实例化非法 } // namespace jc int main() {} 一个简单的 SFINAE 技巧是使用尾置返回类型，用 devltype 和逗号运算符定义返回类型，在 decltype 中定义必须有效的表达式 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e auto size(const T\u0026 t) -\u003e decltype(t.size(), T::size_type()) { return t.size(); } } // namespace jc int main() { std::string s; assert(jc::size(s) == 0); } 如果替换时使用了类成员，则会实例化类模板，此期间发生的错误不在即时上下文中，即使另一个函数模板匹配无误也不会使用 SFINAE namespace jc { template \u003ctypename T\u003e class Array { public: using iterator = T*; }; template \u003ctypename T\u003e void f(typename Array\u003cT\u003e::iterator) {} template \u003ctypename T\u003e void f(T*) {} } // namespace jc int main() { jc::f\u003cint\u0026\u003e(0); // 错误：第一个模板实例化 Array\u003cint\u0026\u003e，创建引用的指针是非法的 } SFINAE 最出名的应用是 std::enable_if #include \u003ccassert\u003e #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003c typename K, typename V, std::enable_if_t\u003cstd::is_same_v\u003cstd::decay_t\u003cV\u003e, bool\u003e, void*\u003e = nullptr\u003e void append(std::ostringstream\u0026 os, const K\u0026 k, const V\u0026 v) { os \u003c\u003c R\"(\")\" \u003c\u003c k \u003c\u003c R\"(\":)\" \u003c\u003c std::boolalpha \u003c\u003c v; } template \u003ctypename K, typename V, std::enable_if_t\u003c!std::is_same_v\u003cstd::decay_t\u003cV\u003e, bool\u003e \u0026\u0026 std::is_arithmetic_v\u003cstd::decay_t\u003cV\u003e\u003e, void*\u003e = nullptr\u003e void append(std::ostringstream\u0026 os, const K\u0026 k, const V\u0026 v) { os \u003c\u003c R\"(\")\" \u003c\u003c k \u003c\u003c R\"(\":)\" \u003c\u003c v; } template \u003c typename K, typename V, std::enable_if_t\u003cstd::is_constructible_v\u003cstd::string, std::decay_t\u003cV\u003e\u003e, void*\u003e = nullptr\u003e void append(std::ostringstream\u0026 os, const K\u0026 k, const V\u0026 v) { os \u003c\u003c R\"(\")\" \u003c\u003c k \u003c\u003c R\"(\":\")\" \u003c\u003c v \u003c\u003c R\"(\")\"; } void kv_string_impl(std::ostringstream\u0026 os) {} template \u003ctypename V, typename... Args\u003e std::void_t\u003cdecltype(std::cout \u003c\u003c std::declval\u003cstd::decay_t\u003cV\u003e\u003e())\u003e kv_string_impl(std::ostringstream\u0026 os, const std::string\u0026 k, const V\u0026 v, const Args\u0026... args) { append(os, k, v); if constexpr (sizeof...(args) \u003e= 2) { os \u003c\u003c \",\"; } kv_string_impl(os, args...); } template \u003ctypename... Args\u003e std::string kv_string(const std::string\u0026 field, const Args\u0026... args) { std::ostringstream os; os \u003c\u003c field \u003c\u003c \":{\"; kv_string_impl(os, args...); os \u003c\u003c \"}\"; return os.str(); } } // namespace jc int main() { std::string a{R\"(data:{})\"}; std::string b{R\"(data:{\"name\":\"jc\",\"ID\":1})\"}; std::string c{R\"(data:{\"name\":\"jc\",\"ID\":1,\"active\":true})\"}; assert(a == jc::kv_string(\"data\")); assert(b == jc::kv_string(\"data\", \"name\", \"jc\", \"ID\", 1)); assert(c == jc::kv_string(\"data\", \"name\", \"jc\", \"ID\", 1, \"active\", true)); } ","date":"2022-06-18","objectID":"/cxx_template/:39:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#sfinaesubstitution-failure-is-not-an-errorhttpsencppreferencecomwcpplanguagesfinae"},{"categories":["编程语言"],"content":" 40 Deduction Guides 字符串字面值传引用时推断为字符数组 #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(const T\u0026 val) : container_({val}) {} private: std::vector\u003cT\u003e container_; }; } // namespace jc int main() { jc::A a = \"downdemo\"; // 错误：T 为 char[9]，构造 std::vector\u003cchar[9]\u003e 出错 } 改为传值，字符串字面值会推断为 const char* #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(T val) : container_({std::move(val)}) {} private: std::vector\u003cT\u003e container_; }; } // namespace jc int main() { jc::A a = \"downdemo\"; static_assert(std::is_same_v\u003cdecltype(a), jc::A\u003cconst char*\u003e\u003e); } C++17 可以定义 deduction guides 对特定类型的实参指定其推断类型 #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(const T\u0026 val) : container_({val}) {} private: std::vector\u003cT\u003e container_; }; A(const char*)-\u003eA\u003cstd::string\u003e; } // namespace jc int main() { jc::A a{\"downdemo\"}; // 等号初始化会出错，const char[9] 不能转为 std::string static_assert(std::is_same_v\u003cdecltype(a), jc::A\u003cstd::string\u003e\u003e); } 为聚合类模板定义 deduction guides #include \u003ccassert\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { T x; std::string s; }; A(const char*, const char*)-\u003eA\u003cstd::string\u003e; } // namespace jc int main() { jc::A a = {\"down\", \"demo\"}; assert(a.x == \"down\"); static_assert(std::is_same_v\u003cdecltype(a.x), std::string\u003e); } 使用花括号赋值可以解决没有初始化列表的问题，圆括号则不行 namespace jc { template \u003ctypename T\u003e struct A { T x; }; template \u003ctypename T\u003e A(T) -\u003e A\u003cT\u003e; } // namespace jc int main() { jc::A a1{0}; // OK jc::A a2 = {0}; // OK jc::A a3(0); // 错误：没有初始化列表，int 不能转为 jc::A\u003cint\u003e jc::A a4 = 0; // 错误：没有初始化列表，int 不能转为 jc::A\u003cint\u003e } explicit 声明的 deduction guides 只用于直接初始化 namespace jc { template \u003ctypename T, typename U\u003e struct A { A(const T\u0026) {} A(T\u0026\u0026) {} }; template \u003ctypename T\u003e A(const T\u0026) -\u003e A\u003cT, T\u0026\u003e; template \u003ctypename T\u003e explicit A(T\u0026\u0026) -\u003e A\u003cT, T\u003e; // 只能用于直接初始化 } // namespace jc int main() { jc::A a = 1; // A\u003cint, int\u0026\u003e a = 1; jc::A b{2}; // A\u003cint, int\u003e b{2}; } std::array 是一个聚合类模板，C++17 为其定义了一个 deduction guides 来推断模板参数 #include \u003carray\u003e #include \u003ctype_traits\u003e // template \u003ctypename T, typename... U\u003e // array(T, U...) // -\u003e array\u003c // enable_if_t\u003c(is_same_v\u003cT, U\u003e \u0026\u0026 ...), T\u003e, // 1 + sizeof...(U) // \u003e; int main() { std::array a{1, 2, 3, 4}; static_assert(std::is_same_v\u003cdecltype(a), std::array\u003cint, 4\u003e\u003e); } C++17 允许类模板实参推断，但类模板的所有参数要么通过显式指定指出，要么通过实参推断推出，不能一部分使用显式指定一部分使用推断 #include \u003cstring\u003e namespace jc { template \u003ctypename T, typename U, typename Y = U\u003e struct A { A(T x = T{}, U y = U{}, Y z = Y{}) {} }; } // namespace jc int main() { jc::A{1, 3.14, \"hello\"}; // T = int，U = double，T3 = const char* jc::A{1, 3.14}; // T = int，U = Y = double jc::A{\"hi\", \"downdemo\"}; // T = U = Y = const char* jc::A\u003cstd::string\u003e{\"hi\", \"downdemo\", 42}; // 错误：只指定了 T，U 未推断 jc::A\u003c\u003e{1, 3.14, 42}; // 错误：T 和 U 都未指定 } 类模板实参推断的本质是为每个构造函数和构造函数模板隐式添加一个 deduction guides #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e class A { public: A(const T\u0026 val) : container_({val}) {} private: std::vector\u003cT\u003e container_; }; // template \u003ctypename T\u003e // A(const T\u0026) -\u003e A\u003cT\u003e; // 隐式 deduction guides } // namespace jc int main() { jc::A a1 = 0; jc::A a2{0}; jc::A a3(0); auto a4 = jc::A{0}; static_assert(std::is_same_v\u003cdecltype(a1), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a2), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a3), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a4), jc::A\u003cint\u003e\u003e); } ","date":"2022-06-18","objectID":"/cxx_template/:40:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#deduction-guides"},{"categories":["编程语言"],"content":" 41 Deduction Guides 的问题 用类模板实例作为实参时，Deduction guides 对实参推断的类型有歧义，标准委员会对于该情况有争议地规定，推断时不会将实参推断为类模板的实例 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { A(T x) {} }; template \u003ctypename T\u003e A(T) -\u003e A\u003cT\u003e; } // namespace jc int main() { jc::A a1{0}; jc::A a2{a1}; // A\u003cint\u003e 还是 A\u003cA\u003cint\u003e\u003e？标准委员会规定为 A\u003cint\u003e jc::A a3(a1); // A\u003cint\u003e 还是 A\u003cA\u003cint\u003e\u003e？标准委员会规定为 A\u003cint\u003e static_assert(std::is_same_v\u003cdecltype(a1), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a2), jc::A\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(a3), jc::A\u003cint\u003e\u003e); } 这个争议造成的问题如下 #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T, typename... Args\u003e auto f(const T\u0026 x, const Args\u0026... args) { // 如果 T 为 std::vector return std::vector{x, args...}; // 参数包是否为空将决定不同的返回类型 } } // namespace jc int main() { using std::vector; vector v1{1, 2, 3}; vector v2{v1}; vector v3{v1, v1}; static_assert(std::is_same_v\u003cdecltype(v1), vector\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(v2), vector\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(v3), vector\u003cvector\u003cint\u003e\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(jc::f(v1)), vector\u003cint\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(jc::f(v1, v1)), vector\u003cvector\u003cint\u003e\u003e\u003e); } 添加隐式 deduction guides 是有争议的，主要反对观点是这个特性自动将接口添加到已存在的库中，并且对于有限定名称的情况，deduction guides 会失效 namespace jc { template \u003ctypename T\u003e struct type_identity { using type = T; }; template \u003ctypename T\u003e class A { public: using ArgType = typename type_identity\u003cT\u003e::type; A(ArgType) {} }; template \u003ctypename T\u003e A(typename type_identity\u003cT\u003e::type) -\u003e A\u003cT\u003e; // 该 deduction guides 无效，因为有限定名称符 type_identity\u003cT\u003e:: } // namespace jc int main() { jc::A a{0}; // 错误 } 为了保持向后兼容性，如果模板名称是注入类名，则禁用类模板实参推断 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { template \u003ctypename U\u003e A(U x) {} template \u003ctypename U\u003e auto f(U x) { return A(x); // 根据注入类名规则 A 是 A\u003cT\u003e，根据类模板实参推断 A 是 A\u003cU\u003e } }; } // namespace jc int main() { jc::A\u003cint\u003e a{0}; auto res = a.f\u003cdouble\u003e(3.14); static_assert(std::is_same_v\u003cdecltype(res), jc::A\u003cint\u003e\u003e); } 使用转发引用的 deduction guides 可能推断出引用类型，导致实例化错误或产生空悬引用，因此标准委员会决定使用隐式 deduction guides 的推断时，禁用 T\u0026\u0026 这个特殊的推断规则 #include \u003cstring\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct A { A(const T\u0026) {} A(T\u0026\u0026) {} }; // template \u003ctypename T\u003e // A(const T\u0026) -\u003e A\u003cT\u003e; // 隐式生成 // template \u003ctypename T\u003e // A(T\u0026\u0026) -\u003e A\u003cT\u003e; // 不会隐式生成该 deduction guides } // namespace jc int main() { std::string s; jc::A a = s; // T 推断为 std::string static_assert(std::is_same_v\u003cdecltype(a), jc::A\u003cstd::string\u003e\u003e); // 若指定 T\u0026\u0026 的 deduction guides，则 T 推断为 std::string\u0026 } Deduction guides 只用于推断而非调用，实参的传递方式不必完全对应构造函数 #include \u003ciostream\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e namespace jc { template \u003ctypename T\u003e struct A {}; template \u003ctypename T\u003e struct B { B(const A\u003cT\u003e\u0026) { std::cout \u003c\u003c 1 \u003c\u003c std::endl; } B(A\u003cT\u003e\u0026\u0026) { std::cout \u003c\u003c 2 \u003c\u003c std::endl; } }; template \u003ctypename T\u003e B(A\u003cT\u003e) -\u003e B\u003cT\u003e; // 不需要完全对应构造函数 } // namespace jc int main() { jc::A\u003cint\u003e a; jc::B{a}; // 1 jc::B{std::move(a)}; // 2 } ","date":"2022-06-18","objectID":"/cxx_template/:41:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#deduction-guides-的问题"},{"categories":["编程语言"],"content":" 42 函数模板重载 对于实参推断能匹配多个模板的情况，标准规定了偏序（partial ordering）规则，最终将调用最特殊（能接受更少类型）的模板 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { return 1; } template \u003ctypename T\u003e int f(T*) { return 2; } } // namespace jc int main() { int* p = nullptr; assert(jc::f\u003cint*\u003e(p) == 1); assert(jc::f\u003cint\u003e(p) == 2); assert(jc::f(p) == 2); // 两个模板均匹配，第二个模板更特殊 assert(jc::f(0) == 1); // 0 推断为 int，匹配第一个模板 assert(jc::f(nullptr) == 1); // nullptr 推断为 std::nullptr_t，匹配第一个模板 } 对于两个模板，用实参替代第一个模板的参数，替代后的结果作为实参去推断第二个模板，如果推断成功，反过来用第二个模板推断第一个模板，若推断失败，则第一个模板更特殊，如果均推断失败或推断成功，则两个模板没有偏序关系 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { // 1 return 1; } template \u003ctypename T\u003e int f(T*) { // 2 return 2; } template \u003ctypename T\u003e int f(const T*) { // 3 return 3; } } // namespace jc int main() { const int* p = nullptr; assert(jc::f(p) == 3); // 推断结果： // 1: f(T) [T = const int*] // 2: f(T*) [T = const int] // 3: f(const T*) [T = int] // 偏序处理： // 用 2 推断 1，T = U*，推断成功 // 用 1 推断 2，T* = U，无法推断 T // 2 比 1 特殊 // 用 3 推断 1，T = const U*，推断成功 // 用 1 推断 3，const T* = U，无法推断 T // 3 比 1 特殊 // 用 3 推断 2，T = const U，推断成功 // 用 2 推断 3，const T = U，无法推断 T // 3 比 2 特殊 // 3 最特殊，因此调用 3 } 函数模板可以和非模板函数重载 #include \u003ciostream\u003e namespace jc { struct A { A() = default; A(const A\u0026) { std::cout \u003c\u003c 1; } A(A\u0026\u0026) { std::cout \u003c\u003c 2; } template \u003ctypename T\u003e A(T\u0026\u0026) { std::cout \u003c\u003c 3; } }; } // namespace jc int main() { jc::A a1; jc::A a2{a1}; // 3，对 non-const 对象，成员模板优于拷贝构造函数 jc::A a3{std::move(a1)}; // 2，移动构造函数 const jc::A b1; jc::A b2{b1}; // 1，拷贝构造函数 jc::A b3{std::move(b1)}; // 3，const A\u0026\u0026，更匹配成员模板 } 变参模板的重载 namespace jc { template \u003ctypename... Ts\u003e struct A {}; template \u003ctypename T\u003e constexpr int f(A\u003cT*\u003e) { return 1; } template \u003ctypename... Ts\u003e constexpr int f(A\u003cTs...\u003e) { return 2; } template \u003ctypename... Ts\u003e constexpr int f(A\u003cTs*...\u003e) { return 3; } static_assert(f(A\u003cint*\u003e{}) == 1); static_assert(f(A\u003cint, double\u003e{}) == 2); static_assert(f(A\u003cint*, double*\u003e{}) == 3); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:42:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#函数模板重载httpsencppreferencecomwcpplanguagefunction_templatefunction_template_overloading"},{"categories":["编程语言"],"content":" 43 特化（Specialization） 函数模板特化引入了重载和实参推断，如果能推断特化版本，就可以不显式声明模板实参 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e int f(T) { // 1 return 1; } template \u003ctypename T\u003e int f(T*) { // 2 return 2; } template \u003c\u003e int f(int) { // OK：1 的特化 return 3; } template \u003c\u003e int f(int*) { // OK：2 的特化 return 4; } } // namespace jc int main() { int* p = nullptr; assert(jc::f(p) == 4); assert(jc::f(0) == 3); assert(jc::f(nullptr) == 1); } 函数模板的特化不能有默认实参，但会使用要被特化的模板的默认实参 namespace jc { template \u003ctypename T\u003e constexpr int f(T x = 1) { // T 不会由默认实参推断 return x; } template \u003c\u003e constexpr int f(int x) { // 不能指定默认实参 return x + 1; } static_assert(f\u003cint\u003e() == 2); } // namespace jc int main() {} 类模板特化的实参列表必须对应模板参数，如果有默认实参可以不指定对应参数。可以特化整个类模板，也可以特化部分成员。如果对某种类型特化类模板成员，就不能再特化整个类模板，其他未特化的成员会被保留 #include \u003ccassert\u003e namespace jc { template \u003ctypename T, typename U = int\u003e struct A; template \u003c\u003e struct A\u003cvoid\u003e { constexpr int f(); }; constexpr int A\u003cvoid\u003e::f() { return 1; } template \u003c\u003e struct A\u003cint, int\u003e { int i = 0; }; template \u003c\u003e struct A\u003cchar, char\u003e { template \u003ctypename T\u003e struct B { int f() { return i; } static int i; }; }; template \u003ctypename T\u003e int A\u003cchar, char\u003e::B\u003cT\u003e::i = 1; template \u003c\u003e int A\u003cchar, char\u003e::B\u003cdouble\u003e::i = 2; template \u003c\u003e int A\u003cchar, char\u003e::B\u003cchar\u003e::f() { return 0; }; // template \u003c\u003e // struct A\u003cchar, char\u003e {}; // 错误，不能对已经特化过成员的类型做特化 template \u003c\u003e struct A\u003cchar, char\u003e::B\u003cbool\u003e { int j = 3; }; } // namespace jc int main() { static_assert(jc::A\u003cvoid\u003e{}.f() == 1); static_assert(jc::A\u003cvoid, int\u003e{}.f() == 1); // jc::A\u003cvoid, double\u003e{}; // 错误：未定义类型 assert((jc::A\u003cint, int\u003e{}.i == 0)); assert((jc::A\u003cchar, char\u003e::B\u003cint\u003e{}.i == 1)); assert((jc::A\u003cchar, char\u003e::B\u003cint\u003e{}.f() == 1)); assert((jc::A\u003cchar, char\u003e::B\u003cdouble\u003e{}.i == 2)); assert((jc::A\u003cchar, char\u003e::B\u003cdouble\u003e{}.f() == 2)); assert((jc::A\u003cchar, char\u003e::B\u003cchar\u003e{}.i == 1)); assert((jc::A\u003cchar, char\u003e::B\u003cchar\u003e{}.f() == 0)); assert((jc::A\u003cchar, char\u003e::B\u003cbool\u003e{}.j == 3)); } 类模板特化必须在实例化之前，对已实例化的类型不能再进行特化 namespace jc { template \u003ctypename T\u003e struct A {}; A\u003cint\u003e a; template \u003c\u003e struct A\u003cdouble\u003e {}; // OK template \u003c\u003e struct A\u003cint\u003e {}; // 错误：不能特化已实例化的 A\u003cint\u003e } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:43:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#特化specializationhttpsencppreferencecomwcpplanguagetemplate_specialization-1"},{"categories":["编程语言"],"content":" 44 偏特化（Partial Specialization） 类模板偏特化限定一些类型，而非某个具体类型 namespace jc { template \u003ctypename T\u003e struct A; // primary template template \u003ctypename T\u003e struct A\u003cconst T\u003e {}; template \u003ctypename T\u003e struct A\u003cT*\u003e { static constexpr int size = 0; }; template \u003ctypename T, int N\u003e struct A\u003cT[N]\u003e { static constexpr int size = N; }; template \u003ctypename Class\u003e struct A\u003cint * Class::*\u003e { static constexpr int i = 1; }; template \u003ctypename T, typename Class\u003e struct A\u003cT * Class::*\u003e { static constexpr int i = 2; }; template \u003ctypename Class\u003e struct A\u003cvoid (Class::*)()\u003e { static constexpr int i = 3; }; template \u003ctypename RT, typename Class\u003e struct A\u003cRT (Class::*)() const\u003e { static constexpr int i = 4; }; template \u003ctypename RT, typename Class, typename... Args\u003e struct A\u003cRT (Class::*)(Args...)\u003e { static constexpr int i = 5; }; template \u003ctypename RT, typename Class, typename... Args\u003e struct A\u003cRT (Class::*)(Args...) const noexcept\u003e { static constexpr int i = 6; }; struct B { int* i = nullptr; double* j = nullptr; void f1() {} constexpr int f2() const { return 0; } void f3(int\u0026, double) {} void f4(int\u0026, double) const noexcept {} }; static_assert(A\u003cdecltype(\u0026B::i)\u003e::i == 1); static_assert(A\u003cdecltype(\u0026B::j)\u003e::i == 2); static_assert(A\u003cdecltype(\u0026B::f1)\u003e::i == 3); static_assert(A\u003cdecltype(\u0026B::f2)\u003e::i == 4); static_assert(A\u003cdecltype(\u0026B::f3)\u003e::i == 5); static_assert(A\u003cdecltype(\u0026B::f4)\u003e::i == 6); } // namespace jc int main() { int a[] = {1, 2, 3}; static_assert(jc::A\u003cdecltype(\u0026a)\u003e::size == 0); static_assert(jc::A\u003cdecltype(a)\u003e::size == 3); // jc::A\u003cconst int[3]\u003e{}; // 错误：匹配多个版本 } 变量模板（variable template）的特化和偏特化 #include \u003ccassert\u003e #include \u003clist\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T\u003e constexpr int i = sizeof(T); template \u003c\u003e constexpr int i\u003cvoid\u003e = 0; template \u003ctypename T\u003e constexpr int i\u003cT\u0026\u003e = sizeof(void*); static_assert(i\u003cint\u003e == sizeof(int)); static_assert(i\u003cdouble\u003e == sizeof(double)); static_assert(i\u003cvoid\u003e == 0); static_assert(i\u003cint\u0026\u003e == sizeof(void*)); // 变量模板特化的类型可以不匹配 primary template template \u003ctypename T\u003e typename T::iterator null_iterator; template \u003c\u003e int* null_iterator\u003cstd::vector\u003cint\u003e\u003e = nullptr; template \u003ctypename T, std::size_t N\u003e T* null_iterator\u003cT[N]\u003e = nullptr; } // namespace jc int main() { auto it1 = jc::null_iterator\u003cstd::vector\u003cint\u003e\u003e; auto it2 = jc::null_iterator\u003cstd::list\u003cint\u003e\u003e; auto it3 = jc::null_iterator\u003cdouble[3]\u003e; static_assert(std::is_same_v\u003cdecltype(it1), int*\u003e); assert(!it1); static_assert(std::is_same_v\u003cdecltype(it2), std::list\u003cint\u003e::iterator\u003e); static_assert(std::is_same_v\u003cdecltype(it3), double*\u003e); assert(!it3); } ","date":"2022-06-18","objectID":"/cxx_template/:44:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#偏特化partial-specializationhttpsencppreferencecomwcpplanguagepartial_specialization-1"},{"categories":["编程语言"],"content":" 45 Traits 的偏特化实现 std::is_same #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename U\u003e struct is_same { static constexpr bool value = false; }; template \u003ctypename T\u003e struct is_same\u003cT, T\u003e { static constexpr bool value = true; }; template \u003ctypename T, typename U\u003e constexpr bool is_same_v = is_same\u003cT, U\u003e::value; } // namespace jc static_assert(jc::is_same_v\u003cint, int\u003e); static_assert(!jc::is_same_v\u003cint, double\u003e); static_assert(!jc::is_same_v\u003cint, int\u0026\u003e); int main() {} 获取元素类型 #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct get_element { using type = T; }; template \u003ctypename T\u003e struct get_element\u003cT[]\u003e { using type = typename get_element\u003cT\u003e::type; }; template \u003ctypename T, std::size_t N\u003e struct get_element\u003cT[N]\u003e { using type = typename get_element\u003cT\u003e::type; }; template \u003ctypename T\u003e using get_element_t = typename get_element\u003cT\u003e::type; } // namespace jc static_assert(std::is_same_v\u003cjc::get_element_t\u003cint\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::get_element_t\u003cint[]\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::get_element_t\u003cint[3][4][5]\u003e, int\u003e); int main() {} std::remove_reference #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct remove_reference { using type = T; }; template \u003ctypename T\u003e struct remove_reference\u003cT\u0026\u003e { using type = T; }; template \u003ctypename T\u003e struct remove_reference\u003cT\u0026\u0026\u003e { using type = T; }; template \u003ctypename T\u003e using remove_reference_t = typename remove_reference\u003cT\u003e::type; } // namespace jc static_assert(std::is_same_v\u003cjc::remove_reference_t\u003cint\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::remove_reference_t\u003cint\u0026\u003e, int\u003e); static_assert(std::is_same_v\u003cjc::remove_reference_t\u003cint\u0026\u0026\u003e, int\u003e); int main() {} std::enable_if #include \u003clist\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e #include \u003cvector\u003e namespace jc { template \u003cbool, typename T = void\u003e struct enable_if {}; template \u003ctypename T\u003e struct enable_if\u003ctrue, T\u003e { using type = T; }; template \u003cbool B, typename T = void\u003e using enable_if_t = typename enable_if\u003cB, T\u003e::type; } // namespace jc struct Base {}; struct Derived1 : Base {}; struct Derived2 : Base {}; template \u003ctypename T, template \u003ctypename...\u003e class V\u003e void impl(const V\u003cT\u003e\u0026) { static_assert(std::is_constructible_v\u003cBase*, T*\u003e); } template \u003ctypename T, template \u003ctypename...\u003e class V, typename... Args, jc::enable_if_t\u003cstd::is_constructible_v\u003cBase*, T*\u003e, void*\u003e = nullptr\u003e void f(const V\u003cT\u003e\u0026 t, Args\u0026\u0026... args) { impl(t); if constexpr (sizeof...(args) \u003e 0) { f(std::forward\u003cArgs\u003e(args)...); } } int main() { f(std::vector\u003cDerived1\u003e{}, std::list\u003cDerived2\u003e{}); } ","date":"2022-06-18","objectID":"/cxx_template/:45:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#traits-的偏特化实现"},{"categories":["编程语言"],"content":" 46 元函数转发（Metafunction Forwarding） Traits 可以视为对类型做操作的函数，称为元函数，元函数一般包含一些相同的成员，将相同成员封装成一个基类作为基本元函数，继承这个基类即可使用成员，这种实现方式称为元函数转发，标准库中实现了 std::integral_constant 作为基本元函数 #include \u003ccassert\u003e #include \u003ctype_traits\u003e namespace jc { template \u003cclass T, T v\u003e struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant\u003cT, v\u003e; constexpr operator value_type() const noexcept { return value; } constexpr value_type operator()() const noexcept { return value; } }; constexpr int to_int(char c) { // hexadecimal letters: if (c \u003e= 'A' \u0026\u0026 c \u003c= 'F') { return static_cast\u003cint\u003e(c) - static_cast\u003cint\u003e('A') + 10; } if (c \u003e= 'a' \u0026\u0026 c \u003c= 'f') { return static_cast\u003cint\u003e(c) - static_cast\u003cint\u003e('a') + 10; } assert(c \u003e= '0' \u0026\u0026 c \u003c= '9'); return static_cast\u003cint\u003e(c) - static_cast\u003cint\u003e('0'); } template \u003cstd::size_t N\u003e constexpr int parse_int(const char (\u0026arr)[N]) { int base = 10; // to handle base (default: decimal) int offset = 0; // to skip prefixes like 0x if (N \u003e 2 \u0026\u0026 arr[0] == '0') { switch (arr[1]) { case 'x': // prefix 0x or 0X, so hexadecimal case 'X': base = 16; offset = 2; break; case 'b': // prefix 0b or 0B (since C++14), so binary case 'B': base = 2; offset = 2; break; default: // prefix 0, so octal base = 8; offset = 1; break; } } int res = 0; int multiplier = 1; for (std::size_t i = 0; i \u003c N - offset; ++i) { if (arr[N - 1 - i] != '\\'') { res += to_int(arr[N - 1 - i]) * multiplier; multiplier *= base; } } return res; } template \u003cchar... cs\u003e constexpr auto operator\"\" _c() { return integral_constant\u003cint, parse_int\u003csizeof...(cs)\u003e({cs...})\u003e{}; } static_assert(std::is_same_v\u003cdecltype(2_c), integral_constant\u003cint, 2\u003e\u003e); static_assert(std::is_same_v\u003cdecltype(0xFF_c), integral_constant\u003cint, 255\u003e\u003e); static_assert( std::is_same_v\u003cdecltype(0b1111'1111_c), integral_constant\u003cint, 255\u003e\u003e); } // namespace jc static_assert(jc::integral_constant\u003cint, 42\u003e::value == 42); static_assert(std::is_same_v\u003cint, jc::integral_constant\u003cint, 0\u003e::value_type\u003e); static_assert(jc::integral_constant\u003cint, 42\u003e{} == 42); int main() { jc::integral_constant\u003cint, 42\u003e f; static_assert(f() == 42); } 利用元函数转发实现 std::is_same namespace jc { template \u003cclass T, T v\u003e struct integral_constant { static constexpr T value = v; using value_type = T; using type = integral_constant\u003cT, v\u003e; constexpr operator value_type() const noexcept { return value; } constexpr value_type operator()() const noexcept { return value; } }; template \u003cbool B\u003e using bool_constant = integral_constant\u003cbool, B\u003e; using true_type = bool_constant\u003ctrue\u003e; using false_type = bool_constant\u003cfalse\u003e; template \u003ctypename T, typename U\u003e struct is_same : false_type {}; template \u003ctypename T\u003e struct is_same\u003cT, T\u003e : true_type {}; template \u003ctypename T, typename U\u003e constexpr bool is_same_v = is_same\u003cT, U\u003e::value; } // namespace jc static_assert(jc::is_same_v\u003cint, int\u003e); static_assert(!jc::is_same_v\u003cint, double\u003e); static_assert(!jc::is_same_v\u003cint, int\u0026\u003e); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:46:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#元函数转发metafunction-forwarding"},{"categories":["编程语言"],"content":" 47 SFINAE-based traits std::is_default_constructible #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e struct is_default_constructible { private: template \u003ctypename U, typename = decltype(U())\u003e static std::true_type test(void*); template \u003ctypename\u003e static std::false_type test(...); public: static constexpr bool value = decltype(test\u003cT\u003e(nullptr))::value; }; template \u003ctypename T\u003e constexpr bool is_default_constructible_v = is_default_constructible\u003cT\u003e::value; } // namespace jc struct A { A() = delete; }; static_assert(!jc::is_default_constructible_v\u003cA\u003e); int main() {} std::void_t #include \u003ctype_traits\u003e namespace jc { template \u003ctypename...\u003e using void_t = void; template \u003ctypename, typename = void_t\u003c\u003e\u003e struct is_default_constructible : std::false_type {}; template \u003ctypename T\u003e struct is_default_constructible\u003cT, void_t\u003cdecltype(T())\u003e\u003e : std::true_type {}; template \u003ctypename T\u003e constexpr bool is_default_constructible_v = is_default_constructible\u003cT\u003e::value; } // namespace jc struct A { A() = delete; }; static_assert(!jc::is_default_constructible_v\u003cA\u003e); int main() {} std::declval #include \u003ctype_traits\u003e namespace jc { template \u003ctypename\u003e constexpr bool always_false = false; template \u003ctypename T\u003e std::add_rvalue_reference_t\u003cT\u003e declval() noexcept { static_assert(always_false\u003cT\u003e, \"declval not allowed in an evaluated context\"); } template \u003ctypename, typename = std::void_t\u003c\u003e\u003e struct has_less : std::false_type {}; template \u003ctypename T\u003e struct has_less\u003cT, std::void_t\u003cdecltype(jc::declval\u003cT\u003e() \u003c jc::declval\u003cT\u003e())\u003e\u003e : std::true_type {}; template \u003ctypename T\u003e constexpr bool has_less_v = has_less\u003cT\u003e::value; } // namespace jc struct A { A() = delete; bool operator\u003c(const A\u0026 rhs) const { return i \u003c rhs.i; } int i; }; static_assert(jc::has_less_v\u003cA\u003e); int main() {} std::is_nothrow_move_constructible #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T, typename = std::void_t\u003c\u003e\u003e struct is_nothrow_move_constructible : std::false_type {}; template \u003ctypename T\u003e struct is_nothrow_move_constructible\u003c T, std::void_t\u003cdecltype(T(std::declval\u003cT\u003e()))\u003e\u003e : std::bool_constant\u003cnoexcept(T(std::declval\u003cT\u003e()))\u003e {}; template \u003ctypename T\u003e constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible\u003cT\u003e::value; } // namespace jc struct A { A(A\u0026\u0026) noexcept {} }; struct B { private: B(B\u0026\u0026) noexcept {}; }; static_assert(jc::is_nothrow_move_constructible_v\u003cA\u003e); static_assert(!jc::is_nothrow_move_constructible_v\u003cB\u003e); int main() {} std::is_convertible #include \u003ctype_traits\u003e namespace jc { // 转为 void 类型需要单独处理，转为数组和函数类型总是 false template \u003ctypename From, typename To, bool = std::is_void_v\u003cTo\u003e || std::is_array_v\u003cTo\u003e || std::is_function_v\u003cTo\u003e\u003e struct is_convertible_impl { using type = std::bool_constant\u003cstd::is_void_v\u003cTo\u003e \u0026\u0026 std::is_void_v\u003cFrom\u003e\u003e; }; template \u003ctypename From, typename To\u003e struct is_convertible_impl\u003cFrom, To, false\u003e { private: static void f(To); template \u003ctypename T, typename U, typename = decltype(f(std::declval\u003cT\u003e()))\u003e // 将 T 转为 To static std::true_type test(void*); template \u003ctypename, typename\u003e static std::false_type test(...); public: using type = decltype(test\u003cFrom, To\u003e(nullptr)); }; template \u003ctypename From, typename To\u003e struct is_convertible : is_convertible_impl\u003cFrom, To\u003e::type {}; template \u003ctypename From, typename To\u003e constexpr bool is_convertible_v = is_convertible\u003cFrom, To\u003e::value; } // namespace jc struct A {}; struct B : A {}; static_assert(jc::is_convertible_v\u003cB, A\u003e); static_assert(jc::is_convertible_v\u003cB*, A*\u003e); static_assert(!jc::is_convertible_v\u003cA*, B*\u003e); static_assert(jc::is_convertible_v\u003cvoid, void\u003e); static_assert(!jc::is_convertible_v\u003cint*, int[]\u003e); int main() {} std::is_class #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename T, typename = std::void_t\u003c\u003e\u003e struct is_class : std::false_type {}; template \u003ctypename T\u003e struct is_class\u003cT, std::void_t\u003cint T::*\u003e\u003e : std::true_type {}; template \u003cclass T\u003e constexpr bool is_class_v = is_class\u003cT\u003e::value; } // namespace jc union A {}; sta","date":"2022-06-18","objectID":"/cxx_template/:47:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#sfinae-based-traits"},{"categories":["编程语言"],"content":" 48 空基类优化（EBCO，Empty Base Class Optimization） 为了保证给类动态分配内存时有不同的地址，C++ 规定空类大小必须大于 0 namespace jc { struct A {}; struct B {}; static_assert(sizeof(A) \u003e 0); static_assert(sizeof(B) \u003e 0); } // namespace jc int main() { jc::A a; jc::B b; static_assert((void*)\u0026a != (void*)\u0026b); } 一般编译器将空类大小设为 1 字节，对于空类存在继承关系的情况，如果支持 EBCO，可以优化派生类的空间占用大小 /* 不支持 EBCO 的内存布局： * [ ] } A } B } C * [ ] } } * [ ] } * * 支持 EBCO 的内存布局： * [ ] } A } B } C */ namespace jc { struct A { using Int = int; }; struct B : A {}; struct C : B {}; static_assert(sizeof(A) == 1); static_assert(sizeof(A) == sizeof(B)); static_assert(sizeof(A) == sizeof(C)); } // namespace jc int main() {} 模板参数可能是空类 namespace jc { struct A {}; struct B {}; template \u003ctypename T, typename U\u003e struct C { T a; U b; }; static_assert(sizeof(C\u003cA, B\u003e) == 2); } // namespace jc int main() {} 为了利用 EBCO 压缩内存空间，可以将模板参数设为基类 namespace jc { struct A {}; struct B {}; template \u003ctypename T, typename U\u003e struct C : T, U {}; static_assert(sizeof(C\u003cA, B\u003e) == 1); } // namespace jc int main() {} 但模板参数可能是相同类型，或者不一定是类，此时将其设为基类在实例化时会报错。如果已知一个模板参数类型为空类，把可能为空的类型参数与一个不为空的成员利用 EBCO 合并起来，即可把空类占用的空间优化掉 namespace jc { template \u003ctypename Base, typename Member\u003e class Pair : private Base { public: Pair(const Base\u0026 b, const Member\u0026 m) : Base(b), member_(m) {} const Base\u0026 first() const { return (const Base\u0026)*this; } Base\u0026 first() { return (Base\u0026)*this; } const Member\u0026 second() const { return this-\u003emember_; } Member\u0026 second() { return this-\u003emember_; } private: Member member_; }; template \u003ctypename T\u003e struct Unoptimizable { T info; void* storage; }; template \u003ctypename T\u003e struct Optimizable { Pair\u003cT, void*\u003e info_and_storage; }; } // namespace jc struct A {}; static_assert(sizeof(jc::Unoptimizable\u003cA\u003e) == 2 * sizeof(void*)); static_assert(sizeof(jc::Optimizable\u003cA\u003e) == sizeof(void*)); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:48:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#空基类优化ebcoempty-base-class-optimization"},{"categories":["编程语言"],"content":" 49 奇异递归模板模式（CRTP，The Curiously Recurring Template Pattern） CRTP 的实现手法是将派生类作为基类的模板参数 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class Base { public: static int count() { return i; } protected: Base() { ++i; } Base(const Base\u003cT\u003e \u0026) { ++i; } Base(Base\u003cT\u003e \u0026\u0026) noexcept { ++i; } ~Base() { --i; } private: inline static int i = 0; }; template \u003ctypename T\u003e class Derived : public Base\u003cDerived\u003cT\u003e\u003e {}; } // namespace jc int main() { jc::Derived\u003cint\u003e a, b; jc::Derived\u003cchar\u003e c; assert(jc::Derived\u003cint\u003e::count() == 2); assert(jc::Derived\u003cchar\u003e::count() == 1); } 通常大量运算符重载会一起出现，但通常这些运算符只需要一个定义，其他运算符可以提取到基类中基于这一个来实现 #include \u003ccassert\u003e namespace jc { template \u003ctypename T\u003e class Base { friend bool operator!=(const T\u0026 lhs, const T\u0026 rhs) { return !(lhs == rhs); } }; class Derived : public Base\u003cDerived\u003e { friend bool operator==(const Derived\u0026 lhs, const Derived\u0026 rhs) { return lhs.i_ == rhs.i_; } public: Derived(int i) : i_(i) {} private: int i_ = 0; }; } // namespace jc int main() { jc::Derived a{1}; jc::Derived b{2}; assert(a != b); } CRTP 基类可以基于 CRTP 派生类暴露的小得多的接口定义大部分接口，这个模式称为 facade 模式 #include \u003ccassert\u003e #include \u003citerator\u003e #include \u003ctype_traits\u003e #include \u003cvector\u003e namespace jc { template \u003ctypename Derived, typename Value, typename Category\u003e class IteratorFacade { public: using value_type = std::remove_const_t\u003cValue\u003e; using reference = Value\u0026; using pointer = Value*; using difference_type = std::ptrdiff_t; using iterator_category = Category; public: reference operator*() const { return as_derived().dereference(); } Derived\u0026 operator++() { as_derived().increment(); return as_derived(); } Derived operator++(int) { Derived tmp(as_derived()); as_derived().increment(); return tmp; } friend bool operator==(const IteratorFacade\u0026 lhs, const IteratorFacade\u0026 rhs) { return lhs.as_derived().equals(rhs.as_derived()); } friend bool operator!=(const IteratorFacade\u0026 lhs, const IteratorFacade\u0026 rhs) { return !operator==(lhs, rhs); } private: Derived\u0026 as_derived() { return *static_cast\u003cDerived*\u003e(this); } const Derived\u0026 as_derived() const { return *static_cast\u003cconst Derived*\u003e(this); } }; template \u003ctypename T\u003e struct ListNode { ListNode(T x) : value(x) {} T value; ListNode\u003cT\u003e* next = nullptr; }; template \u003ctypename T\u003e class ListNodeIterator : public IteratorFacade\u003cListNodeIterator\u003cT\u003e, T, std::forward_iterator_tag\u003e { public: ListNodeIterator(ListNode\u003cT\u003e* t = nullptr) : t_(t) {} T\u0026 dereference() const { return t_-\u003evalue; } void increment() { t_ = t_-\u003enext; } bool equals(const ListNodeIterator\u0026 rhs) const { return t_ == rhs.t_; } private: ListNode\u003cT\u003e* t_ = nullptr; }; } // namespace jc int main() { auto a = new jc::ListNode\u003cint\u003e{1}; auto b = new jc::ListNode\u003cint\u003e{2}; auto c = new jc::ListNode\u003cint\u003e{3}; a-\u003enext = b; b-\u003enext = c; auto first = jc::ListNodeIterator{a}; auto last = ++jc::ListNodeIterator{c}; std::vector\u003cint\u003e v; for (auto it = first; it != last; ++it) { v.emplace_back(*it); } assert((v == std::vector\u003cint\u003e{1, 2, 3})); delete c; delete b; delete a; } ","date":"2022-06-18","objectID":"/cxx_template/:49:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#奇异递归模板模式crtpthe-curiously-recurring-template-pattern"},{"categories":["编程语言"],"content":" 50 Mixins 使用 Mixins 手法可以更方便地引入额外信息 #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename... Mixins\u003e struct Point : Mixins... { Point() : Mixins()..., x(0.0), y(0.0) {} Point(double x, double y) : Mixins()..., x(x), y(y) {} double x; double y; }; struct Label { std::string label = \"point\"; }; struct Color { enum { red, green, blue }; }; using CustomPoint = Point\u003cLabel, Color\u003e; } // namespace jc int main() { jc::CustomPoint p; assert(p.label == \"point\"); assert(p.red == jc::Color::red); assert(p.green == jc::Color::green); assert(p.blue == jc::Color::blue); } CRTP-mixin #include \u003ccassert\u003e #include \u003cstring\u003e namespace jc { template \u003ctypename T\u003e class Base { public: static int count() { return i; } protected: Base() { ++i; } Base(const Base\u003cT\u003e \u0026) { ++i; } Base(Base\u003cT\u003e \u0026\u0026) noexcept { ++i; } ~Base() { --i; } private: inline static int i = 0; }; template \u003ctemplate \u003ctypename\u003e class... Mixins\u003e struct Point : Mixins\u003cPoint\u003c\u003e\u003e... { Point() : Mixins\u003cPoint\u003c\u003e\u003e()..., x(0.0), y(0.0) {} Point(double x, double y) : Mixins\u003cPoint\u003c\u003e\u003e()..., x(x), y(y) {} double x; double y; }; template \u003ctypename T\u003e struct Label { std::string label = \"point\"; }; template \u003ctypename T\u003e struct Color { enum { red, green, blue }; }; using PointCount = Point\u003cBase, Label, Color\u003e; } // namespace jc int main() { jc::PointCount a, b, c; assert(jc::PointCount::count() == 3); assert(a.label == \"point\"); assert(a.red == jc::Color\u003cvoid\u003e::red); assert(a.green == jc::Color\u003cvoid\u003e::green); assert(a.blue == jc::Color\u003cvoid\u003e::blue); } Mixins 参数化成员函数的虚拟性 #include \u003ccassert\u003e namespace jc { template \u003ctypename... Mixins\u003e class Base : private Mixins... { public: int f() { return 1; } // 是否为虚函数由 Mixins 中的声明决定 }; template \u003ctypename... Mixins\u003e class Derived : public Base\u003cMixins...\u003e { public: int f() { return 2; } }; } // namespace jc struct A {}; struct B { virtual int f() = 0; }; int main() { jc::Base\u003cA\u003e* p = new jc::Derived\u003cA\u003e; assert(p-\u003ef() == 1); jc::Base\u003cB\u003e* q = new jc::Derived\u003cB\u003e; assert(q-\u003ef() == 2); } ","date":"2022-06-18","objectID":"/cxx_template/:50:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#mixins"},{"categories":["编程语言"],"content":" 51 指定模板参数 模板常常带有一长串类型参数，不过通常都设有默认值 struct A {}; struct B {}; struct C {}; template \u003ctypename T1 = A, typename T2 = B, typename T3 = C\u003e struct MyClass {}; 现在想指定某个实参，而其他参数依然使用默认实参 namespace jc { struct A {}; struct B {}; struct C { static constexpr int f() { return 1; } }; struct Alias { using P1 = A; using P2 = B; using P3 = C; }; template \u003ctypename T\u003e struct SetT1 : virtual Alias { using P1 = T; }; template \u003ctypename T\u003e struct SetT2 : virtual Alias { using P2 = T; }; template \u003ctypename T\u003e struct SetT3 : virtual Alias { using P3 = T; }; // 由于不能从多个相同类直接继承，需要一个中间层用于区分 template \u003ctypename T, int N\u003e struct Mid : T {}; template \u003ctypename T1, typename T2, typename T3\u003e struct SetBase : Mid\u003cT1, 1\u003e, Mid\u003cT2, 2\u003e, Mid\u003cT3, 3\u003e {}; /* Alias 要被用作默认实参 * 但 SetBase 会将其多次指定为 Mid 的基类 * 为了防止多次继承产生二义性 * 虚派生一个新类替代 Alias 作为默认实参 */ struct Args : virtual Alias {}; // Args 即包含了别名 P1、P2、P3 template \u003ctypename T1 = Args, typename T2 = Args, typename T3 = Args\u003e struct MyClass { using Policies = SetBase\u003cT1, T2, T3\u003e; constexpr int f() { return Policies::P3::f(); } }; struct D { static constexpr int f() { return 2; } }; static_assert(MyClass{}.f() == 1); static_assert(MyClass\u003cSetT3\u003cD\u003e\u003e{}.f() == 2); } // namespace jc int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:51:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#指定模板参数"},{"categories":["编程语言"],"content":" 52 类型擦除（Type Erasure） 类型擦除即将不同类型抽象为相同的表示，但使用时仍可以还原出原有类型的行为，std::any 和 std::function 就使用了类型擦除的手法。比起函数指针，std::function 在编译期擦除掉了不需要关心的原有类型，用同一种表示抽象了所有函数类型，并且能存储 lambda 或函数对象，使用时又能像调用函数一样使用原有类型 #include \u003cany\u003e #include \u003ccassert\u003e #include \u003cexception\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e class is_equality_comparable { private: static void* conv(bool); template \u003ctypename U\u003e static std::true_type test( decltype(conv(std::declval\u003cconst U\u0026\u003e() == std::declval\u003cconst U\u0026\u003e())), decltype(conv(!(std::declval\u003cconst U\u0026\u003e() == std::declval\u003cconst U\u0026\u003e())))); template \u003ctypename U\u003e static std::false_type test(...); public: static constexpr bool value = decltype(test\u003cT\u003e(nullptr, nullptr))::value; }; template \u003ctypename T, bool = is_equality_comparable\u003cT\u003e::value\u003e struct try_equals { static bool equals(const T\u0026 lhs, const T\u0026 rhs) { return lhs == rhs; } }; struct not_equality_comparable : std::exception {}; template \u003ctypename T\u003e struct try_equals\u003cT, false\u003e { static bool equals(const T\u0026 lhs, const T\u0026 rhs) { throw not_equality_comparable(); } }; template \u003ctypename R, typename... Args\u003e class functor_bridge { public: virtual ~functor_bridge() {} virtual functor_bridge* clone() const = 0; virtual R invoke(Args... args) const = 0; virtual bool equals(const functor_bridge*) const = 0; }; template \u003ctypename F, typename R, typename... Args\u003e class functor_bridge_impl : public functor_bridge\u003cR, Args...\u003e { public: template \u003ctypename T\u003e functor_bridge_impl(T\u0026\u0026 f) : f_(std::forward\u003cT\u003e(f)) {} virtual functor_bridge_impl* clone() const override { return new functor_bridge_impl(f_); } virtual R invoke(Args... args) const override { return f_(std::forward\u003cArgs\u003e(args)...); } virtual bool equals(const functor_bridge\u003cR, Args...\u003e* rhs) const override { if (auto p = dynamic_cast\u003cconst functor_bridge_impl*\u003e(rhs)) { return try_equals\u003cF\u003e::equals(f_, p-\u003ef_); } return false; } private: F f_; }; template \u003ctypename\u003e class function; template \u003ctypename R, typename... Args\u003e class function\u003cR(Args...)\u003e { friend bool operator==(const function\u0026 lhs, const function\u0026 rhs) { if (!lhs || !rhs) { return !lhs \u0026\u0026 !rhs; } return lhs.bridge_-\u003eequals(rhs.bridge_); } friend bool operator!=(const function\u0026 lhs, const function\u0026 rhs) { return !(lhs == rhs); } friend void swap(function\u0026 lhs, function\u0026 rhs) noexcept { std::swap(lhs.bridge_, rhs.bridge_); } public: function() = default; function(const function\u0026 rhs) { if (rhs.bridge_) { bridge_ = rhs.bridge_-\u003eclone(); } } function(function\u0026 rhs) : function(static_cast\u003cconst function\u0026\u003e(rhs)) {} function(function\u0026\u0026 rhs) noexcept : bridge_(rhs.bridge_) { rhs.bridge_ = nullptr; } template \u003ctypename F\u003e function(F\u0026\u0026 f) { using Bridge = functor_bridge_impl\u003cstd::decay_t\u003cF\u003e, R, Args...\u003e; bridge_ = new Bridge(std::forward\u003cF\u003e(f)); // type erasure } ~function() { delete bridge_; } function\u0026 operator=(const function\u0026 rhs) { function tmp(rhs); swap(*this, tmp); return *this; } function\u0026 operator=(function\u0026\u0026 rhs) noexcept { delete bridge_; bridge_ = rhs.bridge_; rhs.bridge_ = nullptr; return *this; } template \u003ctypename F\u003e function\u0026 operator=(F\u0026\u0026 rhs) { function tmp(std::forward\u003cF\u003e(rhs)); swap(*this, tmp); return *this; } explicit operator bool() const { return bridge_ == nullptr; } R operator()(Args... args) const { return bridge_-\u003einvoke(std::forward\u003cArgs\u003e(args)...); } private: functor_bridge\u003cR, Args...\u003e* bridge_ = nullptr; }; } // namespace jc int main() { jc::function\u003cbool(int)\u003e f = [](const std::any\u0026 a) -\u003e int { return std::any_cast\u003cint\u003e(a); }; assert(f(3.14) == 1); } ","date":"2022-06-18","objectID":"/cxx_template/:52:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#类型擦除type-erasure"},{"categories":["编程语言"],"content":" 53 元编程（Metaprogramming） 元编程将计算在编译期完成，避免了运行期计算的开销 #include \u003ctype_traits\u003e namespace jc { template \u003cint N, int... Ns\u003e struct max; template \u003cint N\u003e struct max\u003cN\u003e : std::integral_constant\u003cint, N\u003e {}; template \u003cint N1, int N2, int... Ns\u003e struct max\u003cN1, N2, Ns...\u003e : std::integral_constant\u003cint, (N1 \u003c N2) ? max\u003cN2, Ns...\u003e::value : max\u003cN1, Ns...\u003e::value\u003e {}; template \u003cint... Ns\u003e inline constexpr auto max_v = max\u003cNs...\u003e::value; } // namespace jc static_assert(jc::max_v\u003c3, 2, 1, 5, 4\u003e == 5); int main() {} 模板元编程通常使用偏特化和递归实现，由于编译期需要实例化代码，如果递归层次过深，会带来代码体积膨胀的问题 #include \u003ctype_traits\u003e namespace jc { template \u003cint N, int L = 1, int R = N\u003e struct sqrt { static constexpr auto M = L + (R - L) / 2; static constexpr auto T = N / M; static constexpr auto value = // 避免递归实例化所有分支 std::conditional_t\u003c(T \u003c M), sqrt\u003cN, L, M\u003e, sqrt\u003cN, M + 1, R\u003e\u003e::value; }; template \u003cint N, int M\u003e struct sqrt\u003cN, M, M\u003e { static constexpr auto value = M - 1; }; template \u003cint N\u003e inline constexpr auto sqrt_v = sqrt\u003cN, 1, N\u003e::value; } // namespace jc static_assert(jc::sqrt_v\u003c10000\u003e == 100); int main() {} C++14 支持 constexpr 函数，简化了实现并且没有递归实例化的代码膨胀问题 namespace jc { template \u003cint N\u003e constexpr int sqrt() { if constexpr (N \u003c= 1) { return N; } int l = 1; int r = N; while (l \u003c r) { int m = l + (r - l) / 2; int t = N / m; if (m == t) { return m; } else if (m \u003e t) { r = m; } else { l = m + 1; } } return l - 1; } } // namespace jc static_assert(jc::sqrt\u003c10000\u003e() == 100); int main() {} ","date":"2022-06-18","objectID":"/cxx_template/:53:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#元编程metaprogramming"},{"categories":["编程语言"],"content":" 54 循环展开（Loop Unrolling） 在一些机器上，for 循环的汇编将产生分支指令 #include \u003carray\u003e #include \u003ccassert\u003e namespace jc { template \u003ctypename T, std::size_t N\u003e auto dot_product(const std::array\u003cT, N\u003e\u0026 lhs, const std::array\u003cT, N\u003e\u0026 rhs) { T res{}; for (std::size_t i = 0; i \u003c N; ++i) { res += lhs[i] * rhs[i]; } return res; } } // namespace jc int main() { std::array\u003cint, 3\u003e a{1, 2, 3}; std::array\u003cint, 3\u003e b{4, 5, 6}; assert(jc::dot_product(a, b) == 32); } 循环展开是一种牺牲体积加快程序执行速度的方法，现代编译器会优化循环为目标平台最高效形式。使用元编程可以展开循环，虽然已经没有必要，但还是给出实现 #include \u003carray\u003e #include \u003ccassert\u003e namespace jc { template \u003ctypename T, std::size_t N\u003e struct dot_product_impl { static T value(const T* lhs, const T* rhs) { return *lhs * *rhs + dot_product_impl\u003cT, N - 1\u003e::value(lhs + 1, rhs + 1); } }; template \u003ctypename T\u003e struct dot_product_impl\u003cT, 0\u003e { static T value(const T*, const T*) { return T{}; } }; template \u003ctypename T, std::size_t N\u003e auto dot_product(const std::array\u003cT, N\u003e\u0026 lhs, const std::array\u003cT, N\u003e\u0026 rhs) { return dot_product_impl\u003cT, N\u003e::value(\u0026*std::begin(lhs), \u0026*std::begin(rhs)); } } // namespace jc int main() { std::array\u003cint, 3\u003e a{1, 2, 3}; std::array\u003cint, 3\u003e b{4, 5, 6}; assert(jc::dot_product(a, b) == 32); } ","date":"2022-06-18","objectID":"/cxx_template/:54:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#循环展开loop-unrolling"},{"categories":["编程语言"],"content":" 55 Unit Type std::ratio #include \u003ccassert\u003e #include \u003ccmath\u003e #include \u003ctype_traits\u003e namespace jc { template \u003cint N, int D = 1\u003e struct ratio { static constexpr int num = N; static constexpr int den = D; using type = ratio\u003cnum, den\u003e; }; template \u003ctypename R1, typename R2\u003e struct ratio_add_impl { private: static constexpr int den = R1::den * R2::den; static constexpr int num = R1::num * R2::den + R2::num * R1::den; public: using type = ratio\u003cnum, den\u003e; }; template \u003ctypename R1, typename R2\u003e using ratio_add = typename ratio_add_impl\u003cR1, R2\u003e::type; template \u003ctypename T, typename U = ratio\u003c1\u003e\u003e class duration { public: using rep = T; using period = typename U::type; public: constexpr duration(rep r = 0) : r_(r) {} constexpr rep count() const { return r_; } private: rep r_; }; template \u003ctypename T1, typename U1, typename T2, typename U2\u003e constexpr auto operator+(const duration\u003cT1, U1\u003e\u0026 lhs, const duration\u003cT2, U2\u003e\u0026 rhs) { using CommonType = ratio\u003c1, ratio_add\u003cU1, U2\u003e::den\u003e; auto res = (lhs.count() * U1::num / U1::den + rhs.count() * U2::num / U2::den) * CommonType::den; return duration\u003cdecltype(res), CommonType\u003e{res}; } } // namespace jc int main() { constexpr auto a = jc::duration\u003cdouble, jc::ratio\u003c1, 1000\u003e\u003e(10); // 10 ms constexpr auto b = jc::duration\u003cdouble, jc::ratio\u003c1, 3\u003e\u003e(7.5); // 2.5 s constexpr auto c = a + b; // 10 * 3 + 7.5 * 1000 = 7530 * 1/3000 s assert(std::abs(c.count() - 7530) \u003c 1e-6); static_assert(std::is_same_v\u003cstd::decay_t\u003cdecltype(c)\u003e, jc::duration\u003cdouble, jc::ratio\u003c1, 3000\u003e\u003e\u003e); static_assert(decltype(c)::period::num == 1); static_assert(decltype(c)::period::den == 3000); } ","date":"2022-06-18","objectID":"/cxx_template/:55:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#unit-typehttpsenwikipediaorgwikiunit_type"},{"categories":["编程语言"],"content":" 56 Typelist // typelist.hpp #pragma once #include \u003ctype_traits\u003e namespace jc { template \u003ctypename...\u003e struct typelist {}; template \u003ctypename List\u003e struct front; template \u003ctypename Head, typename... Tail\u003e struct front\u003ctypelist\u003cHead, Tail...\u003e\u003e { using type = Head; }; template \u003ctypename List\u003e using front_t = typename front\u003cList\u003e::type; // pop_front_t template \u003ctypename List\u003e struct pop_front; template \u003ctypename Head, typename... Tail\u003e struct pop_front\u003ctypelist\u003cHead, Tail...\u003e\u003e { using type = typelist\u003cTail...\u003e; }; template \u003ctypename List\u003e using pop_front_t = typename pop_front\u003cList\u003e::type; // push_front_t template \u003ctypename List, typename NewElement\u003e struct push_front; template \u003ctypename... Elements, typename NewElement\u003e struct push_front\u003ctypelist\u003cElements...\u003e, NewElement\u003e { using type = typelist\u003cNewElement, Elements...\u003e; }; template \u003ctypename List, typename NewElement\u003e using push_front_t = typename push_front\u003cList, NewElement\u003e::type; // nth_element_t template \u003ctypename List, std::size_t N\u003e struct nth_element : nth_element\u003cpop_front_t\u003cList\u003e, N - 1\u003e {}; template \u003ctypename List\u003e struct nth_element\u003cList, 0\u003e : front\u003cList\u003e {}; template \u003ctypename List, std::size_t N\u003e using nth_element_t = typename nth_element\u003cList, N\u003e::type; // is_empty template \u003ctypename T\u003e struct is_empty { static constexpr bool value = false; }; template \u003c\u003e struct is_empty\u003ctypelist\u003c\u003e\u003e { static constexpr bool value = true; }; template \u003ctypename T\u003e inline constexpr bool is_empty_v = is_empty\u003cT\u003e::value; // find_index_of_t template \u003ctypename List, typename T, std::size_t N = 0, bool Empty = is_empty_v\u003cList\u003e\u003e struct find_index_of; template \u003ctypename List, typename T, std::size_t N\u003e struct find_index_of\u003cList, T, N, false\u003e : std::conditional_t\u003cstd::is_same_v\u003cfront_t\u003cList\u003e, T\u003e, std::integral_constant\u003cstd::size_t, N\u003e, find_index_of\u003cpop_front_t\u003cList\u003e, T, N + 1\u003e\u003e {}; template \u003ctypename List, typename T, std::size_t N\u003e struct find_index_of\u003cList, T, N, true\u003e {}; template \u003ctypename List, typename T\u003e using find_index_of_t = typename find_index_of\u003cList, T\u003e::type; // push_back_t template \u003ctypename List, typename NewElement, bool = is_empty_v\u003cList\u003e\u003e struct push_back_impl; template \u003ctypename List, typename NewElement\u003e struct push_back_impl\u003cList, NewElement, false\u003e { private: using head = front_t\u003cList\u003e; using tail = pop_front_t\u003cList\u003e; using new_tail = typename push_back_impl\u003ctail, NewElement\u003e::type; public: using type = push_front_t\u003cnew_tail, head\u003e; }; template \u003ctypename List, typename NewElement\u003e struct push_back_impl\u003cList, NewElement, true\u003e { using type = push_front_t\u003cList, NewElement\u003e; }; template \u003ctypename List, typename NewElement\u003e struct push_back : push_back_impl\u003cList, NewElement\u003e {}; /* * template \u003ctypename List, typename NewElement\u003e * struct push_back; * * template \u003ctypename... Elements, typename NewElement\u003e * struct push_back\u003ctypelist\u003cElements...\u003e, NewElement\u003e { * using type = typelist\u003cElements..., NewElement\u003e; * }; */ template \u003ctypename List, typename NewElement\u003e using push_back_t = typename push_back\u003cList, NewElement\u003e::type; // reverse_t template \u003ctypename List, bool Empty = is_empty_v\u003cList\u003e\u003e struct reverse; template \u003ctypename List\u003e using reverse_t = typename reverse\u003cList\u003e::type; template \u003ctypename List\u003e struct reverse\u003cList, false\u003e : push_back\u003creverse_t\u003cpop_front_t\u003cList\u003e\u003e, front_t\u003cList\u003e\u003e {}; template \u003ctypename List\u003e struct reverse\u003cList, true\u003e { using type = List; }; // pop_back_t template \u003ctypename List\u003e struct pop_back { using type = reverse_t\u003cpop_front_t\u003creverse_t\u003cList\u003e\u003e\u003e; }; template \u003ctypename List\u003e using pop_back_t = typename pop_back\u003cList\u003e::type; // largest_type_t template \u003ctypename List, bool = is_empty_v\u003cList\u003e\u003e struct largest_type; template \u003ctypename List\u003e struct largest_type\u003cList, false\u003e { private: using contender = front_t\u003cList\u003e; using best = typename largest_type\u003cpop_front_t\u003cList\u003e\u003e::type; public: using type = std::conditional_t\u003c(sizeof(contender) \u003e= sizeof(best)), contender, best\u003e; }; template \u003ctypename List\u003e struct largest_type\u003cList, true\u003e { using type = char; }; ","date":"2022-06-18","objectID":"/cxx_template/:56:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#typelist"},{"categories":["编程语言"],"content":" 57 std::tuple #include \u003ccassert\u003e #include \u003ccomplex\u003e #include \u003ccstring\u003e #include \u003cfunctional\u003e #include \u003costream\u003e #include \u003csstream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e #include \"typelist.hpp\" namespace jc { template \u003ctypename... Types\u003e class tuple; template \u003ctypename Head, typename... Tail\u003e class tuple\u003cHead, Tail...\u003e { public: tuple() = default; tuple(const Head\u0026 head, const tuple\u003cTail...\u003e\u0026 tail) : head_(head), tail_(tail) {} template \u003c typename VHead, typename... VTail, std::enable_if_t\u003csizeof...(VTail) == sizeof...(Tail), void*\u003e = nullptr\u003e tuple(VHead\u0026\u0026 head, VTail\u0026\u0026... tail) : head_(std::forward\u003cVHead\u003e(head)), tail_(std::forward\u003cVTail\u003e(tail)...) {} template \u003c typename VHead, typename... VTail, std::enable_if_t\u003csizeof...(VTail) == sizeof...(Tail), void*\u003e = nullptr\u003e tuple(const tuple\u003cVHead, VTail...\u003e\u0026 rhs) : head_(rhs.get_head()), tail_(rhs.get_tail()) {} // for push_back_tuple template \u003ctypename V, typename VHead, typename... VTail\u003e tuple(const V\u0026 v, const tuple\u003cVHead, VTail...\u003e\u0026 rhs) : head_(v), tail_(rhs) {} Head\u0026 get_head() { return head_; } const Head\u0026 get_head() const { return head_; } tuple\u003cTail...\u003e\u0026 get_tail() { return tail_; } const tuple\u003cTail...\u003e\u0026 get_tail() const { return tail_; } template \u003ctypename T, T Index\u003e auto\u0026 operator[](std::integral_constant\u003cT, Index\u003e); private: Head head_; tuple\u003cTail...\u003e tail_; }; template \u003c\u003e class tuple\u003c\u003e {}; template \u003cstd::size_t N\u003e struct tuple_get { template \u003ctypename Head, typename... Tail\u003e static auto\u0026 apply(const tuple\u003cHead, Tail...\u003e\u0026 t) { return tuple_get\u003cN - 1\u003e::apply(t.get_tail()); } }; template \u003c\u003e struct tuple_get\u003c0\u003e { template \u003ctypename Head, typename... Tail\u003e static const Head\u0026 apply(const tuple\u003cHead, Tail...\u003e\u0026 t) { return t.get_head(); } }; template \u003cstd::size_t N, typename... Types\u003e auto\u0026 get(const tuple\u003cTypes...\u003e\u0026 t) { return tuple_get\u003cN\u003e::apply(t); } template \u003ctypename Head, typename... Tail\u003e template \u003ctypename T, T Index\u003e inline auto\u0026 tuple\u003cHead, Tail...\u003e::operator[]( std::integral_constant\u003cT, Index\u003e) { return get\u003cIndex\u003e(*this); } template \u003ctypename... Types\u003e auto make_tuple(Types\u0026\u0026... args) { return tuple\u003cstd::decay_t\u003cTypes\u003e...\u003e(std::forward\u003cTypes\u003e(args)...); } bool operator==(const tuple\u003c\u003e\u0026, const tuple\u003c\u003e\u0026) { return true; } template \u003c typename Head1, typename... Tail1, typename Head2, typename... Tail2, std::enable_if_t\u003csizeof...(Tail1) == sizeof...(Tail2), void*\u003e = nullptr\u003e bool operator==(const tuple\u003cHead1, Tail1...\u003e\u0026 lhs, const tuple\u003cHead2, Tail2...\u003e\u0026 rhs) { return lhs.get_head() == rhs.get_head() \u0026\u0026 lhs.get_tail() == rhs.get_tail(); } void print_tuple(std::ostream\u0026 os, const tuple\u003c\u003e\u0026, bool is_first = true) { os \u003c\u003c (is_first ? '(' : ')'); } template \u003ctypename Head, typename... Tail\u003e void print_tuple(std::ostream\u0026 os, const tuple\u003cHead, Tail...\u003e\u0026 t, bool is_first = true) { os \u003c\u003c (is_first ? \"(\" : \", \") \u003c\u003c t.get_head(); print_tuple(os, t.get_tail(), false); } template \u003ctypename... Types\u003e std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 os, const tuple\u003cTypes...\u003e\u0026 t) { print_tuple(os, t); return os; } } // namespace jc namespace jc { // typelist template \u003c\u003e struct is_empty\u003ctuple\u003c\u003e\u003e { static constexpr bool value = true; }; template \u003ctypename Head, typename... Tail\u003e class front\u003ctuple\u003cHead, Tail...\u003e\u003e { public: using type = Head; }; template \u003ctypename Head, typename... Tail\u003e class pop_front\u003ctuple\u003cHead, Tail...\u003e\u003e { public: using type = tuple\u003cTail...\u003e; }; template \u003ctypename... Types, typename Element\u003e class push_front\u003ctuple\u003cTypes...\u003e, Element\u003e { public: using type = tuple\u003cElement, Types...\u003e; }; template \u003ctypename... Types, typename Element\u003e class push_back\u003ctuple\u003cTypes...\u003e, Element\u003e { public: using type = tuple\u003cTypes..., Element\u003e; }; template \u003ctypename... Types\u003e pop_front_t\u003ctuple\u003cTypes...\u003e\u003e pop_front_tuple(const tuple\u003cTypes...\u003e\u0026 t) { return t.get_tail(); } template \u003ctypename... Types, typename V\u003e push_front_t\u003ctuple\u003cTypes...\u003e, V\u003e push_front_tuple(const tuple\u003cTypes...\u003e\u0026 t, const V\u0026 v) { return push_front_t\u003ctuple\u003cTypes...\u003e, V\u003e{v, t}; } template \u003ctypename V\u003e tuple\u003cV\u003e ","date":"2022-06-18","objectID":"/cxx_template/:57:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#stdtuplehttpsencppreferencecomwcpputilitytuple"},{"categories":["编程语言"],"content":" 58 std::variant #include \u003ccassert\u003e #include \u003cexception\u003e #include \u003cnew\u003e // for std::launder() #include \u003csstream\u003e #include \u003cstring\u003e #include \u003ctype_traits\u003e #include \u003cutility\u003e #include \"typelist.hpp\" namespace jc { class computed_result_type; template \u003ctypename Visitor, typename T\u003e using visit_element_result = decltype(std::declval\u003cVisitor\u003e()(std::declval\u003cT\u003e())); template \u003ctypename R, typename Visitor, typename... Types\u003e struct visit_result { using type = R; }; template \u003ctypename Visitor, typename... Types\u003e struct visit_result\u003ccomputed_result_type, Visitor, Types...\u003e { using type = std::common_type_t\u003cvisit_element_result\u003cVisitor, Types\u003e...\u003e; }; template \u003ctypename R, typename Visitor, typename... Types\u003e using visit_result_t = typename visit_result\u003cR, Visitor, Types...\u003e::type; struct empty_variant : std::exception {}; template \u003ctypename R, typename V, typename Visitor, typename Head, typename... Tail\u003e R variant_visit_impl(V\u0026\u0026 variant, Visitor\u0026\u0026 vis, typelist\u003cHead, Tail...\u003e) { if (variant.template is\u003cHead\u003e()) { return static_cast\u003cR\u003e(std::forward\u003cVisitor\u003e(vis)( std::forward\u003cV\u003e(variant).template get\u003cHead\u003e())); } else if constexpr (sizeof...(Tail) \u003e 0) { return variant_visit_impl\u003cR\u003e(std::forward\u003cV\u003e(variant), std::forward\u003cVisitor\u003e(vis), typelist\u003cTail...\u003e{}); } else { throw empty_variant(); } } template \u003ctypename... Types\u003e class variant_storage { public: unsigned char get_discriminator() const { return discriminator_; } void set_discriminator(unsigned char d) { discriminator_ = d; } void* get_raw_buffer() { return buffer_; } const void* get_raw_buffer() const { return buffer_; } template \u003ctypename T\u003e T* get_buffer_as() { return std::launder(reinterpret_cast\u003cT*\u003e(buffer_)); } template \u003ctypename T\u003e const T* get_buffer_as() const { return std::launder(reinterpret_cast\u003cconst T*\u003e(buffer_)); } private: using largest_t = largest_type_t\u003ctypelist\u003cTypes...\u003e\u003e; alignas(Types...) unsigned char buffer_[sizeof(largest_t)]; unsigned char discriminator_ = 0; }; template \u003ctypename... Types\u003e class variant; template \u003ctypename T, typename... Types\u003e class variant_choice { using Derived = variant\u003cTypes...\u003e; Derived\u0026 get_derived() { return *static_cast\u003cDerived*\u003e(this); } const Derived\u0026 get_derived() const { return *static_cast\u003cconst Derived*\u003e(this); } protected: static constexpr unsigned Discriminator = find_index_of_t\u003ctypelist\u003cTypes...\u003e, T\u003e::value + 1; public: variant_choice() = default; variant_choice(const T\u0026 value) { new (get_derived().get_raw_buffer()) T(value); // CRTP get_derived().set_discriminator(Discriminator); } variant_choice(T\u0026\u0026 value) { new (get_derived().get_raw_buffer()) T(std::move(value)); get_derived().set_discriminator(Discriminator); } bool destroy() { if (get_derived().get_discriminator() == Discriminator) { get_derived().template get_buffer_as\u003cT\u003e()-\u003e~T(); return true; } return false; } Derived\u0026 operator=(const T\u0026 value) { if (get_derived().get_discriminator() == Discriminator) { *get_derived().template get_buffer_as\u003cT\u003e() = value; } else { get_derived().destroy(); new (get_derived().get_raw_buffer()) T(value); get_derived().set_discriminator(Discriminator); } return get_derived(); } Derived\u0026 operator=(T\u0026\u0026 value) { if (get_derived().get_discriminator() == Discriminator) { *get_derived().template get_buffer_as\u003cT\u003e() = std::move(value); } else { get_derived().destroy(); new (get_derived().get_raw_buffer()) T(std::move(value)); get_derived().set_discriminator(Discriminator); } return get_derived(); } }; /* * class variant\u003cint, double, std::string\u003e * : private variant_storage\u003cint, double, std::string\u003e, * private variant_choice\u003cint, int, double, std::string\u003e, * private variant_choice\u003cdouble, int, double, std::string\u003e, * private variant_choice\u003cstd::string, int, double, std::string\u003e {}; * * variant_choice\u003cint, int, double, std::string\u003e::discriminator_ == 1; * variant_choice\u003cdouble, int, double, std::string\u003e::discriminator_ == 2; * variant_choice\u003cstd::string, int, double, std::string\u003e::discriminator_ == 3; */ template \u003ctypename... Types\u003e class varia","date":"2022-06-18","objectID":"/cxx_template/:58:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#stdvarianthttpsencppreferencecomwcpputilityvariant"},{"categories":["编程语言"],"content":" 59 表达式模板（Expression Template） 表达式模板支持对数组像内置类型一样进行数值运算，并且不会产生临时对象 #include \u003ccassert\u003e #include \u003ccstddef\u003e #include \u003ctype_traits\u003e namespace jc { template \u003ctypename T\u003e class SArray { public: explicit SArray(std::size_t sz) : data_(new T[sz]), sz_(sz) { init(); } SArray(const SArray\u003cT\u003e\u0026 rhs) : data_(new T[rhs.sz_]), sz_(rhs.sz_) { copy(rhs); } SArray\u003cT\u003e\u0026 operator=(const SArray\u003cT\u003e\u0026 rhs) { if (\u0026rhs != this) { copy(rhs); } return *this; } ~SArray() { delete[] data_; } std::size_t size() const { return sz_; } T\u0026 operator[](std::size_t i) { return data_[i]; } const T\u0026 operator[](std::size_t i) const { return data_[i]; } SArray\u003cT\u003e\u0026 operator+=(const SArray\u003cT\u003e\u0026 rhs) { assert(sz_ == rhs.sz_); for (std::size_t i = 0; i \u003c sz_; ++i) { (*this)[i] += rhs[i]; } return *this; } SArray\u003cT\u003e\u0026 operator*=(const SArray\u003cT\u003e\u0026 rhs) { assert(sz_ == rhs.sz_); for (std::size_t i = 0; i \u003c sz_; ++i) { (*this)[i] *= rhs[i]; } return *this; } SArray\u003cT\u003e\u0026 operator*=(const T\u0026 rhs) { for (std::size_t i = 0; i \u003c sz_; ++i) { (*this)[i] *= rhs; } return *this; } protected: void init() { for (std::size_t i = 0; i \u003c sz_; ++i) { data_[i] = T{}; } } void copy(const SArray\u003cT\u003e\u0026 rhs) { assert(sz_ == rhs.sz_); for (std::size_t i = 0; i \u003c sz_; ++i) { data_[i] = rhs.data_[i]; } } private: T* data_; std::size_t sz_; }; template \u003ctypename T\u003e SArray\u003cT\u003e operator+(const SArray\u003cT\u003e\u0026 lhs, const SArray\u003cT\u003e\u0026 rhs) { assert(lhs.size() == rhs.size()); SArray\u003cT\u003e res{lhs.size()}; for (std::size_t i = 0; i \u003c lhs.size(); ++i) { res[i] = lhs[i] + rhs[i]; } return res; } template \u003ctypename T\u003e SArray\u003cT\u003e operator*(const SArray\u003cT\u003e\u0026 lhs, const SArray\u003cT\u003e\u0026 rhs) { assert(lhs.size() == rhs.size()); SArray\u003cT\u003e res{lhs.size()}; for (std::size_t i = 0; i \u003c lhs.size(); ++i) { res[i] = lhs[i] * rhs[i]; } return res; } template \u003ctypename T\u003e SArray\u003cT\u003e operator*(const T\u0026 lhs, const SArray\u003cT\u003e\u0026 rhs) { SArray\u003cT\u003e res{rhs.size()}; for (std::size_t i = 0; i \u003c rhs.size(); ++i) { res[i] = lhs * rhs[i]; } return res; } template \u003ctypename T\u003e class A_Scalar { public: constexpr A_Scalar(const T\u0026 v) : value_(v) {} constexpr const T\u0026 operator[](std::size_t) const { return value_; } constexpr std::size_t size() const { return 0; }; private: const T\u0026 value_; }; template \u003ctypename T\u003e struct A_Traits { using type = const T\u0026; }; template \u003ctypename T\u003e struct A_Traits\u003cA_Scalar\u003cT\u003e\u003e { using type = A_Scalar\u003cT\u003e; }; template \u003ctypename T, typename OP1, typename OP2\u003e class A_Add { public: A_Add(const OP1\u0026 op1, const OP2\u0026 op2) : op1_(op1), op2_(op2) {} T operator[](std::size_t i) const { return op1_[i] + op2_[i]; } std::size_t size() const { assert(op1_.size() == 0 || op2_.size() == 0 || op1_.size() == op2_.size()); return op1_.size() != 0 ? op1_.size() : op2_.size(); } private: typename A_Traits\u003cOP1\u003e::type op1_; typename A_Traits\u003cOP2\u003e::type op2_; }; template \u003ctypename T, typename OP1, typename OP2\u003e class A_Mult { public: A_Mult(const OP1\u0026 op1, const OP2\u0026 op2) : op1_(op1), op2_(op2) {} T operator[](std::size_t i) const { return op1_[i] * op2_[i]; } std::size_t size() const { assert(op1_.size() == 0 || op2_.size() == 0 || op1_.size() == op2_.size()); return op1_.size() != 0 ? op1_.size() : op2_.size(); } private: typename A_Traits\u003cOP1\u003e::type op1_; typename A_Traits\u003cOP2\u003e::type op2_; }; template \u003ctypename T, typename A1, typename A2\u003e class A_Subscript { public: A_Subscript(const A1\u0026 a1, const A2\u0026 a2) : a1_(a1), a2_(a2) {} T\u0026 operator[](std::size_t i) { return const_cast\u003cT\u0026\u003e(a1_[static_cast\u003cstd::size_t\u003e(a2_[i])]); } decltype(auto) operator[](std::size_t i) const { return a1_[static_cast\u003cstd::size_t\u003e(a2_[i])]; } std::size_t size() const { return a2_.size(); } private: const A1\u0026 a1_; const A2\u0026 a2_; }; } // namespace jc namespace jc::test { template \u003ctypename T, typename Rep = SArray\u003cT\u003e\u003e class Array { public: explicit Array(std::size_t i) : r_(i) {} Array(const Rep\u0026 rhs) : r_(rhs) {} Array\u0026 operator=(const Array\u0026 rhs) { assert(size() == rhs.size()); for (std::size_t i = 0; i \u003c rhs.size(); ++i) { r_[i] = rhs[i]; } return *this; } template \u003ctypename T2, t","date":"2022-06-18","objectID":"/cxx_template/:59:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#表达式模板expression-template"},{"categories":["编程语言"],"content":" 60 性能与约束 表达式模板可以提高数组操作性能，跟踪其行为可以发现很多小的内联函数互相调用，调用堆栈分配了很多小的表达式模板对象，因此编译器必须执行完整的内联和去除小对象操作，以产生性能上和手写循环媲美的代码 表达式模板没有解决所有数组数值运算的问题，如对 x = A * x 的运算，A 是 n * n 矩阵，x 是 n 个元素的 vector，临时变量的使用不可避免，因为最终结果的每个元素都依赖于 x 每个元素的初始值，而表达式模板会在一次计算后更新 x 的元素，计算下一个元素时用到已更新的元素就改变了原数组，但针对 x = A * y，如果 x 和 y 不互为别名，就不需要临时对象，因此必须在运行期知道操作数是否为别名关系，即必须生成运行期结构来表示表达式树，而不是在表达式模板的类型中编码这棵树 ","date":"2022-06-18","objectID":"/cxx_template/:60:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#性能与约束"},{"categories":["编程语言"],"content":" 61 浅实例化（Shallow Instantiation） 模板的报错会跟踪导致问题的所有层次，冗长的报错信息使调试变得更为繁琐，真正的问题一般出现在一长串实例化之后 template \u003ctypename T\u003e void f1(T\u0026 i) { *i = 0; // 假设 T 为指针类型 } template \u003ctypename T\u003e void f2(T\u0026 i) { f1(i); } template \u003ctypename T\u003e void f3(typename T::Type i) { f2(i); } template \u003ctypename T\u003e void f4(const T\u0026) { typename T::Type i = 42; f3\u003cT\u003e(i); } struct A { using Type = int; }; int main() { f4(A{}); // 错误，只能在实例化时被检测到 // 实例化 f4\u003cA\u003e(const A\u0026) // 实例化 f3\u003cA\u003e(int) // 实例化 f2\u003cint\u003e(int\u0026) // 实例化 f1\u003cint\u003e(int\u0026)，解引用 int 出错 } /* * error C2100: 非法的间接寻址 * message : 查看对正在编译的函数 模板 实例化“void f1\u003cT\u003e(T \u0026)”的引用 * with * [ * T=A::Type * ] * message : 查看对正在编译的函数 模板 实例化“void f2\u003cA::Type\u003e(T \u0026)”的引用 * with * [ * T=A::Type * ] * message : 查看对正在编译的函数 模板 实例化“void f3\u003cT\u003e(A::Type)”的引用 * with * [ * T=A * ] * message : 查看对正在编译的函数 模板 实例化“void f4\u003cA\u003e(const T \u0026)”的引用 * with * [ * T=A * ] */ 一种简单的减少报错信息长度的方式是提前使用参数 template \u003ctypename T\u003e void f1(T\u0026 i) { *i = 0; // 假设 T 为指针类型 } template \u003ctypename T\u003e void f2(T\u0026 i) { f1(i); } template \u003ctypename T\u003e void f3(typename T::Type i) { f2(i); } template \u003ctypename T\u003e void f4(const T\u0026) { class ShallowChecks { // 未调用，不影响运行期 static void deref(typename T::Type p) { *p; } }; typename T::Type i = 42; f3\u003cT\u003e(i); } struct A { using Type = int; }; int main() { f4(A{}); // 实例化 f4\u003cA\u003e(const A\u0026) 时检测到错误 } /* * error C2100: 非法的间接寻址 * message : 查看对正在编译的函数 模板 实例化“void f4\u003cA\u003e(const T \u0026)”的引用 * with * [ * T=A * ] */ ","date":"2022-06-18","objectID":"/cxx_template/:61:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#浅实例化shallow-instantiation"},{"categories":["编程语言"],"content":" 62 静态断言（Static Assertion） C++11 引入了static_assert，在编译期进行断言，比如下列静态断言确保编译平台带 64 位指针 static_assert(sizeof(void*) * CHAR_BIT == 64, \"Not a 64-bit platform\"); 创建一个检查解引用的 traits，用 static_assert 提供更明确的诊断信息 #include \u003ctype_traits\u003e template \u003ctypename T\u003e class has_dereference { private: template \u003ctypename U\u003e struct Identity; template \u003ctypename U\u003e static std::true_type test(Identity\u003cdecltype(*std::declval\u003cU\u003e())\u003e*); template \u003ctypename U\u003e static std::false_type test(...); public: static constexpr bool value = decltype(test\u003cT\u003e(nullptr))::value; }; template \u003ctypename T\u003e inline constexpr bool has_dereference_v = has_dereference\u003cT\u003e::value; template \u003ctypename T\u003e void f(T\u0026 i) { static_assert(has_dereference_v\u003cT\u003e, \"T is not dereferenceable\"); *i = 0; } int main() { int i = 42; f(i); // static_assert 报错：T is not dereferenceable } C++17 可以用 std::void_t 简化 traits 的实现 #include \u003ctype_traits\u003e template \u003ctypename, typename = std::void_t\u003c\u003e\u003e struct has_dereference : std::false_type {}; template \u003ctypename T\u003e struct has_dereference\u003cT, std::void_t\u003cdecltype(*std::declval\u003cT\u003e())\u003e\u003e : std::true_type {}; template \u003ctypename T\u003e inline constexpr bool has_dereference_v = has_dereference\u003cT\u003e::value; ","date":"2022-06-18","objectID":"/cxx_template/:62:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#静态断言static-assertion"},{"categories":["编程语言"],"content":" 63 Concepts C++20 可以用 concepts 约束类型，代码更简洁 template \u003ctypename T\u003e concept Dereferenceable = requires(T x) { *x; }; template \u003ctypename T\u003e requires Dereferenceable\u003cT\u003e void f(T\u0026 i) { *i = 0; } /* 等价写法 * template \u003ctypename T\u003e * requires requires(T x) { *x; } * void f(T\u0026 i) { * *i = 0; * } */ int main() { int i = 42; f(i); // 未满足关联约束 } ","date":"2022-06-18","objectID":"/cxx_template/:63:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#conceptshttpsencppreferencecomwcppconcepts"},{"categories":["编程语言"],"content":" 64 原型（Archetype） 模板的一个挑战是确保满足特定约束的实参都能通过编译，为了测试满足要求的模板参数，引入原型的概念。原型是用户定义的类，以尽可能小的方式来满足模板大多数要求，而不提供任何外来的操作 // 要求 T 是可比较类型 template \u003ctypename T\u003e int find(const T* a, int n, const T\u0026 v) { int i = 0; while (i != n \u0026\u0026 a[i] != v) { ++i; } return i; } struct EqualityComparable {}; struct ConvertibleToBool { operator bool() const { return true; } // 提供本类型到 bool 的隐式转换 }; ConvertibleToBool // 返回类型要求能转换为 bool operator==(const EqualityComparable\u0026, const EqualityComparable\u0026) { return ConvertibleToBool{}; } // 实例化 find\u003cEqualityComparable\u003e template int find(const EqualityComparable*, int, const EqualityComparable\u0026); int main() {} 实例化将失败，改用 operator== 比较即可解决此问题 template \u003ctypename T\u003e int find(const T* a, int n, const T\u0026 v) { int i = 0; while (i != n \u0026\u0026 !(a[i] == v)) { ++i; } return i; } 但这又在无意中对结果使用了 operator!，如果要发现这点，在 ConvertibleToBool 中禁用 operator! 即可，当其被使用时将报错 struct ConvertibleToBool { operator bool() const { return true; } bool operator!() = delete; }; 可以再对原型做其他扩展，比如禁用 operator\u0026\u0026 和 operator|| 来找出其他的一些模板定义中的问题 ","date":"2022-06-18","objectID":"/cxx_template/:64:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#原型archetype"},{"categories":["编程语言"],"content":" 65 跟踪程序（Tracer） 以上都是编译或链接时的 bug，更大的挑战是确保程序在运行期表现正确 Tracer 是一个用户定义的类，它能用作要测试的模板的实参。通常 tracer 也是一个原型，但包含一些额外的信息。下面是一个用于测试 std::sort 的 tracer，它提供 std::sort 需要的功能（比如 operator== 和 operator\u003e），并给出算法开销的直观结果，但不揭示排序模板的正确性 #include \u003calgorithm\u003e #include \u003ciostream\u003e class SortTracer { public: static long creations() { return n_created; } static long destructions() { return n_destroyed; } static long assignments() { return n_assigned; } static long comparisons() { return n_compared; } static long max_live() { return n_max_live; } public: SortTracer(int v = 0) : value(v), generation(1) { ++n_created; update_max_live(); std::cerr \u003c\u003c \"SortTracer #\" \u003c\u003c n_created \u003c\u003c \", created generation \" \u003c\u003c generation \u003c\u003c \" (total: \" \u003c\u003c n_created - n_destroyed \u003c\u003c \")\\n\"; } SortTracer(const SortTracer\u0026 rhs) : value(rhs.value), generation(rhs.generation + 1) { ++n_created; update_max_live(); std::cerr \u003c\u003c \"SortTracer #\" \u003c\u003c n_created \u003c\u003c \", copied as generation \" \u003c\u003c generation \u003c\u003c \" (total: \" \u003c\u003c n_created - n_destroyed \u003c\u003c \")\\n\"; } ~SortTracer() { ++n_destroyed; update_max_live(); std::cerr \u003c\u003c \"SortTracer generation \" \u003c\u003c generation \u003c\u003c \" destroyed (total: \" \u003c\u003c n_created - n_destroyed \u003c\u003c \")\\n\"; } SortTracer\u0026 operator=(const SortTracer\u0026 rhs) { ++n_assigned; std::cerr \u003c\u003c \"SortTracer assignment #\" \u003c\u003c n_assigned \u003c\u003c \" (generation \" \u003c\u003c generation \u003c\u003c \" = \" \u003c\u003c rhs.generation \u003c\u003c \")\\n\"; value = rhs.value; return *this; } friend bool operator\u003c(const SortTracer\u0026 lhs, const SortTracer\u0026 rhs) { ++n_compared; std::cerr \u003c\u003c \"SortTracer comparison #\" \u003c\u003c n_compared \u003c\u003c \" (generation \" \u003c\u003c lhs.generation \u003c\u003c \" \u003c \" \u003c\u003c rhs.generation \u003c\u003c \")\\n\"; return lhs.value \u003c rhs.value; } int val() const { return value; } private: int value; // integer value to be sorted int generation; // generation of this tracer inline static long n_created = 0; // number of constructor calls inline static long n_destroyed = 0; // number of destructor calls inline static long n_assigned = 0; // number of assignments inline static long n_compared = 0; // number of comparisons inline static long n_max_live = 0; // maximum of existing objects // recompute maximum of existing objects static void update_max_live() { if (n_created - n_destroyed \u003e n_max_live) { n_max_live = n_created - n_destroyed; } } }; int main() { SortTracer input[] = {7, 3, 5, 6, 4, 2, 0, 1, 9, 8}; // 打印初始值 for (int i = 0; i \u003c 10; ++i) { std::cerr \u003c\u003c input[i].val() \u003c\u003c ' '; } std::cerr \u003c\u003c '\\n'; // 记录初始条件 long created_at_start = SortTracer::creations(); long max_live_at_start = SortTracer::max_live(); long assigned_at_start = SortTracer::assignments(); long compared_at_start = SortTracer::comparisons(); // 执行 std::cerr \u003c\u003c \"---[ Start std::sort() ]--------------------\\n\"; std::sort\u003c\u003e(\u0026input[0], \u0026input[9] + 1); std::cerr \u003c\u003c \"---[ End std::sort() ]----------------------\\n\"; // 检查结果 for (int i = 0; i \u003c 10; ++i) { std::cerr \u003c\u003c input[i].val() \u003c\u003c ' '; } std::cerr \u003c\u003c \"\\n\\n\"; // final report std::cerr \u003c\u003c \"std::sort() of 10 SortTracer's was performed by:\\n\" \u003c\u003c SortTracer::creations() - created_at_start \u003c\u003c \" temporary tracers\\n\" \u003c\u003c \"up to \" \u003c\u003c SortTracer::max_live() \u003c\u003c \" tracers at the same time (\" \u003c\u003c max_live_at_start \u003c\u003c \" before)\\n\" \u003c\u003c SortTracer::assignments() - assigned_at_start \u003c\u003c \" assignments\\n\" \u003c\u003c SortTracer::comparisons() - compared_at_start \u003c\u003c \" comparisons\\n\\n\"; } /* * SortTracer #1, created generation 1 (total: 1) * SortTracer #2, created generation 1 (total: 2) * SortTracer #3, created generation 1 (total: 3) * SortTracer #4, created generation 1 (total: 4) * SortTracer #5, created generation 1 (total: 5) * SortTracer #6, created generation 1 (total: 6) * SortTracer #7, created generation 1 (total: 7) * SortTracer #8, created generation 1 (total: 8) * SortTracer #9, created generation 1 (total: 9) * SortTracer #10, created generation 1 (total: 10) * 7 3 5 6 4 2 0 1 9 8 * ---[ Start std::sort() ]-------------------- * SortTracer #11, copied as generation 2 (total: 11) * SortTracer comparison #1 (generation 2 \u003c 1) * SortTracer comparison #2 (generation 1 \u003c 2) *","date":"2022-06-18","objectID":"/cxx_template/:65:0","series":["CXX"],"tags":["C++"],"title":"C++模板","uri":"/cxx_template/#跟踪程序tracer"},{"categories":["rootfs"],"content":"Buildroot构建文件系统 ","date":"2022-03-13","objectID":"/buildroot/:0:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#"},{"categories":["rootfs"],"content":" 1 下载buildroot git clone --depth=1 https://git.busybox.net/buildroot git branch -a [new branch] git checkout [new branch] ","date":"2022-03-13","objectID":"/buildroot/:1:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#下载buildroot"},{"categories":["rootfs"],"content":" 2 快速开始 可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026\u0026 make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh ","date":"2022-03-13","objectID":"/buildroot/:2:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#快速开始"},{"categories":["rootfs"],"content":" 3 基础配置","date":"2022-03-13","objectID":"/buildroot/:3:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#基础配置"},{"categories":["rootfs"],"content":" 3.1 使用自定义的内核在defconfig文件中添加下面的配置 BR2_LINUX_KERNEL=y # 是否编译内核 BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"git@github.com:mengdemao/kernel.git\" # kernel的地址 BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"master\" # 版本 BR2_LINUX_KERNEL_VERSION=\"master\" BR2_LINUX_KERNEL_USE_DEFCONFIG=y BR2_LINUX_KERNEL_DEFCONFIG=\"debian\" BR2_LINUX_KERNEL_ZIMAGE=y BR2_LINUX_KERNEL_GZIP=y ","date":"2022-03-13","objectID":"/buildroot/:3:1","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#使用自定义的内核"},{"categories":["环境搭建"],"content":" 1 nfs","date":"2022-01-28","objectID":"/linux_developer_server/:1:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#nfs"},{"categories":["环境搭建"],"content":" 1.1 安装 sudo apt-get install nfs-kernel-server ","date":"2022-01-28","objectID":"/linux_developer_server/:1:1","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#安装"},{"categories":["环境搭建"],"content":" 1.2 设置导出 /home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) ","date":"2022-01-28","objectID":"/linux_developer_server/:1:2","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#设置导出"},{"categories":["环境搭建"],"content":" 1.3 开启服务 sudo /etc/init.d/nfs-kernel-server restart ","date":"2022-01-28","objectID":"/linux_developer_server/:1:3","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#开启服务"},{"categories":["环境搭建"],"content":" 1.4 测试 sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt ls /mnt ","date":"2022-01-28","objectID":"/linux_developer_server/:1:4","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#测试"},{"categories":["环境搭建"],"content":" 2 samba","date":"2022-01-28","objectID":"/linux_developer_server/:2:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#samba"},{"categories":["环境搭建"],"content":" 3 tftp","date":"2022-01-28","objectID":"/linux_developer_server/:3:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#tftp"},{"categories":["环境搭建"],"content":" 4 ftp","date":"2022-01-28","objectID":"/linux_developer_server/:4:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#ftp"},{"categories":["环境搭建"],"content":" 5 apache","date":"2022-01-28","objectID":"/linux_developer_server/:5:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#apache"},{"categories":["linux"],"content":" 需要处理的问题? 如何确定哪个进程可以运行 进程切换发生后,老的进程去了哪里,新的进程如何变化 PLET实现中,谁负责移动调度实体 ","date":"2021-10-28","objectID":"/cfs/:0:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#"},{"categories":["linux"],"content":" 1 虚拟时间(vruntime) static u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw) { u64 fact = scale_load_down(weight); int shift = WMULT_SHIFT; __update_inv_weight(lw); if (unlikely(fact \u003e\u003e 32)) { while (fact \u003e\u003e 32) { fact \u003e\u003e= 1; shift--; } } /* hint to use a 32x32-\u003e64 mul */ fact = (u64)(u32)fact * lw-\u003einv_weight; while (fact \u003e\u003e 32) { fact \u003e\u003e= 1; shift--; } return mul_u64_u32_shr(delta_exec, fact, shift); } static inline u64 calc_delta_fair(u64 delta, struct sched_entity *se) { if (unlikely(se-\u003eload.weight != NICE_0_LOAD)) delta = __calc_delta(delta, NICE_0_LOAD, \u0026se-\u003eload); return delta; } 最后得到公式 $$ vruntime = \\frac{{delta\\_exec} \\times {nice\\_0\\_weight} \\times {2 ^ {32}}}{weight} $$ ","date":"2021-10-28","objectID":"/cfs/:1:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#虚拟时间vruntime"},{"categories":["linux"],"content":" 2 负载追踪(PLET) struct sched_avg { /* * These sums represent an infinite geometric series and so are bound * above by 1024/(1-y). Thus we only need a u32 to store them for all * choices of y \u003c 1-2^(-32)*1024. */ u32 runnable_avg_sum; // 调度实体在就绪队列 u32 runnable_avg_period; // 调度实体在系统中 u64 last_runnable_update; // 上次更新时间 s64 decay_count; // 衰变计数 unsigned long load_avg_contrib; // 进程平均负载贡献度 }; static __always_inline u64 decay_load(u64 val, u64 n) { unsigned int local_n; if (!n) return val; else if (unlikely(n \u003e LOAD_AVG_PERIOD * 63)) return 0; /* after bounds checking we can collapse to 32-bit */ local_n = n; /* * As y^PERIOD = 1/2, we can combine * y^n = 1/2^(n/PERIOD) * y^(n%PERIOD) * With a look-up table which covers y^n (n\u003cPERIOD) * * To achieve constant time decay_load. */ if (unlikely(local_n \u003e= LOAD_AVG_PERIOD)) { val \u003e\u003e= local_n / LOAD_AVG_PERIOD; local_n %= LOAD_AVG_PERIOD; } val *= runnable_avg_yN_inv[local_n]; /* We don't use SRR here since we always want to round down. */ return val \u003e\u003e 32; } static u32 __compute_runnable_contrib(u64 n) { u32 contrib = 0; if (likely(n \u003c= LOAD_AVG_PERIOD)) return runnable_avg_yN_sum[n]; else if (unlikely(n \u003e= LOAD_AVG_MAX_N)) return LOAD_AVG_MAX; /* Compute \\Sum k^n combining precomputed values for k^i, \\Sum k^j */ do { contrib /= 2; /* y^LOAD_AVG_PERIOD = 1/2 */ contrib += runnable_avg_yN_sum[LOAD_AVG_PERIOD]; n -= LOAD_AVG_PERIOD; } while (n \u003e LOAD_AVG_PERIOD); contrib = decay_load(contrib, n); return contrib + runnable_avg_yN_sum[n]; } static __always_inline int __update_entity_runnable_avg(u64 now, struct sched_avg *sa, int runnable) { u64 delta, periods; u32 runnable_contrib; int delta_w, decayed = 0; delta = now - sa-\u003elast_runnable_update; /* * This should only happen when time goes backwards, which it * unfortunately does during sched clock init when we swap over to TSC. */ if ((s64)delta \u003c 0) { sa-\u003elast_runnable_update = now; return 0; } /* * Use 1024ns as the unit of measurement since it's a reasonable * approximation of 1us and fast to compute. */ delta \u003e\u003e= 10; if (!delta) return 0; sa-\u003elast_runnable_update = now; /* delta_w is the amount already accumulated against our next period */ delta_w = sa-\u003erunnable_avg_period % 1024; if (delta + delta_w \u003e= 1024) { /* period roll-over */ decayed = 1; /* * Now that we know we're crossing a period boundary, figure * out how much from delta we need to complete the current * period and accrue it. */ delta_w = 1024 - delta_w; if (runnable) sa-\u003erunnable_avg_sum += delta_w; sa-\u003erunnable_avg_period += delta_w; delta -= delta_w; /* Figure out how many additional periods this update spans */ periods = delta / 1024; delta %= 1024; sa-\u003erunnable_avg_sum = decay_load(sa-\u003erunnable_avg_sum, periods + 1); sa-\u003erunnable_avg_period = decay_load(sa-\u003erunnable_avg_period, periods + 1); /* Efficiently calculate \\sum (1..n_period) 1024*y^i */ runnable_contrib = __compute_runnable_contrib(periods); if (runnable) sa-\u003erunnable_avg_sum += runnable_contrib; sa-\u003erunnable_avg_period += runnable_contrib; } /* Remainder of delta accrued against u_0` */ if (runnable) sa-\u003erunnable_avg_sum += delta; sa-\u003erunnable_avg_period += delta; return decayed; } static inline void update_entity_load_avg(struct sched_entity *se, int update_cfs_rq) { struct cfs_rq *cfs_rq = cfs_rq_of(se); long contrib_delta; u64 now; /* * For a group entity we need to use their owned cfs_rq_clock_task() in * case they are the parent of a throttled hierarchy. */ if (entity_is_task(se)) now = cfs_rq_clock_task(cfs_rq); else now = cfs_rq_clock_task(group_cfs_rq(se)); if (!__update_entity_runnable_avg(now, \u0026se-\u003eavg, se-\u003eon_rq)) return; contrib_delta = __update_entity_load_avg_contrib(se); if (!update_cfs_rq) return; if (se-\u003eon_rq) cfs_rq-\u003erunnable_load_avg += contrib_delta; else subtract_blocked_load_contrib(cfs_rq, -contrib_delta); } static inline void __update_task_entity_contrib(struct sched_entity *se) { u32 contrib; /* avoid overflowing a 32-bit type w/ SCHED_LOAD_SCALE */ contrib = se-\u003eavg.runnable_avg_","date":"2021-10-28","objectID":"/cfs/:2:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#负载追踪plet"},{"categories":["linux"],"content":" 3 调度器类 const struct sched_class fair_sched_class = { .next = \u0026idle_sched_class, .enqueue_task = enqueue_task_fair, .dequeue_task = dequeue_task_fair, .yield_task = yield_task_fair, .yield_to_task = yield_to_task_fair, .check_preempt_curr = check_preempt_wakeup, .pick_next_task = pick_next_task_fair, .put_prev_task = put_prev_task_fair, #ifdef CONFIG_SMP .select_task_rq = select_task_rq_fair, .migrate_task_rq = migrate_task_rq_fair, .rq_online = rq_online_fair, .rq_offline = rq_offline_fair, .task_dead = task_dead_fair, .set_cpus_allowed = set_cpus_allowed_common, #endif .set_curr_task = set_curr_task_fair, .task_tick = task_tick_fair, .task_fork = task_fork_fair, .prio_changed = prio_changed_fair, .switched_from = switched_from_fair, .switched_to = switched_to_fair, .get_rr_interval = get_rr_interval_fair, .update_curr = update_curr_fair, #ifdef CONFIG_FAIR_GROUP_SCHED .task_change_group = task_change_group_fair, #endif }; 调度器类分析 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf); void (*put_prev_task)(struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int new_cpu); void (*task_woken)(struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task)(struct rq *rq); void (*task_tick)(struct rq *rq, struct task_struct *p, int queued); void (*task_fork)(struct task_struct *p); void (*task_dead)(struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from)(struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval)(struct rq *rq, struct task_struct *task); void (*update_curr)(struct rq *rq); #define TASK_SET_GROUP 0 #define TASK_MOVE_GROUP 1 #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_change_group)(struct task_struct *p, int type); #endif }; ","date":"2021-10-28","objectID":"/cfs/:3:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#调度器类"},{"categories":["linux"],"content":" 4 enqueue_task_fair static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; /* * The code below (indirectly) updates schedutil which looks at * the cfs_rq utilization to select a frequency. * Let's add the task's estimated utilization to the cfs_rq's * estimated utilization, before we update schedutil. */ util_est_enqueue(\u0026rq-\u003ecfs, p); /* * If in_iowait is set, the code below may not trigger any cpufreq * utilization updates, so do it here explicitly with the IOWAIT flag * passed. */ if (p-\u003ein_iowait) cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); for_each_sched_entity(se) { if (se-\u003eon_rq) break; cfs_rq = cfs_rq_of(se); enqueue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running increment below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running++; flags = ENQUEUE_WAKEUP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running++; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) add_nr_running(rq, 1); if (cfs_bandwidth_used()) { /* * When bandwidth control is enabled; the cfs_rq_throttled() * breaks in the above iteration can result in incomplete * leaf list maintenance, resulting in triggering the assertion * below. */ for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); if (list_add_leaf_cfs_rq(cfs_rq)) break; } } assert_list_leaf_cfs_rq(rq); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/cfs/:4:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#enqueue_task_fair"},{"categories":["linux"],"content":" 5 dequeue_task_fair 将任务从CFS队列中移除 static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; int task_sleep = flags \u0026 DEQUEUE_SLEEP; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); dequeue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running decrement below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running--; /* Don't dequeue parent if it has other entities besides us */ if (cfs_rq-\u003eload.weight) { /* Avoid re-evaluating load for this entity: */ se = parent_entity(se); /* * Bias pick_next to pick a task from this cfs_rq, as * p is sleeping when it is within its sched_slice. */ if (task_sleep \u0026\u0026 se \u0026\u0026 !throttled_hierarchy(cfs_rq)) set_next_buddy(se); break; } flags |= DEQUEUE_SLEEP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running--; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) sub_nr_running(rq, 1); util_est_dequeue(\u0026rq-\u003ecfs, p, task_sleep); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/cfs/:5:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#dequeue_task_fair"},{"categories":["linux"],"content":" 6 yield_task_fair static void yield_task_fair(struct rq *rq) { struct task_struct *curr = rq-\u003ecurr; struct cfs_rq *cfs_rq = task_cfs_rq(curr); struct sched_entity *se = \u0026curr-\u003ese; /* * Are we the only task in the tree? */ if (unlikely(rq-\u003enr_running == 1)) return; clear_buddies(cfs_rq, se); if (curr-\u003epolicy != SCHED_BATCH) { update_rq_clock(rq); /* * Update run-time statistics of the 'current'. */ update_curr(cfs_rq); /* * Tell update_rq_clock() that we've just updated, * so we don't do microscopic update in schedule() * and double the fastpath cost. */ rq_clock_skip_update(rq, true); } set_skip_buddy(se); } ","date":"2021-10-28","objectID":"/cfs/:6:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#yield_task_fair"},{"categories":["linux"],"content":" 7 yield_to_task_fair static bool yield_to_task_fair(struct rq *rq, struct task_struct *p, bool preempt) { struct sched_entity *se = \u0026p-\u003ese; /* throttled hierarchies are not runnable */ if (!se-\u003eon_rq || throttled_hierarchy(cfs_rq_of(se))) return false; /* Tell the scheduler that we'd really like pse to run next. */ set_next_buddy(se); yield_task_fair(rq); return true; } ","date":"2021-10-28","objectID":"/cfs/:7:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#yield_to_task_fair"},{"categories":["linux"],"content":" 8 check_preempt_wakeup static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) { struct task_struct *curr = rq-\u003ecurr; struct sched_entity *se = \u0026curr-\u003ese, *pse = \u0026p-\u003ese; struct cfs_rq *cfs_rq = task_cfs_rq(curr); int scale = cfs_rq-\u003enr_running \u003e= sched_nr_latency; int next_buddy_marked = 0; if (unlikely(se == pse)) return; /* * This is possible from callers such as attach_tasks(), in which we * unconditionally check_prempt_curr() after an enqueue (which may have * lead to a throttle). This both saves work and prevents false * next-buddy nomination below. */ if (unlikely(throttled_hierarchy(cfs_rq_of(pse)))) return; if (sched_feat(NEXT_BUDDY) \u0026\u0026 scale \u0026\u0026 !(wake_flags \u0026 WF_FORK)) { set_next_buddy(pse); next_buddy_marked = 1; } /* * We can come here with TIF_NEED_RESCHED already set from new task * wake up path. * * Note: this also catches the edge-case of curr being in a throttled * group (e.g. via set_curr_task), since update_curr() (in the * enqueue of curr) will have resulted in resched being set. This * prevents us from potentially nominating it as a false LAST_BUDDY * below. */ if (test_tsk_need_resched(curr)) return; /* Idle tasks are by definition preempted by non-idle tasks. */ if (unlikely(curr-\u003epolicy == SCHED_IDLE) \u0026\u0026 likely(p-\u003epolicy != SCHED_IDLE)) goto preempt; /* * Batch and idle tasks do not preempt non-idle tasks (their preemption * is driven by the tick): */ if (unlikely(p-\u003epolicy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION)) return; find_matching_se(\u0026se, \u0026pse); update_curr(cfs_rq_of(se)); BUG_ON(!pse); if (wakeup_preempt_entity(se, pse) == 1) { /* * Bias pick_next to pick the sched entity that is * triggering this preemption. */ if (!next_buddy_marked) set_next_buddy(pse); goto preempt; } return; preempt: resched_curr(rq); /* * Only set the backward buddy when the current task is still * on the rq. This can happen when a wakeup gets interleaved * with schedule on the -\u003epre_schedule() or idle_balance() * point, either of which can * drop the rq lock. * * Also, during early boot the idle thread is in the fair class, * for obvious reasons its a bad idea to schedule back to it. */ if (unlikely(!se-\u003eon_rq || curr == rq-\u003eidle)) return; if (sched_feat(LAST_BUDDY) \u0026\u0026 scale \u0026\u0026 entity_is_task(se)) set_last_buddy(se); } ","date":"2021-10-28","objectID":"/cfs/:8:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#check_preempt_wakeup"},{"categories":["linux"],"content":" 9 pick_next_task_fair static struct task_struct * pick_next_task_fair(struct rq *rq, struct task_struct *prev) { struct cfs_rq *cfs_rq = \u0026rq-\u003ecfs; struct sched_entity *se; struct task_struct *p; int new_tasks; again: #ifdef CONFIG_FAIR_GROUP_SCHED if (!cfs_rq-\u003enr_running) goto idle; if (prev-\u003esched_class != \u0026fair_sched_class) goto simple; /* * Because of the set_next_buddy() in dequeue_task_fair() it is rather * likely that a next task is from the same cgroup as the current. * * Therefore attempt to avoid putting and setting the entire cgroup * hierarchy, only change the part that actually changes. */ do { struct sched_entity *curr = cfs_rq-\u003ecurr; /* * Since we got here without doing put_prev_entity() we also * have to consider cfs_rq-\u003ecurr. If it is still a runnable * entity, update_curr() will update its vruntime, otherwise * forget we've ever seen it. */ if (curr \u0026\u0026 curr-\u003eon_rq) update_curr(cfs_rq); else curr = NULL; /* * This call to check_cfs_rq_runtime() will do the throttle and * dequeue its entity in the parent(s). Therefore the 'simple' * nr_running test will indeed be correct. */ if (unlikely(check_cfs_rq_runtime(cfs_rq))) goto simple; se = pick_next_entity(cfs_rq, curr); cfs_rq = group_cfs_rq(se); } while (cfs_rq); p = task_of(se); /* * Since we haven't yet done put_prev_entity and if the selected task * is a different task than we started out with, try and touch the * least amount of cfs_rqs. */ if (prev != p) { struct sched_entity *pse = \u0026prev-\u003ese; while (!(cfs_rq = is_same_group(se, pse))) { int se_depth = se-\u003edepth; int pse_depth = pse-\u003edepth; if (se_depth \u003c= pse_depth) { put_prev_entity(cfs_rq_of(pse), pse); pse = parent_entity(pse); } if (se_depth \u003e= pse_depth) { set_next_entity(cfs_rq_of(se), se); se = parent_entity(se); } } put_prev_entity(cfs_rq, pse); set_next_entity(cfs_rq, se); } if (hrtick_enabled(rq)) hrtick_start_fair(rq, p); return p; simple: cfs_rq = \u0026rq-\u003ecfs; #endif if (!cfs_rq-\u003enr_running) goto idle; put_prev_task(rq, prev); do { se = pick_next_entity(cfs_rq, NULL); set_next_entity(cfs_rq, se); cfs_rq = group_cfs_rq(se); } while (cfs_rq); p = task_of(se); if (hrtick_enabled(rq)) hrtick_start_fair(rq, p); return p; idle: new_tasks = idle_balance(rq); /* * Because idle_balance() releases (and re-acquires) rq-\u003elock, it is * possible for any higher priority task to appear. In that case we * must re-start the pick_next_entity() loop. */ if (new_tasks \u003c 0) return RETRY_TASK; if (new_tasks \u003e 0) goto again; return NULL; } ","date":"2021-10-28","objectID":"/cfs/:9:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#pick_next_task_fair"},{"categories":["linux"],"content":" 10 put_prev_task_fair static void put_prev_task_fair(struct rq *rq, struct task_struct *prev) { struct sched_entity *se = \u0026prev-\u003ese; struct cfs_rq *cfs_rq; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); put_prev_entity(cfs_rq, se); } } ","date":"2021-10-28","objectID":"/cfs/:10:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#put_prev_task_fair"},{"categories":["linux"],"content":" 11 set_curr_task_fair static void set_curr_task_fair(struct rq *rq) { struct sched_entity *se = \u0026rq-\u003ecurr-\u003ese; for_each_sched_entity(se) { struct cfs_rq *cfs_rq = cfs_rq_of(se); set_next_entity(cfs_rq, se); /* ensure bandwidth has been allocated on our new cfs_rq */ account_cfs_rq_runtime(cfs_rq, 0); } } ","date":"2021-10-28","objectID":"/cfs/:11:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#set_curr_task_fair"},{"categories":["linux"],"content":" 12 task_tick_fair static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026curr-\u003ese; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); entity_tick(cfs_rq, se, queued); } if (numabalancing_enabled) task_tick_numa(rq, curr); update_rq_runnable_avg(rq, 1); } ","date":"2021-10-28","objectID":"/cfs/:12:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#task_tick_fair"},{"categories":["linux"],"content":" 13 task_fork_fair static void task_fork_fair(struct task_struct *p) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese, *curr; int this_cpu = smp_processor_id(); struct rq *rq = this_rq(); unsigned long flags; raw_spin_lock_irqsave(\u0026rq-\u003elock, flags); update_rq_clock(rq); cfs_rq = task_cfs_rq(current); curr = cfs_rq-\u003ecurr; /* * Not only the cpu but also the task_group of the parent might have * been changed after parent-\u003ese.parent,cfs_rq were copied to * child-\u003ese.parent,cfs_rq. So call __set_task_cpu() to make those * of child point to valid ones. */ rcu_read_lock(); __set_task_cpu(p, this_cpu); rcu_read_unlock(); update_curr(cfs_rq); if (curr) se-\u003evruntime = curr-\u003evruntime; place_entity(cfs_rq, se, 1); if (sysctl_sched_child_runs_first \u0026\u0026 curr \u0026\u0026 entity_before(curr, se)) { /* * Upon rescheduling, sched_class::put_prev_task() will place * 'current' within the tree based on its new key value. */ swap(curr-\u003evruntime, se-\u003evruntime); resched_curr(rq); } se-\u003evruntime -= cfs_rq-\u003emin_vruntime; raw_spin_unlock_irqrestore(\u0026rq-\u003elock, flags); } ","date":"2021-10-28","objectID":"/cfs/:13:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#task_fork_fair"},{"categories":["linux"],"content":" 14 update_curr_fair static void update_curr_fair(struct rq *rq) { update_curr(cfs_rq_of(\u0026rq-\u003ecurr-\u003ese)); } static void update_curr(struct cfs_rq *cfs_rq) { struct sched_entity *curr = cfs_rq-\u003ecurr; u64 now = rq_clock_task(rq_of(cfs_rq)); u64 delta_exec; if (unlikely(!curr)) return; delta_exec = now - curr-\u003eexec_start; if (unlikely((s64)delta_exec \u003c= 0)) return; curr-\u003eexec_start = now; schedstat_set(curr-\u003estatistics.exec_max, max(delta_exec, curr-\u003estatistics.exec_max)); curr-\u003esum_exec_runtime += delta_exec; schedstat_add(cfs_rq, exec_clock, delta_exec); curr-\u003evruntime += calc_delta_fair(delta_exec, curr); update_min_vruntime(cfs_rq); if (entity_is_task(curr)) { struct task_struct *curtask = task_of(curr); trace_sched_stat_runtime(curtask, delta_exec, curr-\u003evruntime); cpuacct_charge(curtask, delta_exec); account_group_exec_runtime(curtask, delta_exec); } account_cfs_rq_runtime(cfs_rq, delta_exec); } ","date":"2021-10-28","objectID":"/cfs/:14:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#update_curr_fair"},{"categories":["linux"],"content":"物理页面分配器","date":"2021-10-28","objectID":"/page_allocator/","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/"},{"categories":["linux"],"content":" 1 alloc_pageslinux常用的物理界面分配器的函数是alloc_pages,下面分析是如何实现的. #define alloc_pages(gfp_mask, order) alloc_pages_node(numa_node_id(), gfp_mask, order) static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order) { /* Unknown node is current node */ if (nid \u003c 0) nid = numa_node_id(); return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask)); } static inline struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist) { return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL); } 此时正式进入函数分析阶段 /** * @brief 分配物理页面 * @param gfp_mask 分配掩码 * @param order 分配阶数 * @param zonelist 内存区域 * @param nodemask 节点掩码 * @return struct page* 分配的物理页面 */ struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist, nodemask_t *nodemask); 详细解析接口实现 分配掩码 // 分配掩码就是一个unsigned int类型 typedef unsigned __bitwise__ gfp_t; #define ___GFP_DMA 0x01u #define ___GFP_HIGHMEM 0x02u #define ___GFP_DMA32 0x04u #define ___GFP_MOVABLE 0x08u #define ___GFP_WAIT 0x10u #define ___GFP_HIGH 0x20u #define ___GFP_IO 0x40u #define ___GFP_FS 0x80u #define ___GFP_COLD 0x100u #define ___GFP_NOWARN 0x200u #define ___GFP_REPEAT 0x400u #define ___GFP_NOFAIL 0x800u #define ___GFP_NORETRY 0x1000u #define ___GFP_MEMALLOC 0x2000u #define ___GFP_COMP 0x4000u #define ___GFP_ZERO 0x8000u #define ___GFP_NOMEMALLOC 0x10000u #define ___GFP_HARDWALL 0x20000u #define ___GFP_THISNODE 0x40000u #define ___GFP_RECLAIMABLE 0x80000u #define ___GFP_NOTRACK 0x200000u #define ___GFP_NO_KSWAPD 0x400000u #define ___GFP_OTHER_NODE 0x800000u #define ___GFP_WRITE 0x1000000u #define __force __attribute__((force)) #define __GFP_DMA ((__force gfp_t)___GFP_DMA) #define __GFP_HIGHMEM ((__force gfp_t)___GFP_HIGHMEM) #define __GFP_DMA32 ((__force gfp_t)___GFP_DMA32) #define __GFP_MOVABLE ((__force gfp_t)___GFP_MOVABLE) /* Page is movable */ #define __GFP_WAIT ((__force gfp_t)___GFP_WAIT) /* Can wait and reschedule? */ #define __GFP_HIGH ((__force gfp_t)___GFP_HIGH) /* Should access emergency pools? */ #define __GFP_IO ((__force gfp_t)___GFP_IO) /* Can start physical IO? */ #define __GFP_FS ((__force gfp_t)___GFP_FS) /* Can call down to low-level FS? */ #define __GFP_COLD ((__force gfp_t)___GFP_COLD) /* Cache-cold page required */ #define __GFP_NOWARN ((__force gfp_t)___GFP_NOWARN) /* Suppress page allocation failure warning */ #define __GFP_REPEAT ((__force gfp_t)___GFP_REPEAT) /* See above */ #define __GFP_NOFAIL ((__force gfp_t)___GFP_NOFAIL) /* See above */ #define __GFP_NORETRY ((__force gfp_t)___GFP_NORETRY) /* See above */ #define __GFP_MEMALLOC ((__force gfp_t)___GFP_MEMALLOC)/* Allow access to emergency reserves */ #define __GFP_COMP ((__force gfp_t)___GFP_COMP) /* Add compound page metadata */ #define __GFP_ZERO ((__force gfp_t)___GFP_ZERO) /* Return zeroed page on success */ #define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC) /* Don't use emergency reserves. * This takes precedence over the * __GFP_MEMALLOC flag if both are * set */ #define __GFP_HARDWALL ((__force gfp_t)___GFP_HARDWALL) /* Enforce hardwall cpuset memory allocs */ #define __GFP_THISNODE ((__force gfp_t)___GFP_THISNODE)/* No fallback, no policies */ #define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) /* Page is reclaimable */ #define __GFP_NOTRACK ((__force gfp_t)___GFP_NOTRACK) /* Don't track with kmemcheck */ #define __GFP_NO_KSWAPD ((__force gfp_t)___GFP_NO_KSWAPD) #define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) /* On behalf of other node */ #define __GFP_WRITE ((__force gfp_t)___GFP_WRITE) /* Allocator intends to dirty page */ 分配阶数 描述分配的大小 $$ {page_number} = 2 ^ {order} $$ 内存区域 zone令行分析 节点掩码 nodemask令行分析 ","date":"2021-10-28","objectID":"/page_allocator/:1:0","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#alloc_pages"},{"categories":["linux"],"content":" 1.1 __alloc_pages_nodemask struct page * __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist, nodemask_t *nodemask) { struct zoneref *preferred_zoneref; struct page *page = NULL; unsigned int cpuset_mems_cookie; int alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET|ALLOC_FAIR; gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */ struct alloc_context ac = { .high_zoneidx = gfp_zone(gfp_mask), .nodemask = nodemask, .migratetype = gfpflags_to_migratetype(gfp_mask), }; gfp_mask \u0026= gfp_allowed_mask; lockdep_trace_alloc(gfp_mask); might_sleep_if(gfp_mask \u0026 __GFP_WAIT); if (should_fail_alloc_page(gfp_mask, order)) return NULL; /* * Check the zones suitable for the gfp_mask contain at least one * valid zone. It's possible to have an empty zonelist as a result * of GFP_THISNODE and a memoryless node */ if (unlikely(!zonelist-\u003e_zonerefs-\u003ezone)) return NULL; if (IS_ENABLED(CONFIG_CMA) \u0026\u0026 ac.migratetype == MIGRATE_MOVABLE) alloc_flags |= ALLOC_CMA; retry_cpuset: cpuset_mems_cookie = read_mems_allowed_begin(); /* We set it here, as __alloc_pages_slowpath might have changed it */ ac.zonelist = zonelist; /* The preferred zone is used for statistics later */ preferred_zoneref = first_zones_zonelist(ac.zonelist, ac.high_zoneidx, ac.nodemask ? : \u0026cpuset_current_mems_allowed, \u0026ac.preferred_zone); if (!ac.preferred_zone) goto out; ac.classzone_idx = zonelist_zone_idx(preferred_zoneref); /* First allocation attempt */ alloc_mask = gfp_mask|__GFP_HARDWALL; page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026ac); if (unlikely(!page)) { /* * Runtime PM, block IO and its error handling path * can deadlock because I/O on the device might not * complete. */ alloc_mask = memalloc_noio_flags(gfp_mask); page = __alloc_pages_slowpath(alloc_mask, order, \u0026ac); } if (kmemcheck_enabled \u0026\u0026 page) kmemcheck_pagealloc_alloc(page, order, gfp_mask); trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); out: /* * When updating a task's mems_allowed, it is possible to race with * parallel threads in such a way that an allocation can fail while * the mask is being updated. If a page allocation is about to fail, * check if the cpuset changed during allocation and if so, retry. */ if (unlikely(!page \u0026\u0026 read_mems_allowed_retry(cpuset_mems_cookie))) goto retry_cpuset; return page; } struct alloc_context { struct zonelist *zonelist; nodemask_t *nodemask; struct zone *preferred_zone; int classzone_idx; int migratetype; enum zone_type high_zoneidx; }; struct alloc_context ac = { .high_zoneidx = gfp_zone(gfp_mask), .nodemask = nodemask, .migratetype = gfpflags_to_migratetype(gfp_mask), }; static inline enum zone_type gfp_zone(gfp_t flags) { enum zone_type z; int bit = (__force int) (flags \u0026 GFP_ZONEMASK); z = (GFP_ZONE_TABLE \u003e\u003e (bit * ZONES_SHIFT)) \u0026 ((1 \u003c\u003c ZONES_SHIFT) - 1); VM_BUG_ON((GFP_ZONE_BAD \u003e\u003e bit) \u0026 1); return z; } // GFP --\u003e migratetype static inline int gfpflags_to_migratetype(const gfp_t gfp_flags) { WARN_ON((gfp_flags \u0026 GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK); if (unlikely(page_group_by_mobility_disabled)) return MIGRATE_UNMOVABLE; /* Group based on mobility */ return (((gfp_flags \u0026 __GFP_MOVABLE) != 0) \u003c\u003c 1) | ((gfp_flags \u0026 __GFP_RECLAIMABLE) != 0); } ","date":"2021-10-28","objectID":"/page_allocator/:1:1","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__alloc_pages_nodemask"},{"categories":["linux"],"content":" 1.2 first_zones_zonelist static inline struct zoneref *first_zones_zonelist(struct zonelist *zonelist, enum zone_type highest_zoneidx, nodemask_t *nodes, struct zone **zone) { struct zoneref *z = next_zones_zonelist(zonelist-\u003e_zonerefs, highest_zoneidx, nodes); *zone = zonelist_zone(z); return z; } // 提取zone的指针 static inline struct zone *zonelist_zone(struct zoneref *zoneref) { return zoneref-\u003ezone; } struct zoneref *next_zones_zonelist(struct zoneref *z, enum zone_type highest_zoneidx, nodemask_t *nodes) { /* * Find the next suitable zone to use for the allocation. * Only filter based on nodemask if it's set */ if (likely(nodes == NULL)) while (zonelist_zone_idx(z) \u003e highest_zoneidx) z++; else while (zonelist_zone_idx(z) \u003e highest_zoneidx || (z-\u003ezone \u0026\u0026 !zref_in_nodemask(z, nodes))) z++; return z; } ","date":"2021-10-28","objectID":"/page_allocator/:1:2","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#first_zones_zonelist"},{"categories":["linux"],"content":" 2 free_pages void free_pages(unsigned long addr, unsigned int order) { if (addr != 0) { VM_BUG_ON(!virt_addr_valid((void *)addr)); __free_pages(virt_to_page((void *)addr), order); } } ","date":"2021-10-28","objectID":"/page_allocator/:2:0","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#free_pages"},{"categories":["linux"],"content":" 2.1 __free_pages void __free_pages(struct page *page, unsigned int order) { if (put_page_testzero(page)) { if (order == 0) free_hot_cold_page(page, false); else __free_pages_ok(page, order); } } ","date":"2021-10-28","objectID":"/page_allocator/:2:1","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_pages"},{"categories":["linux"],"content":" 2.2 __free_pages_ok static void __free_pages_ok(struct page *page, unsigned int order) { unsigned long flags; int migratetype; unsigned long pfn = page_to_pfn(page); if (!free_pages_prepare(page, order)) return; migratetype = get_pfnblock_migratetype(page, pfn); local_irq_save(flags); __count_vm_events(PGFREE, 1 \u003c\u003c order); set_freepage_migratetype(page, migratetype); free_one_page(page_zone(page), page, pfn, order, migratetype); local_irq_restore(flags); } ","date":"2021-10-28","objectID":"/page_allocator/:2:2","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_pages_ok"},{"categories":["linux"],"content":" 2.3 free_one_page static void free_one_page(struct zone *zone, struct page *page, unsigned long pfn, unsigned int order, int migratetype) { unsigned long nr_scanned; spin_lock(\u0026zone-\u003elock); nr_scanned = zone_page_state(zone, NR_PAGES_SCANNED); if (nr_scanned) __mod_zone_page_state(zone, NR_PAGES_SCANNED, -nr_scanned); if (unlikely(has_isolate_pageblock(zone) || is_migrate_isolate(migratetype))) { migratetype = get_pfnblock_migratetype(page, pfn); } __free_one_page(page, pfn, zone, order, migratetype); spin_unlock(\u0026zone-\u003elock); } ","date":"2021-10-28","objectID":"/page_allocator/:2:3","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#free_one_page"},{"categories":["linux"],"content":" 2.4 __free_one_page static inline void __free_one_page(struct page *page, unsigned long pfn, struct zone *zone, unsigned int order, int migratetype) { unsigned long page_idx; unsigned long combined_idx; unsigned long uninitialized_var(buddy_idx); struct page *buddy; int max_order = MAX_ORDER; VM_BUG_ON(!zone_is_initialized(zone)); VM_BUG_ON_PAGE(page-\u003eflags \u0026 PAGE_FLAGS_CHECK_AT_PREP, page); VM_BUG_ON(migratetype == -1); if (is_migrate_isolate(migratetype)) { /* * We restrict max order of merging to prevent merge * between freepages on isolate pageblock and normal * pageblock. Without this, pageblock isolation * could cause incorrect freepage accounting. */ max_order = min(MAX_ORDER, pageblock_order + 1); } else { __mod_zone_freepage_state(zone, 1 \u003c\u003c order, migratetype); } page_idx = pfn \u0026 ((1 \u003c\u003c max_order) - 1); VM_BUG_ON_PAGE(page_idx \u0026 ((1 \u003c\u003c order) - 1), page); VM_BUG_ON_PAGE(bad_range(zone, page), page); while (order \u003c max_order - 1) { buddy_idx = __find_buddy_index(page_idx, order); buddy = page + (buddy_idx - page_idx); if (!page_is_buddy(page, buddy, order)) break; /* * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page, * merge with it and move up one order. */ if (page_is_guard(buddy)) { clear_page_guard(zone, buddy, order, migratetype); } else { list_del(\u0026buddy-\u003elru); zone-\u003efree_area[order].nr_free--; rmv_page_order(buddy); } combined_idx = buddy_idx \u0026 page_idx; page = page + (combined_idx - page_idx); page_idx = combined_idx; order++; } set_page_order(page, order); /* * If this is not the largest possible page, check if the buddy * of the next-highest order is free. If it is, it's possible * that pages are being freed that will coalesce soon. In case, * that is happening, add the free page to the tail of the list * so it's less likely to be used soon and more likely to be merged * as a higher order page */ if ((order \u003c MAX_ORDER-2) \u0026\u0026 pfn_valid_within(page_to_pfn(buddy))) { struct page *higher_page, *higher_buddy; combined_idx = buddy_idx \u0026 page_idx; higher_page = page + (combined_idx - page_idx); buddy_idx = __find_buddy_index(combined_idx, order + 1); higher_buddy = higher_page + (buddy_idx - combined_idx); if (page_is_buddy(higher_page, higher_buddy, order + 1)) { list_add_tail(\u0026page-\u003elru, \u0026zone-\u003efree_area[order].free_list[migratetype]); goto out; } } list_add(\u0026page-\u003elru, \u0026zone-\u003efree_area[order].free_list[migratetype]); out: zone-\u003efree_area[order].nr_free++; } ","date":"2021-10-28","objectID":"/page_allocator/:2:4","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_one_page"},{"categories":["前端知识"],"content":"javascript基础教程","date":"2021-10-07","objectID":"/javascript/","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/"},{"categories":["前端知识"],"content":" 1 基础知识 JavaScript是一种运行在浏览器中的解释型的编程语言 JavaScript（JS）是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。 虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多非浏览器环境中， 例如 Node.js、Apache CouchDB、Adobe Acrobat 等。 进一步说，JavaScript 是一种基于原型、多范式、单线程的动态 (en-US)语言， 并且支持面向对象、命令式和声明式（如函数式编程）风格。 在hugo中运行javacsript脚本,可以使用hugo的script shortcode在文章中插入Javascript脚本 {{\u003c script \u003e}} console.log('javascript基础教程!'); {{\u003c /script \u003e}} 可以在浏览器的后台中看到日志javascript基础教程! 同样的道理,也可以直接写在html中; \u003cbutton onclick='alert(Date())'\u003e现在的时间是? \u003c/button\u003e 点击下面的按钮，显示效果 现在的时间是? JavaScript严格区分大小写 作为一个新的语言,我们学的第一个程序 打印hello world /* 打印弹窗 */ alert(\"hello world\"); /* 打印在html */ document.write(\"hello world\"); /* 打印在调试窗口 */ console.log(\"Hello world\") 但是直接在浏览器中运行显得特别麻烦,此时我们可以使用NodeJS在命令行中运行程序 Nodejs中的内容 执行js脚本 ","date":"2021-10-07","objectID":"/javascript/:1:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基础知识"},{"categories":["前端知识"],"content":" 2 基本语句 赋值语句 var x = 1; // 定义全局变量 let y = 12; // 定义局部变量 注释语句 // 单行注释 /** * 多行注释 */ 变量 变量必须以字母开头 变量也能以$和_符号开头 变量名称对大小写敏感 ","date":"2021-10-07","objectID":"/javascript/:2:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基本语句"},{"categories":["前端知识"],"content":" 3 数据类型 九种数据类型 值类型(基本类型) 字符串(String) 数字(Number) 布尔(Boolean) 空(Null) 未定义(Undefined) Symbol 引用数据类型(对象类型) 对象(Object) 数组(Array) 函数(Function) ","date":"2021-10-07","objectID":"/javascript/:3:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数据类型"},{"categories":["前端知识"],"content":" 3.1 定义数据 var a = 'Hello'; // 字符串(String) var b = 10; // 数字(Number) var c = true; // 布尔(Boolean) var d = function() { // 函数(Function) console.log(\"Hello\"); }; var e = [1, 2, 3]; // 数组(Array) var f = null; // 空(Null) var g = Symbol(); // Symbol var h; // 未定义(Undefined) var i = Object(); // 对象(Object) ","date":"2021-10-07","objectID":"/javascript/:3:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义数据"},{"categories":["前端知识"],"content":" 3.2 检测数据 typeof 只可以检测基本数据类型 constructor返回实例的构造函数 instanceof 原型查找 Object.prototype.toString // 1. typeof检测类型 console.log(\"\\r\\n1. typeof检测类型\") console.log('type of a is ' + typeof(a)); console.log('type of b is ' + typeof(b)); console.log('type of c is ' + typeof(c)); console.log('type of d is ' + typeof(d)); console.log('type of e is ' + typeof(e)); console.log('type of f is ' + typeof(f)); console.log('type of g is ' + typeof(g)); console.log('type of h is ' + typeof(h)); console.log('type of i is ' + typeof(i)); // 2. constructor返回实例的构造函数 console.log(\"\\r\\n2. constructor返回实例的构造函数\") console.log(a.constructor == String); console.log(a.constructor == Number); console.log(e.constructor == Object); console.log(e.constructor == Array); // 3. instanceof 原型查找 console.log(\"\\r\\n3. instanceof 原型查找\") console.log(a instanceof String); console.log(a instanceof Number); console.log(e instanceof Object); console.log(e instanceof Array); // 4. Object.prototype.toString console.log(\"\\r\\n4. Object.prototype.toString\") console.log('type of a is ' + toString.call(a)); console.log('type of b is ' + toString.call(b)); console.log('type of c is ' + toString.call(c)); console.log('type of d is ' + toString.call(d)); console.log('type of e is ' + toString.call(e)); console.log('type of f is ' + toString.call(f)); console.log('type of g is ' + toString.call(g)); console.log('type of h is ' + toString.call(h)); console.log('type of i is ' + toString.call(i)); ","date":"2021-10-07","objectID":"/javascript/:3:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#检测数据"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#拼接字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串函数"},{"categories":["前端知识"],"content":" 3.4 数组JavaScript的数组可以包含任意数据类型;并通过索引来访问每个元素. var array = [1, 2, 'hello', \"world\", true]; // 定义一个数组 array.length; // 5 array[0]; // 打印 ","date":"2021-10-07","objectID":"/javascript/:3:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数组"},{"categories":["前端知识"],"content":" 4 条件判断 与C相似,此处就不过多赘述 if else else if switch if (1 \u003c 3) { console.log(\"1 \u003c 3 \\r\\n\"); } if (false) { console.log(\"false \\r\\n\"); } else { console.log(\"true \\r\\n\"); } if (false) { console.log(\"false \\r\\n\"); } else if(false) { console.log(\"false \\r\\n\"); } else { console.log(\"true \\r\\n\"); } 同样的道理,js也存在这多路选择 switch (new Date().getDay()) { case 0: day = \"星期天\"; break; case 1: day = \"星期一\"; break; case 2: day = \"星期二\"; break; case 3: day = \"星期三\"; break; case 4: day = \"星期四\"; break; case 5: day = \"星期五\"; break; case 6: day = \"星期六\"; } console.log('今天是' + day); ","date":"2021-10-07","objectID":"/javascript/:4:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#条件判断"},{"categories":["前端知识"],"content":" 5 循环语句 for for (语句 1; 语句 2; 语句 3) { 要执行的代码块 } for-in for (key in object) { // code block to be executed } for-of while do-while ","date":"2021-10-07","objectID":"/javascript/:5:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#循环语句"},{"categories":["前端知识"],"content":" 6 遍历语句","date":"2021-10-07","objectID":"/javascript/:6:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#遍历语句"},{"categories":["前端知识"],"content":" 7 函数(ES5)","date":"2021-10-07","objectID":"/javascript/:7:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数es5"},{"categories":["前端知识"],"content":" 7.1 函数模型 c语言类型 function functionName(args) { return retVal; } function:函数定义 functionName parameter retVal 一种完全等价的定义 var functionName = function(args) { return retVal; } ","date":"2021-10-07","objectID":"/javascript/:7:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数模型"},{"categories":["前端知识"],"content":" 7.2 函数调用 function greet(name) { console.log(\"Hello, \" + name + \"!\"); } greet(\"javascript\"); 函数还可以作为参数使用 function add(a, b) { return a + b; } function sub(a, b) { return a - b; } function calculate(func, a, b) { return func(a, b); } console.log(calculate(add, 5, 3)); // 输出 8 console.log(calculate(sub, 5, 3)); // 输出 2 ","date":"2021-10-07","objectID":"/javascript/:7:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数调用"},{"categories":["前端知识"],"content":" 8 函数(ES6) ES6引入了许多新的函数特性，包括箭头函数、默认参数、剩余参数、展开运算符等。下面是一些重要的内容： ","date":"2021-10-07","objectID":"/javascript/:8:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数es6"},{"categories":["前端知识"],"content":" 8.1 箭头函数箭头函数是ES6中最受欢迎的新特性之一，它简化了函数的书写方式，并且在某些情况下可以提高代码可读性。 箭头函数的语法如下： 复制代码(param1, param2, ..., paramN) =\u003e { statements } 例如，以下两个函数是等价的： // ES5 var square = function(x) { return x * x; }; // ES6 const square = (x) =\u003e { return x * x; }; 当函数体只有一行语句时，可以省略花括号和return关键字： // ES6 const square = (x) =\u003e x * x; 如果函数只有一个参数，甚至可以省略括号： // ES6 const square = x =\u003e x * x; ","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#箭头函数"},{"categories":["前端知识"],"content":" 8.2 默认参数默认参数是指函数定义时指定参数的默认值。如果调用函数时没有传递该参数，则使用默认值。 默认参数的语法如下： function func(param1=default1, param2=default2) { // ... } 例如，以下两个函数是等价的： // ES5 function greet(name) { name = name || 'world'; console.log('Hello, ' + name + '!'); } // ES6 function greet(name='world') { console.log(`Hello, ${name}!`); } 在上面的例子中，如果调用greet()函数时不传递任何参数，则将使用默认参数值 'world'。 ","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#默认参数"},{"categories":["前端知识"],"content":" 8.3 剩余参数剩余参数是指一个函数可以接收多个参数，并将它们转换成一个数组。 剩余参数的语法如下： 复制代码function func(param1, param2, ...rest) { // rest为包含剩余参数的数组 } 例如，以下函数可以将所有传递给它的参数相加： function sum(...args) { return args.reduce((acc, val) =\u003e acc + val, 0); } console.log(sum(1, 2, 3)); // 输出6 console.log(sum(4, 5, 6, 7)); // 输出22 在上面的例子中，sum()函数可以接受任意数量的参数，并将它们存储在一个名为args的数组中。 ","date":"2021-10-07","objectID":"/javascript/:8:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#剩余参数"},{"categories":["前端知识"],"content":" 8.4 展开运算符展开运算符允许将一个数组或对象拆分成单个元素，并将它们传递给函数。 展开运算符的语法如下： // 对象展开 const obj = { prop1: 'value1', prop2: 'value2' }; const newObj = { ...obj, prop3: 'value3' }; // 数组展开 const arr = [1, 2, 3]; const newArr = [0, ...arr, 4]; // 函数参数展开 function func(x, y, z) { // ... } const args = [1, 2, 3]; func(...args); 在上面的例子中，...obj将对象拆分成单个属性，并添加一个新的属性prop3。...arr将数组拆分成单个元素，并将它们插入到新数组中。...args将数组展开并传递给func()函数作为单独的参数。 这些都是ES6引入的一些重要的函数特性。它们使代码更加简洁、易读和灵活，因此在编写现代JavaScript应用程序时非常有用。 ","date":"2021-10-07","objectID":"/javascript/:8:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#展开运算符"},{"categories":["前端知识"],"content":" 9 面向对象","date":"2021-10-07","objectID":"/javascript/:9:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#面向对象"},{"categories":["前端知识"],"content":" 9.1 创建对象(ES5) ES5设计的面向对象真的麻烦 9.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 9.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 9.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 9.1.4 继承语法在 ES5 中，我们可以使用原型链来实现对象的继承。具体来说，就是通过创建一个新的构造函数，并将父类的实例作为新构造函数的原型，从而实现继承。 下面是一个简单的继承示例： function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); }; function Student(name, age, grade) { Person.call(this, name, age); // 调用父类的构造函数 this.grade = grade; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.study = function() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); }; var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了两个构造函数 Person 和 Student，并通过原型链实现了 Student 继承了 Person。具体来说，我们通过 Object.create() 方法创建了一个空对象，并把 Person.prototype 赋值给这个空对象的原型，然后再把这个新对象赋值给 Student.prototype，这样就建立了 Student 的原型链。最后，我们还需要重置 Student.prototype 的构造函数为 Student，以确保继承关系正确。 在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 Person.call(this, name, age)，其中的 this 指代的是子类的实例，并将父类的属性赋值给子类的实例。这样，子类就可以继承父类的属性和方法。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过原型链继承虽然比较简单，但也存在一些缺点，例如： 父类的引用类型属性会被所有子类实例共享，容易造成修改冲突。 不能向父类的构造函数传递参数。 在创建子类实例时，无法向父类构造函数中传递参数。 9.1.5 封装语法在 ES5 中，通过使用函数作用域和闭包，可以实现对象的封装。具体来说，我们可以使用函数作为对象的构造函数，并在构造函数内部定义变量和方法，并使用闭包来保护这些私有属性和方法，使得它们不能被外界直接访问。 下面是一个简单的封装示例： function Person(name, age) { var _name = name; var _age = age; function getName() { return _name; } function getAge() { return _age; } function setName(name) { _name = name; } function setAge(age) { _age = age; } this.sayHello = function() { console.log(\"Hello, my name is \" + _name + \", I'm \" + _age + \" years old.\"); }; Object.defineProperty(this, \"name\", { get: getName, set: setName }); Object.defineProperty(this, \"age\", { get: getAge, set: setAge }); } var tom = new Person(\"Tom\", 29); console.log(tom.name); // 输出：Tom console.log(tom.age); // 输出：29 tom.sayHello(); // 输出：Hello, my name is Tom, I'm 29 years old. tom.name = \"Jerry\"; tom.age = 30; console.log(tom.name); // 输出：Jerry console.log(tom.age); // 输出：30 tom.sayHello(); // 输出：Hello, my name is Jerry, I'm 30 years old. 在上面的示例中，我们使用函数作为 Person 的构造函数，并在构造函数内部定义了变量 _name 和 _age，以及方法 getName()、getAge()、setName() 和 setAge()。这些变量和方法通过闭包来保护，使得它们只能在构造函数内部被访问。 为了使得外部代码可以访问到对象的属性 name 和 age，我们使用 Object.defineProperty() 方法给对象定义了 getter 和 setter。 最后，我们还在对象的原型上定义了公共方法 sayHello()，用于向外界展示对象的信息。 通过封装，我们可以将对象的实现细节隐藏起来，避免外部直接访问和修改对象的内部状态，从而提高了代码的安全性和可维护性。 ","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建对象es5"},{"categories":["前端知识"],"content":" 9.1 创建对象(ES5) ES5设计的面向对象真的麻烦 9.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 9.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 9.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 9.1.4 继承语法在 ES5 中，我们可以使用原型链来实现对象的继承。具体来说，就是通过创建一个新的构造函数，并将父类的实例作为新构造函数的原型，从而实现继承。 下面是一个简单的继承示例： function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); }; function Student(name, age, grade) { Person.call(this, name, age); // 调用父类的构造函数 this.grade = grade; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.study = function() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); }; var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了两个构造函数 Person 和 Student，并通过原型链实现了 Student 继承了 Person。具体来说，我们通过 Object.create() 方法创建了一个空对象，并把 Person.prototype 赋值给这个空对象的原型，然后再把这个新对象赋值给 Student.prototype，这样就建立了 Student 的原型链。最后，我们还需要重置 Student.prototype 的构造函数为 Student，以确保继承关系正确。 在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 Person.call(this, name, age)，其中的 this 指代的是子类的实例，并将父类的属性赋值给子类的实例。这样，子类就可以继承父类的属性和方法。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过原型链继承虽然比较简单，但也存在一些缺点，例如： 父类的引用类型属性会被所有子类实例共享，容易造成修改冲突。 不能向父类的构造函数传递参数。 在创建子类实例时，无法向父类构造函数中传递参数。 9.1.5 封装语法在 ES5 中，通过使用函数作用域和闭包，可以实现对象的封装。具体来说，我们可以使用函数作为对象的构造函数，并在构造函数内部定义变量和方法，并使用闭包来保护这些私有属性和方法，使得它们不能被外界直接访问。 下面是一个简单的封装示例： function Person(name, age) { var _name = name; var _age = age; function getName() { return _name; } function getAge() { return _age; } function setName(name) { _name = name; } function setAge(age) { _age = age; } this.sayHello = function() { console.log(\"Hello, my name is \" + _name + \", I'm \" + _age + \" years old.\"); }; Object.defineProperty(this, \"name\", { get: getName, set: setName }); Object.defineProperty(this, \"age\", { get: getAge, set: setAge }); } var tom = new Person(\"Tom\", 29); console.log(tom.name); // 输出：Tom console.log(tom.age); // 输出：29 tom.sayHello(); // 输出：Hello, my name is Tom, I'm 29 years old. tom.name = \"Jerry\"; tom.age = 30; console.log(tom.name); // 输出：Jerry console.log(tom.age); // 输出：30 tom.sayHello(); // 输出：Hello, my name is Jerry, I'm 30 years old. 在上面的示例中，我们使用函数作为 Person 的构造函数，并在构造函数内部定义了变量 _name 和 _age，以及方法 getName()、getAge()、setName() 和 setAge()。这些变量和方法通过闭包来保护，使得它们只能在构造函数内部被访问。 为了使得外部代码可以访问到对象的属性 name 和 age，我们使用 Object.defineProperty() 方法给对象定义了 getter 和 setter。 最后，我们还在对象的原型上定义了公共方法 sayHello()，用于向外界展示对象的信息。 通过封装，我们可以将对象的实现细节隐藏起来，避免外部直接访问和修改对象的内部状态，从而提高了代码的安全性和可维护性。 ","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#object对象"},{"categories":["前端知识"],"content":" 9.1 创建对象(ES5) ES5设计的面向对象真的麻烦 9.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 9.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 9.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 9.1.4 继承语法在 ES5 中，我们可以使用原型链来实现对象的继承。具体来说，就是通过创建一个新的构造函数，并将父类的实例作为新构造函数的原型，从而实现继承。 下面是一个简单的继承示例： function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); }; function Student(name, age, grade) { Person.call(this, name, age); // 调用父类的构造函数 this.grade = grade; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.study = function() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); }; var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了两个构造函数 Person 和 Student，并通过原型链实现了 Student 继承了 Person。具体来说，我们通过 Object.create() 方法创建了一个空对象，并把 Person.prototype 赋值给这个空对象的原型，然后再把这个新对象赋值给 Student.prototype，这样就建立了 Student 的原型链。最后，我们还需要重置 Student.prototype 的构造函数为 Student，以确保继承关系正确。 在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 Person.call(this, name, age)，其中的 this 指代的是子类的实例，并将父类的属性赋值给子类的实例。这样，子类就可以继承父类的属性和方法。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过原型链继承虽然比较简单，但也存在一些缺点，例如： 父类的引用类型属性会被所有子类实例共享，容易造成修改冲突。 不能向父类的构造函数传递参数。 在创建子类实例时，无法向父类构造函数中传递参数。 9.1.5 封装语法在 ES5 中，通过使用函数作用域和闭包，可以实现对象的封装。具体来说，我们可以使用函数作为对象的构造函数，并在构造函数内部定义变量和方法，并使用闭包来保护这些私有属性和方法，使得它们不能被外界直接访问。 下面是一个简单的封装示例： function Person(name, age) { var _name = name; var _age = age; function getName() { return _name; } function getAge() { return _age; } function setName(name) { _name = name; } function setAge(age) { _age = age; } this.sayHello = function() { console.log(\"Hello, my name is \" + _name + \", I'm \" + _age + \" years old.\"); }; Object.defineProperty(this, \"name\", { get: getName, set: setName }); Object.defineProperty(this, \"age\", { get: getAge, set: setAge }); } var tom = new Person(\"Tom\", 29); console.log(tom.name); // 输出：Tom console.log(tom.age); // 输出：29 tom.sayHello(); // 输出：Hello, my name is Tom, I'm 29 years old. tom.name = \"Jerry\"; tom.age = 30; console.log(tom.name); // 输出：Jerry console.log(tom.age); // 输出：30 tom.sayHello(); // 输出：Hello, my name is Jerry, I'm 30 years old. 在上面的示例中，我们使用函数作为 Person 的构造函数，并在构造函数内部定义了变量 _name 和 _age，以及方法 getName()、getAge()、setName() 和 setAge()。这些变量和方法通过闭包来保护，使得它们只能在构造函数内部被访问。 为了使得外部代码可以访问到对象的属性 name 和 age，我们使用 Object.defineProperty() 方法给对象定义了 getter 和 setter。 最后，我们还在对象的原型上定义了公共方法 sayHello()，用于向外界展示对象的信息。 通过封装，我们可以将对象的实现细节隐藏起来，避免外部直接访问和修改对象的内部状态，从而提高了代码的安全性和可维护性。 ","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#对象初始化器"},{"categories":["前端知识"],"content":" 9.1 创建对象(ES5) ES5设计的面向对象真的麻烦 9.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 9.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 9.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 9.1.4 继承语法在 ES5 中，我们可以使用原型链来实现对象的继承。具体来说，就是通过创建一个新的构造函数，并将父类的实例作为新构造函数的原型，从而实现继承。 下面是一个简单的继承示例： function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); }; function Student(name, age, grade) { Person.call(this, name, age); // 调用父类的构造函数 this.grade = grade; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.study = function() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); }; var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了两个构造函数 Person 和 Student，并通过原型链实现了 Student 继承了 Person。具体来说，我们通过 Object.create() 方法创建了一个空对象，并把 Person.prototype 赋值给这个空对象的原型，然后再把这个新对象赋值给 Student.prototype，这样就建立了 Student 的原型链。最后，我们还需要重置 Student.prototype 的构造函数为 Student，以确保继承关系正确。 在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 Person.call(this, name, age)，其中的 this 指代的是子类的实例，并将父类的属性赋值给子类的实例。这样，子类就可以继承父类的属性和方法。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过原型链继承虽然比较简单，但也存在一些缺点，例如： 父类的引用类型属性会被所有子类实例共享，容易造成修改冲突。 不能向父类的构造函数传递参数。 在创建子类实例时，无法向父类构造函数中传递参数。 9.1.5 封装语法在 ES5 中，通过使用函数作用域和闭包，可以实现对象的封装。具体来说，我们可以使用函数作为对象的构造函数，并在构造函数内部定义变量和方法，并使用闭包来保护这些私有属性和方法，使得它们不能被外界直接访问。 下面是一个简单的封装示例： function Person(name, age) { var _name = name; var _age = age; function getName() { return _name; } function getAge() { return _age; } function setName(name) { _name = name; } function setAge(age) { _age = age; } this.sayHello = function() { console.log(\"Hello, my name is \" + _name + \", I'm \" + _age + \" years old.\"); }; Object.defineProperty(this, \"name\", { get: getName, set: setName }); Object.defineProperty(this, \"age\", { get: getAge, set: setAge }); } var tom = new Person(\"Tom\", 29); console.log(tom.name); // 输出：Tom console.log(tom.age); // 输出：29 tom.sayHello(); // 输出：Hello, my name is Tom, I'm 29 years old. tom.name = \"Jerry\"; tom.age = 30; console.log(tom.name); // 输出：Jerry console.log(tom.age); // 输出：30 tom.sayHello(); // 输出：Hello, my name is Jerry, I'm 30 years old. 在上面的示例中，我们使用函数作为 Person 的构造函数，并在构造函数内部定义了变量 _name 和 _age，以及方法 getName()、getAge()、setName() 和 setAge()。这些变量和方法通过闭包来保护，使得它们只能在构造函数内部被访问。 为了使得外部代码可以访问到对象的属性 name 和 age，我们使用 Object.defineProperty() 方法给对象定义了 getter 和 setter。 最后，我们还在对象的原型上定义了公共方法 sayHello()，用于向外界展示对象的信息。 通过封装，我们可以将对象的实现细节隐藏起来，避免外部直接访问和修改对象的内部状态，从而提高了代码的安全性和可维护性。 ","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#构造函数"},{"categories":["前端知识"],"content":" 9.1 创建对象(ES5) ES5设计的面向对象真的麻烦 9.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 9.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 9.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 9.1.4 继承语法在 ES5 中，我们可以使用原型链来实现对象的继承。具体来说，就是通过创建一个新的构造函数，并将父类的实例作为新构造函数的原型，从而实现继承。 下面是一个简单的继承示例： function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); }; function Student(name, age, grade) { Person.call(this, name, age); // 调用父类的构造函数 this.grade = grade; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.study = function() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); }; var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了两个构造函数 Person 和 Student，并通过原型链实现了 Student 继承了 Person。具体来说，我们通过 Object.create() 方法创建了一个空对象，并把 Person.prototype 赋值给这个空对象的原型，然后再把这个新对象赋值给 Student.prototype，这样就建立了 Student 的原型链。最后，我们还需要重置 Student.prototype 的构造函数为 Student，以确保继承关系正确。 在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 Person.call(this, name, age)，其中的 this 指代的是子类的实例，并将父类的属性赋值给子类的实例。这样，子类就可以继承父类的属性和方法。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过原型链继承虽然比较简单，但也存在一些缺点，例如： 父类的引用类型属性会被所有子类实例共享，容易造成修改冲突。 不能向父类的构造函数传递参数。 在创建子类实例时，无法向父类构造函数中传递参数。 9.1.5 封装语法在 ES5 中，通过使用函数作用域和闭包，可以实现对象的封装。具体来说，我们可以使用函数作为对象的构造函数，并在构造函数内部定义变量和方法，并使用闭包来保护这些私有属性和方法，使得它们不能被外界直接访问。 下面是一个简单的封装示例： function Person(name, age) { var _name = name; var _age = age; function getName() { return _name; } function getAge() { return _age; } function setName(name) { _name = name; } function setAge(age) { _age = age; } this.sayHello = function() { console.log(\"Hello, my name is \" + _name + \", I'm \" + _age + \" years old.\"); }; Object.defineProperty(this, \"name\", { get: getName, set: setName }); Object.defineProperty(this, \"age\", { get: getAge, set: setAge }); } var tom = new Person(\"Tom\", 29); console.log(tom.name); // 输出：Tom console.log(tom.age); // 输出：29 tom.sayHello(); // 输出：Hello, my name is Tom, I'm 29 years old. tom.name = \"Jerry\"; tom.age = 30; console.log(tom.name); // 输出：Jerry console.log(tom.age); // 输出：30 tom.sayHello(); // 输出：Hello, my name is Jerry, I'm 30 years old. 在上面的示例中，我们使用函数作为 Person 的构造函数，并在构造函数内部定义了变量 _name 和 _age，以及方法 getName()、getAge()、setName() 和 setAge()。这些变量和方法通过闭包来保护，使得它们只能在构造函数内部被访问。 为了使得外部代码可以访问到对象的属性 name 和 age，我们使用 Object.defineProperty() 方法给对象定义了 getter 和 setter。 最后，我们还在对象的原型上定义了公共方法 sayHello()，用于向外界展示对象的信息。 通过封装，我们可以将对象的实现细节隐藏起来，避免外部直接访问和修改对象的内部状态，从而提高了代码的安全性和可维护性。 ","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#继承语法"},{"categories":["前端知识"],"content":" 9.1 创建对象(ES5) ES5设计的面向对象真的麻烦 9.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 9.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 9.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 9.1.4 继承语法在 ES5 中，我们可以使用原型链来实现对象的继承。具体来说，就是通过创建一个新的构造函数，并将父类的实例作为新构造函数的原型，从而实现继承。 下面是一个简单的继承示例： function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHello = function() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); }; function Student(name, age, grade) { Person.call(this, name, age); // 调用父类的构造函数 this.grade = grade; } Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; Student.prototype.study = function() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); }; var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了两个构造函数 Person 和 Student，并通过原型链实现了 Student 继承了 Person。具体来说，我们通过 Object.create() 方法创建了一个空对象，并把 Person.prototype 赋值给这个空对象的原型，然后再把这个新对象赋值给 Student.prototype，这样就建立了 Student 的原型链。最后，我们还需要重置 Student.prototype 的构造函数为 Student，以确保继承关系正确。 在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 Person.call(this, name, age)，其中的 this 指代的是子类的实例，并将父类的属性赋值给子类的实例。这样，子类就可以继承父类的属性和方法。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过原型链继承虽然比较简单，但也存在一些缺点，例如： 父类的引用类型属性会被所有子类实例共享，容易造成修改冲突。 不能向父类的构造函数传递参数。 在创建子类实例时，无法向父类构造函数中传递参数。 9.1.5 封装语法在 ES5 中，通过使用函数作用域和闭包，可以实现对象的封装。具体来说，我们可以使用函数作为对象的构造函数，并在构造函数内部定义变量和方法，并使用闭包来保护这些私有属性和方法，使得它们不能被外界直接访问。 下面是一个简单的封装示例： function Person(name, age) { var _name = name; var _age = age; function getName() { return _name; } function getAge() { return _age; } function setName(name) { _name = name; } function setAge(age) { _age = age; } this.sayHello = function() { console.log(\"Hello, my name is \" + _name + \", I'm \" + _age + \" years old.\"); }; Object.defineProperty(this, \"name\", { get: getName, set: setName }); Object.defineProperty(this, \"age\", { get: getAge, set: setAge }); } var tom = new Person(\"Tom\", 29); console.log(tom.name); // 输出：Tom console.log(tom.age); // 输出：29 tom.sayHello(); // 输出：Hello, my name is Tom, I'm 29 years old. tom.name = \"Jerry\"; tom.age = 30; console.log(tom.name); // 输出：Jerry console.log(tom.age); // 输出：30 tom.sayHello(); // 输出：Hello, my name is Jerry, I'm 30 years old. 在上面的示例中，我们使用函数作为 Person 的构造函数，并在构造函数内部定义了变量 _name 和 _age，以及方法 getName()、getAge()、setName() 和 setAge()。这些变量和方法通过闭包来保护，使得它们只能在构造函数内部被访问。 为了使得外部代码可以访问到对象的属性 name 和 age，我们使用 Object.defineProperty() 方法给对象定义了 getter 和 setter。 最后，我们还在对象的原型上定义了公共方法 sayHello()，用于向外界展示对象的信息。 通过封装，我们可以将对象的实现细节隐藏起来，避免外部直接访问和修改对象的内部状态，从而提高了代码的安全性和可维护性。 ","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装语法"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建对象es6"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#继承语法-1"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装语法-1"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#类class"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#构造函数constructor"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#get和set方法"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#symbol类型"},{"categories":["前端知识"],"content":" 9.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 9.2.1 继承语法在 ES6 中，我们可以使用 class 关键字来定义一个类，并使用 extends 关键字来实现继承。具体来说，我们可以定义一个子类并通过 extends 关键字指定它的父类，从而实现子类继承父类的所有属性和方法。 下面是一个简单的继承示例： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(\"Hello, my name is \" + this.name + \", I'm \" + this.age + \" years old.\"); } } class Student extends Person { constructor(name, age, grade) { super(name, age); // 调用父类的构造函数 this.grade = grade; } study() { console.log(this.name + \" is studying in grade \" + this.grade + \".\"); } } var jerry = new Student(\"Jerry\", 12, 6); jerry.sayHello(); // 输出：Hello, my name is Jerry, I'm 12 years old. jerry.study(); // 输出：Jerry is studying in grade 6. 在上面的示例中，我们定义了一个 Person 类作为父类，并定义了两个实例属性 name 和 age，以及一个实例方法 sayHello()。然后，我们定义了一个 Student 类作为子类，并通过 extends 关键字让它继承了 Person 类的所有属性和方法。在子类的构造函数中，我们需要调用父类的构造函数来初始化父类的属性。这里使用了 super() 方法，其中的 super 指代的是父类的构造函数。 在子类的原型上，我们还可以定义新的方法，例如 study() 方法。 通过类继承，不仅可以实现继承，还可以实现多态和封装等面向对象编程的基本概念，同时也更易于理解和使用，代码可读性更高。 需要注意的是，在子类中重写父类的方法时，如果要调用父类的方法，可以通过 super 关键字来调用父类的同名方法。例如： class Person { sayHello() { console.log(\"Hello, I'm a person.\"); } } class Student extends Person { sayHello() { super.sayHello(); // 调用父类的 sayHello() 方法 console.log(\"I'm a student.\"); } } var jerry = new Student(); jerry.sayHello(); // 输出：Hello, I'm a person. I'm a student. 以上就是 ES6 中继承的语法和用法。相较于 ES5 中的原型链继承，ES6 的类继承更加灵活易用，同时也符合面向对象编程的基本概念和规范。 9.2.2 封装语法ES6中提供了一些封装语法，可以用来实现面向对象编程中的封装。 其中包括： 类(Class)：使用class关键字定义一个类，可以封装属性和方法。 构造函数(Constructor)：使用constructor方法定义一个构造函数，可以在创建对象时初始化对象的属性。 get和set方法：可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 Symbol类型：可以使用Symbol类型定义一个独一无二的属性，为类添加私有变量。 封装模块(Module)：使用export和import关键字将模块封装成一个独立的单元。 Proxy代理：使用Proxy代理可以控制对类和对象的访问，实现更加精细的权限控制。 这些封装语法可以帮助开发者更好地实现代码的封装，提高代码的可维护性和安全性。 9.2.2.1 类(Class)可以使用class关键字定义一个类，包含属性和方法。下面是一个简单的例子： class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`); } } 在这个例子中，我们定义了一个名为Person的类，它有两个属性name和age以及一个方法sayHello。构造函数constructor会在实例化对象时被调用，用来初始化属性值。方法sayHello用来输出属性值。 可以通过以下方式创建Person的实例： javascript复制代码const person = new Person('Tom', 18); person.sayHello(); // Hello, my name is Tom, I'm 18 years old. 9.2.2.2 构造函数(Constructor)构造函数是类中特殊的方法，在类实例化时被调用，用来初始化对象的属性。 class Person { constructor(name, age) { this.name = name; this.age = age; } } 在这个例子中，我们定义了一个名为Person的类，构造函数constructor接受两个参数name和age，并将它们分别赋值给实例的属性name和age。 9.2.2.3 get和set方法可以使用get和set方法对类的属性进行读取和设置操作，从而实现隐藏属性的细节。 class Person { constructor(name, age) { this._name = name; this._age = age; } get name() { return this._name; } set name(name) { this._name = name; } get age() { return this._age; } set age(age) { this._age = age; } } 在这个例子中，我们使用get和set方法来封装属性name和age。注意：我们将实际存储数据的变量名改为了以\"_“开头的变量名，避免与get和set方法同名而造成冲突。 可以通过以下方式读取或设置Person的实例的属性： javascript复制代码const person = new Person('Tom', 18); console.log(person.name); // Tom person.name = 'Jerry'; console.log(person.name); // Jerry 9.2.2.4 Symbol类型Symbol类型是ES6新增的一种基本数据类型，可以用来定义独一无二的属性值，从而达到隐藏属性的目的。 javascript复制代码const _name = Symbol('name'); const _age = Symbol('age'); class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; } set name(name) { this[_name] = name; } get age() { return this[_age]; } set age(age) { this[_age] = age; } } 在这个例子中，我们使用Symbol类型创建了两个唯一的属性_name和_age，并通过get和set方法来封装属性。 9.2.2.5 封装模块(Module)可以使用export和import关键字将模块封装成一个独立的单元，从而实现代码的模块化和封装。 // person.js const _name = Symbol('name'); const _age = Symbol('age'); export class Person { constructor(name, age) { this[_name] = name; this[_age] = age; } get name() { return this[_name]; }","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装模块module"},{"categories":["前端知识"],"content":" 9.3 访问成员 访问成员的方式存在两种 C方式:对象名.成员名 反射式:对象名['成员名'] 'use strict'; var student = { name: \"hello\", age: 18 }; console.log(student.name); // hello console.log(student['age']); // 18 ","date":"2021-10-07","objectID":"/javascript/:9:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#访问成员"},{"categories":["前端知识"],"content":" 10 标准对象 JS为我们定义的标准对象 Map(映射) Set(集合) Date(日期) RegExp(正则表达式) JSON(JSON) Math(数学) ","date":"2021-10-07","objectID":"/javascript/:10:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#标准对象"},{"categories":["前端知识"],"content":" 10.1 Map(映射)Map 是一种用于在 JavaScript 中存储键值对的数据结构，其中每个键唯一且与一个值关联。它是 ES6 中引入的新类型之一。以下是使用 Map 的一些基本操作： 创建 Map 对象 可以通过以下方式创建一个空 Map 对象： const myMap = new Map(); 也可以将初始键值对作为数组传递给 Map 构造函数： const myMap = new Map([['key1', 'value1'], ['key2', 'value2']]); 在 Map 中添加/更新键值对 可以使用 set() 方法向 Map 中添加键值对。如果键已经存在，则会更新其对应的值。 myMap.set('key3', 'value3'); 从 Map 中获取值 可以使用 get() 方法从 Map 中获取与给定键相关联的值。如果该键不存在，则返回 undefined。 console.log(myMap.get('key1')); // 输出 \"value1\" console.log(myMap.get('nonexistentKey')); // 输出 \"undefined\" 检查 Map 中是否存在某个键 可以使用 has() 方法检查 Map 中是否存在指定的键。 console.log(myMap.has('key1')); // 输出 \"true\" console.log(myMap.has('nonexistentKey')); // 输出 \"false\" 从 Map 中删除某个键值对 可以使用 delete() 方法从 Map 中删除指定的键值对。 myMap.delete('key2'); 获取 Map 中键值对的数量 可以使用 size 属性获取 Map 中键值对的数量。 console.log(myMap.size); // 输出 \"2\" 以上是一些基本操作，还可以使用 forEach() 方法遍历 Map 中的所有键值对。在这个方法中，每个键值对将作为参数传递给回调函数。 myMap.forEach(function(value, key) { console.log(key + ' = ' + value); }); 希望这些基本操作能够帮助你了解如何使用 Map 在 JavaScript 中存储和操作键值对。 ","date":"2021-10-07","objectID":"/javascript/:10:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#map映射"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#set集合"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建set"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#向set中添加元素"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#从set中删除元素"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#检查set中是否存在元素"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#获取set中的元素数量"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#遍历set对象"},{"categories":["前端知识"],"content":" 10.2 Set(集合)JavaScript中的Set对象是ES6中新增的一种数据结构，它可以帮助我们快速地存储和检索一些独特的值。本文将简要介绍Set对象以及如何使用它。 10.2.1 创建Set我们可以使用new关键字来创建一个新的Set对象，例如： const mySet = new Set() 这将创建一个名为mySet的空Set对象。如果我们想初始化Set对象并传入一些值，则可以在创建时将一个可迭代对象作为参数传递，例如： const mySet = new Set([1, 2, 3]) 这将创建一个名为mySet的Set对象，并将1、2和3添加到其中。 10.2.2 向Set中添加元素我们可以使用add()方法向Set对象中添加元素，例如： mySet.add(4) 这将向mySet中添加数字4。 请注意，Set对象只能包含唯一的值，因此如果我们尝试向Set中添加一个已经存在的值，它将被忽略。 10.2.3 从Set中删除元素我们可以使用delete()方法从Set对象中删除元素，例如： mySet.delete(4) 这将从mySet中删除数字4。 10.2.4 检查Set中是否存在元素我们可以使用has()方法来检查Set对象中是否存在某个元素，例如： mySet.has(3) // true mySet.has(4) // false 10.2.5 获取Set中的元素数量我们可以使用size属性来获取Set对象中元素的数量，例如： mySet.size // 3 10.2.6 遍历Set对象我们可以使用forEach()方法或者for...of循环来遍历Set对象中的元素，例如： // 使用forEach() mySet.forEach(function(value) { console.log(value) }) // 使用for...of for (const value of mySet) { console.log(value) } 这些代码将输出Set对象中的每个元素。 10.2.7 将Set转换为数组我们可以使用扩展运算符(...)或者Array.from()方法将Set对象转换为数组，例如： // 使用扩展运算符 const myArray = [...mySet] // 使用Array.from() const myArray = Array.from(mySet) 这些代码将创建一个名为myArray的数组，并将Set对象中的所有元素添加到其中。 ","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#将set转换为数组"},{"categories":["前端知识"],"content":" 10.3 Date(日期)在JavaScript中，Date对象是一种用于处理日期和时间的内置对象。我们可以使用它来获取当前日期和时间、创建指定日期的实例、执行日期和时间计算等操作。本文将介绍如何使用Date对象。 10.3.1 获取当前日期和时间我们可以使用new Date()构造函数来创建一个Date对象，该对象将包含当前日期和时间。例如： const now = new Date() console.log(now) // 输出当前日期和时间 10.3.2 创建指定日期的实例我们可以使用new Date(year, month, day, hours, minutes, seconds, milliseconds)构造函数来创建一个指定日期和时间的Date对象。其中，year表示年份（从1900开始），month表示月份（0表示1月，11表示12月），day表示日期（从1开始）。hours、minutes、seconds和milliseconds分别表示小时、分钟、秒和毫秒数。如果这些参数中任意一个省略，则默认为0。例如： const someDate = new Date(2023, 5, 15, 8, 30) console.log(someDate) // 输出2023年6月15日 08:30:00 10.3.3 获取Date对象的值我们可以使用Date对象的各种方法来获取其表示的日期和时间。例如： const date = new Date() // 获取年份（四位数） const year = date.getFullYear() console.log(year) // 获取月份（0-11） const month = date.getMonth() console.log(month) // 获取日期（1-31） const day = date.getDate() console.log(day) // 获取星期几（0-6，0表示星期日） const weekday = date.getDay() console.log(weekday) // 获取小时数（0-23） const hours = date.getHours() console.log(hours) // 获取分钟数（0-59） const minutes = date.getMinutes() console.log(minutes) // 获取秒数（0-59） const seconds = date.getSeconds() console.log(seconds) // 获取毫秒数 const milliseconds = date.getMilliseconds() console.log(milliseconds) 10.3.4 设置Date对象的值我们可以使用各种set方法来设置Date对象表示的日期和时间。例如： const date = new Date() // 设置年份 date.setFullYear(2023) // 设置月份 date.setMonth(5) // 月份从0开始计数 // 设置日期 date.setDate(15) // 设置小时数 date.setHours(8) // 设置分钟数 date.setMinutes(30) // 设置秒数 date.setSeconds(0) // 设置毫秒数 date.setMilliseconds(0) console.log(date) // 输出2023年6月15日 08:30:00 10.3.5 执行日期和时间计算我们可以使用各种算术运算符和函数来执行日期和时间计算。例如： const now = new Date() // 将日期增加1天 const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000) console.log(tomorrow) // 计算两个日期之间的天数差 const start = new Date(2023, 5, 1) const end = new Date(2023, 5, 15) const days = Math.floor((end - start) / (24 * 60 * 60 * 1000)) console.log(days) 这些代码将增加当前日期1天，并计算6月1日和6月15日之间的天数差。 ","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#date日期"},{"categories":["前端知识"],"content":" 10.3 Date(日期)在JavaScript中，Date对象是一种用于处理日期和时间的内置对象。我们可以使用它来获取当前日期和时间、创建指定日期的实例、执行日期和时间计算等操作。本文将介绍如何使用Date对象。 10.3.1 获取当前日期和时间我们可以使用new Date()构造函数来创建一个Date对象，该对象将包含当前日期和时间。例如： const now = new Date() console.log(now) // 输出当前日期和时间 10.3.2 创建指定日期的实例我们可以使用new Date(year, month, day, hours, minutes, seconds, milliseconds)构造函数来创建一个指定日期和时间的Date对象。其中，year表示年份（从1900开始），month表示月份（0表示1月，11表示12月），day表示日期（从1开始）。hours、minutes、seconds和milliseconds分别表示小时、分钟、秒和毫秒数。如果这些参数中任意一个省略，则默认为0。例如： const someDate = new Date(2023, 5, 15, 8, 30) console.log(someDate) // 输出2023年6月15日 08:30:00 10.3.3 获取Date对象的值我们可以使用Date对象的各种方法来获取其表示的日期和时间。例如： const date = new Date() // 获取年份（四位数） const year = date.getFullYear() console.log(year) // 获取月份（0-11） const month = date.getMonth() console.log(month) // 获取日期（1-31） const day = date.getDate() console.log(day) // 获取星期几（0-6，0表示星期日） const weekday = date.getDay() console.log(weekday) // 获取小时数（0-23） const hours = date.getHours() console.log(hours) // 获取分钟数（0-59） const minutes = date.getMinutes() console.log(minutes) // 获取秒数（0-59） const seconds = date.getSeconds() console.log(seconds) // 获取毫秒数 const milliseconds = date.getMilliseconds() console.log(milliseconds) 10.3.4 设置Date对象的值我们可以使用各种set方法来设置Date对象表示的日期和时间。例如： const date = new Date() // 设置年份 date.setFullYear(2023) // 设置月份 date.setMonth(5) // 月份从0开始计数 // 设置日期 date.setDate(15) // 设置小时数 date.setHours(8) // 设置分钟数 date.setMinutes(30) // 设置秒数 date.setSeconds(0) // 设置毫秒数 date.setMilliseconds(0) console.log(date) // 输出2023年6月15日 08:30:00 10.3.5 执行日期和时间计算我们可以使用各种算术运算符和函数来执行日期和时间计算。例如： const now = new Date() // 将日期增加1天 const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000) console.log(tomorrow) // 计算两个日期之间的天数差 const start = new Date(2023, 5, 1) const end = new Date(2023, 5, 15) const days = Math.floor((end - start) / (24 * 60 * 60 * 1000)) console.log(days) 这些代码将增加当前日期1天，并计算6月1日和6月15日之间的天数差。 ","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#获取当前日期和时间"},{"categories":["前端知识"],"content":" 10.3 Date(日期)在JavaScript中，Date对象是一种用于处理日期和时间的内置对象。我们可以使用它来获取当前日期和时间、创建指定日期的实例、执行日期和时间计算等操作。本文将介绍如何使用Date对象。 10.3.1 获取当前日期和时间我们可以使用new Date()构造函数来创建一个Date对象，该对象将包含当前日期和时间。例如： const now = new Date() console.log(now) // 输出当前日期和时间 10.3.2 创建指定日期的实例我们可以使用new Date(year, month, day, hours, minutes, seconds, milliseconds)构造函数来创建一个指定日期和时间的Date对象。其中，year表示年份（从1900开始），month表示月份（0表示1月，11表示12月），day表示日期（从1开始）。hours、minutes、seconds和milliseconds分别表示小时、分钟、秒和毫秒数。如果这些参数中任意一个省略，则默认为0。例如： const someDate = new Date(2023, 5, 15, 8, 30) console.log(someDate) // 输出2023年6月15日 08:30:00 10.3.3 获取Date对象的值我们可以使用Date对象的各种方法来获取其表示的日期和时间。例如： const date = new Date() // 获取年份（四位数） const year = date.getFullYear() console.log(year) // 获取月份（0-11） const month = date.getMonth() console.log(month) // 获取日期（1-31） const day = date.getDate() console.log(day) // 获取星期几（0-6，0表示星期日） const weekday = date.getDay() console.log(weekday) // 获取小时数（0-23） const hours = date.getHours() console.log(hours) // 获取分钟数（0-59） const minutes = date.getMinutes() console.log(minutes) // 获取秒数（0-59） const seconds = date.getSeconds() console.log(seconds) // 获取毫秒数 const milliseconds = date.getMilliseconds() console.log(milliseconds) 10.3.4 设置Date对象的值我们可以使用各种set方法来设置Date对象表示的日期和时间。例如： const date = new Date() // 设置年份 date.setFullYear(2023) // 设置月份 date.setMonth(5) // 月份从0开始计数 // 设置日期 date.setDate(15) // 设置小时数 date.setHours(8) // 设置分钟数 date.setMinutes(30) // 设置秒数 date.setSeconds(0) // 设置毫秒数 date.setMilliseconds(0) console.log(date) // 输出2023年6月15日 08:30:00 10.3.5 执行日期和时间计算我们可以使用各种算术运算符和函数来执行日期和时间计算。例如： const now = new Date() // 将日期增加1天 const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000) console.log(tomorrow) // 计算两个日期之间的天数差 const start = new Date(2023, 5, 1) const end = new Date(2023, 5, 15) const days = Math.floor((end - start) / (24 * 60 * 60 * 1000)) console.log(days) 这些代码将增加当前日期1天，并计算6月1日和6月15日之间的天数差。 ","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建指定日期的实例"},{"categories":["前端知识"],"content":" 10.3 Date(日期)在JavaScript中，Date对象是一种用于处理日期和时间的内置对象。我们可以使用它来获取当前日期和时间、创建指定日期的实例、执行日期和时间计算等操作。本文将介绍如何使用Date对象。 10.3.1 获取当前日期和时间我们可以使用new Date()构造函数来创建一个Date对象，该对象将包含当前日期和时间。例如： const now = new Date() console.log(now) // 输出当前日期和时间 10.3.2 创建指定日期的实例我们可以使用new Date(year, month, day, hours, minutes, seconds, milliseconds)构造函数来创建一个指定日期和时间的Date对象。其中，year表示年份（从1900开始），month表示月份（0表示1月，11表示12月），day表示日期（从1开始）。hours、minutes、seconds和milliseconds分别表示小时、分钟、秒和毫秒数。如果这些参数中任意一个省略，则默认为0。例如： const someDate = new Date(2023, 5, 15, 8, 30) console.log(someDate) // 输出2023年6月15日 08:30:00 10.3.3 获取Date对象的值我们可以使用Date对象的各种方法来获取其表示的日期和时间。例如： const date = new Date() // 获取年份（四位数） const year = date.getFullYear() console.log(year) // 获取月份（0-11） const month = date.getMonth() console.log(month) // 获取日期（1-31） const day = date.getDate() console.log(day) // 获取星期几（0-6，0表示星期日） const weekday = date.getDay() console.log(weekday) // 获取小时数（0-23） const hours = date.getHours() console.log(hours) // 获取分钟数（0-59） const minutes = date.getMinutes() console.log(minutes) // 获取秒数（0-59） const seconds = date.getSeconds() console.log(seconds) // 获取毫秒数 const milliseconds = date.getMilliseconds() console.log(milliseconds) 10.3.4 设置Date对象的值我们可以使用各种set方法来设置Date对象表示的日期和时间。例如： const date = new Date() // 设置年份 date.setFullYear(2023) // 设置月份 date.setMonth(5) // 月份从0开始计数 // 设置日期 date.setDate(15) // 设置小时数 date.setHours(8) // 设置分钟数 date.setMinutes(30) // 设置秒数 date.setSeconds(0) // 设置毫秒数 date.setMilliseconds(0) console.log(date) // 输出2023年6月15日 08:30:00 10.3.5 执行日期和时间计算我们可以使用各种算术运算符和函数来执行日期和时间计算。例如： const now = new Date() // 将日期增加1天 const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000) console.log(tomorrow) // 计算两个日期之间的天数差 const start = new Date(2023, 5, 1) const end = new Date(2023, 5, 15) const days = Math.floor((end - start) / (24 * 60 * 60 * 1000)) console.log(days) 这些代码将增加当前日期1天，并计算6月1日和6月15日之间的天数差。 ","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#获取date对象的值"},{"categories":["前端知识"],"content":" 10.3 Date(日期)在JavaScript中，Date对象是一种用于处理日期和时间的内置对象。我们可以使用它来获取当前日期和时间、创建指定日期的实例、执行日期和时间计算等操作。本文将介绍如何使用Date对象。 10.3.1 获取当前日期和时间我们可以使用new Date()构造函数来创建一个Date对象，该对象将包含当前日期和时间。例如： const now = new Date() console.log(now) // 输出当前日期和时间 10.3.2 创建指定日期的实例我们可以使用new Date(year, month, day, hours, minutes, seconds, milliseconds)构造函数来创建一个指定日期和时间的Date对象。其中，year表示年份（从1900开始），month表示月份（0表示1月，11表示12月），day表示日期（从1开始）。hours、minutes、seconds和milliseconds分别表示小时、分钟、秒和毫秒数。如果这些参数中任意一个省略，则默认为0。例如： const someDate = new Date(2023, 5, 15, 8, 30) console.log(someDate) // 输出2023年6月15日 08:30:00 10.3.3 获取Date对象的值我们可以使用Date对象的各种方法来获取其表示的日期和时间。例如： const date = new Date() // 获取年份（四位数） const year = date.getFullYear() console.log(year) // 获取月份（0-11） const month = date.getMonth() console.log(month) // 获取日期（1-31） const day = date.getDate() console.log(day) // 获取星期几（0-6，0表示星期日） const weekday = date.getDay() console.log(weekday) // 获取小时数（0-23） const hours = date.getHours() console.log(hours) // 获取分钟数（0-59） const minutes = date.getMinutes() console.log(minutes) // 获取秒数（0-59） const seconds = date.getSeconds() console.log(seconds) // 获取毫秒数 const milliseconds = date.getMilliseconds() console.log(milliseconds) 10.3.4 设置Date对象的值我们可以使用各种set方法来设置Date对象表示的日期和时间。例如： const date = new Date() // 设置年份 date.setFullYear(2023) // 设置月份 date.setMonth(5) // 月份从0开始计数 // 设置日期 date.setDate(15) // 设置小时数 date.setHours(8) // 设置分钟数 date.setMinutes(30) // 设置秒数 date.setSeconds(0) // 设置毫秒数 date.setMilliseconds(0) console.log(date) // 输出2023年6月15日 08:30:00 10.3.5 执行日期和时间计算我们可以使用各种算术运算符和函数来执行日期和时间计算。例如： const now = new Date() // 将日期增加1天 const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000) console.log(tomorrow) // 计算两个日期之间的天数差 const start = new Date(2023, 5, 1) const end = new Date(2023, 5, 15) const days = Math.floor((end - start) / (24 * 60 * 60 * 1000)) console.log(days) 这些代码将增加当前日期1天，并计算6月1日和6月15日之间的天数差。 ","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#设置date对象的值"},{"categories":["前端知识"],"content":" 10.3 Date(日期)在JavaScript中，Date对象是一种用于处理日期和时间的内置对象。我们可以使用它来获取当前日期和时间、创建指定日期的实例、执行日期和时间计算等操作。本文将介绍如何使用Date对象。 10.3.1 获取当前日期和时间我们可以使用new Date()构造函数来创建一个Date对象，该对象将包含当前日期和时间。例如： const now = new Date() console.log(now) // 输出当前日期和时间 10.3.2 创建指定日期的实例我们可以使用new Date(year, month, day, hours, minutes, seconds, milliseconds)构造函数来创建一个指定日期和时间的Date对象。其中，year表示年份（从1900开始），month表示月份（0表示1月，11表示12月），day表示日期（从1开始）。hours、minutes、seconds和milliseconds分别表示小时、分钟、秒和毫秒数。如果这些参数中任意一个省略，则默认为0。例如： const someDate = new Date(2023, 5, 15, 8, 30) console.log(someDate) // 输出2023年6月15日 08:30:00 10.3.3 获取Date对象的值我们可以使用Date对象的各种方法来获取其表示的日期和时间。例如： const date = new Date() // 获取年份（四位数） const year = date.getFullYear() console.log(year) // 获取月份（0-11） const month = date.getMonth() console.log(month) // 获取日期（1-31） const day = date.getDate() console.log(day) // 获取星期几（0-6，0表示星期日） const weekday = date.getDay() console.log(weekday) // 获取小时数（0-23） const hours = date.getHours() console.log(hours) // 获取分钟数（0-59） const minutes = date.getMinutes() console.log(minutes) // 获取秒数（0-59） const seconds = date.getSeconds() console.log(seconds) // 获取毫秒数 const milliseconds = date.getMilliseconds() console.log(milliseconds) 10.3.4 设置Date对象的值我们可以使用各种set方法来设置Date对象表示的日期和时间。例如： const date = new Date() // 设置年份 date.setFullYear(2023) // 设置月份 date.setMonth(5) // 月份从0开始计数 // 设置日期 date.setDate(15) // 设置小时数 date.setHours(8) // 设置分钟数 date.setMinutes(30) // 设置秒数 date.setSeconds(0) // 设置毫秒数 date.setMilliseconds(0) console.log(date) // 输出2023年6月15日 08:30:00 10.3.5 执行日期和时间计算我们可以使用各种算术运算符和函数来执行日期和时间计算。例如： const now = new Date() // 将日期增加1天 const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000) console.log(tomorrow) // 计算两个日期之间的天数差 const start = new Date(2023, 5, 1) const end = new Date(2023, 5, 15) const days = Math.floor((end - start) / (24 * 60 * 60 * 1000)) console.log(days) 这些代码将增加当前日期1天，并计算6月1日和6月15日之间的天数差。 ","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#执行日期和时间计算"},{"categories":["前端知识"],"content":" 10.4 RegExp(正则表达式)","date":"2021-10-07","objectID":"/javascript/:10:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#regexp正则表达式"},{"categories":["前端知识"],"content":" 10.5 JSON(JSON) 序列化: stringify() 反序列化: parse() var text = '{ \"student\" : [' + '{ \"name\":\"hello\" , \"age\": 18 },' + '{ \"name\":\"world\" , \"age\": 18 }]}'; var jsonObj = JSON.parse(text); var jsonTxt = JSON.stringify(jsonObj); console.log(jsonObj); console.log(jsonTxt); ","date":"2021-10-07","objectID":"/javascript/:10:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#jsonjson"},{"categories":["前端知识"],"content":" 10.6 Math(数学) 与其他全局对象不同的是，Math 不是一个构造器。 Math 的所有属性与方法都是静态的. 引用圆周率的写法是 Math.PI,调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参数。 Math 的常量是使用 JavaScript 中的全精度浮点数来定义的。 Math 用于 Number 类型。它不支持 BigInt // 常数 console.log(\"自然常数: \" + Math.E); console.log(\"2的自然对数: \" + Math.LN2); console.log(\"10的自然对数: \" + Math.LN10); // 函数 console.log(\"-10的绝对值: \" + Math.abs(-10)); console.log(\"10的正弦值: \" + Math.sin(10)); console.log(\"10的余弦值: \" + Math.cos(10)); 输出值 $ node Math.js 自然常数: 2.718281828459045 2的自然对数: 0.6931471805599453 10的自然对数: 2.302585092994046 -10的绝对值: 10 10的正弦值: -0.5440211108893698 10的余弦值: -0.8390715290764524 ","date":"2021-10-07","objectID":"/javascript/:10:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#math数学"},{"categories":["前端知识"],"content":" 11 宿主对象 由浏览器提供的对象 window navigator location document history ","date":"2021-10-07","objectID":"/javascript/:11:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#宿主对象"},{"categories":["前端知识"],"content":" 11.1 window window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档。 使用 document.defaultView 属性可以获取指定文档所在窗口。 window作为全局变量，代表了脚本正在运行的窗口，暴露给 Javascript 代码。 ","date":"2021-10-07","objectID":"/javascript/:11:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#window"},{"categories":["前端知识"],"content":" 11.2 navigator","date":"2021-10-07","objectID":"/javascript/:11:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#navigator"},{"categories":["前端知识"],"content":" 11.3 location","date":"2021-10-07","objectID":"/javascript/:11:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#location"},{"categories":["前端知识"],"content":" 11.4 document","date":"2021-10-07","objectID":"/javascript/:11:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#document"},{"categories":["前端知识"],"content":" 11.5 history","date":"2021-10-07","objectID":"/javascript/:11:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#history"},{"categories":["前端知识"],"content":" 11.6 cookie","date":"2021-10-07","objectID":"/javascript/:11:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#cookie"},{"categories":["前端知识"],"content":" 12 DOM 文档对象模型(DOM)将web页面与到脚本或编程语言连接起来. JS通过DOM访问文档; DOM（Document Object Model）指的是文档对象模型，它是一种用来访问和操作HTML文档的API。在JavaScript中，可以使用DOM API来访问和修改HTML文档中的元素、属性和样式等内容。 以下是一个简单的DOM操作示例： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eDOM示例\u003c/title\u003e \u003cscript\u003e window.onload = function() { var element = document.getElementById(\"myElement\"); element.innerHTML = \"Hello DOM!\"; }; \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"myElement\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 上述代码将在页面加载完成后，使用document对象的getElementById方法获取id为\"myElement\"的元素，并将其innerHTML属性设置为\"Hello DOM!\"。 下面是一些常见的DOM操作： 获取元素： 可以使用document对象的getElementById、getElementsByClassName、getElementsByTagName等方法获取HTML元素，例如： var element = document.getElementById(\"myElement\"); var elements = document.getElementsByClassName(\"myClass\"); var elements = document.getElementsByTagName(\"div\"); 修改元素： 可以使用元素的innerHTML、textContent、setAttribute等属性或方法来修改元素的内容和属性，例如： element.innerHTML = \"New content\"; element.setAttribute(\"class\", \"newClass\"); 添加新元素： 可以使用document.createElement方法创建新元素，然后使用appendChild或insertBefore方法将其添加到文档中，例如： var newElement = document.createElement(\"div\"); newElement.innerHTML = \"New element\"; document.body.appendChild(newElement); 删除元素： 可以使用元素的removeChild方法或parentElement.removeChild方法将元素从文档中删除，例如： var element = document.getElementById(\"myElement\"); element.parentElement.removeChild(element); 除了以上列出的DOM操作，还有许多其他的操作，如动态修改样式、注册事件处理程序等。总之，DOM提供了一些强大的API，使得JavaScript能够更好地控制和访问HTML文档中的元素、属性和样式等内容。 测试程序 这里有一个div标签\r程序会将上面的这里有一个div标签改写成Hello DOM! ","date":"2021-10-07","objectID":"/javascript/:12:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#dom"},{"categories":["前端知识"],"content":" 13 表单JavaScript可以用于操作HTML表单元素，包括获取和设置表单元素的值、验证表单输入等。 以下是一些常见的表单操作示例： 获取表单元素的值： 可以通过document对象的getElementById方法或getElementsByTagName方法获取表单元素，并使用其value属性获取元素的值，例如： var input = document.getElementById(\"myInput\"); var value = input.value; 设置表单元素的值： 可以通过setAttribute方法或直接修改元素的value属性来设置表单元素的值，例如： var input = document.getElementById(\"myInput\"); input.setAttribute(\"value\", \"new value\"); // 或者 input.value = \"new value\"; 验证表单输入： 可以使用正则表达式或其他逻辑来验证表单输入是否符合要求，并在必要时向用户显示错误消息，例如： var input = document.getElementById(\"myInput\"); if (!/^[a-zA-Z]+$/.test(input.value)) { alert(\"请输入字母！\"); } 提交表单数据： 可以使用form元素的submit方法提交表单数据，例如： var form = document.getElementById(\"myForm\"); form.submit(); 除了以上列出的表单操作，还有其他一些常见的操作，如重置表单数据、动态添加表单元素等。总之，JavaScript可以帮助我们更好地控制和操作HTML表单元素。 ","date":"2021-10-07","objectID":"/javascript/:13:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#表单"},{"categories":["前端知识"],"content":" 14 文件JavaScript 可以操作文件，但是在浏览器端的 JavaScript 有一些限制，不能直接访问本地文件系统。如果您需要在浏览器中读取或写入文件，可以使用 HTML5 的 File API 来实现。 以下是一个使用 File API 读取本地文件的例子： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFile Reader Example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"file\" id=\"file-input\"\u003e \u003cdiv id=\"file-content\"\u003e\u003c/div\u003e \u003cscript\u003e const fileInput = document.getElementById('file-input'); const fileContent = document.getElementById('file-content'); fileInput.addEventListener('change', (event) =\u003e { const file = event.target.files[0]; const reader = new FileReader(); reader.readAsText(file); reader.onload = (event) =\u003e { fileContent.textContent = event.target.result; }; }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 这个例子创建了一个文件输入框和一个用于显示文件内容的 div 元素。当用户选择一个文件后，它将被读取并显示在 div 中。 在 Node.js 服务器环境中，可以使用 fs 模块来进行文件操作。以下是一个使用 fs 模块读取文件的例子： const fs = require('fs'); fs.readFile('/path/to/file', 'utf8', (err, data) =\u003e { if (err) throw err; console.log(data); }); 这个例子使用 fs.readFile 方法读取指定路径的文件，并在控制台打印出文件内容。 ","date":"2021-10-07","objectID":"/javascript/:14:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#文件"},{"categories":["前端知识"],"content":" 15 AJAXAJAX（Asynchronous JavaScript And XML）是一种用于创建动态 Web 应用程序的技术。它可以在不刷新整个页面的情况下，从服务器端异步加载数据，更新部分页面内容，提高用户体验。 以下是使用原生 JavaScript 实现 AJAX 的基本步骤： 创建 XMLHttpRequest 对象 javascript复制代码const xhr = new XMLHttpRequest(); 指定请求处理函数 xhr.onreadystatechange = function() { if (xhr.readyState === XMLHttpRequest.DONE \u0026\u0026 xhr.status === 200) { console.log(xhr.responseText); } }; 发送请求 javascript复制代码xhr.open('GET', 'https://example.com/data'); xhr.send(); 以上代码创建了一个 XMLHttpRequest 对象，并指定了 onreadystatechange 函数来处理服务器返回的响应。然后发送一个 GET 请求到指定的 URL。 当 readyState 的值为 4 时，表示请求已完成并接收到了响应。如果 status 的值为 200，则说明响应成功。此时可以通过 responseText 属性来获取服务器返回的数据。 实际上，AJAX 可以使用多种 HTTP 方法（例如 GET、POST、DELETE、PUT 等），也可以发送任何类型的数据（例如表单数据、JSON 数据等）。根据实际需求选择相应的方法和数据格式即可。 需要注意的是，在跨域请求时，需要设置 CORS 或 JSONP 等方式来允许跨域访问。 ","date":"2021-10-07","objectID":"/javascript/:15:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#ajax"},{"categories":["前端知识"],"content":" 16 PromisePromise 是一种处理异步操作的技术，它可以让我们更优雅地编写异步代码，并避免了回调地狱等问题。 以下是 Promise 的基本使用方法： 创建 Promise 对象 javascript复制代码const promise = new Promise((resolve, reject) =\u003e { // 异步操作 }); Promise 构造函数接受一个函数作为参数，该函数有两个参数：resolve 和 reject。当异步操作成功时，调用 resolve 函数并传递数据；当异步操作失败时，调用 reject 函数并传递错误信息。 处理 Promise 结果 javascript复制代码promise.then(data =\u003e { // 成功处理 }).catch(error =\u003e { // 失败处理 }); then 方法用于处理异步操作成功时的结果，接收一个回调函数作为参数，该函数的参数即为 resolve 函数传递的数据。catch 方法用于处理异步操作失败时的结果，接收一个回调函数作为参数，该函数的参数即为 reject 函数传递的错误信息。 Promise 链式调用 promise.then(data =\u003e { // 处理第一次异步操作 return anotherPromise; }).then(data =\u003e { // 处理第二次异步操作 }).catch(error =\u003e { // 错误处理 }); Promise 对象可以链式调用，每个 then 方法返回的都是一个新的 Promise 对象。这样可以依次执行多个异步操作，并在最后处理成功或失败的结果。 需要注意的是，Promise 可以使用异步操作、回调函数等技术来实现，但它本身并不是异步的。Promise 的作用在于封装和组合异步操作，使代码更加可读和易维护。 当然，如果需要兼容一些比较老的浏览器，可以使用 Promise 的 polyfill 库来实现 Promise 相关的功能。 ","date":"2021-10-07","objectID":"/javascript/:16:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#promise"},{"categories":["前端知识"],"content":" 17 CanvasCanvas 是 HTML5 中新增的一个用于绘制图形的技术，它可以实现动画效果、游戏开发等功能。以下是 Canvas 的基本使用方法： 获取 Canvas 元素 javascript复制代码const canvas = document.getElementById('my-canvas'); const ctx = canvas.getContext('2d'); Canvas 元素是一个 HTML 元素，在 JavaScript 中可以通过 document.getElementById 方法获取到。获取到元素后，还需要调用 getContext 方法来获取绘图上下文对象。 绘制图形 javascript复制代码ctx.fillStyle = 'red'; ctx.fillRect(10, 10, 100, 100); 这个例子使用 fillStyle 属性设置填充颜色为红色，然后使用 fillRect 方法在 Canvas 上绘制一个矩形。 清空 Canvas javascript复制代码ctx.clearRect(0, 0, canvas.width, canvas.height); 使用 clearRect 方法可以清空整个 Canvas。 绘制路径 javascript复制代码ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(100, 100); ctx.lineTo(50, 150); ctx.closePath(); ctx.stroke(); 这个例子使用 beginPath 方法开始一条新路径，然后依次调用 moveTo 和 lineTo 方法来绘制路径，最后使用 closePath 方法闭合路径，并使用 stroke 方法描边。 绘制图片 javascript复制代码const img = new Image(); img.onload = function() { ctx.drawImage(img, 0, 0); }; img.src = 'image.jpg'; 使用 Image 对象加载图片后，可以在 onload 回调函数中使用 drawImage 方法将图片绘制到 Canvas 中。 Canvas 还有很多其他的功能，例如设置字体、旋转变换等。需要根据实际需求选择相应的 API。 需要注意的是，Canvas 是一个位图技术，它不支持矢量图形。因此，在设计图形时需要注意分辨率和像素密度等问题。 ","date":"2021-10-07","objectID":"/javascript/:17:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#canvas"},{"categories":["前端知识"],"content":" 18 WASM在 JavaScript 中，可以通过以下方法与 WebAssembly 模块进行交互： 加载 WebAssembly 模块：使用 WebAssembly.instantiate() 或 WebAssembly.instantiateStreaming() 函数加载并实例化 WebAssembly 模块。 导入和导出函数：WebAssembly 模块可以从 JavaScript 中导入函数，并且可以将函数从 WebAssembly 模块导出到 JavaScript 中。 使用内存：WebAssembly 模块可以分配内存，并通过指针引用内存中的数据。在 JavaScript 中，可以通过 WebAssembly.Memory 对象来访问 WebAssembly 内存。 调用函数：在 JavaScript 中，可以通过 WebAssembly.Instance 对象来调用 WebAssembly 模块中导出的函数。可以将参数传递给这些函数，并获取函数的返回值。 下面是一个简单的示例，展示了如何在 JavaScript 中加载、实例化和调用 WebAssembly 模块： // 从 URL 加载 WebAssembly 模块 fetch('example.wasm') .then(response =\u003e response.arrayBuffer()) .then(bytes =\u003e WebAssembly.instantiate(bytes, {})) .then(obj =\u003e { // 获取导出的函数 const { add } = obj.instance.exports; // 调用函数并获取返回值 const result = add(1, 2); console.log(result); // 输出: 3 }); 在这个示例中，我们首先从 URL 加载 WebAssembly 模块，并使用 WebAssembly.instantiate() 函数实例化它。然后，我们获取导出的函数 add 并调用它，传递两个整数参数。最后，我们将函数的返回值打印到控制台上。 ","date":"2021-10-07","objectID":"/javascript/:18:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#wasm"},{"categories":["前端知识"],"content":" 19 错误处理 程序有可能会出错,因此需要进行错误处理;高级语言try ... catch ... finally, 'use strict'; var r1, r2, s = null; try { r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行 } catch (e) { console.log('error: ' + e); } finally { console.log('finally'); } console.log('r1 = ' + r1); // r1应为undefined console.log('r2 = ' + r2); // r2应为undefined // 下面的文件 // 出错了：TypeError: Cannot read properties of null (reading 'length') // finally // r1 = undefined // r2 = undefined 出错 先执行try { ... }的代码; 执行到出错的语句时,后续语句不再继续执行.转而执行catch (e) { ... }代码； 最后执行finally{ ... }代码。 无错 先执行try { … }的代码； 因为没有出错，catch (e) { … }代码不会被执行； 最后执行finally { … }代码。 ","date":"2021-10-07","objectID":"/javascript/:19:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#错误处理"},{"categories":["前端知识"],"content":"CSS3基础教程","date":"2021-10-07","objectID":"/css3/","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/"},{"categories":["前端知识"],"content":" 1 基础知识 Cascading Style Sheets(层叠样式表) HTML + CSS + JavaScript =\u003e 名词 + 形容词 + 动词 CSS可以认为对原始的HTML进行美化 ","date":"2021-10-07","objectID":"/css3/:1:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基础知识"},{"categories":["前端知识"],"content":" 1.1 快速入门 CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画 ","date":"2021-10-07","objectID":"/css3/:1:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#快速入门"},{"categories":["前端知识"],"content":" 1.2 什么是CSS美化:字体, 颜色,高度,宽度, 背景图片 ","date":"2021-10-07","objectID":"/css3/:1:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#什么是css"},{"categories":["前端知识"],"content":" 1.3 CSS的优势 内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件 ","date":"2021-10-07","objectID":"/css3/:1:3","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css的优势"},{"categories":["前端知识"],"content":" 1.4 CSS导入的方法 行内样式 \u003ch1 style=\"color: red\"\u003e一级标题\u003c/h1\u003e style标签 \u003cstyle\u003e\u003c/style\u003e 外部样式 链接方式 \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e 导入式 \u003cstyle\u003e @import url(\"css/style.css\"); \u003c/style\u003e ","date":"2021-10-07","objectID":"/css3/:1:4","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css导入的方法"},{"categories":["前端知识"],"content":" 1.5 基本语法 /* 注释语法 */ selector { /* 声明 */ attr:value; } 下面的代码可以直接修改背景颜色 \u003cstyle\u003e body { background-color:gray; } \u003c/style\u003e CSS基本操作 选中元素(选择某一类或者某一个) 属性修改(修改一个或者多个) ","date":"2021-10-07","objectID":"/css3/:1:5","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基本语法"},{"categories":["前端知识"],"content":" 2 选择器 选择某一类或者某一个元素 ","date":"2021-10-07","objectID":"/css3/:2:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 \u003ch1 class=\"test\"\u003e测试\u003c/h1\u003e 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 \u003ch1 id=\"test\"\u003e测试\u003c/h1\u003e #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基本选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#标签选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#类选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#id选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 \u003cp class=\"active\"\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp id=\"test\"\u003ep3\u003c/p\u003e \u003cp\u003ep4\u003c/p\u003e \u003cstyle\u003e .active+p { color: red; } #test+p { color: blue; } \u003c/style\u003e 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 \u003cp\u003ep1\u003c/p\u003e \u003cp class=\"hello\"\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cstyle\u003e .hello~{ color: red; } \u003c/style\u003e p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp id=\"test\"\u003ep7\u003c/p\u003e \u003cp\u003ep8\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#高级选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#层次选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#后代选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#子选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#相邻兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#通用兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#结构伪类选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS graph LR\rbody--\u003ep1\rbody--\u003ep2\rbody--\u003ep3\rp3--\u003ep4\rp3--\u003ep5\rp3--\u003ep6 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性选择器"},{"categories":["前端知识"],"content":" 3 CSS属性 选中元素开始设置属性 ","date":"2021-10-07","objectID":"/css3/:3:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css属性"},{"categories":["前端知识"],"content":" 3.1 属性基础 字体样式 文本样式 文本阴影 超链接 列表样式 背景 span标签强调,这是一个标签, div标签,分块 \u003c!-- 字体样式 --\u003e \u003cstyle\u003e body { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-style: oblique; } \u003c/style\u003e font-family; 字体设置 font-size 字体大小 font-style 字体风格 ","date":"2021-10-07","objectID":"/css3/:3:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性基础"},{"categories":["前端知识"],"content":" 3.2 属性提高 盒子模型与边框 ","date":"2021-10-07","objectID":"/css3/:3:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性提高"},{"categories":["前端知识"],"content":"html5基础教程","date":"2021-10-07","objectID":"/html5/","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/"},{"categories":["前端知识"],"content":" hugo中markdown可以直接渲染html,可以直接得到效果 但是网页基础结构却不可以编写,这样会破坏渲染过程 因此点击例子,同时点击F12,确定效果. 页面显示空白 但是我们可以在源代码中看到 \u003c!-- 告诉浏览器,需要使用的规范 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 网页标题 --\u003e \u003chead\u003e \u003c!-- 描述标签 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页标题 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 网页主体 --\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 因此后面我们就使用独立的html文件进行学习 ","date":"2021-10-07","objectID":"/html5/:0:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#"},{"categories":["前端知识"],"content":" 1 网页结构 \u003c!DOCTYPE html\u003e www规范\r注释的写法 \u003c!-- 注释 --\u003e html: 网页 head: 标题标签 meta: 网站信息 body: 网页主题 meta标签处于head区,对用户不可见,用于对网页进行描述,一般SEO优化 \u003chead\u003e \u003cmeta name=\"description\" content=\"前端基础\"\u003e \u003cmeta name=\"keywords\" content=\"HTML,CSS,JavaScript\"\u003e \u003cmeta name=\"author\" content=\"孟德茂\"\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c/head\u003e 实现自动跳转 因此点击例子,网页显示空白,等待3S,网页自动回到本页面 实现原理 \u003cmeta http-equiv=\"refresh\" content=\"3; https://mengdemao.github.io/html5\"/\u003e 头文件区添加,可以看到虽然meta没有显示,但还是存在较大用处 ","date":"2021-10-07","objectID":"/html5/:1:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#网页结构"},{"categories":["前端知识"],"content":" 2 基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号标签 ","date":"2021-10-07","objectID":"/html5/:2:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#基本标签"},{"categories":["前端知识"],"content":" 2.1 标题标签 \u003ch1\u003e一级标签\u003c/h1\u003e \u003ch2\u003e二级标签\u003c/h2\u003e \u003ch3\u003e三级标签\u003c/h3\u003e \u003ch4\u003e四级标签\u003c/h4\u003e \u003ch5\u003e五级标签\u003c/h5\u003e \u003ch6\u003e六级标签\u003c/h6\u003e 在HUGO中实现,但是效果会显示的很诡异,因此独立文件实现; 点击例子,可以看到效果;同时F12，检查元素实现 ","date":"2021-10-07","objectID":"/html5/:2:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#标题标签"},{"categories":["前端知识"],"content":" 2.2 段落标签 \u003cp\u003e段落标签\u003c/p\u003e 显示如下: 我是一个段落 我又是一个段落 ","date":"2021-10-07","objectID":"/html5/:2:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#段落标签"},{"categories":["前端知识"],"content":" 2.3 换行标签 \u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:2:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#换行标签"},{"categories":["前端知识"],"content":" 2.4 抄录环境 pre code pre显示的是原始的结构文本,程序不修改其中的tab,回车空格等;pre演示 code标签显示的语义化文本,显示等宽字体,但是格式被打乱code演示 语义化演示 var 定义程序变量 kbd 定义用户输入 samp 定义程序输出 \u003cp\u003e定义变量\u003cvar\u003euser_input\u003c/var\u003e,用作用户的输入\u003c/p\u003e \u003cp\u003e接收用户的输入\u003ckbd\u003e用户输入\u003c/kbd\u003e\u003c/p\u003e \u003cp\u003e执行程序的输出\u003csamp\u003e程序输出\u003c/samp\u003e\u003c/p\u003e 但是程序好像并没有产生什么效果 演示 ","date":"2021-10-07","objectID":"/html5/:2:4","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#抄录环境"},{"categories":["前端知识"],"content":" 2.5 引用标签","date":"2021-10-07","objectID":"/html5/:2:5","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#引用标签"},{"categories":["前端知识"],"content":" 2.6 强调标签","date":"2021-10-07","objectID":"/html5/:2:6","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#强调标签"},{"categories":["前端知识"],"content":" 2.7 水平线标签 \u003chr/\u003e 我在水平线标签上方 我在水平线标签下方 ","date":"2021-10-07","objectID":"/html5/:2:7","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#水平线标签"},{"categories":["前端知识"],"content":" 2.8 字体样式标签 \u003c!-- 字体样式标签 --\u003e 普通文本\u003cspan\u003e无效果\u003c/span\u003e\u003c/br\u003e 普通文本\u003cb\u003e加粗\u003c/b\u003e\u003c/br\u003e 普通文本\u003cstrong\u003e粗体\u003c/strong\u003e\u003c/br\u003e 普通文本\u003ci\u003e斜体\u003c/i\u003e\u003c/br\u003e 普通文本\u003cem\u003e斜体\u003c/em\u003e\u003c/br\u003e 普通文本\u003cu\u003e下划线\u003c/u\u003e\u003c/br\u003e 普通文本\u003cins\u003e下划线\u003c/ins\u003e\u003c/br\u003e 普通文本\u003cs\u003e删除线\u003c/s\u003e\u003c/br\u003e 普通文本\u003cdel\u003e删除线\u003c/del\u003e\u003c/br\u003e 普通文本\u003csub\u003e下标文本\u003c/sub\u003e\u003c/br\u003e 普通文本\u003csup\u003e上标文本\u003c/sup\u003e\u003c/br\u003e 普通文本无效果 普通文本加粗 普通文本粗体 普通文本斜体 普通文本斜体 普通文本下划线 普通文本下划线 普通文本删除线 普通文本删除线 普通文本下标文本 普通文本上标文本 ","date":"2021-10-07","objectID":"/html5/:2:8","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#字体样式标签"},{"categories":["前端知识"],"content":" 3 图片标签 \u003cimg src=\"测试.png\" alt=\"测试\" title=\"测试\"/\u003e ","date":"2021-10-07","objectID":"/html5/:3:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#图片标签"},{"categories":["前端知识"],"content":" 4 链接 \u003c!-- 当前页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_self\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e \u003c!-- 新建页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:4:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#链接"},{"categories":["前端知识"],"content":" 5 列表标签","date":"2021-10-07","objectID":"/html5/:5:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#列表标签"},{"categories":["前端知识"],"content":" 5.1 有序列表 \u003col\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ol\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#有序列表"},{"categories":["前端知识"],"content":" 5.2 无序列表 \u003cul\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ul\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#无序列表"},{"categories":["前端知识"],"content":" 5.3 定义列表 \u003cdl\u003e \u003cdt\u003e前端\u003c/dt\u003e \u003cdd\u003ehtml\u003c/dd\u003e \u003cdd\u003eCSS\u003c/dd\u003e \u003cdd\u003eJavaScript\u003c/dd\u003e \u003c/dl\u003e 前端\rhtml\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#定义列表"},{"categories":["前端知识"],"content":" 6 表格 \u003ctable border=\"1px\"\u003e \u003ctr\u003e \u003ctd\u003e1-1\u003c/td\u003e \u003ctd\u003e1-2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2-1\u003c/td\u003e \u003ctd\u003e2-2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 1-1\r1-2\r2-1\r2-2\r","date":"2021-10-07","objectID":"/html5/:6:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表格"},{"categories":["前端知识"],"content":" 7 页面结构分析 元素名 描述 header 标题头部区域 footer 标记尾部内容 section web页面中一块独立的区域 article 独立文章内容 aside 相关页面或者内容 nav 导航类辅助内容 ","date":"2021-10-07","objectID":"/html5/:7:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#页面结构分析"},{"categories":["前端知识"],"content":" 8 iframe内联框架 \u003ciframe src=\"path\" name=\"mainFrame\"\u003e\u003c/frame\u003e bilibili的例子 \u003ciframe src=\"//player.bilibili.com/player.html?aid=55631961\u0026bvid=BV1x4411V75C\u0026cid=97257967\u0026page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e \u003c/iframe\u003e ","date":"2021-10-07","objectID":"/html5/:8:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#iframe内联框架"},{"categories":["前端知识"],"content":" 9 表单 \u003cform action=\"submit.html\" method=\"GET/POST\"\u003e \u003cp\u003e名字: \u003cinput type=\"text\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003e密码: \u003cinput type=\"password\" name=\"password\"\u003e\u003c/p\u003e \u003cp\u003e \u003cinput type=\"submit\"\u003e \u003cinput type=\"reset\"\u003e \u003c/p\u003e \u003c/form\u003e 出入账户和密码,点击按钮会触发相应的 动作http://url/html5/submit.html?name=mengdemao\u0026password=1234, 但是此时会显示失败,因为没有处理函数. 名字: 密码: ","date":"2021-10-07","objectID":"/html5/:9:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表单"},{"categories":["开源软件"],"content":"sds","date":"2021-10-06","objectID":"/sds/","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/"},{"categories":["开源软件"],"content":" A C dynamic strings library C语言版本动态字符串库 ","date":"2021-10-06","objectID":"/sds/:0:0","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#"},{"categories":["开源软件"],"content":" 1 SDSSDS的类型就是 typedef char *sds; 可以明显的看到,sds就是普通的char类型 ","date":"2021-10-06","objectID":"/sds/:1:0","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#sds"},{"categories":["开源软件"],"content":" 1.1 下面是sds的数据类型 +--------+-------------------------------+-----------+ | Header | Binary safe C alike string... | Null term | +--------+-------------------------------+-----------+ | -\u003e Pointer returned to the user. #define SDS_HDR_VAR(T,s) \\ struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); #define SDS_HDR(T,s) \\ ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) #define SDS_TYPE_5_LEN(f) ((f)\u003e\u003eSDS_TYPE_BITS) ","date":"2021-10-06","objectID":"/sds/:1:1","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#下面是sds的数据类型"},{"categories":["开源软件"],"content":" 1.2 SDS 头根据不同的标志计算不同的头部数据 宏定义 标志 SDS_TYPE_5 sdshdr5 SDS_TYPE_8 sdshdr8 SDS_TYPE_16 sdshdr16 SDS_TYPE_32 sdshdr32 SDS_TYPE_64 sdshdr64 flag标志: unsigned char flags = s[-1]; /* 最后一个头部数据 */ #define SDS_TYPE_5 0 #define SDS_TYPE_8 1 #define SDS_TYPE_16 2 #define SDS_TYPE_32 3 #define SDS_TYPE_64 4 /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; #define SDS_TYPE_MASK 7 #define SDS_TYPE_BITS 3 ","date":"2021-10-06","objectID":"/sds/:1:2","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#sds-头"},{"categories":["开源软件"],"content":" 2 创建SDS函数原型 sds sdsnewlen(const void *init, size_t initlen); ","date":"2021-10-06","objectID":"/sds/:2:0","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#创建sds"},{"categories":["开源软件"],"content":" 3 扩张字符串缓存区 sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh; void *newsh; size_t avail = sdsavail(s); /* 计算剩余的可以使用的大小 */ size_t len; size_t newlen; char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; int hdrlen; if (avail \u003e= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ return s; } len = sdslen(s); /* 计算字符串大小 */ sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ /* 计算得到新的长度 */ newlen = (len+addlen); if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; /* 重新生成类型 */ type = sdsReqType(newlen); /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) { type = SDS_TYPE_8; } /* 计算头部大小 */ hdrlen = sdsHdrSize(type); if (oldtype == type) { newsh = s_realloc(sh, hdrlen + newlen + 1); if (newsh == NULL) { return NULL; } s = (char*)newsh + hdrlen; } else { /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc(hdrlen+newlen+1); if (newsh == NULL) { return NULL; } memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); } sdssetalloc(s, newlen); return s; } ","date":"2021-10-06","objectID":"/sds/:3:0","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#扩张字符串缓存区"},{"categories":["开源软件"],"content":" 4 追加字符串 sds sdscatlen(sds s, const void *t, size_t len) { size_t curlen = sdslen(s); /* 计算字符串的长度 */ s = sdsMakeRoomFor(s,len); /* 扩展字符串缓冲区长度 */ if (s == NULL) { return NULL; } memcpy(s+curlen, t, len); /* 添加字符串 */ sdssetlen(s, curlen+len); /* 设置长度标志 */ s[curlen+len] = '\\0'; /* 补全结束符 */ return s; } ","date":"2021-10-06","objectID":"/sds/:4:0","series":["GNU开源软件"],"tags":["开源软件"],"title":"Sds","uri":"/sds/#追加字符串"},{"categories":["C++"],"content":"STL基础笔记","date":"2021-10-06","objectID":"/stl/","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/"},{"categories":["C++"],"content":" STL称为标准模板库(Standard Template Library) 广义上可以分为容器,算法,迭代器 容器和算法通过迭代器进行无缝连接 STL几乎所有的代码都采用了函数模版或者类模板 ","date":"2021-10-06","objectID":"/stl/:0:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#"},{"categories":["C++"],"content":" 1 STL分类 序号 名称 解释 1 容器 各种数据结构 2 算法 各种常用的算法 3 迭代器 容器域算法的胶合 4 仿函数 行为类似函数 5 适配器 修饰容器或者仿函数迭代器 6 空间配置器 负责空间的配置和管理 ","date":"2021-10-06","objectID":"/stl/:1:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#stl分类"},{"categories":["C++"],"content":" 2 容器","date":"2021-10-06","objectID":"/stl/:2:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#容器"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector\u003cint\u003e v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector\u003cint\u003e::iterator itBegin = v.begin(); vector\u003cint\u003e::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector\u003cint\u003e::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template \u003cclass T\u003e void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint\u003cint\u003e); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector\u003cvector\u003cint\u003e\u003ev; // 外部大容器 vector\u003cint\u003e vx[10]; // 内部小容器 /* 插入容器 */ for (int i = 0; i \u003c 10; i++) { for (int j = 0; j \u003c 30; j++) { vx[i].push_back(i + j + 10); } v.push_back(vx[i]); } /* 遍历容器 */ for (vector\u003cvector\u003cint\u003e\u003e::iterator it = v.begin(); it != v.end(); it++) { for (vector\u003cint\u003e::iterator vit = it-\u003ebegin(); vit != it-\u003eend(); vit++) { cout \u003c\u003c *vit \u003c\u003c \" \"; } cout \u003c\u003c endl; } ","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#vector"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#vector使用"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#迭代器使用"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#迭代器方案1"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#迭代器2"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#遍历算法"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#容器自定义数据"},{"categories":["C++"],"content":" 2.1 vector 2.1.1 vector使用 /* 创建vector容器 */ vector v; /* 插入数据 */ v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); 2.1.2 迭代器使用 2.1.2.1 迭代器方案1 vector::iterator itBegin = v.begin(); vector::iterator itEnd = v.end(); while (itBegin != itEnd) { cout \u003c\u003c *itBegin \u003c\u003c endl; itBegin += 1; } 2.1.2.2 迭代器2 for (vector::iterator it = v.begin(); it != v.end(); it++) { cout \u003c\u003c *it \u003c\u003c endl; } 2.1.2.3 遍历算法 template void myPrint(T val) { cout \u003c\u003c val \u003c\u003c endl; } /* 可惜回调函数不支持自动推导 */ for_each(v.begin(), v.end(), myPrint); 2.1.3 容器自定义数据 2.1.4 容器嵌套容器 vector","date":"2021-10-06","objectID":"/stl/:2:1","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#容器嵌套容器"},{"categories":["C++"],"content":" 2.2 stringstring本质上是一个类,封装了char*,提供了许多的成员方法; 2.2.1 构造函数 string s1(str); string s2 = \"Hello World\"; string s3(s2); ","date":"2021-10-06","objectID":"/stl/:2:2","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#string"},{"categories":["C++"],"content":" 2.2 stringstring本质上是一个类,封装了char*,提供了许多的成员方法; 2.2.1 构造函数 string s1(str); string s2 = \"Hello World\"; string s3(s2); ","date":"2021-10-06","objectID":"/stl/:2:2","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#构造函数"},{"categories":["C++"],"content":" 2.3 赋值操作 重载操作符**=** string s1; s1 = \"Hello World\"; 成员函数assign string str; str.assign(\"Hello World\"); ","date":"2021-10-06","objectID":"/stl/:2:3","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#赋值操作"},{"categories":["C++"],"content":" 2.4 追加操作 重载操作符**+=** 成员函数append ","date":"2021-10-06","objectID":"/stl/:2:4","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#追加操作"},{"categories":["C++"],"content":" 2.5 查找和替换 2.5.1 find 2.5.2 replace","date":"2021-10-06","objectID":"/stl/:2:5","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#查找和替换"},{"categories":["C++"],"content":" 2.5 查找和替换 2.5.1 find 2.5.2 replace","date":"2021-10-06","objectID":"/stl/:2:5","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#find"},{"categories":["C++"],"content":" 2.5 查找和替换 2.5.1 find 2.5.2 replace","date":"2021-10-06","objectID":"/stl/:2:5","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#replace"},{"categories":["C++"],"content":" 2.6 比较 2.6.1 compare","date":"2021-10-06","objectID":"/stl/:2:6","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#比较"},{"categories":["C++"],"content":" 2.6 比较 2.6.1 compare","date":"2021-10-06","objectID":"/stl/:2:6","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#compare"},{"categories":["C++"],"content":" 2.7 字符存取 [] at ","date":"2021-10-06","objectID":"/stl/:2:7","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#字符存取"},{"categories":["C++"],"content":" 2.8 插入和删除 2.8.1 insert 2.8.2 earse","date":"2021-10-06","objectID":"/stl/:2:8","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#插入和删除"},{"categories":["C++"],"content":" 2.8 插入和删除 2.8.1 insert 2.8.2 earse","date":"2021-10-06","objectID":"/stl/:2:8","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#insert"},{"categories":["C++"],"content":" 2.8 插入和删除 2.8.1 insert 2.8.2 earse","date":"2021-10-06","objectID":"/stl/:2:8","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#earse"},{"categories":["C++"],"content":" 2.9 子串 2.9.1 substr","date":"2021-10-06","objectID":"/stl/:2:9","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#子串"},{"categories":["C++"],"content":" 2.9 子串 2.9.1 substr","date":"2021-10-06","objectID":"/stl/:2:9","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#substr"},{"categories":["C++"],"content":" 3 array","date":"2021-10-06","objectID":"/stl/:3:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#array"},{"categories":["C++"],"content":" 4 deque","date":"2021-10-06","objectID":"/stl/:4:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#deque"},{"categories":["C++"],"content":" 5 hashtable","date":"2021-10-06","objectID":"/stl/:5:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#hashtable"},{"categories":["C++"],"content":" 6 map","date":"2021-10-06","objectID":"/stl/:6:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#map"},{"categories":["C++"],"content":" 7 list","date":"2021-10-06","objectID":"/stl/:7:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#list"},{"categories":["C++"],"content":" 8 queue","date":"2021-10-06","objectID":"/stl/:8:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#queue"},{"categories":["C++"],"content":" 9 stack","date":"2021-10-06","objectID":"/stl/:9:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#stack"},{"categories":["C++"],"content":" 10 set","date":"2021-10-06","objectID":"/stl/:10:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#set"},{"categories":["C++"],"content":" 11 rbtree","date":"2021-10-06","objectID":"/stl/:11:0","series":null,"tags":["C++"],"title":"STL基础笔记","uri":"/stl/#rbtree"},{"categories":["操作系统"],"content":"进程创建","date":"2021-10-04","objectID":"/fork/","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/"},{"categories":["操作系统"],"content":" fork linux创建线程的函数 fork –\u003e do_fork do_fork的执行线路 graph LR do_fork --\u003e copy_process --\u003e get_task_pid --\u003e wake_up_new_task --\u003e put_pid do_fork函数原型 long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); clone_flags stack_start stack_size parent_tidptr child_tidptr tls ","date":"2021-10-04","objectID":"/fork/:0:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#fork"},{"categories":["操作系统"],"content":" 1 copy_process","date":"2021-10-04","objectID":"/fork/:1:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#copy_process"},{"categories":["操作系统"],"content":" 2 get_task_pid","date":"2021-10-04","objectID":"/fork/:2:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#get_task_pid"},{"categories":["操作系统"],"content":" 3 wake_up_new_task","date":"2021-10-04","objectID":"/fork/:3:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#wake_up_new_task"},{"categories":["linux"],"content":"系统调度","date":"2021-10-04","objectID":"/scheduler/","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/"},{"categories":["linux"],"content":" 调度器分为主调度器和周期调度器 但是本节不考虑调度器的具体实现 只进行大方向接口的分析 系统调度器基础 完全公平调度器 ","date":"2021-10-04","objectID":"/scheduler/:0:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#"},{"categories":["linux"],"content":" 1 权重计算","date":"2021-10-04","objectID":"/scheduler/:1:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#权重计算"},{"categories":["linux"],"content":" 1.1 优先级计算优先级 // 1. 当前优先级normal_prio p-\u003eprio = current-\u003enormal_prio; // 2. 静态优先级 p-\u003estatic_prio = NICE_TO_PRIO(0) // 3. 继续计算优先级 p-\u003eprio = p-\u003enormal_prio = __normal_prio(p); // 4. 这在计算什么? #define NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO) #define PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO) static inline int __normal_prio(struct task_struct *p) { return p-\u003estatic_prio; } ","date":"2021-10-04","objectID":"/scheduler/:1:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#优先级计算"},{"categories":["linux"],"content":" 1.2 权重计算 struct load_weight { unsigned long weight; u32 inv_weight; }; static void set_load_weight(struct task_struct *p) { int prio = p-\u003estatic_prio - MAX_RT_PRIO; struct load_weight *load = \u0026p-\u003ese.load; /* * SCHED_IDLE tasks get minimal weight: */ if (p-\u003epolicy == SCHED_IDLE) { load-\u003eweight = scale_load(WEIGHT_IDLEPRIO); load-\u003einv_weight = WMULT_IDLEPRIO; return; } load-\u003eweight = scale_load(prio_to_weight[prio]); load-\u003einv_weight = prio_to_wmult[prio]; } static const int prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; static const u32 prio_to_wmult[40] = { /* -20 */ 48388, 59856, 76040, 92818, 118348, /* -15 */ 147320, 184698, 229616, 287308, 360437, /* -10 */ 449829, 563644, 704093, 875809, 1099582, /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, }; 优先级与负载计算关系 $weight = \\frac{1024}{1.25^{nice}}$ ${inv_weight} = \\frac{2^{32}}{weight}$ ","date":"2021-10-04","objectID":"/scheduler/:1:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#权重计算-1"},{"categories":["linux"],"content":" 2 调度器类linux内核充分使用了面向对象的思想, 依靠sched_class将所有的调度器整合 linux上的调度器 调度器类 描述信息 用户接口调度策略 dl_sched_class deadline调度器 SCHED_DEADLINE rt_sched_class 实时调度器 SCHED_FIFO、``SCHED_RR` fair_sched_class 完全公平调度器 SCHED_NORMAL、``SCHED_BATCH` idle_sched_class idle task SCHED_IDLE ","date":"2021-10-04","objectID":"/scheduler/:2:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器类"},{"categories":["linux"],"content":" 2.1 调度器类结构体 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task) (struct rq *rq, struct task_struct *prev); void (*put_prev_task) (struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int next_cpu); void (*post_schedule) (struct rq *this_rq); void (*task_waking) (struct task_struct *task); void (*task_woken) (struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task) (struct rq *rq); void (*task_tick) (struct rq *rq, struct task_struct *p, int queued); void (*task_fork) (struct task_struct *p); void (*task_dead) (struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from) (struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval) (struct rq *rq, struct task_struct *task); void (*update_curr) (struct rq *rq); #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_move_group) (struct task_struct *p, int on_rq); #endif }; ","date":"2021-10-04","objectID":"/scheduler/:2:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器类结构体"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器封装"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#入队出队"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#激活销毁"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#主动放弃"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#唤醒抢占任务"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#获取释放任务"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#任务切换"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#更新当前任务"},{"categories":["linux"],"content":" 3 任务创建任务创建是由do_fork进行,与调度器进行沟通的函数是sched_fork,沟通的数据结构是 int sched_fork(unsigned long clone_flags, struct task_struct *p) { unsigned long flags; // #define get_cpu() ({ preempt_disable(); smp_processor_id(); }) // #define put_cpu() preempt_enable() int cpu = get_cpu(); // 获取CPUID // 进入内部实现 __sched_fork(clone_flags, p); /* * We mark the process as running here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u003estate = TASK_RUNNING; // 设置运行状态 /* * Make sure we do not leak PI boosting priority to the child. */ p-\u003eprio = current-\u003enormal_prio; // 复制父优先级到当前 /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u003esched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { p-\u003epolicy = SCHED_NORMAL; p-\u003estatic_prio = NICE_TO_PRIO(0); p-\u003ert_priority = 0; } else if (PRIO_TO_NICE(p-\u003estatic_prio) \u003c 0) p-\u003estatic_prio = NICE_TO_PRIO(0); p-\u003eprio = p-\u003enormal_prio = __normal_prio(p); set_load_weight(p); /* * We don't need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u003esched_reset_on_fork = 0; } if (dl_prio(p-\u003eprio)) { put_cpu(); return -EAGAIN; } else if (rt_prio(p-\u003eprio)) { p-\u003esched_class = \u0026rt_sched_class; } else { p-\u003esched_class = \u0026fair_sched_class; } if (p-\u003esched_class-\u003etask_fork) p-\u003esched_class-\u003etask_fork(p); /* * The child is not yet in the pid-hash so no cgroup attach races, * and the cgroup is pinned to this child due to cgroup_fork() * is ran before sched_fork(). * * Silence PROVE_RCU. */ raw_spin_lock_irqsave(\u0026p-\u003epi_lock, flags); set_task_cpu(p, cpu); raw_spin_unlock_irqrestore(\u0026p-\u003epi_lock, flags); #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) if (likely(sched_info_on())) memset(\u0026p-\u003esched_info, 0, sizeof(p-\u003esched_info)); #endif #if defined(CONFIG_SMP) p-\u003eon_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026p-\u003epushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026p-\u003epushable_dl_tasks); #endif put_cpu(); return 0; } static void __sched_fork(unsigned long clone_flags, struct task_struct *p) { p-\u003eon_rq = 0; // 当前不在队列中 // 设置sched_entity p-\u003ese.on_rq = 0; // 当前不在队列中 p-\u003ese.exec_start = 0; p-\u003ese.sum_exec_runtime = 0; p-\u003ese.prev_sum_exec_runtime = 0; p-\u003ese.nr_migrations = 0; p-\u003ese.vruntime = 0; #ifdef CONFIG_SMP p-\u003ese.avg.decay_count = 0; #endif INIT_LIST_HEAD(\u0026p-\u003ese.group_node); #ifdef CONFIG_SCHEDSTATS memset(\u0026p-\u003ese.statistics, 0, sizeof(p-\u003ese.statistics)); #endif RB_CLEAR_NODE(\u0026p-\u003edl.rb_node); init_dl_task_timer(\u0026p-\u003edl); __dl_clear_params(p); INIT_LIST_HEAD(\u0026p-\u003ert.run_list); #ifdef CONFIG_PREEMPT_NOTIFIERS INIT_HLIST_HEAD(\u0026p-\u003epreempt_notifiers); #endif #ifdef CONFIG_NUMA_BALANCING if (p-\u003emm \u0026\u0026 atomic_read(\u0026p-\u003emm-\u003emm_users) == 1) { p-\u003emm-\u003enuma_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); p-\u003emm-\u003enuma_scan_seq = 0; } if (clone_flags \u0026 CLONE_VM) p-\u003enuma_preferred_nid = current-\u003enuma_preferred_nid; else p-\u003enuma_preferred_nid = -1; p-\u003enode_stamp = 0ULL; p-\u003enuma_scan_seq = p-\u003emm ? p-\u003emm-\u003enuma_scan_seq : 0; p-\u003enuma_scan_period = sysctl_numa_balancing_scan_delay; p-\u003enuma_work.next = \u0026p-\u003enuma_work; p-\u003enuma_faults = NULL; p-\u003elast_task_numa_placement = 0; p-\u003elast_sum_exec_runtime = 0; p-\u003enuma_group = NULL; #endif /* CONFIG_NUMA_BALANCING */ } 分析函数执行 根据上图，我们可以得知创建的是一个线程函数,但是这个不是我们要分析的,我们要分析``sched_fork`函数实现; 设置sched_entity成员 设置优先级 调用调度器类中的task_fork函数 执行结束之后 // 将任务添加到调度器 void wake_up_new_task(struct task_struct *p) { unsigned long flags; struct rq *rq; raw_spin_lock_irqsave(\u0026p-\u003epi_lock, flags); #ifdef CONFIG_SMP /* * Fork balancing, do it here and not earlier because: * - cpus_allowed can change in the fork path * - any previously selected cpu might disappear through hotplug */ set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); #endif /* Initialize new task's runnable average */ init_task_runnable_average(p); rq = __task_rq_lock(p); activate_task(rq, p, 0); // 激活任务 p-\u003eon_rq = TASK_ON_RQ_QUEUED; // 进入队列 trac","date":"2021-10-04","objectID":"/scheduler/:3:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#任务创建"},{"categories":["linux"],"content":" 4 调度基础 主调度器 滴答调度器 ","date":"2021-10-04","objectID":"/scheduler/:4:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度基础"},{"categories":["linux"],"content":" 4.1 主调度器 static void __sched __schedule(void) { struct task_struct *prev, *next; unsigned long *switch_count; struct rq *rq; int cpu; preempt_disable(); cpu = smp_processor_id(); rq = cpu_rq(cpu); rcu_note_context_switch(); prev = rq-\u003ecurr; schedule_debug(prev); if (sched_feat(HRTICK)) hrtick_clear(rq); /* * Make sure that signal_pending_state()-\u003esignal_pending() below * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) * done by the caller to avoid the race with signal_wake_up(). */ smp_mb__before_spinlock(); raw_spin_lock_irq(\u0026rq-\u003elock); rq-\u003eclock_skip_update \u003c\u003c= 1; /* promote REQ to ACT */ switch_count = \u0026prev-\u003enivcsw; if (prev-\u003estate \u0026\u0026 !(preempt_count() \u0026 PREEMPT_ACTIVE)) { if (unlikely(signal_pending_state(prev-\u003estate, prev))) { prev-\u003estate = TASK_RUNNING; } else { deactivate_task(rq, prev, DEQUEUE_SLEEP); prev-\u003eon_rq = 0; /* * If a worker went to sleep, notify and ask workqueue * whether it wants to wake up a task to maintain * concurrency. */ if (prev-\u003eflags \u0026 PF_WQ_WORKER) { struct task_struct *to_wakeup; to_wakeup = wq_worker_sleeping(prev, cpu); if (to_wakeup) try_to_wake_up_local(to_wakeup); } } switch_count = \u0026prev-\u003envcsw; } if (task_on_rq_queued(prev)) update_rq_clock(rq); next = pick_next_task(rq, prev); clear_tsk_need_resched(prev); clear_preempt_need_resched(); rq-\u003eclock_skip_update = 0; if (likely(prev != next)) { rq-\u003enr_switches++; rq-\u003ecurr = next; ++*switch_count; rq = context_switch(rq, prev, next); /* unlocks the rq */ cpu = cpu_of(rq); } else raw_spin_unlock_irq(\u0026rq-\u003elock); post_schedule(rq); sched_preempt_enable_no_resched(); } graph TD schedule --\u003e __schedule --\u003e context_switch 进入任务切换的核心函数context_switch,这个函数真够复杂的; static inline struct rq *context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next) { struct mm_struct *mm, *oldmm; // 执行切换前准备 prepare_task_switch(rq, prev, next); // 普通进程mm和active_mm相等 // 但是内核线程没有mm,只有active_mm mm = next-\u003emm; oldmm = prev-\u003eactive_mm; arch_start_context_switch(prev); if (!mm) { // 这个是内核线程 next-\u003eactive_mm = oldmm; // next线程借用oldmem，什么原因 atomic_inc(\u0026oldmm-\u003emm_count); // 减少计数 enter_lazy_tlb(oldmm, next); // 进入lazytlb，arm上为空 } else // 这个是用户线程 switch_mm(oldmm, mm, next); if (!prev-\u003emm) { // 代表prev是一个内核线程 prev-\u003eactive_mm = NULL; rq-\u003eprev_mm = oldmm; // 内核线程共享内存 } /* * Since the runqueue lock will be released by the next * task (which is an invalid locking op but in the case * of the scheduler it's an obvious special-case), so we * do an early lockdep release here: */ spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); context_tracking_task_switch(prev, next); // 调试使用 /* Here we just switch the register state and the stack. */ switch_to(prev, next, prev); // 这个函数和体系相关 barrier(); return finish_task_switch(prev); } extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *); #define switch_to(prev,next,last) \\ do { \\ last = __switch_to(prev,task_thread_info(prev), task_thread_info(next)); \\ } while (0) 在arm32的实现中,这个是汇编编写的；我并没有看明白 这个地方和硬件进行强相关； 最终需要考虑的是进程在队列中的实现; ","date":"2021-10-04","objectID":"/scheduler/:4:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#主调度器"},{"categories":["linux"],"content":" 4.2 内存空间切换switch_mm当然也是和硬件体系强相关 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { #ifdef CONFIG_MMU unsigned int cpu = smp_processor_id(); /* * __sync_icache_dcache doesn't broadcast the I-cache invalidation, * so check for possible thread migration and invalidate the I-cache * if we're new to this CPU. */ if (cache_ops_need_broadcast() \u0026\u0026 !cpumask_empty(mm_cpumask(next)) \u0026\u0026 !cpumask_test_cpu(cpu, mm_cpumask(next))) __flush_icache_all(); if (!cpumask_test_and_set_cpu(cpu, mm_cpumask(next)) || prev != next) { check_and_switch_context(next, tsk); if (cache_is_vivt()) cpumask_clear_cpu(cpu, mm_cpumask(prev)); } #endif } ","date":"2021-10-04","objectID":"/scheduler/:4:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#内存空间切换switch_mm"},{"categories":["linux"],"content":" 4.3 滴答调度器 void scheduler_tick(void) { int cpu = smp_processor_id(); struct rq *rq = cpu_rq(cpu); struct task_struct *curr = rq-\u003ecurr; sched_clock_tick(); raw_spin_lock(\u0026rq-\u003elock); update_rq_clock(rq); curr-\u003esched_class-\u003etask_tick(rq, curr, 0); update_cpu_load_active(rq); raw_spin_unlock(\u0026rq-\u003elock); perf_event_task_tick(); #ifdef CONFIG_SMP rq-\u003eidle_balance = idle_cpu(cpu); trigger_load_balance(rq); #endif rq_last_tick_reset(rq); } ","date":"2021-10-04","objectID":"/scheduler/:4:3","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#滴答调度器"},{"categories":["linux"],"content":" 5 就绪队列","date":"2021-10-04","objectID":"/scheduler/:5:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#就绪队列"},{"categories":["linux"],"content":" 5.1 成员分析 struct rq { /* runqueue lock: */ raw_spinlock_t lock; /* * nr_running and cpu_load should be in the same cacheline because * remote CPUs use both these fields when doing load calculation. */ unsigned int nr_running; #ifdef CONFIG_NUMA_BALANCING unsigned int nr_numa_running; unsigned int nr_preferred_running; #endif #define CPU_LOAD_IDX_MAX 5 unsigned long cpu_load[CPU_LOAD_IDX_MAX]; unsigned long last_load_update_tick; #ifdef CONFIG_NO_HZ_COMMON u64 nohz_stamp; unsigned long nohz_flags; #endif #ifdef CONFIG_NO_HZ_FULL unsigned long last_sched_tick; #endif /* capture load from *all* tasks on this cpu: */ struct load_weight load; unsigned long nr_load_updates; u64 nr_switches; struct cfs_rq cfs; struct rt_rq rt; struct dl_rq dl; #ifdef CONFIG_FAIR_GROUP_SCHED /* list of leaf cfs_rq on this cpu: */ struct list_head leaf_cfs_rq_list; struct sched_avg avg; #endif /* CONFIG_FAIR_GROUP_SCHED */ /* * This is part of a global counter where only the total sum * over all CPUs matters. A task can increase this counter on * one CPU and if it got migrated afterwards it may decrease * it on another CPU. Always updated under the runqueue lock: */ unsigned long nr_uninterruptible; struct task_struct *curr, *idle, *stop; unsigned long next_balance; struct mm_struct *prev_mm; unsigned int clock_skip_update; u64 clock; u64 clock_task; atomic_t nr_iowait; #ifdef CONFIG_SMP struct root_domain *rd; struct sched_domain *sd; unsigned long cpu_capacity; unsigned char idle_balance; /* For active balancing */ int post_schedule; int active_balance; int push_cpu; struct cpu_stop_work active_balance_work; /* cpu of this runqueue: */ int cpu; int online; struct list_head cfs_tasks; u64 rt_avg; u64 age_stamp; u64 idle_stamp; u64 avg_idle; /* This is used to determine avg_idle's max value */ u64 max_idle_balance_cost; #endif #ifdef CONFIG_IRQ_TIME_ACCOUNTING u64 prev_irq_time; #endif #ifdef CONFIG_PARAVIRT u64 prev_steal_time; #endif #ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING u64 prev_steal_time_rq; #endif /* calc_load related fields */ unsigned long calc_load_update; long calc_load_active; #ifdef CONFIG_SCHED_HRTICK #ifdef CONFIG_SMP int hrtick_csd_pending; struct call_single_data hrtick_csd; #endif struct hrtimer hrtick_timer; #endif #ifdef CONFIG_SCHEDSTATS /* latency stats */ struct sched_info rq_sched_info; unsigned long long rq_cpu_time; /* could above be rq-\u003ecfs_rq.exec_clock + rq-\u003ert_rq.rt_runtime ? */ /* sys_sched_yield() stats */ unsigned int yld_count; /* schedule() stats */ unsigned int sched_count; unsigned int sched_goidle; /* try_to_wake_up() stats */ unsigned int ttwu_count; unsigned int ttwu_local; #endif #ifdef CONFIG_SMP struct llist_head wake_list; #endif #ifdef CONFIG_CPU_IDLE /* Must be inspected within a rcu lock section */ struct cpuidle_state *idle_state; #endif }; 系统中每一个CPU都存在一个就绪队列,一个percpu变量. #define DEFINE_PER_CPU_SHARED_ALIGNED(type, name) \\ DEFINE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \\ ____cacheline_aligned_in_smp DEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); 操作宏 DECLARE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues); #define cpu_rq(cpu) (\u0026per_cpu(runqueues, (cpu))) #define this_rq() this_cpu_ptr(\u0026runqueues) #define task_rq(p) cpu_rq(task_cpu(p)) #define cpu_curr(cpu) (cpu_rq(cpu)-\u003ecurr) #define raw_rq() raw_cpu_ptr(\u0026runqueues) 设置当前运行队列的任务 ","date":"2021-10-04","objectID":"/scheduler/:5:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#成员分析"},{"categories":["linux"],"content":" 5.2 操作函数 void update_rq_clock(struct rq *rq) { s64 delta; lockdep_assert_held(\u0026rq-\u003elock); if (rq-\u003eclock_skip_update \u0026 RQCF_ACT_SKIP) return; delta = sched_clock_cpu(cpu_of(rq)) - rq-\u003eclock; if (delta \u003c 0) return; rq-\u003eclock += delta; update_rq_clock_task(rq, delta); } ","date":"2021-10-04","objectID":"/scheduler/:5:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#操作函数"},{"categories":["linux"],"content":" 6 调度增强","date":"2021-10-04","objectID":"/scheduler/:6:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度增强"},{"categories":["linux"],"content":" 6.1 组调度组调度:多个用户登录时平均分配计算机时间; /* task group related information */ struct task_group { struct cgroup_subsys_state css; #ifdef CONFIG_FAIR_GROUP_SCHED /* schedulable entities of this group on each cpu */ struct sched_entity **se; /* runqueue \"owned\" by this group on each cpu */ struct cfs_rq **cfs_rq; unsigned long shares; #ifdef CONFIG_SMP atomic_long_t load_avg; atomic_t runnable_avg; #endif #endif #ifdef CONFIG_RT_GROUP_SCHED struct sched_rt_entity **rt_se; struct rt_rq **rt_rq; struct rt_bandwidth rt_bandwidth; #endif struct rcu_head rcu; struct list_head list; struct task_group *parent; struct list_head siblings; struct list_head children; #ifdef CONFIG_SCHED_AUTOGROUP struct autogroup *autogroup; #endif struct cfs_bandwidth cfs_bandwidth; }; ","date":"2021-10-04","objectID":"/scheduler/:6:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#组调度"},{"categories":["linux"],"content":" 6.2 负载均衡","date":"2021-10-04","objectID":"/scheduler/:6:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#负载均衡"},{"categories":["前端知识"],"content":"WebAssembly","date":"2021-10-03","objectID":"/webassembly/","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/"},{"categories":["前端知识"],"content":"WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。 ","date":"2021-10-03","objectID":"/webassembly/:0:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#"},{"categories":["前端知识"],"content":" 1 安装编译器 $ git clone https://github.com/juj/emsdk.git $ cd emsdk $ ./emsdk install sdk-incoming-64bit binaryen-master-64bit $ ./emsdk activate sdk-incoming-64bit binaryen-master-64bit # 使用最新的代码 $ ./emsdk install latest $ ./emsdk activate latest 但是因为llvm需要连接github进行下载,常常会失败,因此需要使用mirror, 修改emsdk_manifest.json,找到https://github.com/llvm/llvm-project.git,修改为 https://mirrors.tuna.tsinghua.edu.cn/git/llvm-project.git,然后在执行下编译. 工具链编译结束,导入环境变量 source ./emsdk_env.sh #include \u003cstdio.h\u003e int main(int argc, char *argv[]) { printf(\"Hello world\\r\\n\"); return 0; } #include \u003ciostream\u003e int main(int argc, char *argv[]) { std::cout \u003c\u003c \"Hello world\\r\\n\" \u003c\u003c std::endl; return 0; } 执行编译 emcc hello.c -s WASM=1 -o hello.html # 执行编译 emrun --no_browser --port 8080 . # 运行 ","date":"2021-10-03","objectID":"/webassembly/:1:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#安装编译器"},{"categories":["前端知识"],"content":" 2 入门","date":"2021-10-03","objectID":"/webassembly/:2:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#入门"},{"categories":null,"content":" 博客内容 大部分都没有完成 C++ C++教程 C++模板 stl分析 汇编语言 kernel 系统调度 组调度 PLET 负载均衡 完全公平调度算法 实时系统 FreeRTOS RT-Thread 编译原理 词法分析 语法分析 语义分析 中间代码 目标代码 编程语言 python rust go lua 前端 html5 css3 javascript wasm tauri ","date":"2021-09-25","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/#博客内容"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制 ","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#"},{"categories":null,"content":" 使用","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#使用"},{"categories":null,"content":" 1 等待队列头 struct __wait_queue_head { wq_lock_t lock; struct list_head task_list; }; typedef struct __wait_queue_head wait_queue_head_t; ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列头"},{"categories":null,"content":" 2 等待队列实体 struct __wait_queue { unsigned int flags; struct task_struct * task; struct list_head task_list; }; typedef struct __wait_queue wait_queue_t; ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列实体"},{"categories":null,"content":" 3 初始化等待队列头 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *); void init_waitqueue_head(struct wait_queue_head *wq_head); ","date":"2021-05-04","objectID":"/wait_queue/:3:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列头"},{"categories":null,"content":" 4 初始化等待队列 #define __WAITQUEUE_INITIALIZER(name, tsk) \\ { \\ .private = tsk, \\ .func = default_wake_function, \\ .entry = { NULL, NULL } \\ } #define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) // 但是，一般直接 DECLARE_WAITQUEUE(wait, current); 等待队列入口 等待的任务 ","date":"2021-05-04","objectID":"/wait_queue/:4:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列"},{"categories":null,"content":" 5 等待队列操作 void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); 等待队列头 等待队列实体 ","date":"2021-05-04","objectID":"/wait_queue/:5:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列操作"},{"categories":null,"content":" 6 等待事件 void wait_event(wq, condition); void wait_event_interruptible(wq, condition); ","date":"2021-05-04","objectID":"/wait_queue/:6:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待事件"},{"categories":null,"content":" 7 唤醒队列 wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync ","date":"2021-05-04","objectID":"/wait_queue/:7:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#唤醒队列"},{"categories":null,"content":" 例子","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#例子"},{"categories":null,"content":" 1 写端 ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = -1; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_write; } add_wait_queue(\u0026wait_device.wait_w, \u0026wait); while (wait_device.wait_flag == true) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); pure_write: wait_device.wait_flag = true; pr_err(\"Write Successful\"); wake_up_interruptible(\u0026wait_device.wait_r); pr_err(\"Wakeup Read\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return ret; } ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#写端"},{"categories":null,"content":" 2 读端 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = 0; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_read; } add_wait_queue(\u0026wait_device.wait_r, \u0026wait); while (wait_device.wait_flag == false) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); pure_read: wait_device.wait_flag = false; pr_err(\"Read Successful\"); wake_up_interruptible(\u0026wait_device.wait_w); pr_err(\"Wakeup Write\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return 0; } ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#读端"},{"categories":null,"content":" 原理","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#原理"},{"categories":["编译原理"],"content":"编译原理","date":"2021-05-04","objectID":"/antlr/","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/"},{"categories":["编译原理"],"content":" 1 简介 ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件. 类似于flex/bison,根据描述文件,自动生成词法语法分析器; 解析规则文件,生成解析源文件,与SDK组合编译生成可执行文件; 生成器可以支持的语言,但是下面我只会其中的几个语言: 因此暂时只进行下面几种语言的开发,下面描述开发的情况和进度 Python3 JavaScript Go C++ ","date":"2021-05-04","objectID":"/antlr/:1:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#简介"},{"categories":["编译原理"],"content":" 2 安装说明 下载antlr 设置path和classpath 编写相关脚本 ","date":"2021-05-04","objectID":"/antlr/:2:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#安装说明"},{"categories":["编译原理"],"content":" 3 语法设计","date":"2021-05-04","objectID":"/antlr/:3:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#语法设计"},{"categories":["编译原理"],"content":" 4 错误处理","date":"2021-05-04","objectID":"/antlr/:4:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#错误处理"},{"categories":["编译原理"],"content":" 5 解析器","date":"2021-05-04","objectID":"/antlr/:5:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#解析器"},{"categories":["编译原理"],"content":" 6 测试程序","date":"2021-05-04","objectID":"/antlr/:6:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#测试程序"},{"categories":["编译原理"],"content":" 6.1 antlr4编译器 #!/bin/sh antlr4 Expr.g4 ","date":"2021-05-04","objectID":"/antlr/:6:1","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#antlr4编译器"},{"categories":["编译原理"],"content":" 6.2 编译生成的java文件 $ javac *.java ","date":"2021-05-04","objectID":"/antlr/:6:2","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#编译生成的java文件"},{"categories":["编译原理"],"content":" 6.3 运行编译的结果 $ grun Expr prog -tree (prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) grun Expr prog -gui grun Expr prog -tokens [@0,0:0='1',\u003cINT\u003e,1:0] [@1,1:1='+',\u003c'+'\u003e,1:1] [@2,2:2='2',\u003cINT\u003e,1:2] [@3,3:3='+',\u003c'+'\u003e,1:3] [@4,4:4='3',\u003cINT\u003e,1:4] [@5,5:6='\\r\\n',\u003cNEWLINE\u003e,1:5] [@6,7:6='\u003cEOF\u003e',\u003cEOF\u003e,2:0] ","date":"2021-05-04","objectID":"/antlr/:6:3","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#运行编译的结果"},{"categories":["编译原理"],"content":" 7 antlr语法详解","date":"2021-05-04","objectID":"/antlr/:7:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#antlr语法详解"},{"categories":["编译原理"],"content":" 7.1 Hello // antlr4 Hello.g4 // javac *.java // grun Hello r -gui grammar Hello; // 定义一个Hello的grammer r : 'hello' ID ; // 开头是hello后面接着一个ID ID : [a-z]+ ; // ID由小写字母组成 WS : [ \\t\\r\\n]+ -\u003e skip ; // 控制符清除 ","date":"2021-05-04","objectID":"/antlr/:7:1","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#hello"},{"categories":["编译原理"],"content":" 7.2 ArrayInit // antlr4 ArrayInit.g4 // javac *.java // grun ArrayInit init -gui grammar ArrayInit; // 定义一个ArrayInit的grammer init : '{' value (',' value)* '}' ; // value : init // 嵌套定义 | INT // 定义整数 ; INT : [0-9]+ ; WS : [ \\t\\r\\n]+ -\u003e skip ; ()* –\u003e 相当于扩展 ","date":"2021-05-04","objectID":"/antlr/:7:2","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#arrayinit"},{"categories":["编译原理"],"content":" 7.3 Expr // antlr4 Expr.g4 // javac *.java // grun Expr prog -gui grammar Expr; prog : stat+; stat: expr NEWLINE # printExpr | ID '=' expr NEWLINE # assign | NEWLINE # blank ; expr: expr op=('*'|'/') expr # MulDiv | expr op=('+'|'-') expr # AddSub | INT # int | ID # id | '('expr')' # parens ; MUL : '*' ; // assigns token name to '*' used above in grammar DIV : '/' ; ADD : '+' ; SUB : '-' ; ID : [a-zA-Z]+ ; INT : [0-9]+ ; NEWLINE :'\\r'? '\\n' ; WS : [ \\t]+ -\u003e skip; ","date":"2021-05-04","objectID":"/antlr/:7:3","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#expr"},{"categories":["编译原理"],"content":" 7.4 json 在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础 grammar JSON; // 声明一个grammar json : value // 一个value候选 ; obj // 对象类型 : '{' pair (',' pair)* '}' | '{' '}' ; pair : STRING ':' value ; arr : '[' value (',' value)* ']' | '[' ']' ; value : STRING | NUMBER | obj | arr | 'true' | 'false' | 'null' ; STRING : '\"' (ESC | SAFECODEPOINT)* '\"' ; fragment ESC : '\\\\' ([\"\\\\/bfnrt] | UNICODE) ; fragment UNICODE : 'u' HEX HEX HEX HEX ; fragment HEX : [0-9a-fA-F] ; fragment SAFECODEPOINT : ~ [\"\\\\\\u0000-\\u001F] ; NUMBER : '-'? INT ('.' [0-9] +)? EXP? ; fragment INT : '0' | [1-9] [0-9]* ; // no leading zeros fragment EXP : [Ee] [+\\-]? INT ; // \\- since - means \"range\" inside [...] WS : [ \\t\\n\\r] + -\u003e skip ; 测试例子 { \"glossary\": { \"title\": \"example glossary\", \"GlossDiv\": { \"title\": \"S\", \"GlossList\": { \"GlossEntry\": { \"ID\": \"SGML\", \"SortAs\": \"SGML\", \"GlossTerm\": \"Standard Generalized Markup Language\", \"Acronym\": \"SGML\", \"Abbrev\": \"ISO 8879:1986\", \"GlossDef\": { \"para\": \"A meta-markup language\", \"GlossSeeAlso\": [\"GML\", \"XML\"] }, \"GlossSee\": \"markup\" } } } } } 显示结果： ","date":"2021-05-04","objectID":"/antlr/:7:4","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#json"},{"categories":["编译原理"],"content":" 7.5 XML 孤岛语法: ","date":"2021-05-04","objectID":"/antlr/:7:5","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#xml"},{"categories":["编译原理"],"content":" 7.6 dot grammar DOT; graph : STRICT? ( GRAPH | DIGRAPH ) id_? '{' stmt_list '}' ; stmt_list : ( stmt ';'? )* ; stmt : node_stmt | edge_stmt | attr_stmt | id_ '=' id_ | subgraph ; attr_stmt : ( GRAPH | NODE | EDGE ) attr_list ; attr_list : ( '[' a_list? ']' )+ ; a_list : ( id_ ( '=' id_ )? ','? )+ ; edge_stmt : ( node_id | subgraph ) edgeRHS attr_list? ; edgeRHS : ( edgeop ( node_id | subgraph ) )+ ; edgeop : '-\u003e' | '--' ; node_stmt : node_id attr_list? ; node_id : id_ port? ; port : ':' id_ ( ':' id_ )? ; subgraph : ( SUBGRAPH id_? )? '{' stmt_list '}' ; id_ : ID | STRING | HTML_STRING | NUMBER ; // \"The keywords node, edge, graph, digraph, subgraph, and strict are // case-independent\" STRICT : [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] ; GRAPH : [Gg] [Rr] [Aa] [Pp] [Hh] ; DIGRAPH : [Dd] [Ii] [Gg] [Rr] [Aa] [Pp] [Hh] ; NODE : [Nn] [Oo] [Dd] [Ee] ; EDGE : [Ee] [Dd] [Gg] [Ee] ; SUBGRAPH : [Ss] [Uu] [Bb] [Gg] [Rr] [Aa] [Pp] [Hh] ; /** \"a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\" */ NUMBER : '-'? ( '.' DIGIT+ | DIGIT+ ( '.' DIGIT* )? ) ; fragment DIGIT : [0-9] ; /** \"any double-quoted string (\"...\") possibly containing escaped quotes\" */ STRING : '\"' ( '\\\\\"' | . )*? '\"' ; /** \"Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores * ('_') or digits ([0-9]), not beginning with a digit\" */ ID : LETTER ( LETTER | DIGIT )* ; fragment LETTER : [a-zA-Z\\u0080-\\u00FF_] ; /** \"HTML strings, angle brackets must occur in matched pairs, and * unescaped newlines are allowed.\" */ HTML_STRING : '\u003c' ( TAG | ~ [\u003c\u003e] )* '\u003e' ; fragment TAG : '\u003c' .*? '\u003e' ; COMMENT : '/*' .*? '*/' -\u003e skip ; LINE_COMMENT : '//' .*? '\\r'? '\\n' -\u003e skip ; /** \"a '#' character is considered a line output from a C preprocessor (e.g., * # 34 to indicate line 34 ) and discarded\" */ PREPROC : '#' ~[\\r\\n]* -\u003e skip ; WS : [ \\t\\n\\r]+ -\u003e skip ; ","date":"2021-05-04","objectID":"/antlr/:7:6","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#dot"},{"categories":null,"content":" 1 基本操作","date":"2021-05-04","objectID":"/hugo/:1:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#基本操作"},{"categories":null,"content":" 1.1 安装hugo在linux/windows上只能通过直接release下载, ","date":"2021-05-04","objectID":"/hugo/:1:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#安装hugo"},{"categories":null,"content":" 1.2 创建网站 hugo new site 路径 ","date":"2021-05-04","objectID":"/hugo/:1:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建网站"},{"categories":null,"content":" 1.3 添加主题 将主题直接添加到theme文件下面 将主题作为一个submodule ","date":"2021-05-04","objectID":"/hugo/:1:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#添加主题"},{"categories":null,"content":" 1.4 创建文档 hugo new posts/hugo.md ","date":"2021-05-04","objectID":"/hugo/:1:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建文档"},{"categories":null,"content":" 1.5 设置预览 hugo server -D --disableFastRender ","date":"2021-05-04","objectID":"/hugo/:1:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#设置预览"},{"categories":null,"content":" 2 文件结构 . ├── archetypes ├── config ├── content ├── data ├── layouts ├── static ├── themes ├── static └── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。 ","date":"2021-05-04","objectID":"/hugo/:2:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#文件结构"},{"categories":null,"content":" 2.1 archetypeshugo模板,在创建文件时作为模板自动生成 ","date":"2021-05-04","objectID":"/hugo/:2:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#archetypes"},{"categories":null,"content":" 2.2 assets存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录 ","date":"2021-05-04","objectID":"/hugo/:2:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#assets"},{"categories":null,"content":" 2.3 configHugo配置目录 ","date":"2021-05-04","objectID":"/hugo/:2:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#config"},{"categories":null,"content":" 2.4 content此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分. ","date":"2021-05-04","objectID":"/hugo/:2:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#content"},{"categories":null,"content":" 2.5 data该目录用于存储 Hugo 在生成网站时可以使用的配置文件 ","date":"2021-05-04","objectID":"/hugo/:2:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#data"},{"categories":null,"content":" 2.6 layouts以 .html文件的形式存储模板. ","date":"2021-05-04","objectID":"/hugo/:2:6","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#layouts"},{"categories":null,"content":" 2.7 static存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制 ","date":"2021-05-04","objectID":"/hugo/:2:7","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#static"},{"categories":null,"content":" 3 编写工具","date":"2021-05-04","objectID":"/hugo/:3:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#编写工具"},{"categories":null,"content":" 3.1 typora使用typora作为markdown编写工具 ","date":"2021-05-04","objectID":"/hugo/:3:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#typora"},{"categories":null,"content":" 3.2 picgo ","date":"2021-05-04","objectID":"/hugo/:3:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#picgo"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线","uri":"/offline/#"}]
[{"categories":["RTOS"],"content":"RTOS","date":"2022-10-30","objectID":"/freertos/","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/"},{"categories":["RTOS"],"content":" 1 基本概念","date":"2022-10-30","objectID":"/freertos/:1:0","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#基本概念"},{"categories":["RTOS"],"content":" 1.1 任务 一个死循环的函数运行(在RTOS中) ","date":"2022-10-30","objectID":"/freertos/:1:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务"},{"categories":["RTOS"],"content":" 1.2 函数运行环境(context) 寄存器 堆栈信息 ","date":"2022-10-30","objectID":"/freertos/:1:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#函数运行环境context"},{"categories":["RTOS"],"content":" 1.3 函数执行原理 pc/lr push/pop 下面写一个简单的函数,测试一下 函数是如何尽心调用的; int test(int a, int b) { return 0; } void main(void) { test(1, 2); } main –\u003e test 下面是程序编译后得到的汇编源码 test: push {r7} @ r7 --\u003e stack sub sp, sp, #12 @ sp = sp + 12 // 三个局部变量 add r7, sp, #0 @ r7 = sp str r0, [r7, #4] @ 保存第一个变量 str r1, [r7] @ 保存第二个变量 movs r3, #0 @ r3 = 0 mov r0, r3 @ r0 = r3 adds r7, r7, #12 @ r7 = r7 + 12 mov sp, r7 @ sp = r7 (销毁堆栈) ldr r7, [sp], #4 @ 恢复r7 bx lr @ 执行返回 main: push {r7, lr} @ 保存r7, lr add r7, sp, #0 @ r7 = sp movs r1, #2 @ r1 = 2 movs r0, #1 @ r0 = 1 bl test @ call test nop @ nop pop {r7, pc} @ lr_r = pc_v @ r7_r = r7_v ","date":"2022-10-30","objectID":"/freertos/:1:3","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#函数执行原理"},{"categories":["RTOS"],"content":" 1.4 总结那么,多任务就可以任务是从一个函数切换到另外一个函数; 但是此种切换对于任务来说是不可见的; 任务切换需要特权(定时器中断) 任务切换需要时停(开关中断) ","date":"2022-10-30","objectID":"/freertos/:1:4","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#总结"},{"categories":["RTOS"],"content":" 2 任务","date":"2022-10-30","objectID":"/freertos/:2:0","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务-1"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务创建"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#分配tcb结构体"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#初始化tcb成员变量"},{"categories":["RTOS"],"content":" 2.1 任务创建 分配TCB_t结构体 初始化参数(prvInitialiseNewTask) 添加到就绪列表(prvAddNewTaskToReadyList) 2.1.1 分配TCB结构体 申请TCB内存 申请栈内存 TCB结构体类型 typedef tskTCB TCB_t; typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*\u003c Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS == 1 ) xMPU_SETTINGS xMPUSettings; /*\u003c The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*\u003c The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*\u003c Used to reference a task from an event list. */ UBaseType_t uxPriority; /*\u003c The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*\u003c Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*\u003c Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH \u003e 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) ) StackType_t * pxEndOfStack; /*\u003c Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB == 1 ) UBaseType_t uxCriticalNesting; /*\u003c Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY == 1 ) UBaseType_t uxTCBNumber; /*\u003c Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*\u003c Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES == 1 ) UBaseType_t uxBasePriority; /*\u003c The priority last assigned to the task - used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG == 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS \u003e 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS == 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*\u003c Stores the amount of time the task has spent in the Running state. */ #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) /* Allocate a Newlib reent structure that is specific to this task. * Note Newlib support has been included by popular demand, but is not * used by the FreeRTOS maintainers themselves. FreeRTOS is not * responsible for resulting newlib operation. User must be familiar with * newlib and must provide system-wide implementations of the necessary * stubs. Be warned that (at the time of writing) the current newlib design * implements a system-wide malloc() that must be provided with locks. * * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html * for additional information. */ struct _reent xNewLib_reent; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*\u003c Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay == 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO == 1 ) int iTaskErrno; #endif } tskTCB; 实现的地方 StackType_t * pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = pvPortMallocStack( ( ( ( size_t ","date":"2022-10-30","objectID":"/freertos/:2:1","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#加入就绪列表"},{"categories":["RTOS"],"content":" 2.2 任务调度 任务调度的基础 可调用中断(可选) 定时器中断 2.2.1 调度器核心 void vTaskSwitchContext(void) { if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) { /* The scheduler is currently suspended - do not allow a context * switch. */ xYieldPending = pdTRUE; } else { xYieldPending = pdFALSE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations - which * are provided by the application, not the kernel. */ if( ulTotalRunTime \u003e ulTaskSwitchedInTime ) { pxCurrentTCB-\u003eulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime ); } else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime = ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskCHECK_FOR_STACK_OVERFLOW(); /* Before the currently running task is switched out, save its errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { pxCurrentTCB-\u003eiTaskErrno = FreeRTOS_errno; } #endif /* Select a new task to run using either the generic C or port * optimised asm code. */ taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ traceTASK_SWITCHED_IN(); /* After the new task is switched in, update the global errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { FreeRTOS_errno = pxCurrentTCB-\u003eiTaskErrno; } #endif #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) { /* Switch C-Runtime's TLS Block to point to the TLS * Block specific to this task. */ configSET_TLS_BLOCK( pxCurrentTCB-\u003exTLSBlock ); } #endif } } 分析M3的调度实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } 分析A9实现 vTaskSwitchContextConst: .word vTaskSwitchContext .macro portSAVE_CONTEXT /* Save the LR and SPSR onto the system mode stack before switching to system mode to save the remaining system mode registers. */ SRSDB sp!, #SYS_MODE CPS #SYS_MODE PUSH {R0-R12, R14} /* Push the critical nesting count. */ LDR R2, ulCriticalNestingConst LDR R1, [R2] PUSH {R1} /* Does the task have a floating point context that needs saving? If ulPortTaskHasFPUContext is 0 then no. */ LDR R2, ulPortTaskHasFPUContextConst LDR R3, [R2] CMP R3, #0 /* Save the floating point context, if any. */ FMRXNE R1, FPSCR VPUSHNE {D0-D15} VPUSHNE {D16-D31} PUSHNE {R1} /* Save ulPortTaskHasFPUContext itself. */ PUSH {R3} /* Save the stack pointer in the TCB. */ LDR R0, pxCurrentTCBConst LDR R1, [R0] STR SP, [R1] .endm ; /**********************************************************************/ .macro portRESTORE_CONTEXT /* Set the SP to point to the stack of the task being","date":"2022-10-30","objectID":"/freertos/:2:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务调度"},{"categories":["RTOS"],"content":" 2.2 任务调度 任务调度的基础 可调用中断(可选) 定时器中断 2.2.1 调度器核心 void vTaskSwitchContext(void) { if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE ) { /* The scheduler is currently suspended - do not allow a context * switch. */ xYieldPending = pdTRUE; } else { xYieldPending = pdFALSE; traceTASK_SWITCHED_OUT(); #if ( configGENERATE_RUN_TIME_STATS == 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations - which * are provided by the application, not the kernel. */ if( ulTotalRunTime \u003e ulTaskSwitchedInTime ) { pxCurrentTCB-\u003eulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime ); } else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime = ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ /* Check for stack overflow, if configured. */ taskCHECK_FOR_STACK_OVERFLOW(); /* Before the currently running task is switched out, save its errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { pxCurrentTCB-\u003eiTaskErrno = FreeRTOS_errno; } #endif /* Select a new task to run using either the generic C or port * optimised asm code. */ taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ traceTASK_SWITCHED_IN(); /* After the new task is switched in, update the global errno. */ #if ( configUSE_POSIX_ERRNO == 1 ) { FreeRTOS_errno = pxCurrentTCB-\u003eiTaskErrno; } #endif #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) ) { /* Switch C-Runtime's TLS Block to point to the TLS * Block specific to this task. */ configSET_TLS_BLOCK( pxCurrentTCB-\u003exTLSBlock ); } #endif } } 分析M3的调度实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } 分析A9实现 vTaskSwitchContextConst: .word vTaskSwitchContext .macro portSAVE_CONTEXT /* Save the LR and SPSR onto the system mode stack before switching to system mode to save the remaining system mode registers. */ SRSDB sp!, #SYS_MODE CPS #SYS_MODE PUSH {R0-R12, R14} /* Push the critical nesting count. */ LDR R2, ulCriticalNestingConst LDR R1, [R2] PUSH {R1} /* Does the task have a floating point context that needs saving? If ulPortTaskHasFPUContext is 0 then no. */ LDR R2, ulPortTaskHasFPUContextConst LDR R3, [R2] CMP R3, #0 /* Save the floating point context, if any. */ FMRXNE R1, FPSCR VPUSHNE {D0-D15} VPUSHNE {D16-D31} PUSHNE {R1} /* Save ulPortTaskHasFPUContext itself. */ PUSH {R3} /* Save the stack pointer in the TCB. */ LDR R0, pxCurrentTCBConst LDR R1, [R0] STR SP, [R1] .endm ; /**********************************************************************/ .macro portRESTORE_CONTEXT /* Set the SP to point to the stack of the task being","date":"2022-10-30","objectID":"/freertos/:2:2","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#调度器核心"},{"categories":["RTOS"],"content":" 2.3 任务状态 心跳实现 M3实现 void xPortPendSVHandler( void ) { /* This is a naked function. */ __asm volatile ( \" mrs r0, psp \\n\" \" isb \\n\" \" \\n\" \" ldr r3, pxCurrentTCBConst \\n\"/* Get the location of the current TCB. */ \" ldr r2, [r3] \\n\" \" \\n\" \" stmdb r0!, {r4-r11} \\n\"/* Save the remaining registers. */ \" str r0, [r2] \\n\"/* Save the new top of stack into the first member of the TCB. */ \" \\n\" \" stmdb sp!, {r3, r14} \\n\" \" mov r0, %0 \\n\" \" msr basepri, r0 \\n\" \" bl vTaskSwitchContext \\n\" \" mov r0, #0 \\n\" \" msr basepri, r0 \\n\" \" ldmia sp!, {r3, r14} \\n\" \" \\n\"/* Restore the context, including the critical nesting count. */ \" ldr r1, [r3] \\n\" \" ldr r0, [r1] \\n\"/* The first item in pxCurrentTCB is the task top of stack. */ \" ldmia r0!, {r4-r11} \\n\"/* Pop the registers. */ \" msr psp, r0 \\n\" \" isb \\n\" \" bx r14 \\n\" \" \\n\" \" .align 4 \\n\" \"pxCurrentTCBConst: .word pxCurrentTCB \\n\" ::\"i\" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) ); } A9实现 .align 4 .type FreeRTOS_IRQ_Handler, %function FreeRTOS_IRQ_Handler: /* Return to the interrupted instruction. */ SUB lr, lr, #4 /* Push the return address and SPSR. */ PUSH {lr} MRS lr, SPSR PUSH {lr} /* Change to supervisor mode to allow reentry. */ CPS #SVC_MODE /* Push used registers. */ PUSH {r0-r4, r12} /* Increment nesting count. r3 holds the address of ulPortInterruptNesting for future use. r1 holds the original ulPortInterruptNesting value for future use. */ LDR r3, ulPortInterruptNestingConst LDR r1, [r3] ADD r4, r1, #1 STR r4, [r3] /* Read value from the interrupt acknowledge register, which is stored in r0 for future parameter and interrupt clearing use. */ LDR r2, ulICCIARConst LDR r2, [r2] LDR r0, [r2] /* Ensure bit 2 of the stack pointer is clear. r2 holds the bit 2 value for future use. _RB_ Does this ever actually need to be done provided the start of the stack is 8-byte aligned? */ MOV r2, sp AND r2, r2, #4 SUB sp, sp, r2 /* Call the interrupt handler. r4 pushed to maintain alignment. */ PUSH {r0-r4, lr} LDR r1, vApplicationIRQHandlerConst BLX r1 POP {r0-r4, lr} ADD sp, sp, r2 CPSID i DSB ISB /* Write the value read from ICCIAR to ICCEOIR. */ LDR r4, ulICCEOIRConst LDR r4, [r4] STR r0, [r4] /* Restore the old nesting count. */ STR r1, [r3] /* A context switch is never performed if the nesting count is not 0. */ CMP r1, #0 BNE exit_without_switch /* Did the interrupt request a context switch? r1 holds the address of ulPortYieldRequired and r0 the value of ulPortYieldRequired for future use. */ LDR r1, =ulPortYieldRequired LDR r0, [r1] CMP r0, #0 BNE switch_before_exit exit_without_switch: /* No context switch. Restore used registers, LR_irq and SPSR before returning. */ POP {r0-r4, r12} CPS #IRQ_MODE POP {LR} MSR SPSR_cxsf, LR POP {LR} MOVS PC, LR switch_before_exit: /* A context swtich is to be performed. Clear the context switch pending flag. */ MOV r0, #0 STR r0, [r1] /* Restore used registers, LR-irq and SPSR before saving the context to the task stack. */ POP {r0-r4, r12} CPS #IRQ_MODE POP {LR} MSR SPSR_cxsf, LR POP {LR} portSAVE_CONTEXT /* Call the function that selects the new task to execute. vTaskSwitchContext() if vTaskSwitchContext() uses LDRD or STRD instructions, or 8 byte aligned stack allocated data. LR does not need saving as a new LR will be loaded by portRESTORE_CONTEXT anyway. */ LDR R0, vTaskSwitchContextConst BLX R0 /* Restore the context of, and branch to, the task selected to execute next. */ portRESTORE_CONTEXT ","date":"2022-10-30","objectID":"/freertos/:2:3","series":null,"tags":["RTOS"],"title":"FreeRTOS","uri":"/freertos/#任务状态"},{"categories":["arm"],"content":"arm汇编","date":"2022-09-24","objectID":"/arm/","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/"},{"categories":["arm"],"content":" 1 体系结构参考文件 arm指令手册1 arm指令手册2 arm指令手册3 ","date":"2022-09-24","objectID":"/arm/:1:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#体系结构"},{"categories":["arm"],"content":" 1.1 相关术语 流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE ","date":"2022-09-24","objectID":"/arm/:1:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#相关术语"},{"categories":["arm"],"content":" 1.2 工具链 文件名 详解 addr2line 把程序地址转化为文件名和行号 ar 建立、修改和提取归档文件 as 汇编编译器 ld 链接器 nm 列出文件的符号 objcopy 文件个数格式转换 objdump 反汇编 ranlib 产生索引,并且保存进入文件中 readelf 显示elf文件信息 size 列出文件大小 string 打印文件可打印字符串 strip 丢弃文件符号 交叉工具链测试 arm-none-eabi-addr2line arm-none-eabi-gdb arm-none-eabi-ar arm-none-eabi-gdb-add-index arm-none-eabi-as arm-none-eabi-gfortran arm-none-eabi-c++ arm-none-eabi-gprof arm-none-eabi-c++filt arm-none-eabi-ld arm-none-eabi-cpp arm-none-eabi-ld.bfd arm-none-eabi-dwp arm-none-eabi-ld.gold arm-none-eabi-elfedit arm-none-eabi-lto-dump arm-none-eabi-g++ arm-none-eabi-nm arm-none-eabi-gcc arm-none-eabi-objcopy arm-none-eabi-gcc-10.2.1 arm-none-eabi-objdump arm-none-eabi-gcc-ar arm-none-eabi-ranlib arm-none-eabi-gcc-nm arm-none-eabi-readelf arm-none-eabi-gcc-ranlib arm-none-eabi-size arm-none-eabi-gcov arm-none-eabi-strings arm-none-eabi-gcov-dump arm-none-eabi-strip arm-none-eabi-gcov-tool ","date":"2022-09-24","objectID":"/arm/:1:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#工具链"},{"categories":["arm"],"content":" 1.3 ARMv7处理器模式 模式 编码 功能 安全 优先级 User (USR) 10000 大多数运行的非特权模式 Both PL0 FIQ 10001 FIQ中断 Both PL1 IRQ 10010 IRQ中断 Both PL1 Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1 Monitor (MON) 10110 安全扩展实现 only PL1 Abort (ABT) 10111 内存权限异常 Both PL1 Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2 Undef (UND) 11011 未定义指令调用 Both PL1 System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1 不同的处理器模式上寄存器共享的情况 ","date":"2022-09-24","objectID":"/arm/:1:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#armv7处理器模式"},{"categories":["arm"],"content":" 1.4 指令条件码指令条件码由CPSR/SPSR同时确定 ","date":"2022-09-24","objectID":"/arm/:1:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#指令条件码"},{"categories":["arm"],"content":" 2 寻址方式 立即数寻址 寄存器寻址 寄存器间接寻址 寄存器偏移寻址 寄存器基址变址寻址 批量寄存器寻址 相对寻址 堆栈寻址 块拷贝寻址 ","date":"2022-09-24","objectID":"/arm/:2:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寻址方式"},{"categories":["arm"],"content":" 2.1 立即数寻址立即数为操作数,其中立即数前面加上# ;; 立即数寻址 mov r0, #0 ; r0 = 0 mov r1, #64 ; r1 = 64 ","date":"2022-09-24","objectID":"/arm/:2:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#立即数寻址"},{"categories":["arm"],"content":" 2.2 寄存器寻址","date":"2022-09-24","objectID":"/arm/:2:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器寻址"},{"categories":["arm"],"content":" 2.3 寄存器偏移寻址寄存器寻址就是直接将寄存器中的数值作为操作数 指令 作用 LSL Logical Shift Left by 1-31 bits. LSR Logical Shift Right by 1-32 bits. ASR Arithmetic Shift Right by 1-32 bits. ROR Rotate Right by 1-31 bits. RRX Rotate Right with Extend. mov r0, r1 ; r0 = r1 mov r1, #12 ; r1 = 12; mov r0, r1, LSL #3 ; r0 = r1 \u003c\u003c 3 = 512 mov r0, r1, LSR #3 ; r0 = r1 \u003e\u003e 3 = 8 mov r0, r1, ASR #3 ; r0 = r1 \u003e\u003e 3 = 8 不改写符号位 mov r0, r1, ROR #3 ; r1 = 0x80000001 mov r0, r1, RRX ; r0 = r1 \u003e\u003e 1 | 空位 = C ","date":"2022-09-24","objectID":"/arm/:2:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器偏移寻址"},{"categories":["arm"],"content":" 2.4 寄存器间接寻址获取内存地址中的数据,需要使用LDR/STR操作符; 首先确定,RAM的地址范围; 打开simulator-\u003eMemory Configuration 可以得到RAM的地址0x00900000 –\u003e 0x0097FFFF, ldr r0, =0x123 ;; r0 = 0x123 ldr r1, =0x900000 ;; r1 = 0x900000 str r0, [r1] ;; *((unsigned long *)r1) = r0; mov r0, 0 ;; r0 = 0 ldr r0, [r1] ;; r0 = *((unsigned long *)r1) 但是此时只能得到一些奇怪的数据,那如何确定程序是运行正常的? ;; 读取异常地址,看看是否会崩溃 ;; 如果获取一个异常的地址, ;; 看看会发生什么? ldr r1, =0x00980000 ldr r0, [r1] 程序立即崩溃, 我们的测试是正确的; ","date":"2022-09-24","objectID":"/arm/:2:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器间接寻址"},{"categories":["arm"],"content":" 2.5 寄存器基址变址寻址 LDR R0, [R1,#0X0F] ;; R0 = *(unsigned long *)(R1 + 0x0f) LDR R0, [R1],#4 ;; R0 = *(unsigned long *)(R1 + 0x04) LDR R0, [R1,R2] ;; R0 = *(unsigned long *)(R1 + R2) ","date":"2022-09-24","objectID":"/arm/:2:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#寄存器基址变址寻址"},{"categories":["arm"],"content":" 2.6 批量寄存器寻址批量寻址来自于批量操作符STM/LDM, LDMIA R0,{R1,R2,R3,R4} STMIA R0,{R3-R5,R10} ","date":"2022-09-24","objectID":"/arm/:2:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#批量寄存器寻址"},{"categories":["arm"],"content":" 2.7 堆栈寻址 LDMFD SP!,{R1-R7,LR} STMFD SP!,{R1-R7,LR} ","date":"2022-09-24","objectID":"/arm/:2:7","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#堆栈寻址"},{"categories":["arm"],"content":" 3 指令集","date":"2022-09-24","objectID":"/arm/:3:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#指令集"},{"categories":["arm"],"content":" 3.1 跳转指令 跳转指令可以向前后32M地址跳转 跳转为24位长有符号数据 B: 绝对跳转 BL: 带返回的跳转 BLX: 带返回和状态切换的跳转 BX: 状态切换的跳转 B(跳转) L(设置链接寄存器) X(切换arm/thumb状态) 跳转指令的详细解释: add pc, pc, #跳转地址 ;; 跳转指令 B label_jump_B label_jump_B: mov pc, lr ;; 但是此时编译会报错,需要状态切换 BX label_jump_BX label_jump_BX: BL label_jump_BL label_jump_BL: BLX label_jump_BLX label_jump_BLX: ","date":"2022-09-24","objectID":"/arm/:3:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#跳转指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据处理指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据传送指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#比较指令"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#加减法"},{"categories":["arm"],"content":" 3.2 数据处理指令 3.2.1 数据传送指令 mov: 直接传送 mvn: 取反码传送 mov r0, #12 ;; R0 = 0x0000000C mvn r1, #12 ;; R1 = 0xFFFFFFF3 3.2.2 比较指令 cmp cmn tst teq cmp r0, r1 ;; r0 - r1 ==\u003e NZCV cmn r0, r1 ;; r0 + r1 ==\u003e NZCV tst r0, r1 ;; r0 \u0026 r1 ==\u003e NZCV 比较指令会影响到NZCV标志 N -\u003e Negative 负数 Z -\u003e Zero 零 C -\u003e Carry 进位 V -\u003e oVerflow 溢出 3.2.3 加减法 add sub rsb adc sbc rsc 3.2.4 逻辑运算 and bic eor orr ","date":"2022-09-24","objectID":"/arm/:3:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#逻辑运算"},{"categories":["arm"],"content":" 3.3 乘法指令 mul mla smull umull umlal ","date":"2022-09-24","objectID":"/arm/:3:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#乘法指令"},{"categories":["arm"],"content":" 3.4 杂项算数指令 clz ","date":"2022-09-24","objectID":"/arm/:3:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#杂项算数指令"},{"categories":["arm"],"content":" 3.5 状态寄存器 mrs: 状态寄存器到通用寄存器 msr: 通用寄存器到状态寄存器 ","date":"2022-09-24","objectID":"/arm/:3:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#状态寄存器"},{"categories":["arm"],"content":" 3.6 内存操作指令 ldr/str ldm/stm ","date":"2022-09-24","objectID":"/arm/:3:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#内存操作指令"},{"categories":["arm"],"content":" 3.7 信号量操作指令 原子操作指令 swp swpb ","date":"2022-09-24","objectID":"/arm/:3:7","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#信号量操作指令"},{"categories":["arm"],"content":" 3.8 异常与中端指令 swi bkpt ","date":"2022-09-24","objectID":"/arm/:3:8","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#异常与中端指令"},{"categories":["arm"],"content":" 3.9 协处理器指令 cdp ldc stc mcr mrc ","date":"2022-09-24","objectID":"/arm/:3:9","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#协处理器指令"},{"categories":["arm"],"content":" 3.10 NEON指令 16个NEON寄存器(128bit), Q0-Q15(同时也可以被视为32个64bit的寄存器,D0-D31) ","date":"2022-09-24","objectID":"/arm/:3:10","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#neon指令"},{"categories":["arm"],"content":" 3.11 VFP指令 16个VFP寄存器(32bit),S0-S15 ","date":"2022-09-24","objectID":"/arm/:3:11","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#vfp指令"},{"categories":["arm"],"content":" 4 伪指令","date":"2022-09-24","objectID":"/arm/:4:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#伪指令"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#启动符号"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar"},{"categories":["arm"],"content":" 4.1 启动符号 4.1.1 IAR SECTION .intvec:CODE:NOROOT (2) END 但是此时是无法进行编译的 4.1.2 GCC .global _start _start: @汇编入口 loop: B loop .end @汇编程序结束 ","date":"2022-09-24","objectID":"/arm/:4:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#符号定义"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-1"},{"categories":["arm"],"content":" 4.2 符号定义 4.2.1 IAR 4.2.2 GCC","date":"2022-09-24","objectID":"/arm/:4:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-1"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#数据定义"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-2"},{"categories":["arm"],"content":" 4.3 数据定义 4.3.1 IAR 4.3.2 GCC","date":"2022-09-24","objectID":"/arm/:4:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-2"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#汇编控制"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-3"},{"categories":["arm"],"content":" 4.4 汇编控制 4.4.1 IAR 4.4.2 GCC","date":"2022-09-24","objectID":"/arm/:4:4","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-3"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#段定义"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar-4"},{"categories":["arm"],"content":" 4.5 段定义 4.5.1 IAR 4.5.2 GCC","date":"2022-09-24","objectID":"/arm/:4:5","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#gcc-4"},{"categories":["arm"],"content":" 4.6 杂项指令 GCC armasm 描述信息 @ ; Comment #\u0026 #0x An immediate hex value .if IFDEF, IF 条件编译 .else ELSE .elseif ELSEIF .endif ENDIF .ltorg LTORG ` ` :OR: \u0026 :AND: AND « :SHL: Shift Left » :SHR: Shift Right .macro MACRO Start macro definition .endm ENDM End macro definition .include INCLUDE GNU Assembler requires “filename” .word DCD A data word .short DCW .long DCD .byte DCB .req RN .global IMPORT, EXPORT .equ EQU ","date":"2022-09-24","objectID":"/arm/:4:6","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#杂项指令"},{"categories":["arm"],"content":" 5 程序设计","date":"2022-09-24","objectID":"/arm/:5:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#程序设计"},{"categories":["arm"],"content":" 5.1 条件语句","date":"2022-09-24","objectID":"/arm/:5:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#条件语句"},{"categories":["arm"],"content":" 5.2 循环语句","date":"2022-09-24","objectID":"/arm/:5:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#循环语句"},{"categories":["arm"],"content":" 5.3 函数定义","date":"2022-09-24","objectID":"/arm/:5:3","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#函数定义"},{"categories":["arm"],"content":" 6 混合编程","date":"2022-09-24","objectID":"/arm/:6:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#混合编程"},{"categories":["arm"],"content":" 6.1 C与汇编","date":"2022-09-24","objectID":"/arm/:6:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#c与汇编"},{"categories":["arm"],"content":" 6.2 C与thumb","date":"2022-09-24","objectID":"/arm/:6:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#c与thumb"},{"categories":["arm"],"content":" 7 存储系统","date":"2022-09-24","objectID":"/arm/:7:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#存储系统"},{"categories":["arm"],"content":" 7.1 MMU","date":"2022-09-24","objectID":"/arm/:7:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#mmu"},{"categories":["arm"],"content":" 7.2 cache","date":"2022-09-24","objectID":"/arm/:7:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#cache"},{"categories":["arm"],"content":" 8 仿真工具","date":"2022-09-24","objectID":"/arm/:8:0","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#仿真工具"},{"categories":["arm"],"content":" 8.1 IAR仿真设置新建工程 设置仿真 构建仿真 ","date":"2022-09-24","objectID":"/arm/:8:1","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#iar仿真设置"},{"categories":["arm"],"content":" 8.2 eclipse仿真设置 arm-none-eabi-gcc: 编译器 openocd: 调试器 qemu: 仿真器 ","date":"2022-09-24","objectID":"/arm/:8:2","series":null,"tags":["arm"],"title":"Arm笔记","uri":"/arm/#eclipse仿真设置"},{"categories":["Bsdiff"],"content":"Bsdiff","date":"2022-08-17","objectID":"/bsdiff/","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/"},{"categories":["Bsdiff"],"content":" 1 引言 bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u003e sorting (specifically, Larsson and Sadakane’s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) – 直接摘抄自官网 详情可以查看bsdiff官网,存在这个详细描述. bsdiff基本原理： 存在差异的数据: diff 不存在的数据: extra 最后生成的文件 = diff + extra; ","date":"2022-08-17","objectID":"/bsdiff/:1:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#引言"},{"categories":["Bsdiff"],"content":" 2 测试新建立两个文件old.c与new.c,二者的差别是 // new.c #include \u003cstdio.h\u003e int main(void) { printf(\"Hello World\\r\\n\"); return 0; } // old.c #include \u003cstdio.h\u003e int main(void) { return 0; } 测试的情况 # 执行编译 gcc old.c -o old \u0026\u0026 ./old gcc new.c -o new \u0026\u0026 ./new 计算md5 md5sum old # d08fd167e74f279522fe8aa64d8e27dd old md5sum new # b0b4be993de61064a118d32a692bf795 new md5sum mid # b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试 # 生成diff bsdiff old new test.diff # 打入补丁--\u003emid bspatch old mid test.diff ","date":"2022-08-17","objectID":"/bsdiff/:2:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#测试"},{"categories":["Bsdiff"],"content":" 3 原理 后缀数组实现 ","date":"2022-08-17","objectID":"/bsdiff/:3:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#原理"},{"categories":["Bsdiff"],"content":" 3.1 后缀数组定义","date":"2022-08-17","objectID":"/bsdiff/:3:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#后缀数组定义"},{"categories":["Bsdiff"],"content":" 3.2 后缀数组计算 倍增法和桶排序 倍增法的时间复杂度是O(NlogN)的,程序简单,算法过程易于理解. 桶排序时间复杂度是O(N),数据量大的时候,效率比倍增算法有显著提升,但是缺点在于DC3算法原理较难理解,代码冗长. ","date":"2022-08-17","objectID":"/bsdiff/:3:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#后缀数组计算"},{"categories":["Bsdiff"],"content":" 4 补丁文件bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件 每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容 diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件 start/bytes length/bytes content 0 8 “BSDIFF40” 8 8 the length of ctrl block 16 8 the length of diff block 24 8 新文件的大小 BSDIFF40 0x93 –\u003e 147 0x313 –\u003e 787 0x3ED0 –\u003e 16080 可以匹配新生成的文件 ","date":"2022-08-17","objectID":"/bsdiff/:4:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#补丁文件"},{"categories":["Bsdiff"],"content":" 5 生成补丁 bsdiff bspatch ","date":"2022-08-17","objectID":"/bsdiff/:5:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#生成补丁"},{"categories":["Bsdiff"],"content":" 5.1 数据结构 struct bsdiff_stream { void* opaque; /* bzip文件 */ void* (*malloc)(size_t size); /* 内存申请接口 */ void (*free)(void* ptr); /* 内存释放接口 */ int (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ const void* buffer, int size); }; struct bsdiff_request { const uint8_t* old; int64_t oldsize; const uint8_t* new; int64_t newsize; struct bsdiff_stream* stream; int64_t *I; uint8_t *buffer; }; ","date":"2022-08-17","objectID":"/bsdiff/:5:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#数据结构"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#接口分析"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行"},{"categories":["Bsdiff"],"content":" 5.2 接口分析 5.2.1 函数执行 5.2.2 代码分析 int bsdiff(const uint8_t* old, int64_t oldsize, const uint8_t* new, int64_t newsize, struct bsdiff_stream* stream) { int result; struct bsdiff_request req; if((req.I=stream-\u003emalloc((oldsize+1)*sizeof(int64_t)))==NULL) return -1; if((req.buffer=stream-\u003emalloc(newsize+1))==NULL) { stream-\u003efree(req.I); return -1; } req.old = old; req.oldsize = oldsize; req.new = new; req.newsize = newsize; req.stream = stream; result = bsdiff_internal(req); stream-\u003efree(req.buffer); stream-\u003efree(req.I); return result; } 此处的代码只能 ","date":"2022-08-17","objectID":"/bsdiff/:5:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan\u003creq.newsize) { oldscore=0; for(scsc=scan+=len;scan\u003creq.newsize;scan++) { len=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 0,req.oldsize,\u0026pos); for(;scsc\u003cscan+len;scsc++) if((scsc+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scsc+lastoffset] == req.new[scsc])) oldscore++; if(((len==oldscore) \u0026\u0026 (len!=0)) || (len\u003eoldscore+8)) break; if((scan+lastoffset\u003creq.oldsize) \u0026\u0026 (req.old[scan+lastoffset] == req.new[scan])) oldscore--; }; if((len!=oldscore) || (scan==req.newsize)) { s=0;Sf=0;lenf=0; for(i=0;(lastscan+i\u003cscan)\u0026\u0026(lastpos+i\u003creq.oldsize);) { if(req.old[lastpos+i]==req.new[lastscan+i]) s++; i++; if(s*2-i\u003eSf*2-lenf) { Sf=s; lenf=i; }; }; lenb=0; if(scan\u003creq.newsize) { s=0;Sb=0; for(i=1;(scan\u003e=lastscan+i)\u0026\u0026(pos\u003e=i);i++) { if(req.old[pos-i]==req.new[scan-i]) s++; if(s*2-i\u003eSb*2-lenb) { Sb=s; lenb=i; }; }; }; if(lastscan+lenf\u003escan-lenb) { overlap=(lastscan+lenf)-(scan-lenb); s=0;Ss=0;lens=0; for(i=0;i\u003coverlap;i++) { if(req.new[lastscan+lenf-overlap+i]== req.old[lastpos+lenf-overlap+i]) s++; if(req.new[scan-lenb+i]== req.old[pos-lenb+i]) s--; if(s\u003eSs) { Ss=s; lens=i+1; }; }; lenf+=lens-overlap; lenb-=lens; }; offtout(lenf,buf); offtout((scan-lenb)-(lastscan+lenf),buf+8); offtout((pos-lenb)-(lastpos+lenf),buf+16); /* Write control data */ if (writedata(req.stream, buf, sizeof(buf))) return -1; /* Write diff data */ for(i=0;i\u003clenf;i++) buffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; if (writedata(req.stream, buffer, lenf)) return -1; /* Write extra data */ for(i=0;i\u003c(scan-lenb)-(lastscan+lenf);i++) buffer[i]=req.new[lastscan+lenf+i]; if (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) return -1; lastscan=scan-lenb; lastpos=pos-lenb; lastoffset=pos-scan; }; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#核心处理"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-1"},{"categories":["Bsdiff"],"content":" 5.3 核心处理 5.3.1 函数执行 5.3.2 代码分析 static int bsdiff_internal(const struct bsdiff_request req) { int64_t *I,*V; int64_t scan,pos,len; int64_t lastscan,lastpos,lastoffset; int64_t oldscore,scsc; int64_t s,Sf,lenf,Sb,lenb; int64_t overlap,Ss,lens; int64_t i; uint8_t *buffer; uint8_t buf[8 * 3]; if((V=req.stream-\u003emalloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; I = req.I; qsufsort(I, V, req.old, req.oldsize); req.stream-\u003efree(V); buffer = req.buffer; /* Compute the differences, writing ctrl as we go */ scan=0;len=0;pos=0; lastscan=0;lastpos=0;lastoffset=0; while(scan","date":"2022-08-17","objectID":"/bsdiff/:5:3","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-1"},{"categories":["Bsdiff"],"content":" 5.4 偏移转缓存 偏移转缓存 缓存转偏移 static void offtout(int64_t x, uint8_t *buf) { int64_t y; if(x\u003c0) y=-x; else y=x; buf[0]=y%256;y-=buf[0]; y=y/256;buf[1]=y%256;y-=buf[1]; y=y/256;buf[2]=y%256;y-=buf[2]; y=y/256;buf[3]=y%256;y-=buf[3]; y=y/256;buf[4]=y%256;y-=buf[4]; y=y/256;buf[5]=y%256;y-=buf[5]; y=y/256;buf[6]=y%256;y-=buf[6]; y=y/256;buf[7]=y%256; if(x\u003c0) buf[7]|=0x80; } ","date":"2022-08-17","objectID":"/bsdiff/:5:4","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#偏移转缓存"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i\u003coldsize)\u0026\u0026(i\u003cnewsize);i++) if(old[i]!=new[i]) break; return i; } static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, const uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) { int64_t x,y; if(en-st\u003c2) { x=matchlen(old+I[st],oldsize-I[st],new,newsize); y=matchlen(old+I[en],oldsize-I[en],new,newsize); if(x\u003ey) { *pos=I[st]; return x; } else { *pos=I[en]; return y; } }; x=st+(en-st)/2; if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u003c0) { return search(I,old,oldsize,new,newsize,x,en,pos); } else { return search(I,old,oldsize,new,newsize,st,x,pos); }; } ","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#搜索"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-2"},{"categories":["Bsdiff"],"content":" 5.5 搜索 5.5.1 函数执行 5.5.2 代码分析 static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) { int64_t i; for(i=0;(i","date":"2022-08-17","objectID":"/bsdiff/:5:5","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-2"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k\u003cstart+len;k+=j) { j=1;x=V[I[k]+h]; for(i=1;k+i\u003cstart+len;i++) { if(V[I[k+i]+h]\u003cx) { x=V[I[k+i]+h]; j=0; }; if(V[I[k+i]+h]==x) { tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; j++; }; }; for(i=0;i\u003cj;i++) V[I[k+i]]=k+j-1; if(j==1) I[k]=-1; }; return; }; x=V[I[start+len/2]+h]; jj=0;kk=0; for(i=start;i\u003cstart+len;i++) { if(V[I[i]+h]\u003cx) jj++; if(V[I[i]+h]==x) kk++; }; jj+=start;kk+=jj; i=start;j=0;k=0; while(i\u003cjj) { if(V[I[i]+h]\u003cx) { i++; } else if(V[I[i]+h]==x) { tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; j++; } else { tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; k++; }; }; while(jj+j\u003ckk) { if(V[I[jj+j]+h]==x) { j++; } else { tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; k++; }; }; if(jj\u003estart) split(I,V,start,jj-start,h); for(i=0;i\u003ckk-jj;i++) V[I[jj+i]]=kk-1; if(jj==kk-1) I[jj]=-1; if(start+len\u003ekk) split(I,V,kk,start+len-kk,h); } static void qsufsort(int64_t *I, const uint8_t *old, int64_t oldsize) { int64_t buckets[256]; int64_t i,h,len; int64_t *V; if ((V = req.stream-\u003emalloc((req.oldsize+1) * sizeof(int64_t))) == NULL) { return -1; } for (i=0; i\u003c256; i++) { buckets[i]=0; } for(i=0;i\u003coldsize;i++) buckets[old[i]]++; for(i=1;i\u003c256;i++) buckets[i]+=buckets[i-1]; for(i=255;i\u003e0;i--) buckets[i]=buckets[i-1]; buckets[0]=0; for(i=0;i\u003coldsize;i++) I[++buckets[old[i]]]=i; I[0]=oldsize; for(i=0;i\u003coldsize;i++) V[i]=buckets[old[i]]; V[oldsize]=0; for(i=1;i\u003c256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; I[0]=-1; for(h=1;I[0]!=-(oldsize+1);h+=h) { len=0; for(i=0;i\u003coldsize+1;) { if(I[i]\u003c0) { len-=I[i]; i-=I[i]; } else { if(len) I[i-len]=-len; len=V[I[i]]+1-i; split(I,V,i,len,h); i+=len; len=0; }; }; if(len) I[i-len]=-len; }; for(i=0;i\u003coldsize+1;i++) I[V[i]]=i; free(V); } ","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#排序"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#函数执行-3"},{"categories":["Bsdiff"],"content":" 5.6 排序 5.6.1 函数执行 5.6.2 代码分析 static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) { int64_t i,j,k,x,tmp,jj,kk; if(len\u003c16) { for(k=start;k","date":"2022-08-17","objectID":"/bsdiff/:5:6","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-3"},{"categories":["Bsdiff"],"content":" 5.7 保存文件 简要写法 主要的操作就是将buffer直接写到文件中 static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { const int writeresult = stream-\u003ewrite(stream, buffer, length); return writeresult; } 原始写法 为了保证大小不超过API的大小 static int64_t writedata(struct bsdiff_stream* stream, const void* buffer, int64_t length) { int64_t result = 0; while (length \u003e 0) { const int smallsize = (int)MIN(length, INT_MAX); const int writeresult = stream-\u003ewrite(stream, buffer, smallsize); if (writeresult == -1) { return -1; } result += writeresult; length -= smallsize; buffer = (uint8_t*)buffer + smallsize; } return result; } ","date":"2022-08-17","objectID":"/bsdiff/:5:7","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#保存文件"},{"categories":["Bsdiff"],"content":" 6 打入补丁 bsdiff bspatch ","date":"2022-08-17","objectID":"/bsdiff/:6:0","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#打入补丁"},{"categories":["Bsdiff"],"content":" 6.1 缓存转偏移 偏移转缓存 缓存转偏移 /* 一般情况下,buf的长度为8个字节 */ static int64_t offtin(uint8_t *buf) { int64_t y; y=buf[7]\u00260x7F; /* 提取绝对值 */ y=y*256;y+=buf[6]; y=y*256;y+=buf[5]; y=y*256;y+=buf[4]; y=y*256;y+=buf[3]; y=y*256;y+=buf[2]; y=y*256;y+=buf[1]; y=y*256;y+=buf[0]; /* 根据最高位置确定正负 */ if (buf[7] \u0026 0x80) { y=-y; } return y; } ","date":"2022-08-17","objectID":"/bsdiff/:6:1","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#缓存转偏移"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i\u003cctrl[0];i++) if((oldpos+i\u003e=0) \u0026\u0026 (oldpos+i\u003coldsize)) new[newpos+i]+=old[oldpos+i]; /* Adjust pointers */ newpos+=ctrl[0]; oldpos+=ctrl[0]; /* Sanity-check */ if(newpos+ctrl[1]\u003enewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#核心功能"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#执行路线"},{"categories":["Bsdiff"],"content":" 6.2 核心功能 6.2.1 执行路线 6.2.2 代码分析 int bspatch(const uint8_t* old, int64_t oldsize, uint8_t* new, int64_t newsize, struct bspatch_stream* stream) { uint8_t buf[8]; int64_t oldpos; int64_t newpos; int64_t ctrl[3]; int64_t i; oldpos=0; newpos=0; while (newpos \u003c newsize) { /* Read control data 3*8个为一组,每次生成3个控制数据 */ for(i=0;i\u003c=2;i++) { if (stream-\u003eread(stream, buf, 8)) return -1; ctrl[i]=offtin(buf); }; /* 健壮性检查 */ if (ctrl[0]\u003c0 || ctrl[0]\u003eINT_MAX || ctrl[1]\u003c0 || ctrl[1]\u003eINT_MAX || newpos+ctrl[0]\u003enewsize) return -1; /* Read diff string */ if (stream-\u003eread(stream, new + newpos, ctrl[0])) return -1; /* Add old data to diff string */ for(i=0;i=0) \u0026\u0026 (oldpos+inewsize) return -1; /* Read extra string */ if (stream-\u003eread(stream, new + newpos, ctrl[1])) return -1; /* Adjust pointers */ newpos+=ctrl[1]; oldpos+=ctrl[2]; }; return 0; } ","date":"2022-08-17","objectID":"/bsdiff/:6:2","series":null,"tags":null,"title":"Bsdiff","uri":"/bsdiff/#代码分析-4"},{"categories":["编程语言"],"content":"C++基础笔记","date":"2022-07-28","objectID":"/cxx_basic/","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 ","date":"2022-07-28","objectID":"/cxx_basic/:0:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#"},{"categories":["编程语言"],"content":" 1 第一个程序 #include \u003ciostream\u003e using namespace std; int main(int argc, char *argv[]) { cout \u003c\u003c \"Hello World\" \u003c\u003c endl; return 0; } 编译指令 从生成的汇编指令来看,复杂不少 __cxx_global_var_init: push {r11, lr} mov r11, sp sub sp, sp, #8 ldr r0, .LCPI0_0 .LPC0_0: add r0, pc, r0 str r0, [sp, #4] @ 4-byte Spill bl std::ios_base::Init::Init() [complete object constructor] ldr r1, [sp, #4] @ 4-byte Reload ldr r0, .LCPI0_1 .LPC0_1: ldr r0, [pc, r0] ldr r2, .LCPI0_2 .LPC0_2: add r2, pc, r2 bl __cxa_atexit mov sp, r11 pop {r11, lr} bx lr .LCPI0_0: .long _ZStL8__ioinit-(.LPC0_0+8) .LCPI0_1: .Ltmp2: .long _ZNSt8ios_base4InitD1Ev(GOT_PREL)-((.LPC0_1+8)-.Ltmp2) .LCPI0_2: .long __dso_handle-(.LPC0_2+8) main: push {r11, lr} mov r11, sp sub sp, sp, #16 mov r2, #0 str r2, [sp] @ 4-byte Spill str r2, [r11, #-4] str r0, [sp, #8] str r1, [sp, #4] ldr r0, .LCPI1_0 .LPC1_0: ldr r0, [pc, r0] ldr r1, .LCPI1_1 .LPC1_1: add r1, pc, r1 bl std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 std::operator\u003c\u003c \u003cstd::char_traits\u003cchar\u003e \u003e(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026, char const*) ldr r1, .LCPI1_2 .LPC1_2: ldr r1, [pc, r1] bl std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e::operator\u003c\u003c(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026 (*)(std::basic_ostream\u003cchar, std::char_traits\u003cchar\u003e \u003e\u0026)) ldr r0, [sp] @ 4-byte Reload mov sp, r11 pop {r11, lr} bx lr .LCPI1_0: .Ltmp5: .long _ZSt4cout(GOT_PREL)-((.LPC1_0+8)-.Ltmp5) .LCPI1_1: .long .L.str-(.LPC1_1+8) .LCPI1_2: .Ltmp6: .long _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(GOT_PREL)-((.LPC1_2+8)-.Ltmp6) _GLOBAL__sub_I_example.cpp: push {r11, lr} mov r11, sp bl __cxx_global_var_init pop {r11, lr} bx lr .L.str: .asciz \"Hello World\" ","date":"2022-07-28","objectID":"/cxx_basic/:1:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#第一个程序"},{"categories":["编程语言"],"content":" 2 注释","date":"2022-07-28","objectID":"/cxx_basic/:2:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#注释"},{"categories":["编程语言"],"content":" 2.1 C++注释 // 这个是一个单行注释 ","date":"2022-07-28","objectID":"/cxx_basic/:2:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c注释"},{"categories":["编程语言"],"content":" 2.2 C注释 /* 这个里面是一个注释 */ 在C/C++中两种注释都是可以使用的 并不是绝对的,只因为提出者是C或者C++ 注释不影响程序的编译–\u003e(预编译删除所有注释) 推荐使用doxygen–\u003e(使用doxygen漂亮的注释) ","date":"2022-07-28","objectID":"/cxx_basic/:2:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c注释-1"},{"categories":["编程语言"],"content":" 3 标识符","date":"2022-07-28","objectID":"/cxx_basic/:3:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#标识符"},{"categories":["编程语言"],"content":" 3.1 变量变量的存在意义:方便我们管理内存 变量创建的语法 存储类型 数据类型 变量名 = 变量初始化; 自动,不使用标识符 寄存器(register) 静态static 外部extern /* auto */ int a = 0; // C++不在添加自动变量标识符 static int a = 0; // 静态 register int a = 0; // 寄存器 extern int a = 0; // 外部 总结 存储类型 持续性 作用域 链接性 定义 自动变量 自动 函数内 ❎ 无标志符,定义在函数内 寄存器 自动 函数内 ❎ register 静态 全局 函数内|文件内 ❎ static 外部 全局 文件内 ✅ 无标志符,定义在文件内 ","date":"2022-07-28","objectID":"/cxx_basic/:3:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#变量"},{"categories":["编程语言"],"content":" 3.2 常量作用: 记录程序中不可以改变的数据 define 宏常量(预编译期) const 修饰变量(编译期) ","date":"2022-07-28","objectID":"/cxx_basic/:3:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#常量"},{"categories":["编程语言"],"content":" 3.3 关键字 关键字 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template ","date":"2022-07-28","objectID":"/cxx_basic/:3:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#关键字"},{"categories":["编程语言"],"content":" 3.4 命名规则 标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写 ","date":"2022-07-28","objectID":"/cxx_basic/:3:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#命名规则"},{"categories":["编程语言"],"content":" 4 数据类型指定类型,分配内存 ","date":"2022-07-28","objectID":"/cxx_basic/:4:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#数据类型"},{"categories":["编程语言"],"content":" 4.1 整形","date":"2022-07-28","objectID":"/cxx_basic/:4:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#整形"},{"categories":["编程语言"],"content":" 4.2 浮点型 单精度float 双精度double ","date":"2022-07-28","objectID":"/cxx_basic/:4:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#浮点型"},{"categories":["编程语言"],"content":" 4.3 字符型","date":"2022-07-28","objectID":"/cxx_basic/:4:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#字符型"},{"categories":["编程语言"],"content":" 4.4 转义字符","date":"2022-07-28","objectID":"/cxx_basic/:4:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#转义字符"},{"categories":["编程语言"],"content":" 4.5 字符串 C风格 char 变量名[] = \"字符串值\"; C++风格 string 变量名 = \"字符串值\"; ","date":"2022-07-28","objectID":"/cxx_basic/:4:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#字符串"},{"categories":["编程语言"],"content":" 4.6 布尔类型 bool A = true; bool B = false; ","date":"2022-07-28","objectID":"/cxx_basic/:4:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#布尔类型"},{"categories":["编程语言"],"content":" 5 运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#运算符"},{"categories":["编程语言"],"content":" 5.1 基本运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#基本运算符"},{"categories":["编程语言"],"content":" 5.2 取模运算就是取余数 ","date":"2022-07-28","objectID":"/cxx_basic/:5:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#取模运算"},{"categories":["编程语言"],"content":" 5.3 自增自减运算 a1++; a2--; ","date":"2022-07-28","objectID":"/cxx_basic/:5:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#自增自减运算"},{"categories":["编程语言"],"content":" 5.4 赋值运算 运算符 术语 示例 结果 = += -= *= /= %= ","date":"2022-07-28","objectID":"/cxx_basic/:5:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#赋值运算"},{"categories":["编程语言"],"content":" 5.5 比较运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#比较运算符"},{"categories":["编程语言"],"content":" 5.6 逻辑运算符","date":"2022-07-28","objectID":"/cxx_basic/:5:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#逻辑运算符"},{"categories":["编程语言"],"content":" 6 流程控制","date":"2022-07-28","objectID":"/cxx_basic/:6:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#流程控制"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#顺序结构"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#if语句"},{"categories":["编程语言"],"content":" 6.1 顺序结构 6.1.1 if语句 // 情景1 if (条件) { } // 情景2 if (条件) { } else { } // 情景3 if (条件1) { } else if (条件2) { } else { } 6.1.2 三目运算符 表达式1? 表达式2:表达式3 ","date":"2022-07-28","objectID":"/cxx_basic/:6:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#三目运算符"},{"categories":["编程语言"],"content":" 6.2 选择结构 switch(condition) { case 条件1: break; case 条件2: break; default: break; } ","date":"2022-07-28","objectID":"/cxx_basic/:6:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#选择结构"},{"categories":["编程语言"],"content":" 6.3 循环结构","date":"2022-07-28","objectID":"/cxx_basic/:6:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#循环结构"},{"categories":["编程语言"],"content":" 6.4 while循环 while(条件) { 循环体; } ###do...while循环 do { } while(条件) ","date":"2022-07-28","objectID":"/cxx_basic/:6:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#while循环"},{"categories":["编程语言"],"content":" 6.5 for循环 for (起始表达式; 条件表达式; 末尾循环体) { 循环体; } ","date":"2022-07-28","objectID":"/cxx_basic/:6:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#for循环"},{"categories":["编程语言"],"content":" 6.6 跳转语句 break continue 6.6.1 goto 绝对跳转语句 ","date":"2022-07-28","objectID":"/cxx_basic/:6:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#跳转语句"},{"categories":["编程语言"],"content":" 6.6 跳转语句 break continue 6.6.1 goto 绝对跳转语句 ","date":"2022-07-28","objectID":"/cxx_basic/:6:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#goto"},{"categories":["编程语言"],"content":" 7 函数定义 返回值类型 函数名 参数列表 函数体语句 return表达式 返回值类型 函数名字(参数列表) { 函数体语句; return 表达式; } ","date":"2022-07-28","objectID":"/cxx_basic/:7:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数定义"},{"categories":["编程语言"],"content":" 7.1 值传递 类似数值拷贝 ","date":"2022-07-28","objectID":"/cxx_basic/:7:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#值传递"},{"categories":["编程语言"],"content":" 7.2 函数的常见样式 无参无返 有参无返 无参有反 有参有返 ","date":"2022-07-28","objectID":"/cxx_basic/:7:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数的常见样式"},{"categories":["编程语言"],"content":" 7.3 声明作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现; ","date":"2022-07-28","objectID":"/cxx_basic/:7:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#声明"},{"categories":["编程语言"],"content":" 7.4 多文件","date":"2022-07-28","objectID":"/cxx_basic/:7:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#多文件"},{"categories":["编程语言"],"content":" 8 复合数据结构","date":"2022-07-28","objectID":"/cxx_basic/:8:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#复合数据结构"},{"categories":["编程语言"],"content":" 8.1 数组","date":"2022-07-28","objectID":"/cxx_basic/:8:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#数组"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针的定义和使用"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针所占用空间"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#空指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#野指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#const与指针"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针与数组"},{"categories":["编程语言"],"content":" 8.2 指针 8.2.1 指针的定义和使用 8.2.2 指针所占用空间 8.2.3 空指针含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的 8.2.4 野指针指针指向非法的内存空间 8.2.5 const与指针 const修饰指针 const修饰常量 const既修饰指针又修饰常量 const int *p = \u0026a; int const *p = \u0026a; const int *const p = \u0026a; 8.2.6 指针与数组 8.2.7 指针与函数","date":"2022-07-28","objectID":"/cxx_basic/:8:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#指针与函数"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体数组"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体指针"},{"categories":["编程语言"],"content":" 8.3 结构体 8.3.1 结构体数组 8.3.2 结构体指针 8.3.3 结构体嵌套","date":"2022-07-28","objectID":"/cxx_basic/:8:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#结构体嵌套"},{"categories":["编程语言"],"content":" 8.4 枚举","date":"2022-07-28","objectID":"/cxx_basic/:8:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#枚举"},{"categories":["编程语言"],"content":" 8.5 联合","date":"2022-07-28","objectID":"/cxx_basic/:8:5","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#联合"},{"categories":["编程语言"],"content":" 8.6 位域","date":"2022-07-28","objectID":"/cxx_basic/:8:6","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#位域"},{"categories":["编程语言"],"content":" 9 C++内存分区c++程序在运行时,将内存分为4个区域 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放 ","date":"2022-07-28","objectID":"/cxx_basic/:9:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#c内存分区"},{"categories":["编程语言"],"content":" 10 new/delete操作符 new操作符在堆区开辟内存 delete释放内存对象 ","date":"2022-07-28","objectID":"/cxx_basic/:10:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#newdelete操作符"},{"categories":["编程语言"],"content":" 11 引用作用: 给变量起别名 语法: 数据类型 \u0026别名 = 原名; ","date":"2022-07-28","objectID":"/cxx_basic/:11:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用"},{"categories":["编程语言"],"content":" 11.1 引用做参数 #include \u003ciostream\u003e void swap(int \u0026a, int \u0026b) { int t; t = a;a = b;b = t; } int main(int argc, char *argv[]) { int a = 10;int b = 12; std::cout \u003c\u003c \"交换前\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; swap(a, b); std::cout \u003c\u003c \"交换后\" \u003c\u003c a \u003c\u003c '\\t' \u003c\u003c b \u003c\u003c std::endl; return 0; } 执行结果 ","date":"2022-07-28","objectID":"/cxx_basic/:11:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用做参数"},{"categories":["编程语言"],"content":" 11.2 引用做返回值","date":"2022-07-28","objectID":"/cxx_basic/:11:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用做返回值"},{"categories":["编程语言"],"content":" 11.3 引用的本质引用的本质是C++内部实现的一个指针常量 ","date":"2022-07-28","objectID":"/cxx_basic/:11:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#引用的本质"},{"categories":["编程语言"],"content":" 11.4 常量引用 const int \u0026ref = 10; ","date":"2022-07-28","objectID":"/cxx_basic/:11:4","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#常量引用"},{"categories":["编程语言"],"content":" 12 函数提高","date":"2022-07-28","objectID":"/cxx_basic/:12:0","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数提高"},{"categories":["编程语言"],"content":" 12.1 函数默认值 某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突) void test_default_param(int a = 0, int b = 0, int c = 0) { std::cout \u003c\u003c a + b + c \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/cxx_basic/:12:1","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数默认值"},{"categories":["编程语言"],"content":" 12.2 函数的占位参数占位参数还可以有默认值 void test(int a, int = 10) { std::cout \u003c\u003c a \u003c\u003c std::endl; } ","date":"2022-07-28","objectID":"/cxx_basic/:12:2","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数的占位参数"},{"categories":["编程语言"],"content":" 12.3 函数重载作用:函数名相同,提高复用性 重载的条件: 相同作用域 函数名相同 参数不同(类型, 个数,顺序) 注意事项: 引用作为重载条件 函数重载碰到默认参数 ","date":"2022-07-28","objectID":"/cxx_basic/:12:3","series":null,"tags":["C++"],"title":"C++基础笔记","uri":"/cxx_basic/#函数重载"},{"categories":["编程语言"],"content":"C++提高笔记","date":"2022-07-28","objectID":"/cxx_enhance/","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 ","date":"2022-07-28","objectID":"/cxx_enhance/:0:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#"},{"categories":["编程语言"],"content":" 1 类和对象 类的访问属性 类的继承属性 public: protected: private: ","date":"2022-07-28","objectID":"/cxx_enhance/:1:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类和对象"},{"categories":["编程语言"],"content":" 1.1 成员函数 成员函数 + delete表示删除此函数 成员函数 + default表示默认函数 explicit: 关闭隐式类型转换 关键字只能作用域类构造函数 只作用单个参数的构造函数 final: 第一个用在类，用于说明该类是继承体系下最后的一个类，不要其他类继承我，当继承时就会报错。 第二个用在虚函数，表示这个虚函数不能再被override了，再override就会报错 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员函数"},{"categories":["编程语言"],"content":" 1.2 虚函数 override用于虚函数,上面的virtual void func(int)实际上不是重写父类的虚函数,而是定义一个新的虚函数; 我们的本意是重写虚函数,当不加overrride的时候,这样写编译器不会报错 那如果像下面加上override的话，则会报错，表示告诉了编译器，我确实要重写，但写错了，没有重写，于是就报错了 这样就能给我们对虚函数的重写做检查! ","date":"2022-07-28","objectID":"/cxx_enhance/:1:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数"},{"categories":["编程语言"],"content":" 1.3 class与struct的区别class默认权限是private struct默认权限是public ","date":"2022-07-28","objectID":"/cxx_enhance/:1:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#class与struct的区别"},{"categories":["编程语言"],"content":" 1.4 构造函数和析构函数对象的初始化和清理 构造函数有参数 析构函数没有参数 二者都没有返回值 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数和析构函数"},{"categories":["编程语言"],"content":" 1.5 拷贝构造函数 class Person { public: /* 构造函数 */ Person(std::string name, int age) { std::cout \u003c\u003c \"构造函数\" \u003c\u003c std::endl; } /* 析构函数 */ ~Person() { std::cout \u003c\u003c \"析构函数\" \u003c\u003c std::endl; } /* 拷贝构造函数 */ Person(const Person \u0026p) { std::cout \u003c\u003c \"拷贝构造函数\" \u003c\u003c std::endl; } }; 调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果 Person testPerson(); // 表面上是执行构造函数 int func(); // 类似函数声明 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数"},{"categories":["编程语言"],"content":" 1.6 拷贝构造函数的调用时机 使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:6","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#拷贝构造函数的调用时机"},{"categories":["编程语言"],"content":" 1.7 构造函数的调用规则默认情况下:C++编译器至少给一个类添加3个函数 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝 构造函数构造规则如下: 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:7","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造函数的调用规则"},{"categories":["编程语言"],"content":" 1.8 深拷贝和浅拷贝 浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作 ","date":"2022-07-28","objectID":"/cxx_enhance/:1:8","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#深拷贝和浅拷贝"},{"categories":["编程语言"],"content":" 2 初始化列表作用:C++提供了初始化列表语法,用来初始化属性; 语法: 构造函数(): 属性1(值1),属性2(值2),属性3(值3) { /* 函数体 */ } ","date":"2022-07-28","objectID":"/cxx_enhance/:2:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#初始化列表"},{"categories":["编程语言"],"content":" 3 类对象作为类成员","date":"2022-07-28","objectID":"/cxx_enhance/:3:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#类对象作为类成员"},{"categories":["编程语言"],"content":" 3.1 静态成员静态成员就是在静态成员变量和成员函数前加上static,称为静态成员; 静态成员变量 所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 class Person { public: static int age; static void func() { std::cout \u003c\u003c \"静态成员函数\" \u003c\u003c std::endl; } }; /* 通过对象访问 */ Person p; p.func(); /* 通过类访问 */ Person::func(); ","date":"2022-07-28","objectID":"/cxx_enhance/:3:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#静态成员"},{"categories":["编程语言"],"content":" 3.2 成员变量和成员函数分开存储 非静态成员, 属于类的对象 静态成员, 不属于类的对象 非静态成员函数, 不属于类的对象 静态成员函数, 不属于类的对象 空对象大小为1 ","date":"2022-07-28","objectID":"/cxx_enhance/:3:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#成员变量和成员函数分开存储"},{"categories":["编程语言"],"content":" 4 C++对象模型","date":"2022-07-28","objectID":"/cxx_enhance/:4:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#c对象模型"},{"categories":["编程语言"],"content":" 5 this指针this指针指向被调用成员函数所属的对象 this指针本质：指针常量 ","date":"2022-07-28","objectID":"/cxx_enhance/:5:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#this指针"},{"categories":["编程语言"],"content":" 6 空指针访问成员函数C++空指针也是可以访问成员函数的,但是要注意的this指针; ","date":"2022-07-28","objectID":"/cxx_enhance/:6:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#空指针访问成员函数"},{"categories":["编程语言"],"content":" 7 const修饰成员函数常函数: 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数 执行原理 this ==\u003e Person * const this; 后面新追加的const则会造成 const Person * const this; class Person { public: int m_A; mutable int m_B; void showPerson() const { m_A = 10; /* 错误,不可修改 */ m_B = 10; /* 正确,可以修改 */ } }; ","date":"2022-07-28","objectID":"/cxx_enhance/:7:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#const修饰成员函数"},{"categories":["编程语言"],"content":" 8 友元 全局函数 全局类 成员函数 ","date":"2022-07-28","objectID":"/cxx_enhance/:8:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#友元"},{"categories":["编程语言"],"content":" 9 运算符重载重载的原理:对已有的运算符进行重新定义,赋予新的功能含义; ","date":"2022-07-28","objectID":"/cxx_enhance/:9:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#运算符重载"},{"categories":["编程语言"],"content":" 9.1 通过成员函数重载运算符 class Person { public: int m_A; int m_B; /* 使用成员函数实现 */ Person PersonAddPerson(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } /* 重载+ */ Person operator+(Person \u0026p) { Person t; t.m_A = this-\u003em_A + p.m_A; t.m_B = this-\u003em_B + p.m_B; return t; } }; int main(int argc, char *argv[]) { Person p1; Person p2; Person p3 = p1.PersonAddPerson(p2); Person p4 = p1.operator+(p2); Person p5 = p1 + p2; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#通过成员函数重载运算符"},{"categories":["编程语言"],"content":" 9.2 通过全局函数重载 Person operator+(Person \u0026p1, Person \u0026p2) { Person t; t.m_A = p1.m_A + p2.m_A; t.m_B = p2.m_B + p2.m_B; return t; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#通过全局函数重载"},{"categories":["编程语言"],"content":" 9.3 重载左移运算符 std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Person \u0026p) { cout \u003c\u003c p.m_A \u003c\u003c p.m_B; return cout; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#重载左移运算符"},{"categories":["编程语言"],"content":" 9.4 递增重载++注意: 前置递增 p++ 后置递增 ++p ","date":"2022-07-28","objectID":"/cxx_enhance/:9:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#递增重载"},{"categories":["编程语言"],"content":" 9.5 重载例子(复数) #include \u003ciostream\u003e class Complex { friend std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p); public: Complex(int i, int j); Complex(); /* 重载+ */ Complex operator+(Complex \u0026p) { Complex t; t.i = this-\u003ei + p.i; t.j = this-\u003ej + p.j; return t; } /* 重载前置++ */ Complex\u0026 operator++() { this-\u003ei++; this-\u003ej++; return *this; } /* 重载后置++ */ Complex operator++(int) { Complex t; /* 记录 */ t.i = this-\u003ei; t.j = this-\u003ej; /* 递增 */ this-\u003ei++; this-\u003ej++; return t; } /* 重载= */ Complex\u0026 operator=(Complex \u0026p) { this-\u003ei = p.i; this-\u003ej = p.j; return *this; } private: int i; /* 实部 */ int j; /* 虚部 */ }; /* 构造函数 */ Complex::Complex(int i, int j) { this-\u003ei = i; this-\u003ej = j; } Complex::Complex() { this-\u003ei = 0; this-\u003ej = 0; } std::ostream \u0026operator\u003c\u003c(std::ostream \u0026cout, Complex p) { cout \u003c\u003c p.i \u003c\u003c \"+\" \u003c\u003c p.j \u003c\u003c \"i\"; return cout; } int main(int argc, char *argv[]) { Complex p1(1, 2); Complex p2(3, 4); std::cout \u003c\u003c p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2 \u003c\u003c std::endl; std::cout \u003c\u003c p1 + p2 \u003c\u003c std::endl; std::cout \u003c\u003c ++p1 \u003c\u003c std::endl; std::cout \u003c\u003c p2++ \u003c\u003c std::endl; Complex p3 = p2 = p1; std::cout \u003c\u003c p1 \u003c\u003c \" \" \u003c\u003c p2 \u003c\u003c \" \" \u003c\u003c p3 \u003c\u003c std::endl; return 0; } ","date":"2022-07-28","objectID":"/cxx_enhance/:9:5","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#重载例子复数"},{"categories":["编程语言"],"content":" 10 继承减少重复代码 class 子类 : 继承方式 父类 父类:基类 子类:派生类 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承"},{"categories":["编程语言"],"content":" 10.1 继承方式 公共继承 保护继承 私有继承 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承方式"},{"categories":["编程语言"],"content":" 10.2 继承中的对象模型","date":"2022-07-28","objectID":"/cxx_enhance/:10:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承中的对象模型"},{"categories":["编程语言"],"content":" 10.3 构造和析构的顺序 先构造父类再构造子类 先析构子类再析构父类 ","date":"2022-07-28","objectID":"/cxx_enhance/:10:3","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#构造和析构的顺序"},{"categories":["编程语言"],"content":" 10.4 继承中同名成员处理 访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A ","date":"2022-07-28","objectID":"/cxx_enhance/:10:4","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#继承中同名成员处理"},{"categories":["编程语言"],"content":" 11 多重继承C++允许一个类继承多个基类 class 子类 : 继承方式 父类1, 继承方式 父类2... 冲突解决：加上类名 ","date":"2022-07-28","objectID":"/cxx_enhance/:11:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#多重继承"},{"categories":["编程语言"],"content":" 11.1 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。 多重继承数据会产生二义性 数据只需要一份即可 /* 动物类 */ class Animal { public: int m_age; }; class Sheep : public Animal {}; /* 羊类 */ class Camel : public Animal {}; /* 驼类 */ class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ int main(int argc, char *argv[]) { Alpaca a; a.Sheep::m_age = 18; a.Camel::m_age = 18; return 0; } 虚继承 class Sheep : virtual public Animal {}; /* 羊类 */ class Camel : virtual public Animal {}; /* 驼类 */ ","date":"2022-07-28","objectID":"/cxx_enhance/:11:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#菱形继承"},{"categories":["编程语言"],"content":" 11.2 虚基类指针(vbptr)vbptr –\u003e vbtable ","date":"2022-07-28","objectID":"/cxx_enhance/:11:2","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚基类指针vbptr"},{"categories":["编程语言"],"content":" 12 多态 分类 静态多态: 重载 动态多态:虚函数 区别 静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址 父类接收子类的对象,在程序运行期间确定具体改调用那个函数; 有继承关系 子类重写父类的虚函数 重写：函数完全一致 ","date":"2022-07-28","objectID":"/cxx_enhance/:12:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#多态"},{"categories":["编程语言"],"content":" 13 虚函数 只要有一个纯虚函数，就称为抽象类 抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类 ","date":"2022-07-28","objectID":"/cxx_enhance/:13:0","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚函数-1"},{"categories":["编程语言"],"content":" 13.1 虚析构和纯虚析构","date":"2022-07-28","objectID":"/cxx_enhance/:13:1","series":null,"tags":["C++"],"title":"C++提高笔记","uri":"/cxx_enhance/#虚析构和纯虚析构"},{"categories":["编程语言"],"content":"C++增强笔记","date":"2022-07-28","objectID":"/cxx_advance/","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/"},{"categories":["编程语言"],"content":" 这个是我在学习C++语言中所记录的笔记,有可能会存在错误和遗漏,并且我有一点点C语言基础, 会大量的提及C语言与C++的不同,从而造成笔记晦涩; 另外C++的学习是一个长期且艰难的过程,因此本文进行了切分; C++基础笔记 C++提高笔记 C++增强笔记 ","date":"2022-07-28","objectID":"/cxx_advance/:0:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#"},{"categories":["编程语言"],"content":" 1 对象模型","date":"2022-07-28","objectID":"/cxx_advance/:1:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#对象模型"},{"categories":["编程语言"],"content":" 2 运行期间","date":"2022-07-28","objectID":"/cxx_advance/:2:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#运行期间"},{"categories":["编程语言"],"content":" 2.1 函数对象","date":"2022-07-28","objectID":"/cxx_advance/:2:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#函数对象"},{"categories":["编程语言"],"content":" 2.2 右值引用","date":"2022-07-28","objectID":"/cxx_advance/:2:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#右值引用"},{"categories":["编程语言"],"content":" 3 构造函数 普通构造 拷贝构造 移动构造 委托构造 ","date":"2022-07-28","objectID":"/cxx_advance/:3:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#构造函数"},{"categories":["编程语言"],"content":" 4 智能指针","date":"2022-07-28","objectID":"/cxx_advance/:4:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#智能指针"},{"categories":["编程语言"],"content":" 4.1 RAII 与引用计数","date":"2022-07-28","objectID":"/cxx_advance/:4:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#raii-与引用计数"},{"categories":["编程语言"],"content":" 4.2 std::shared_ptr","date":"2022-07-28","objectID":"/cxx_advance/:4:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdshared_ptr"},{"categories":["编程语言"],"content":" 4.3 std::unique_ptr","date":"2022-07-28","objectID":"/cxx_advance/:4:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdunique_ptr"},{"categories":["编程语言"],"content":" 4.4 std::weak_ptr","date":"2022-07-28","objectID":"/cxx_advance/:4:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#stdweak_ptr"},{"categories":["编程语言"],"content":" 5 强制类型转换","date":"2022-07-28","objectID":"/cxx_advance/:5:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#强制类型转换"},{"categories":["编程语言"],"content":" 5.1 C风格的强制转换","date":"2022-07-28","objectID":"/cxx_advance/:5:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#c风格的强制转换"},{"categories":["编程语言"],"content":" 5.2 const_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#const_cast"},{"categories":["编程语言"],"content":" 5.3 static_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#static_cast"},{"categories":["编程语言"],"content":" 5.4 dynamic_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#dynamic_cast"},{"categories":["编程语言"],"content":" 5.5 reinterpret_cast","date":"2022-07-28","objectID":"/cxx_advance/:5:5","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#reinterpret_cast"},{"categories":["编程语言"],"content":" 6 模板类型","date":"2022-07-28","objectID":"/cxx_advance/:6:0","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#模板类型"},{"categories":["编程语言"],"content":" 6.1 class templates,","date":"2022-07-28","objectID":"/cxx_advance/:6:1","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#class-templates"},{"categories":["编程语言"],"content":" 6.2 function templates","date":"2022-07-28","objectID":"/cxx_advance/:6:2","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#function-templates"},{"categories":["编程语言"],"content":" 6.3 variable templates.","date":"2022-07-28","objectID":"/cxx_advance/:6:3","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#variable-templates"},{"categories":["编程语言"],"content":" 6.4 alias templates","date":"2022-07-28","objectID":"/cxx_advance/:6:4","series":null,"tags":["C++"],"title":"C++增强笔记","uri":"/cxx_advance/#alias-templates"},{"categories":["pthread"],"content":"线程局部存储分析","date":"2022-07-18","objectID":"/pthread_local_storage/","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/"},{"categories":["pthread"],"content":" 1 前言 在Linux C/C++编程时不可避免的会遇到以下的需求,全局变量线程共享;最为典型的功能则是errno,变量 在程序的任何地方都可以访问,但是不会影响到其他线程,这就是本文档说明的TLS(线程局部存储变量) 如何创建并且使用TLS? 存在下面两种方法 线程库函数 编译器提供 下面分别进行说明分析 ","date":"2022-07-18","objectID":"/pthread_local_storage/:1:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#前言"},{"categories":["pthread"],"content":" 2 线程库函数 pthread提供了函数用来处理TLS, 分别管理键值和数据 ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#线程库函数"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 j\u003cPTHREAD_DESTRUCTOR_ITERATIONS; j++) { self-\u003etsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#创建键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#销毁键值"},{"categories":["pthread"],"content":" 2.1 键值 typedef unsigned pthread_key_t; int pthread_key_create(pthread_key_t *, void (*)(void *)); int pthread_key_delete(pthread_key_t); // 进程最多可以创建128个键值 #define PTHREAD_KEYS_MAX 128 2.1.1 创建键值pthread_key_create pthread_key_t 键值变量 析构函数(线程退出时,自动调用) 下面的代码为了减少篇幅和增加可读性,我删除了不少辅助代码; pthread_key_t j = next_key; do { if (!keys[j]) { keys[next_key = *k = j] = dtor; return 0; } } while ((j=(j+1)%PTHREAD_KEYS_MAX) != next_key); 2.1.2 销毁键值pthread_key_delete do { td-\u003etsd[k] = 0; } while ((td=td-\u003enext)!=self); keys[k] = 0; 2.1.3 析构调用pthread_tsd_run_dtors 线程退出__pthread_exit函数调用; for (j=0; self-\u003etsd_used \u0026\u0026 jtsd_used = 0; for (i=0; i \u003c PTHREAD_KEYS_MAX; i++) { void *val = self-\u003etsd[i]; void (*dtor)(void *) = keys[i]; self-\u003etsd[i] = 0; if (val \u0026\u0026 dtor \u0026\u0026 dtor != nodtor) { dtor(val); } } } ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:1","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#析构调用"},{"categories":["pthread"],"content":" 2.2 数据 void *pthread_getspecific(pthread_key_t); int pthread_setspecific(pthread_key_t, const void *); // 设置 self-\u003etsd[k] = 私有数据; self-\u003etsd_used = 1; // 读取 return self-\u003etsd[k]; ","date":"2022-07-18","objectID":"/pthread_local_storage/:2:2","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#数据"},{"categories":["pthread"],"content":" 3 编译器提供 musl线程库提供的私有数据还可以理解,但是GCC的__thread变量就比较难以分析了,因此此时只能通过 汇编文件进行分析 給出测试程序 __thread int num; int test(void) { return num; } GCC生成的汇编语言 num: test: push {r7} @ 进入函数,保存现场 add r7, sp, #0 @ R7 = SP mrc p15, 0, r3, c13, c0, 3 @ R3 = 线程号 ldr r2, .L3 @ R2 = \u0026num ldr r3, [r3, r2] @ R3 = *((int *)(R3 + R2)) mov r0, r3 @ R0 = R3 mov sp, r7 @ 恢复SP ldr r7, [sp], #4 @ 恢复R7 bx lr @ return .L3: .word num(tpoff) 但是到现在我们还是没有通过汇编理解原因,但是我们可以注意到一个可疑点.word num(tpoff),这个表达式中tpoff是什么?那么只好到GCC官网上看看是怎么处理的. GCC Thread-Local Storage 同时可以得到一份文档ELF Handling For Thread-Local Storage; 那么就开始分析此文档 ","date":"2022-07-18","objectID":"/pthread_local_storage/:3:0","series":null,"tags":["pthread"],"title":"线程局部存储分析","uri":"/pthread_local_storage/#编译器提供"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_lock/","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/"},{"categories":["pthread"],"content":" 1 futex实现 高级锁的实现都是与futex实现相关 Futex是Fast Userspace muTexes的缩写 常用的锁都是通过futex实现的 mutex (互斥锁) rwlock (读写锁) cond (条件变量) ","date":"2022-07-18","objectID":"/pthread_lock/:1:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#futex实现"},{"categories":["pthread"],"content":" 1.1 内核实现但是我并没有搞明白futex实现的原理,造成难以继续分析, 因此只能分析别人的文档(注:不分析原理,只进行使用) 主要存在文件futex-internal.c/futex-internal.h,lowlevellock-futex.h,lowlevellock.c 另外lll-\u003elowlevellock缩写形式 其中futex提供的最重要的两个操作wait和wake // 可以使用的op定义类型 #define FUTEX_WAIT 0 #define FUTEX_WAKE 1 #define FUTEX_REQUEUE 3 #define FUTEX_CMP_REQUEUE 4 #define FUTEX_WAKE_OP 5 #define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE ((4 \u003c\u003c 24) | 1) #define FUTEX_LOCK_PI 6 #define FUTEX_UNLOCK_PI 7 #define FUTEX_TRYLOCK_PI 8 #define FUTEX_WAIT_BITSET 9 #define FUTEX_WAKE_BITSET 10 #define FUTEX_WAIT_REQUEUE_PI 11 #define FUTEX_CMP_REQUEUE_PI 12 #define FUTEX_LOCK_PI2 13 #define FUTEX_PRIVATE_FLAG 128 #define FUTEX_CLOCK_REALTIME 256 ","date":"2022-07-18","objectID":"/pthread_lock/:1:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#内核实现"},{"categories":["pthread"],"content":" 1.2 musl实现 #define lll_trylock(lock) 原子的(lock 0 --\u003e 1) // 不等待 #define lll_cond_trylock(lock) 原子的(lock 0 --\u003e 2) // 不等待 #define lll_lock(futex, private) 1. 原子的(futex 0 --\u003e 1) // 等待 2. __lll_lock_wait (futex, private) #define __lll_cond_lock(futex, private) 1. 原子的(futex 0 --\u003e 2) // 等待 2. __lll_lock_wait (futex, private) #define __lll_unlock(futex, private) 1. 原子的(futex ? --\u003e 0) // 等待 2. __lll_lock_wait (futex, private) void __lll_lock_wake_private (int *futex); void __lll_lock_wait_private (int *futex); void __lll_lock_wait (int *futex, int private); void __lll_lock_wake (int *futex, int private); int lll_futex_wake(int *futex, int nr, int private); int lll_futex_wait(int *futex, int val, int private); int futex_wait(unsigned int *futex_word, unsigned int expected, int private); void futex_wake(unsigned int* futex_word, int processes_to_wake, int private); // 进入系统调用阶段 int lll_futex_syscall(int nargs, int *futexp, int op, ...); 那么进入到最后可以得知,一般会进行一些原子操作,启动的操作都是INTERNAL_SYSCALL进行实现的,然后就是swi指令实现的原理 ","date":"2022-07-18","objectID":"/pthread_lock/:1:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现"},{"categories":["pthread"],"content":" 2 原子操作","date":"2022-07-18","objectID":"/pthread_lock/:2:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#原子操作"},{"categories":["pthread"],"content":" 2.1 musl实现 /// 原子操作由汇编实现 ","date":"2022-07-18","objectID":"/pthread_lock/:2:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-1"},{"categories":["pthread"],"content":" 2.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:2:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现"},{"categories":["pthread"],"content":" 3 自旋锁","date":"2022-07-18","objectID":"/pthread_lock/:3:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#自旋锁"},{"categories":["pthread"],"content":" 3.1 musl实现spinlock句柄就是一个32位的数; typedef int pthread_spinlock_t; 五种函数的实现 int pthread_spin_init(pthread_spinlock_t *s, int shared) { return *s = 0; } int pthread_spin_destroy(pthread_spinlock_t *s) { return 0; } int pthread_spin_lock(pthread_spinlock_t *s) { while (*(volatile int *)s || a_cas(s, 0, EBUSY)) a_spin(); return 0; } int pthread_spin_trylock(pthread_spinlock_t *s) { return a_cas(s, 0, EBUSY); } int pthread_spin_unlock(pthread_spinlock_t *s) { a_store(s, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:3:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-2"},{"categories":["pthread"],"content":" 3.2 glibc实现glibc的实现就较为复杂了点 typedef __pthread_spinlock_t pthread_spinlock_t; typedef volatile int __pthread_spinlock_t; 加上__作为内部使用的句柄 volatile使编译器强行读取 int pthread_spin_init(pthread_spinlock_t *lock, int pshared) { /* Relaxed MO is fine because this is an initializing store. */ atomic_store_relaxed(lock, 0); return 0; } int pthread_spin_destroy (pthread_spinlock_t *lock) { /* Nothing to do. */ return 0; } int pthread_spin_lock (pthread_spinlock_t *lock) { int val = 0; #if ! ATOMIC_EXCHANGE_USES_CAS if (__glibc_likely(atomic_exchange_acquire(lock, 1) == 0)) { return 0; } #else if (__glibc_likely(atomic_compare_exchange_weak_acquire(lock, \u0026val, 1))) { return 0; } #endif do { do { atomic_spin_nop(); val = atomic_load_relaxed(lock); } while (val != 0); } while (!atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)); return 0; } int pthread_spin_trylock(pthread_spinlock_t *lock) { #if ! ATOMIC_EXCHANGE_USES_CAS if (atomic_exchange_acquire (lock, 1) == 0) { return 0; } #else do { int val = 0; if (atomic_compare_exchange_weak_acquire (lock, \u0026val, 1)) return 0; } while (atomic_load_relaxed (lock) == 0); #endif return EBUSY; } int pthread_spin_unlock(pthread_spinlock_t *lock) { atomic_store_release(lock, 0); return 0; } ","date":"2022-07-18","objectID":"/pthread_lock/:3:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-1"},{"categories":["pthread"],"content":" 4 内存屏障","date":"2022-07-18","objectID":"/pthread_lock/:4:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#内存屏障"},{"categories":["pthread"],"content":" 4.1 musl实现 int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); int pthread_barrier_destroy(pthread_barrier_t *); int pthread_barrier_wait(pthread_barrier_t *); ","date":"2022-07-18","objectID":"/pthread_lock/:4:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-3"},{"categories":["pthread"],"content":" 4.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:4:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-2"},{"categories":["pthread"],"content":" 5 互斥锁","date":"2022-07-18","objectID":"/pthread_lock/:5:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#互斥锁"},{"categories":["pthread"],"content":" 5.1 musl实现在musl库上的互斥锁,但是我感觉musl的设计存在一些瑕疵,还是在去分析一下glibc的设计思路吧. typedef struct { union { int __i[sizeof(long)==8?10:6]; volatile int __vi[sizeof(long)==8?10:6]; volatile void *volatile __p[sizeof(long)==8?5:6]; } __u; } pthread_mutex_t; int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a) { *m = (pthread_mutex_t){0}; if (a) { m-\u003e_m_type = a-\u003e__attr; } return 0; } int pthread_mutex_destroy(pthread_mutex_t *mutex) { if (mutex-\u003e_m_type \u003e 128) { __vm_wait(); } return 0; } int pthread_mutex_lock(pthread_mutex_t *m) { if ((m-\u003e_m_type \u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; return __pthread_mutex_timedlock(m, 0); } int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at) { /* PTHREAD_MUTEX_NORMAL:死等 */ if ((m-\u003e_m_type\u002615) == PTHREAD_MUTEX_NORMAL \u0026\u0026 !a_cas(\u0026m-\u003e_m_lock, 0, EBUSY)) return 0; int type = m-\u003e_m_type; int r, t, priv = (type \u0026 128) ^ 128; /* 尝试加锁 */ r = __pthread_mutex_trylock(m); if (r != EBUSY) { return r; } if (type\u00268) return pthread_mutex_timedlock_pi(m, at); int spins = 100; while (spins-- \u0026\u0026 m-\u003e_m_lock \u0026\u0026 !m-\u003e_m_waiters) a_spin(); while ((r=__pthread_mutex_trylock(m)) == EBUSY) { r = m-\u003e_m_lock; int own = r \u0026 0x3fffffff; if (!own \u0026\u0026 (!r || (type\u00264))) continue; if ((type\u00263) == PTHREAD_MUTEX_ERRORCHECK \u0026\u0026 own == __pthread_self()-\u003etid) return EDEADLK; a_inc(\u0026m-\u003e_m_waiters); t = r | 0x80000000; a_cas(\u0026m-\u003e_m_lock, r, t); r = __timedwait(\u0026m-\u003e_m_lock, t, CLOCK_REALTIME, at, priv); a_dec(\u0026m-\u003e_m_waiters); if (r \u0026\u0026 r != EINTR) break; } return r; } ","date":"2022-07-18","objectID":"/pthread_lock/:5:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-4"},{"categories":["pthread"],"content":" 5.2 glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) 5.2.1 互斥锁的定义 struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 int __pthread_mutex_lock (pthread_mutex_t *mtxp) { struct __pthread *self; int flags = mtxp-\u003e__flags \u0026 GSYNC_SHARED; int ret = 0; // 根据不同的类型确定 #define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED #define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) #define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) switch (MTX_TYPE (mtxp)) { /* 普通上锁方式 */ case PT_MTX_NORMAL: lll_lock (mtxp-\u003e__lock, flags); break; /* 迭代锁 */ case PT_MTX_RECURSIVE: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) { if (__glibc_unlikely (mtxp-\u003e__cnt + 1 == 0)) return EAGAIN; ++mtxp-\u003e__cnt; return ret; } lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); mtxp-\u003e__cnt = 1; break; case PT_MTX_ERRORCHECK: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) return EDEADLK; lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); break; case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: self = _pthread_self (); ROBUST_LOCK (self, mtxp, lll_robust_lock, flags); break; default: ret = EINVAL; break; } return ret; } ","date":"2022-07-18","objectID":"/pthread_lock/:5:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-3"},{"categories":["pthread"],"content":" 5.2 glibc实现musl的互斥锁好像缺少了排队机制,造成可能抢占的问题(真正实现排队的是futex) 5.2.1 互斥锁的定义 struct __pthread_mutex_s { int __lock; unsigned int __count; int __owner; int __kind; union { int __spins; __pthread_slist_t __list; }; }; typedef union { struct __pthread_mutex_s __data; char __size[__SIZEOF_PTHREAD_MUTEX_T]; long int __align; } pthread_mutex_t; 上锁的实现 int __pthread_mutex_lock (pthread_mutex_t *mtxp) { struct __pthread *self; int flags = mtxp-\u003e__flags \u0026 GSYNC_SHARED; int ret = 0; // 根据不同的类型确定 #define PT_MTX_NORMAL __PTHREAD_MUTEX_TIMED #define PT_MTX_RECURSIVE (__PTHREAD_MUTEX_RECURSIVE + 1) #define PT_MTX_ERRORCHECK (__PTHREAD_MUTEX_ERRORCHECK + 1) switch (MTX_TYPE (mtxp)) { /* 普通上锁方式 */ case PT_MTX_NORMAL: lll_lock (mtxp-\u003e__lock, flags); break; /* 迭代锁 */ case PT_MTX_RECURSIVE: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) { if (__glibc_unlikely (mtxp-\u003e__cnt + 1 == 0)) return EAGAIN; ++mtxp-\u003e__cnt; return ret; } lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); mtxp-\u003e__cnt = 1; break; case PT_MTX_ERRORCHECK: self = _pthread_self (); if (mtx_owned_p (mtxp, self, flags)) return EDEADLK; lll_lock (mtxp-\u003e__lock, flags); mtx_set_owner (mtxp, self, flags); break; case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST: case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST: case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST: self = _pthread_self (); ROBUST_LOCK (self, mtxp, lll_robust_lock, flags); break; default: ret = EINVAL; break; } return ret; } ","date":"2022-07-18","objectID":"/pthread_lock/:5:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#互斥锁的定义"},{"categories":["pthread"],"content":" 6 条件变量","date":"2022-07-18","objectID":"/pthread_lock/:6:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#条件变量"},{"categories":["pthread"],"content":" 6.1 musl实现","date":"2022-07-18","objectID":"/pthread_lock/:6:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-5"},{"categories":["pthread"],"content":" 6.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:6:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-4"},{"categories":["pthread"],"content":" 7 读写锁","date":"2022-07-18","objectID":"/pthread_lock/:7:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#读写锁"},{"categories":["pthread"],"content":" 7.1 musl实现","date":"2022-07-18","objectID":"/pthread_lock/:7:1","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#musl实现-6"},{"categories":["pthread"],"content":" 7.2 glibc实现","date":"2022-07-18","objectID":"/pthread_lock/:7:2","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#glibc实现-5"},{"categories":["pthread"],"content":" 8 pthread杂项","date":"2022-07-18","objectID":"/pthread_lock/:8:0","series":null,"tags":["pthread"],"title":"pthread线程同步","uri":"/pthread_lock/#pthread杂项"},{"categories":["pthread"],"content":"pthread线程源码分析","date":"2022-07-18","objectID":"/pthread_thread/","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/"},{"categories":["pthread"],"content":" 基于musl源码库与glibc库,其中musl提供分析的思路,glibc分析具体实现 ","date":"2022-07-18","objectID":"/pthread_thread/:0:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#"},{"categories":["pthread"],"content":" 1 pthread句柄","date":"2022-07-18","objectID":"/pthread_thread/:1:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread句柄"},{"categories":["pthread"],"content":" 1.1 musl实现 struct pthread { struct pthread *self; #ifndef TLS_ABOVE_TP uintptr_t *dtv; #endif /* 线程链表项 */ struct pthread *prev, *next; /* non-ABI */ /* 系统信息 */ uintptr_t sysinfo; #ifndef TLS_ABOVE_TP #ifdef CANARY_PAD uintptr_t canary_pad; #endif uintptr_t canary; #endif /* TLS_ABOVE_TP */ int tid; // 线程ID int errno_val; volatile int detach_state; // 分离状态 volatile int cancel; // cancle启动标志 volatile unsigned char canceldisable; // cancle控制 volatile unsigned char cancelasync; // cancle同步标志 unsigned char tsd_used:1; unsigned char dlerror_flag:1; unsigned char *map_base; // mmap size_t map_size; void *stack; // 堆栈 size_t stack_size; size_t guard_size; void *result; // 返回结果, /* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ struct __ptcb *cancelbuf; void **tsd; struct { volatile void *volatile head; long off; volatile void *volatile pending; } robust_list; int h_errno_val; volatile int timer_id; locale_t locale; volatile int killlock[1]; // 退出锁 char *dlerror_buf; void *stdio_locks; #ifdef TLS_ABOVE_TP uintptr_t canary; uintptr_t *dtv; #endif }; ","date":"2022-07-18","objectID":"/pthread_thread/:1:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#musl实现"},{"categories":["pthread"],"content":" 1.2 glibc实现 struct __pthread { /* 线程ID: typedef unsigned long int pthread_t; */ pthread_t thread; unsigned int nr_refs; /* Detached threads have a self reference only, while joinable threads have two references. These are used to keep the structure valid at thread destruction. Detaching/joining a thread drops a reference. */ /* Cancellation. */ pthread_mutex_t cancel_lock; /* Protect cancel_xxx members. */ void (*cancel_hook) (void *); /* Called to unblock a thread blocking in a cancellation point (namely, __pthread_cond_timedwait_internal). */ void *cancel_hook_arg; int cancel_state; int cancel_type; int cancel_pending; /* Thread stack. */ void *stackaddr; /* 堆栈地址 */ size_t stacksize; /* 堆栈大小 */ size_t guardsize; /* 预留用来保护堆栈大小的字节 */ int stack; /* Nonzero if the stack was allocated. */ /* Exit status. */ void *status; /* Thread state. */ enum pthread_state state; pthread_mutex_t state_lock; /* Locks the state. */ pthread_cond_t state_cond; /* Signalled when the state changes. */ bool terminated; /* Whether the kernel thread is over and we can reuse this structure. */ /* Resolver state. */ struct __res_state res_state; /* Indicates whether is a C11 thread created by thrd_creat. */ bool c11; /* Initial sigset for the thread. */ sigset_t init_sigset; /* Thread context. */ struct pthread_mcontext mcontext; PTHREAD_KEY_MEMBERS /* void **thread_specifics; // This is only resized by the thread, and always growing unsigned thread_specifics_size; // Number of entries in thread_specifics */ PTHREAD_SYSDEP_MEMBERS /* thread_t kernel_thread; mach_msg_header_t wakeupmsg; */ /* 线程控制块:与系统进行沟通 */ tcbhead_t *tcb; /* Queue links. Since PREVP is used to determine if a thread has been awaken, it must be protected by the queue lock. */ struct __pthread *next, **prevp; }; 但是在我们使用的时候发现与我们正常的使用不太一致,在用户层,我们一般认为pthread为线程ID，但是内部实现好像都是指针,因此出现了什么特殊的原因； 在musl中,直接抹掉了内部结构; // 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 #ifdef __cplusplus typedef unsigned long pthread_t; #else typedef struct __pthread* pthread_t; #endif 而在glibc中,线程ID仅仅是线程结构体中的一个成员,因此,glibc的处理更加安全, 下面分析一下id的实现, __pthread_create (pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine) (void *), void *arg) { int err; struct __pthread *pthread; err = __pthread_create_internal (\u0026pthread, attr, start_routine, arg); if (!err) *thread = pthread-\u003ethread; else if (err == ENOMEM) err = EAGAIN; return err; } /* 那么可以明白,线程ID */ int _dl_pthread_num_threads; struct __pthread **_dl_pthread_threads; __libc_rwlock_define_initialized (, _dl_pthread_threads_lock) /* 下面的代码实现线程ID的分配:只保留了成功的部分,没有考虑意外情况 */ __libc_rwlock_wrlock (GL(dl_pthread_threads_lock)); if (GL(dl_pthread_num_threads) \u003c __pthread_max_threads) { /* We have a free slot. Use the slot number plus one as the thread ID for the new thread. */ new-\u003ethread = 1 + GL(dl_pthread_num_threads)++; GL(dl_pthread_threads)[new-\u003ethread - 1] = NULL; __libc_rwlock_unlock (GL(dl_pthread_threads_lock)); *pthread = new; return 0; } 但是GL是什么呢?hehe #define GL(x) _##x ","date":"2022-07-18","objectID":"/pthread_thread/:1:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现"},{"categories":["pthread"],"content":" 2 所有的函数","date":"2022-07-18","objectID":"/pthread_thread/:2:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#所有的函数"},{"categories":["pthread"],"content":" 2.1 线程基础 // 线程创建 int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict); // 线程退出 void pthread_exit(void *); // 线程属性 int pthread_attr_init(pthread_attr_t *); int pthread_attr_destroy(pthread_attr_t *); int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setguardsize(pthread_attr_t *, size_t); int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); int pthread_attr_setstacksize(pthread_attr_t *, size_t); int pthread_attr_getdetachstate(const pthread_attr_t *, int *); int pthread_attr_setdetachstate(pthread_attr_t *, int); int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); int pthread_attr_setstack(pthread_attr_t *, void *, size_t); int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setscope(pthread_attr_t *, int); int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setschedpolicy(pthread_attr_t *, int); int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); int pthread_attr_setinheritsched(pthread_attr_t *, int); ","date":"2022-07-18","objectID":"/pthread_thread/:2:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程基础"},{"categories":["pthread"],"content":" 2.2 线程分离 // 线程分离 int pthread_detach(pthread_t); // 线程等待 int pthread_join(pthread_t, void **); // 获取线程自己的ID pthread_t pthread_self(void); // 判断线程是否相等 int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 ","date":"2022-07-18","objectID":"/pthread_thread/:2:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离"},{"categories":["pthread"],"content":" 2.3 线程取消 int pthread_setcancelstate(int, int *); int pthread_setcanceltype(int, int *); void pthread_testcancel(void); int pthread_cancel(pthread_t); ","date":"2022-07-18","objectID":"/pthread_thread/:2:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程取消"},{"categories":["pthread"],"content":" 2.4 调度相关 int pthread_getschedparam(pthread_t t, int *restrict policy, struct sched_param *restrict param); __syscall(SYS_sched_getparam, pthread_t-\u003etid, sched_param); __syscall(SYS_sched_getscheduler, pthread_t-\u003etid); int pthread_setschedparam(pthread_t t, int policy, const struct sched_param *param); __syscall(SYS_sched_setscheduler, pthread_t-\u003etid, policy, sched_param); // sched_param保存着优先级参数 int pthread_setschedprio(pthread_t t, int prio); __syscall(SYS_sched_setparam, pthread_t-\u003etid, \u0026prio); ","date":"2022-07-18","objectID":"/pthread_thread/:2:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#调度相关"},{"categories":["pthread"],"content":" 3 补充知识","date":"2022-07-18","objectID":"/pthread_thread/:3:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#补充知识"},{"categories":["pthread"],"content":" 3.1 Linux线程实现","date":"2022-07-18","objectID":"/pthread_thread/:3:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#linux线程实现"},{"categories":["pthread"],"content":" 3.2 系统调用实现 #define __asm_syscall(...) do { __asm__ __volatile__ ( \"svc 0\" : \"=r\"(r0) : __VA_ARGS__ : \"memory\"); return r0; } while (0); #define R7_OPERAND \"r\"(r7) static inline long __syscall0(long n) { register long r7 __ASM____R7__ = n; //使用R7传递个数 register long r0 __asm__(\"r0\"); __asm_syscall(R7_OPERAND); } static inline long __syscall1(long n, long a) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; __asm_syscall(R7_OPERAND, \"0\"(r0)); } static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) { register long r7 __ASM____R7__ = n; register long r0 __asm__(\"r0\") = a; register long r1 __asm__(\"r1\") = b; register long r2 __asm__(\"r2\") = c; register long r3 __asm__(\"r3\") = d; register long r4 __asm__(\"r4\") = e; register long r5 __asm__(\"r5\") = f; __asm_syscall(R7_OPERAND, \"0\"(r0), \"r\"(r1), \"r\"(r2), \"r\"(r3), \"r\"(r4), \"r\"(r5)); } // 一个相当巧妙的宏定义的实现 #define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n #define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) // 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 // 拼装函数调用 #define __SYSCALL_CONCAT_X(a,b) a##b #define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) #define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) // __syscall_ret仅仅检查了系统调用号 #define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) #define syscall(...) __syscall_ret(__syscall(__VA_ARGS__)) syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束 系统调用号实现 #ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H #define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 #define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) #define __NR_exit (__NR_SYSCALL_BASE + 1) #define __NR_fork (__NR_SYSCALL_BASE + 2) #define __NR_read (__NR_SYSCALL_BASE + 3) #define __NR_write (__NR_SYSCALL_BASE + 4) #define __NR_open (__NR_SYSCALL_BASE + 5) #define __NR_close (__NR_SYSCALL_BASE + 6) #define __NR_creat (__NR_SYSCALL_BASE + 8) ... #define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) #endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */ ","date":"2022-07-18","objectID":"/pthread_thread/:3:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#系统调用实现"},{"categories":["pthread"],"content":" 3.3 glibc系统调用同样的道理,可以分析一下glibc的系统调用时如何进行 但是在一般的情况下此时就可以明白,与musl相同的调用方式时一样的 INLINE_SYSCALL_CALL --\u003e __INLINE_SYSCALL_DISP __INLINE_SYSCALL_DISP --\u003e __SYSCALL_CONCAT 生成一条调用指令的语言 # define INTERNAL_SYSCALL_RAW(name, nr, args...) \\ ({ \\ register int _a1 asm (\"r0\"), _nr asm (\"r7\"); \\ LOAD_ARGS_##nr (args) \\ _nr = name; \\ asm volatile (\"swi 0x0 @ syscall \" #name \\ : \"=r\" (_a1) \\ : \"r\" (_nr) ASM_ARGS_##nr \\ : \"memory\"); \\ _a1; }) ","date":"2022-07-18","objectID":"/pthread_thread/:3:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc系统调用"},{"categories":["pthread"],"content":" 3.4 clone系统调用 int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...); // 但是实现的地方却存在着异常 __clone: stmfd sp!,{r4,r5,r6,r7} mov r7,#120 mov r6,r3 mov r5,r0 mov r0,r2 and r1,r1,#-16 ldr r2,[sp,#16] ldr r3,[sp,#20] ldr r4,[sp,#24] svc 0 tst r0,r0 beq 1f ldmfd sp!,{r4,r5,r6,r7} bx lr ","date":"2022-07-18","objectID":"/pthread_thread/:3:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#clone系统调用"},{"categories":["pthread"],"content":" 4 线程基础","date":"2022-07-18","objectID":"/pthread_thread/:4:0","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程基础-1"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程创建"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#glibc实现的线程函数"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#pthread管理单元申请与释放"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#内核线程创建"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#tls创建"},{"categories":["pthread"],"content":" 4.1 线程创建 typedef struct { union { int __i[sizeof(long)==8?14:9]; volatile int __vi[sizeof(long)==8?14:9]; unsigned long __s[sizeof(long)==8?7:9]; } __u; } pthread_attr_t; #define __SU (sizeof(size_t)/sizeof(int)) #define _a_stacksize __u.__s[0] #define _a_guardsize __u.__s[1] #define _a_stackaddr __u.__s[2] #define _a_detach __u.__i[3*__SU+0] #define _a_sched __u.__i[3*__SU+1] #define _a_policy __u.__i[3*__SU+2] #define _a_prio __u.__i[3*__SU+3] #define _m_type __u.__i[0] #define _m_lock __u.__vi[1] #define _m_waiters __u.__vi[2] #define _m_prev __u.__p[3] #define _m_next __u.__p[4] #define _m_count __u.__i[5] #define _c_shared __u.__p[0] #define _c_seq __u.__vi[2] #define _c_waiters __u.__vi[3] #define _c_clock __u.__i[4] #define _c_lock __u.__vi[8] #define _c_head __u.__p[1] #define _c_tail __u.__p[5] #define _rw_lock __u.__vi[0] #define _rw_waiters __u.__vi[1] #define _rw_shared __u.__i[2] #define _b_lock __u.__vi[0] #define _b_waiters __u.__vi[1] #define _b_limit __u.__i[2] #define _b_count __u.__vi[3] #define _b_waiters2 __u.__vi[4] #define _b_inst __u.__p[3] /** * @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) * @brief 创建线程 * * @param res pthread指针 * @param attrp pthread属性 * @param entry 入口地址 * @param arg 入口属性 * @return 创建结果 */ int pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg) { int ret, c11 = (attrp == __ATTRP_C11_THREAD); size_t size; size_t guard; struct pthread *self; struct pthread *new; unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; // 通过一定的规则将attrp--\u003eattr pthread_attr_t attr = { 0 }; sigset_t set; /* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ attr._a_stacksize = __default_stacksize; attr._a_guardsize = __default_guardsize; /* 填充pthread成员 */ new = __copy_tls(tsd - libc.tls_size); new-\u003emap_base = map; new-\u003emap_size = size; new-\u003estack = stack; new-\u003estack_size = stack - stack_limit; new-\u003eguard_size = guard; new-\u003eself = new; new-\u003etsd = (void *)tsd; new-\u003elocale = \u0026libc.global_locale; if (attr._a_detach) { new-\u003edetach_state = DT_DETACHED; } else { new-\u003edetach_state = DT_JOINABLE; } new-\u003erobust_list.head = \u0026new-\u003erobust_list.head; new-\u003ecanary = self-\u003ecanary; new-\u003esysinfo = self-\u003esysinfo; /* 移动stack指针,保存启动参数 */ stack -= (uintptr_t)stack % sizeof(uintptr_t); stack -= sizeof(struct start_args); /* 设置启动参数 */ struct start_args *args = (void *)stack; args-\u003estart_func = entry; args-\u003estart_arg = arg; args-\u003econtrol = attr._a_sched ? 1 : 0; /* 调用clone创建线程 */ clone(start, stack, flags, args, \u0026new-\u003etid, TP_ADJ(new), \u0026__thread_list_lock); /* 设置调度器 */ ret = __syscall(SYS_sched_setscheduler, new-\u003etid, attr._a_policy, \u0026attr._a_prio); if (a_swap(\u0026args-\u003econtrol, ret ? 3 : 0)==2) __wake(\u0026args-\u003econtrol, 1, 1); if (ret) __wait(\u0026args-\u003econtrol, 0, 3, 0); /* 初始化链表 */ new-\u003enext = self-\u003enext; new-\u003eprev = self; new-\u003enext-\u003eprev = new; new-\u003eprev-\u003enext = new; /* 返回new作为线程ID */ } void __pthread_exit(void *result) { pthread_t self = __pthread_self(); sigset_t set; /* 设置退出标志 */ self-\u003ecanceldisable = 1; self-\u003ecancelasync = 0; self-\u003eresult = result; /* 执行线程清理函数 */ while (self-\u003ecancelbuf) { void (*f)(void *) = self-\u003ecancelbuf-\u003e__f; void *x = self-\u003ecancelbuf-\u003e__x; self-\u003ecancelbuf = self-\u003ecancelbuf-\u003e__next; f(x); } int state = a_cas(\u0026self-\u003edetach_state, DT_JOINABLE, DT_EXITING); /* 如果线程分离状态,则代表需要自己手动释放内存 */ if (state==DT_DETACHED \u0026\u0026 self-\u003emap_base) { __vm_wait(); } volatile void *volatile *rp; while ((rp=self-\u003erobust_list.head) \u0026\u0026 rp != \u0026self-\u003erobust_list.head) { pthread_mutex_t *m = (void *)((char *)rp - offsetof(pthread_mutex_t, _m_next)); int waiters = m-\u003e_m_waiters; int priv = (m-\u003e_m_type \u0026 128) ^ 128; self-\u003erobust_list.pending = rp; self-\u003erobust_list.head = *rp; int cont = a_swap(\u0026m-\u003e_m_lock, 0x40000000); self-\u003erobust_list.pending = 0; if (cont \u003c 0 ||","date":"2022-07-18","objectID":"/pthread_thread/:4:1","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#设置启动参数"},{"categories":["pthread"],"content":" 4.2 ptrhead进程属性机制 int pthread_attr_init(pthread_attr_t *a); pthread_attr_t-\u003e_a_stacksize = __default_stacksize; pthread_attr_t-\u003e_a_guardsize = __default_guardsize; int pthread_attr_setdetachstate(pthread_attr_t *a, int state); pthread_attr_t-\u003e_a_detach = state; int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_guardsize = size; int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); pthread_attr_t-\u003e_a_sched = inherit; int pthread_attr_setschedparam(pthread_attr_t *restrict a, const struct sched_param *restrict param); pthread_attr_t-\u003e_a_prio = param-\u003esched_priority; int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); pthread_attr_t-\u003e_a_policy = policy; int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); pthread_attr_t-\u003e_a_stackaddr = (size_t)addr + size; pthread_attr_t-\u003e_a_stacksize = size; int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); pthread_attr_t-\u003e_a_stackaddr = 0; pthread_attr_t-\u003e_a_stacksize = size; ","date":"2022-07-18","objectID":"/pthread_thread/:4:2","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#ptrhead进程属性机制"},{"categories":["pthread"],"content":" 4.3 自身线程ID // 在musl和glibc的实现上二者不太一样 static inline uintptr_t __get_tp() { uintptr_t tp; __asm__ ( \"mrc p15,0,%0,c13,c0,3\" : \"=r\"(tp) ); return tp; } // 获取线程自身的方法 #define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) // 二者实现不太一样 /* Return the thread descriptor for the current thread. */ # define THREAD_SELF ((struct pthread *)__builtin_thread_pointer () - 1) pthread_t __pthread_self (void) { return (pthread_t) THREAD_SELF; } ","date":"2022-07-18","objectID":"/pthread_thread/:4:3","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#自身线程id"},{"categories":["pthread"],"content":" 4.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 4.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:4:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程清理函数"},{"categories":["pthread"],"content":" 4.4 线程清理函数一句话:就是设置pthread-\u003ecancelbuf成员函数 #define pthread_cleanup_push(f, x) \\ do { \\ struct __ptcb __cb; \\ _pthread_cleanup_push(\u0026__cb, f, x); \\ #define pthread_cleanup_pop(r) \\ _pthread_cleanup_pop(\u0026__cb, (r)); \\ } while(0) void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) { cb-\u003e__f = f; cb-\u003e__x = x; __do_cleanup_push(cb); } void _pthread_cleanup_pop(struct __ptcb *cb, int run) { __do_cleanup_pop(cb); if (run) cb-\u003e__f(cb-\u003e__x); } void __do_cleanup_push(struct __ptcb *cb) { struct pthread *self = __pthread_self(); cb-\u003e__next = self-\u003ecancelbuf; self-\u003ecancelbuf = cb; } void __do_cleanup_pop(struct __ptcb *cb) { __pthread_self()-\u003ecancelbuf = cb-\u003e__next; } 4.4.1 cancle设置 int __pthread_setcancelstate(int new, int *old); self-\u003ecanceldisable --\u003e old; self-\u003ecanceldisable \u003c-- new; int pthread_setcanceltype(int new, int *old); self-\u003ecancelasync --\u003e old; self-\u003ecancelasync \u003c-- new; // 同时还会执行__pthread_testcancel int pthread_cancel(pthread_t t) { // 自己的线程,直接退出 pthread_exit(PTHREAD_CANCELED); // 不是自己,发送退出信息 pthread_kill(t, SIGCANCEL) } // 设置线程取消点 __pthread_testcancel --\u003e __testcancel --\u003e __cancel() void __pthread_testcancel() { __testcancel(); } void __testcancel() { pthread_t self = __pthread_self(); if (self-\u003ecancel \u0026\u0026 !self-\u003ecanceldisable) __cancel(); } /* 允许进行cancle才可以 */ long __cancel() { pthread_t self = __pthread_self(); if (self-\u003ecanceldisable == PTHREAD_CANCEL_ENABLE || self-\u003ecancelasync) pthread_exit(PTHREAD_CANCELED); self-\u003ecanceldisable = PTHREAD_CANCEL_DISABLE; return -ECANCELED; } // 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么? 因此需要分析一下pthread_kill发生了什么? int pthread_kill(pthread_t t, int sig) { __block_all_sigs(\u0026set); LOCK(t-\u003ekilllock); // 仅仅对线程发送了一个信号 __syscall(SYS_tkill, t-\u003etid, sig); UNLOCK(t-\u003ekilllock); __restore_sigs(\u0026set); } // 那么在此回到pthread_cancle函数 static void init_cancellation() { struct sigaction sa = { .sa_flags = SA_SIGINFO | SA_RESTART, .sa_sigaction = cancel_handler }; memset(\u0026sa.sa_mask, -1, _NSIG/8); __libc_sigaction(SIGCANCEL, \u0026sa, 0); } int pthread_cancel(pthread_t t) { /* 此处存在这一个初始化 */ static int init; if (!init) { init_cancellation(); init = 1; } } static void cancel_handler(int sig, siginfo_t *si, void *ctx) { pthread_t self = __pthread_self(); ucontext_t *uc = ctx; uintptr_t pc = uc-\u003euc_mcontext.MC_PC; a_barrier(); if (!self-\u003ecancel || self-\u003ecanceldisable == PTHREAD_CANCEL_DISABLE) return; _sigaddset(\u0026uc-\u003euc_sigmask, SIGCANCEL); if (self-\u003ecancelasync || pc \u003e= (uintptr_t)__cp_begin \u0026\u0026 pc \u003c (uintptr_t)__cp_end) { uc-\u003euc_mcontext.MC_PC = (uintptr_t)__cp_cancel; #ifdef CANCEL_GOT uc-\u003euc_mcontext.MC_GOT = CANCEL_GOT; #endif return; } __syscall(SYS_tkill, self-\u003etid, SIGCANCEL); } 在musl中分析结束,现在分析一下glibc是如何实现的？ // 确实,在glibc中更加清晰,但是我还是没有明白,为什么会在此处进行退出呢 void __pthread_testcancel (void) { struct __pthread *p = _pthread_self (); int cancelled; __pthread_mutex_lock (\u0026p-\u003ecancel_lock); cancelled = (p-\u003ecancel_state == PTHREAD_CANCEL_ENABLE) \u0026\u0026 p-\u003ecancel_pending; __pthread_mutex_unlock (\u0026p-\u003ecancel_lock); if (cancelled) __pthread_exit (PTHREAD_CANCELED); } // 但是glibc没有什么特别的差别 ","date":"2022-07-18","objectID":"/pthread_thread/:4:4","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#cancle设置"},{"categories":["pthread"],"content":" 4.5 线程分离 // 线程分离 int pthread_detach(pthread_t) --\u003e __pthread_join(pthread_t, 0) --\u003e __pthread_timedjoin_np(pthread_t, 0, 0) // 设置线程等待 int pthread_join(pthread_t, void **); --\u003e__pthread_timedjoin_np(pthread_t, res, 0) // 那么也就是说明都调用了相同的函数 static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) { /* 设置线程分离状态 */ } ","date":"2022-07-18","objectID":"/pthread_thread/:4:5","series":null,"tags":["pthread"],"title":"pthread线程源码分析","uri":"/pthread_thread/#线程分离-1"},{"categories":["编译原理"],"content":"编译原理","date":"2022-07-07","objectID":"/compile/","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/"},{"categories":["编译原理"],"content":" 1 词法分析","date":"2022-07-07","objectID":"/compile/:1:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#词法分析"},{"categories":["编译原理"],"content":" 1.1 概述 词法分析是编译原理的第一个阶段,词法分析的任务是读入源程序的输入字符,生成一个个的单词,其主要的功能是为语法分析提供词法单元 ","date":"2022-07-07","objectID":"/compile/:1:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#概述"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compile/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#正则表达式"},{"categories":["编译原理"],"content":" 1.2 正则表达式 对于给定的正则表达式 $\\Sigma$={c1, c2, c3…cn} 归纳定义: 对于空串是正则表达式$\\epsilon$是正则表达式 对于任何$c\\in\\Sigma$,$c$是正则表达式 如果M和N都是正则表达式,那么下面的也是正则表达式 选择: M | N = {M, N} 连接: MN = {mn| m $\\in$ M, n, $\\in$ M } 闭包: M* = {$\\epsilon$, M, MM, MMMM….} 1.2.1 flex正则表达式 使用flex学习正则表达式 Flex由三部分组成 定义部分 %% 规则部分 %% 用户附加的C语言部分 %% [+-]?[0-9]+ { /* Print integers */ printf(\"%s\\n\", yytext); } \\n { /* newline */ } . { /* For others, do nothing */ } %% void main(){ yylex(); } int yywrap(){ return 1; } 编译指令 #!/bin/sh # 生成c源程序 flex lex.l # 执行程序编译 gcc lex.yy.c ","date":"2022-07-07","objectID":"/compile/:1:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#flex正则表达式"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA) 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#有限状态自动机fa"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA) 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#数学描述"},{"categories":["编译原理"],"content":" 1.3 有限状态自动机(FA) 1.3.1 数学描述M = ($\\Epsilon$, $S$, $q0$, $F$, $\\delta$) $\\Epsilon$ 字母表 $S$ 状态集 $q0$ 初始状态 $F$ 终止状态 $\\delta$ 转移函数 1.3.2 例子 下面什么样子的串可以接受 转移函数 ($q0$, a) –\u003e $q1$, ($q0$, b) –\u003e $q0$, ($q1$, a) –\u003e $q2$, ($q1$, b) –\u003e $q1$, ($q2$, a) –\u003e $q2$, ($q2$, b) –\u003e $q2$, ","date":"2022-07-07","objectID":"/compile/:1:3","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#例子"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自动生成"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#thompson算法"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#解释"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#例子-1"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#子集构造算法"},{"categories":["编译原理"],"content":" 1.4 自动生成 1.4.1 Thompson算法 1.4.1.1 解释 基于RE的结构进行归纳 对基本的RE进行直接构造 对于复合的RE进行递归构造 递归,容易实现 代码实现较少 1.4.2 例子$a(b|c)*$ 1.4.3 子集构造算法 1.4.4 Hopcroft算法","date":"2022-07-07","objectID":"/compile/:1:4","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#hopcroft算法"},{"categories":["编译原理"],"content":" 2 语法分析","date":"2022-07-07","objectID":"/compile/:2:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#语法分析"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自顶向下"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1分析文法"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1文法概述"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#ll1一般步骤"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#如何生成ll1分析表"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#first集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#follow集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#select集"},{"categories":["编译原理"],"content":" 2.1 自顶向下 递归下降 预测分析LL(1) 2.1.1 LL(1)分析文法 鉴于自定向下分析法存在回溯的问题,对于现代编译器设计是不可以接受的;由此提出了LL(1)分析文法 2.1.1.1 LL(1)文法概述给出文法 0: S -\u003e N V M 1: N -\u003e s 2: | t 3: | g 4: | w 5: V -\u003e e 6: | d 那么同时给出LL(1)分析表 N\\T s t g w e d S 0 0 0 0 X X N 1 2 3 4 X X V X X X X 5 6 那么在分析g d w语句的时候,可以得到如下的分析 解析算法 tokens[]; // all tokens i = 0; stack = [S] // S 是开始符号 while(stack[] != []) if(stack[top] is a terminal t) if(t == tokens[i++]) pop(); else error(...); else if(stack[top] is a nonterminal T) pop(); push(table[T, tokens[i]]) 2.1.1.2 LL(1)一般步骤 如何判断文法是LL(1)文法 求出该文法的first集、follow集和select集， 通过select集之间的关系进行判断 2.1.1.3 如何生成LL(1)分析表那么就可以得到一个没有回溯的分析算法,但是怎么得到这个分析表呢？ 2.1.1.3.1 FIRST集 2.1.1.3.2 FOLLOW集 2.1.1.3.3 SELECT集 2.1.2 分析流程","date":"2022-07-07","objectID":"/compile/:2:1","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#分析流程"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#自底向上"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#lr0分析算法"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#点记号"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#生成一个逆序的最右推导"},{"categories":["编译原理"],"content":" 2.2 自底向上 2.2.1 LR(0)分析算法 移进-规约算法 2.2.2 点记号.为了方便标记语法分析器已经读入可多少输入,我们可以引入一个点记号,来表示为读入的数据 2.2.3 生成一个逆序的最右推导 需要两个步骤 移进一个记号到栈顶上 规约栈顶上的n个符号到左部的非终结符 对于产生式 $A$ -\u003e $\\beta$1 … $\\beta$n,如果可以推导,那么弹出$\\beta$1 … $\\beta$n, 压入非终结符 如何确定移进-规约的时机 2.2.3.1 构造分析表","date":"2022-07-07","objectID":"/compile/:2:2","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#构造分析表"},{"categories":["编译原理"],"content":" 3 语义分析","date":"2022-07-07","objectID":"/compile/:3:0","series":null,"tags":["编译原理"],"title":"编译原理","uri":"/compile/#语义分析"},{"categories":["rootfs"],"content":" 1 下载buildroot git clone --depth=1 https://git.busybox.net/buildroot git branch -a [new branch] git checkout [new branch] ","date":"2022-03-13","objectID":"/buildroot/:1:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#下载buildroot"},{"categories":["rootfs"],"content":" 2 快速开始 可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026\u0026 make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh ","date":"2022-03-13","objectID":"/buildroot/:2:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#快速开始"},{"categories":["rootfs"],"content":" 3 基础配置","date":"2022-03-13","objectID":"/buildroot/:3:0","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#基础配置"},{"categories":["rootfs"],"content":" 3.1 使用自定义的内核在defconfig文件中添加下面的配置 BR2_LINUX_KERNEL=y # 是否编译内核 BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\"git@github.com:mengdemao/kernel.git\" # kernel的地址 BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\"master\" # 版本 BR2_LINUX_KERNEL_VERSION=\"master\" BR2_LINUX_KERNEL_USE_DEFCONFIG=y BR2_LINUX_KERNEL_DEFCONFIG=\"debian\" BR2_LINUX_KERNEL_ZIMAGE=y BR2_LINUX_KERNEL_GZIP=y ","date":"2022-03-13","objectID":"/buildroot/:3:1","series":null,"tags":["rootfs"],"title":"Buildroot","uri":"/buildroot/#使用自定义的内核"},{"categories":["环境搭建"],"content":" 1 nfs","date":"2022-01-28","objectID":"/linux_developer_server/:1:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#nfs"},{"categories":["环境搭建"],"content":" 1.1 安装 sudo apt-get install nfs-kernel-server ","date":"2022-01-28","objectID":"/linux_developer_server/:1:1","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#安装"},{"categories":["环境搭建"],"content":" 1.2 设置导出 /home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) ","date":"2022-01-28","objectID":"/linux_developer_server/:1:2","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#设置导出"},{"categories":["环境搭建"],"content":" 1.3 开启服务 sudo /etc/init.d/nfs-kernel-server restart ","date":"2022-01-28","objectID":"/linux_developer_server/:1:3","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#开启服务"},{"categories":["环境搭建"],"content":" 1.4 测试 sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt ls /mnt ","date":"2022-01-28","objectID":"/linux_developer_server/:1:4","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#测试"},{"categories":["环境搭建"],"content":" 2 samba","date":"2022-01-28","objectID":"/linux_developer_server/:2:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#samba"},{"categories":["环境搭建"],"content":" 3 tftp","date":"2022-01-28","objectID":"/linux_developer_server/:3:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#tftp"},{"categories":["环境搭建"],"content":" 4 ftp","date":"2022-01-28","objectID":"/linux_developer_server/:4:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#ftp"},{"categories":["环境搭建"],"content":" 5 apache","date":"2022-01-28","objectID":"/linux_developer_server/:5:0","series":null,"tags":["环境搭建"],"title":"linux开发环境搭建","uri":"/linux_developer_server/#apache"},{"categories":["linux"],"content":" 需要处理的问题? 如何确定哪个进程可以运行 进程切换发生后,老的进程去了哪里,新的进程如何变化 PLET实现中,谁负责移动调度实体 ","date":"2021-10-28","objectID":"/cfs/:0:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#"},{"categories":["linux"],"content":" 1 虚拟时间(vruntime) static u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw) { u64 fact = scale_load_down(weight); int shift = WMULT_SHIFT; __update_inv_weight(lw); if (unlikely(fact \u003e\u003e 32)) { while (fact \u003e\u003e 32) { fact \u003e\u003e= 1; shift--; } } /* hint to use a 32x32-\u003e64 mul */ fact = (u64)(u32)fact * lw-\u003einv_weight; while (fact \u003e\u003e 32) { fact \u003e\u003e= 1; shift--; } return mul_u64_u32_shr(delta_exec, fact, shift); } static inline u64 calc_delta_fair(u64 delta, struct sched_entity *se) { if (unlikely(se-\u003eload.weight != NICE_0_LOAD)) delta = __calc_delta(delta, NICE_0_LOAD, \u0026se-\u003eload); return delta; } 最后得到公式 $$ vruntime = \\frac{{delta\\_exec} \\times {nice\\_0\\_weight} \\times {2 ^ {32}}}{weight} $$ ","date":"2021-10-28","objectID":"/cfs/:1:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#虚拟时间vruntime"},{"categories":["linux"],"content":" 2 负载追踪(PLET) struct sched_avg { /* * These sums represent an infinite geometric series and so are bound * above by 1024/(1-y). Thus we only need a u32 to store them for all * choices of y \u003c 1-2^(-32)*1024. */ u32 runnable_avg_sum; // 调度实体在就绪队列 u32 runnable_avg_period; // 调度实体在系统中 u64 last_runnable_update; // 上次更新时间 s64 decay_count; // 衰变计数 unsigned long load_avg_contrib; // 进程平均负载贡献度 }; static __always_inline u64 decay_load(u64 val, u64 n) { unsigned int local_n; if (!n) return val; else if (unlikely(n \u003e LOAD_AVG_PERIOD * 63)) return 0; /* after bounds checking we can collapse to 32-bit */ local_n = n; /* * As y^PERIOD = 1/2, we can combine * y^n = 1/2^(n/PERIOD) * y^(n%PERIOD) * With a look-up table which covers y^n (n\u003cPERIOD) * * To achieve constant time decay_load. */ if (unlikely(local_n \u003e= LOAD_AVG_PERIOD)) { val \u003e\u003e= local_n / LOAD_AVG_PERIOD; local_n %= LOAD_AVG_PERIOD; } val *= runnable_avg_yN_inv[local_n]; /* We don't use SRR here since we always want to round down. */ return val \u003e\u003e 32; } static u32 __compute_runnable_contrib(u64 n) { u32 contrib = 0; if (likely(n \u003c= LOAD_AVG_PERIOD)) return runnable_avg_yN_sum[n]; else if (unlikely(n \u003e= LOAD_AVG_MAX_N)) return LOAD_AVG_MAX; /* Compute \\Sum k^n combining precomputed values for k^i, \\Sum k^j */ do { contrib /= 2; /* y^LOAD_AVG_PERIOD = 1/2 */ contrib += runnable_avg_yN_sum[LOAD_AVG_PERIOD]; n -= LOAD_AVG_PERIOD; } while (n \u003e LOAD_AVG_PERIOD); contrib = decay_load(contrib, n); return contrib + runnable_avg_yN_sum[n]; } static __always_inline int __update_entity_runnable_avg(u64 now, struct sched_avg *sa, int runnable) { u64 delta, periods; u32 runnable_contrib; int delta_w, decayed = 0; delta = now - sa-\u003elast_runnable_update; /* * This should only happen when time goes backwards, which it * unfortunately does during sched clock init when we swap over to TSC. */ if ((s64)delta \u003c 0) { sa-\u003elast_runnable_update = now; return 0; } /* * Use 1024ns as the unit of measurement since it's a reasonable * approximation of 1us and fast to compute. */ delta \u003e\u003e= 10; if (!delta) return 0; sa-\u003elast_runnable_update = now; /* delta_w is the amount already accumulated against our next period */ delta_w = sa-\u003erunnable_avg_period % 1024; if (delta + delta_w \u003e= 1024) { /* period roll-over */ decayed = 1; /* * Now that we know we're crossing a period boundary, figure * out how much from delta we need to complete the current * period and accrue it. */ delta_w = 1024 - delta_w; if (runnable) sa-\u003erunnable_avg_sum += delta_w; sa-\u003erunnable_avg_period += delta_w; delta -= delta_w; /* Figure out how many additional periods this update spans */ periods = delta / 1024; delta %= 1024; sa-\u003erunnable_avg_sum = decay_load(sa-\u003erunnable_avg_sum, periods + 1); sa-\u003erunnable_avg_period = decay_load(sa-\u003erunnable_avg_period, periods + 1); /* Efficiently calculate \\sum (1..n_period) 1024*y^i */ runnable_contrib = __compute_runnable_contrib(periods); if (runnable) sa-\u003erunnable_avg_sum += runnable_contrib; sa-\u003erunnable_avg_period += runnable_contrib; } /* Remainder of delta accrued against u_0` */ if (runnable) sa-\u003erunnable_avg_sum += delta; sa-\u003erunnable_avg_period += delta; return decayed; } static inline void update_entity_load_avg(struct sched_entity *se, int update_cfs_rq) { struct cfs_rq *cfs_rq = cfs_rq_of(se); long contrib_delta; u64 now; /* * For a group entity we need to use their owned cfs_rq_clock_task() in * case they are the parent of a throttled hierarchy. */ if (entity_is_task(se)) now = cfs_rq_clock_task(cfs_rq); else now = cfs_rq_clock_task(group_cfs_rq(se)); if (!__update_entity_runnable_avg(now, \u0026se-\u003eavg, se-\u003eon_rq)) return; contrib_delta = __update_entity_load_avg_contrib(se); if (!update_cfs_rq) return; if (se-\u003eon_rq) cfs_rq-\u003erunnable_load_avg += contrib_delta; else subtract_blocked_load_contrib(cfs_rq, -contrib_delta); } static inline void __update_task_entity_contrib(struct sched_entity *se) { u32 contrib; /* avoid overflowing a 32-bit type w/ SCHED_LOAD_SCALE */ contrib = se-\u003eavg.runnable_avg_","date":"2021-10-28","objectID":"/cfs/:2:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#负载追踪plet"},{"categories":["linux"],"content":" 3 调度器类 const struct sched_class fair_sched_class = { .next = \u0026idle_sched_class, .enqueue_task = enqueue_task_fair, .dequeue_task = dequeue_task_fair, .yield_task = yield_task_fair, .yield_to_task = yield_to_task_fair, .check_preempt_curr = check_preempt_wakeup, .pick_next_task = pick_next_task_fair, .put_prev_task = put_prev_task_fair, #ifdef CONFIG_SMP .select_task_rq = select_task_rq_fair, .migrate_task_rq = migrate_task_rq_fair, .rq_online = rq_online_fair, .rq_offline = rq_offline_fair, .task_dead = task_dead_fair, .set_cpus_allowed = set_cpus_allowed_common, #endif .set_curr_task = set_curr_task_fair, .task_tick = task_tick_fair, .task_fork = task_fork_fair, .prio_changed = prio_changed_fair, .switched_from = switched_from_fair, .switched_to = switched_to_fair, .get_rr_interval = get_rr_interval_fair, .update_curr = update_curr_fair, #ifdef CONFIG_FAIR_GROUP_SCHED .task_change_group = task_change_group_fair, #endif }; 调度器类分析 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf); void (*put_prev_task)(struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int new_cpu); void (*task_woken)(struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task)(struct rq *rq); void (*task_tick)(struct rq *rq, struct task_struct *p, int queued); void (*task_fork)(struct task_struct *p); void (*task_dead)(struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from)(struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval)(struct rq *rq, struct task_struct *task); void (*update_curr)(struct rq *rq); #define TASK_SET_GROUP 0 #define TASK_MOVE_GROUP 1 #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_change_group)(struct task_struct *p, int type); #endif }; ","date":"2021-10-28","objectID":"/cfs/:3:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#调度器类"},{"categories":["linux"],"content":" 4 enqueue_task_fair static void enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; /* * The code below (indirectly) updates schedutil which looks at * the cfs_rq utilization to select a frequency. * Let's add the task's estimated utilization to the cfs_rq's * estimated utilization, before we update schedutil. */ util_est_enqueue(\u0026rq-\u003ecfs, p); /* * If in_iowait is set, the code below may not trigger any cpufreq * utilization updates, so do it here explicitly with the IOWAIT flag * passed. */ if (p-\u003ein_iowait) cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); for_each_sched_entity(se) { if (se-\u003eon_rq) break; cfs_rq = cfs_rq_of(se); enqueue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running increment below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running++; flags = ENQUEUE_WAKEUP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running++; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) add_nr_running(rq, 1); if (cfs_bandwidth_used()) { /* * When bandwidth control is enabled; the cfs_rq_throttled() * breaks in the above iteration can result in incomplete * leaf list maintenance, resulting in triggering the assertion * below. */ for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); if (list_add_leaf_cfs_rq(cfs_rq)) break; } } assert_list_leaf_cfs_rq(rq); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/cfs/:4:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#enqueue_task_fair"},{"categories":["linux"],"content":" 5 dequeue_task_fair static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese; int task_sleep = flags \u0026 DEQUEUE_SLEEP; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); dequeue_entity(cfs_rq, se, flags); /* * end evaluation on encountering a throttled cfs_rq * * note: in the case of encountering a throttled cfs_rq we will * post the final h_nr_running decrement below. */ if (cfs_rq_throttled(cfs_rq)) break; cfs_rq-\u003eh_nr_running--; /* Don't dequeue parent if it has other entities besides us */ if (cfs_rq-\u003eload.weight) { /* Avoid re-evaluating load for this entity: */ se = parent_entity(se); /* * Bias pick_next to pick a task from this cfs_rq, as * p is sleeping when it is within its sched_slice. */ if (task_sleep \u0026\u0026 se \u0026\u0026 !throttled_hierarchy(cfs_rq)) set_next_buddy(se); break; } flags |= DEQUEUE_SLEEP; } for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); cfs_rq-\u003eh_nr_running--; if (cfs_rq_throttled(cfs_rq)) break; update_load_avg(cfs_rq, se, UPDATE_TG); update_cfs_group(se); } if (!se) sub_nr_running(rq, 1); util_est_dequeue(\u0026rq-\u003ecfs, p, task_sleep); hrtick_update(rq); } ","date":"2021-10-28","objectID":"/cfs/:5:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#dequeue_task_fair"},{"categories":["linux"],"content":" 6 yield_task_fair static void yield_task_fair(struct rq *rq) { struct task_struct *curr = rq-\u003ecurr; struct cfs_rq *cfs_rq = task_cfs_rq(curr); struct sched_entity *se = \u0026curr-\u003ese; /* * Are we the only task in the tree? */ if (unlikely(rq-\u003enr_running == 1)) return; clear_buddies(cfs_rq, se); if (curr-\u003epolicy != SCHED_BATCH) { update_rq_clock(rq); /* * Update run-time statistics of the 'current'. */ update_curr(cfs_rq); /* * Tell update_rq_clock() that we've just updated, * so we don't do microscopic update in schedule() * and double the fastpath cost. */ rq_clock_skip_update(rq, true); } set_skip_buddy(se); } ","date":"2021-10-28","objectID":"/cfs/:6:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#yield_task_fair"},{"categories":["linux"],"content":" 7 yield_to_task_fair static bool yield_to_task_fair(struct rq *rq, struct task_struct *p, bool preempt) { struct sched_entity *se = \u0026p-\u003ese; /* throttled hierarchies are not runnable */ if (!se-\u003eon_rq || throttled_hierarchy(cfs_rq_of(se))) return false; /* Tell the scheduler that we'd really like pse to run next. */ set_next_buddy(se); yield_task_fair(rq); return true; } ","date":"2021-10-28","objectID":"/cfs/:7:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#yield_to_task_fair"},{"categories":["linux"],"content":" 8 check_preempt_wakeup static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags) { struct task_struct *curr = rq-\u003ecurr; struct sched_entity *se = \u0026curr-\u003ese, *pse = \u0026p-\u003ese; struct cfs_rq *cfs_rq = task_cfs_rq(curr); int scale = cfs_rq-\u003enr_running \u003e= sched_nr_latency; int next_buddy_marked = 0; if (unlikely(se == pse)) return; /* * This is possible from callers such as attach_tasks(), in which we * unconditionally check_prempt_curr() after an enqueue (which may have * lead to a throttle). This both saves work and prevents false * next-buddy nomination below. */ if (unlikely(throttled_hierarchy(cfs_rq_of(pse)))) return; if (sched_feat(NEXT_BUDDY) \u0026\u0026 scale \u0026\u0026 !(wake_flags \u0026 WF_FORK)) { set_next_buddy(pse); next_buddy_marked = 1; } /* * We can come here with TIF_NEED_RESCHED already set from new task * wake up path. * * Note: this also catches the edge-case of curr being in a throttled * group (e.g. via set_curr_task), since update_curr() (in the * enqueue of curr) will have resulted in resched being set. This * prevents us from potentially nominating it as a false LAST_BUDDY * below. */ if (test_tsk_need_resched(curr)) return; /* Idle tasks are by definition preempted by non-idle tasks. */ if (unlikely(curr-\u003epolicy == SCHED_IDLE) \u0026\u0026 likely(p-\u003epolicy != SCHED_IDLE)) goto preempt; /* * Batch and idle tasks do not preempt non-idle tasks (their preemption * is driven by the tick): */ if (unlikely(p-\u003epolicy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION)) return; find_matching_se(\u0026se, \u0026pse); update_curr(cfs_rq_of(se)); BUG_ON(!pse); if (wakeup_preempt_entity(se, pse) == 1) { /* * Bias pick_next to pick the sched entity that is * triggering this preemption. */ if (!next_buddy_marked) set_next_buddy(pse); goto preempt; } return; preempt: resched_curr(rq); /* * Only set the backward buddy when the current task is still * on the rq. This can happen when a wakeup gets interleaved * with schedule on the -\u003epre_schedule() or idle_balance() * point, either of which can * drop the rq lock. * * Also, during early boot the idle thread is in the fair class, * for obvious reasons its a bad idea to schedule back to it. */ if (unlikely(!se-\u003eon_rq || curr == rq-\u003eidle)) return; if (sched_feat(LAST_BUDDY) \u0026\u0026 scale \u0026\u0026 entity_is_task(se)) set_last_buddy(se); } ","date":"2021-10-28","objectID":"/cfs/:8:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#check_preempt_wakeup"},{"categories":["linux"],"content":" 9 pick_next_task_fair static struct task_struct * pick_next_task_fair(struct rq *rq, struct task_struct *prev) { struct cfs_rq *cfs_rq = \u0026rq-\u003ecfs; struct sched_entity *se; struct task_struct *p; int new_tasks; again: #ifdef CONFIG_FAIR_GROUP_SCHED if (!cfs_rq-\u003enr_running) goto idle; if (prev-\u003esched_class != \u0026fair_sched_class) goto simple; /* * Because of the set_next_buddy() in dequeue_task_fair() it is rather * likely that a next task is from the same cgroup as the current. * * Therefore attempt to avoid putting and setting the entire cgroup * hierarchy, only change the part that actually changes. */ do { struct sched_entity *curr = cfs_rq-\u003ecurr; /* * Since we got here without doing put_prev_entity() we also * have to consider cfs_rq-\u003ecurr. If it is still a runnable * entity, update_curr() will update its vruntime, otherwise * forget we've ever seen it. */ if (curr \u0026\u0026 curr-\u003eon_rq) update_curr(cfs_rq); else curr = NULL; /* * This call to check_cfs_rq_runtime() will do the throttle and * dequeue its entity in the parent(s). Therefore the 'simple' * nr_running test will indeed be correct. */ if (unlikely(check_cfs_rq_runtime(cfs_rq))) goto simple; se = pick_next_entity(cfs_rq, curr); cfs_rq = group_cfs_rq(se); } while (cfs_rq); p = task_of(se); /* * Since we haven't yet done put_prev_entity and if the selected task * is a different task than we started out with, try and touch the * least amount of cfs_rqs. */ if (prev != p) { struct sched_entity *pse = \u0026prev-\u003ese; while (!(cfs_rq = is_same_group(se, pse))) { int se_depth = se-\u003edepth; int pse_depth = pse-\u003edepth; if (se_depth \u003c= pse_depth) { put_prev_entity(cfs_rq_of(pse), pse); pse = parent_entity(pse); } if (se_depth \u003e= pse_depth) { set_next_entity(cfs_rq_of(se), se); se = parent_entity(se); } } put_prev_entity(cfs_rq, pse); set_next_entity(cfs_rq, se); } if (hrtick_enabled(rq)) hrtick_start_fair(rq, p); return p; simple: cfs_rq = \u0026rq-\u003ecfs; #endif if (!cfs_rq-\u003enr_running) goto idle; put_prev_task(rq, prev); do { se = pick_next_entity(cfs_rq, NULL); set_next_entity(cfs_rq, se); cfs_rq = group_cfs_rq(se); } while (cfs_rq); p = task_of(se); if (hrtick_enabled(rq)) hrtick_start_fair(rq, p); return p; idle: new_tasks = idle_balance(rq); /* * Because idle_balance() releases (and re-acquires) rq-\u003elock, it is * possible for any higher priority task to appear. In that case we * must re-start the pick_next_entity() loop. */ if (new_tasks \u003c 0) return RETRY_TASK; if (new_tasks \u003e 0) goto again; return NULL; } ","date":"2021-10-28","objectID":"/cfs/:9:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#pick_next_task_fair"},{"categories":["linux"],"content":" 10 put_prev_task_fair static void put_prev_task_fair(struct rq *rq, struct task_struct *prev) { struct sched_entity *se = \u0026prev-\u003ese; struct cfs_rq *cfs_rq; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); put_prev_entity(cfs_rq, se); } } ","date":"2021-10-28","objectID":"/cfs/:10:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#put_prev_task_fair"},{"categories":["linux"],"content":" 11 set_curr_task_fair static void set_curr_task_fair(struct rq *rq) { struct sched_entity *se = \u0026rq-\u003ecurr-\u003ese; for_each_sched_entity(se) { struct cfs_rq *cfs_rq = cfs_rq_of(se); set_next_entity(cfs_rq, se); /* ensure bandwidth has been allocated on our new cfs_rq */ account_cfs_rq_runtime(cfs_rq, 0); } } ","date":"2021-10-28","objectID":"/cfs/:11:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#set_curr_task_fair"},{"categories":["linux"],"content":" 12 task_tick_fair static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026curr-\u003ese; for_each_sched_entity(se) { cfs_rq = cfs_rq_of(se); entity_tick(cfs_rq, se, queued); } if (numabalancing_enabled) task_tick_numa(rq, curr); update_rq_runnable_avg(rq, 1); } ","date":"2021-10-28","objectID":"/cfs/:12:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#task_tick_fair"},{"categories":["linux"],"content":" 13 task_fork_fair static void task_fork_fair(struct task_struct *p) { struct cfs_rq *cfs_rq; struct sched_entity *se = \u0026p-\u003ese, *curr; int this_cpu = smp_processor_id(); struct rq *rq = this_rq(); unsigned long flags; raw_spin_lock_irqsave(\u0026rq-\u003elock, flags); update_rq_clock(rq); cfs_rq = task_cfs_rq(current); curr = cfs_rq-\u003ecurr; /* * Not only the cpu but also the task_group of the parent might have * been changed after parent-\u003ese.parent,cfs_rq were copied to * child-\u003ese.parent,cfs_rq. So call __set_task_cpu() to make those * of child point to valid ones. */ rcu_read_lock(); __set_task_cpu(p, this_cpu); rcu_read_unlock(); update_curr(cfs_rq); if (curr) se-\u003evruntime = curr-\u003evruntime; place_entity(cfs_rq, se, 1); if (sysctl_sched_child_runs_first \u0026\u0026 curr \u0026\u0026 entity_before(curr, se)) { /* * Upon rescheduling, sched_class::put_prev_task() will place * 'current' within the tree based on its new key value. */ swap(curr-\u003evruntime, se-\u003evruntime); resched_curr(rq); } se-\u003evruntime -= cfs_rq-\u003emin_vruntime; raw_spin_unlock_irqrestore(\u0026rq-\u003elock, flags); } ","date":"2021-10-28","objectID":"/cfs/:13:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#task_fork_fair"},{"categories":["linux"],"content":" 14 update_curr_fair static void update_curr_fair(struct rq *rq) { update_curr(cfs_rq_of(\u0026rq-\u003ecurr-\u003ese)); } static void update_curr(struct cfs_rq *cfs_rq) { struct sched_entity *curr = cfs_rq-\u003ecurr; u64 now = rq_clock_task(rq_of(cfs_rq)); u64 delta_exec; if (unlikely(!curr)) return; delta_exec = now - curr-\u003eexec_start; if (unlikely((s64)delta_exec \u003c= 0)) return; curr-\u003eexec_start = now; schedstat_set(curr-\u003estatistics.exec_max, max(delta_exec, curr-\u003estatistics.exec_max)); curr-\u003esum_exec_runtime += delta_exec; schedstat_add(cfs_rq, exec_clock, delta_exec); curr-\u003evruntime += calc_delta_fair(delta_exec, curr); update_min_vruntime(cfs_rq); if (entity_is_task(curr)) { struct task_struct *curtask = task_of(curr); trace_sched_stat_runtime(curtask, delta_exec, curr-\u003evruntime); cpuacct_charge(curtask, delta_exec); account_group_exec_runtime(curtask, delta_exec); } account_cfs_rq_runtime(cfs_rq, delta_exec); } ","date":"2021-10-28","objectID":"/cfs/:14:0","series":null,"tags":["kernel"],"title":"完全公平调度器","uri":"/cfs/#update_curr_fair"},{"categories":["linux"],"content":"物理页面分配器","date":"2021-10-28","objectID":"/page_allocator/","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/"},{"categories":["linux"],"content":" 1 alloc_pageslinux常用的物理界面分配器的函数是alloc_pages,下面分析是如何实现的. #define alloc_pages(gfp_mask, order) alloc_pages_node(numa_node_id(), gfp_mask, order) static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order) { /* Unknown node is current node */ if (nid \u003c 0) nid = numa_node_id(); return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask)); } static inline struct page *__alloc_pages(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist) { return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL); } 此时正式进入函数分析阶段 /** * @brief 分配物理页面 * @param gfp_mask 分配掩码 * @param order 分配阶数 * @param zonelist 内存区域 * @param nodemask 节点掩码 * @return struct page* 分配的物理页面 */ struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist, nodemask_t *nodemask); 详细解析接口实现 分配掩码 // 分配掩码就是一个unsigned int类型 typedef unsigned __bitwise__ gfp_t; #define ___GFP_DMA 0x01u #define ___GFP_HIGHMEM 0x02u #define ___GFP_DMA32 0x04u #define ___GFP_MOVABLE 0x08u #define ___GFP_WAIT 0x10u #define ___GFP_HIGH 0x20u #define ___GFP_IO 0x40u #define ___GFP_FS 0x80u #define ___GFP_COLD 0x100u #define ___GFP_NOWARN 0x200u #define ___GFP_REPEAT 0x400u #define ___GFP_NOFAIL 0x800u #define ___GFP_NORETRY 0x1000u #define ___GFP_MEMALLOC 0x2000u #define ___GFP_COMP 0x4000u #define ___GFP_ZERO 0x8000u #define ___GFP_NOMEMALLOC 0x10000u #define ___GFP_HARDWALL 0x20000u #define ___GFP_THISNODE 0x40000u #define ___GFP_RECLAIMABLE 0x80000u #define ___GFP_NOTRACK 0x200000u #define ___GFP_NO_KSWAPD 0x400000u #define ___GFP_OTHER_NODE 0x800000u #define ___GFP_WRITE 0x1000000u #define __force __attribute__((force)) #define __GFP_DMA ((__force gfp_t)___GFP_DMA) #define __GFP_HIGHMEM ((__force gfp_t)___GFP_HIGHMEM) #define __GFP_DMA32 ((__force gfp_t)___GFP_DMA32) #define __GFP_MOVABLE ((__force gfp_t)___GFP_MOVABLE) /* Page is movable */ #define __GFP_WAIT ((__force gfp_t)___GFP_WAIT) /* Can wait and reschedule? */ #define __GFP_HIGH ((__force gfp_t)___GFP_HIGH) /* Should access emergency pools? */ #define __GFP_IO ((__force gfp_t)___GFP_IO) /* Can start physical IO? */ #define __GFP_FS ((__force gfp_t)___GFP_FS) /* Can call down to low-level FS? */ #define __GFP_COLD ((__force gfp_t)___GFP_COLD) /* Cache-cold page required */ #define __GFP_NOWARN ((__force gfp_t)___GFP_NOWARN) /* Suppress page allocation failure warning */ #define __GFP_REPEAT ((__force gfp_t)___GFP_REPEAT) /* See above */ #define __GFP_NOFAIL ((__force gfp_t)___GFP_NOFAIL) /* See above */ #define __GFP_NORETRY ((__force gfp_t)___GFP_NORETRY) /* See above */ #define __GFP_MEMALLOC ((__force gfp_t)___GFP_MEMALLOC)/* Allow access to emergency reserves */ #define __GFP_COMP ((__force gfp_t)___GFP_COMP) /* Add compound page metadata */ #define __GFP_ZERO ((__force gfp_t)___GFP_ZERO) /* Return zeroed page on success */ #define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC) /* Don't use emergency reserves. * This takes precedence over the * __GFP_MEMALLOC flag if both are * set */ #define __GFP_HARDWALL ((__force gfp_t)___GFP_HARDWALL) /* Enforce hardwall cpuset memory allocs */ #define __GFP_THISNODE ((__force gfp_t)___GFP_THISNODE)/* No fallback, no policies */ #define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) /* Page is reclaimable */ #define __GFP_NOTRACK ((__force gfp_t)___GFP_NOTRACK) /* Don't track with kmemcheck */ #define __GFP_NO_KSWAPD ((__force gfp_t)___GFP_NO_KSWAPD) #define __GFP_OTHER_NODE ((__force gfp_t)___GFP_OTHER_NODE) /* On behalf of other node */ #define __GFP_WRITE ((__force gfp_t)___GFP_WRITE) /* Allocator intends to dirty page */ 分配阶数 描述分配的大小 $$ {page_number} = 2 ^ {order} $$ 内存区域 zone令行分析 节点掩码 nodemask令行分析 ","date":"2021-10-28","objectID":"/page_allocator/:1:0","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#alloc_pages"},{"categories":["linux"],"content":" 1.1 __alloc_pages_nodemask struct page * __alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, struct zonelist *zonelist, nodemask_t *nodemask) { struct zoneref *preferred_zoneref; struct page *page = NULL; unsigned int cpuset_mems_cookie; int alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET|ALLOC_FAIR; gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */ struct alloc_context ac = { .high_zoneidx = gfp_zone(gfp_mask), .nodemask = nodemask, .migratetype = gfpflags_to_migratetype(gfp_mask), }; gfp_mask \u0026= gfp_allowed_mask; lockdep_trace_alloc(gfp_mask); might_sleep_if(gfp_mask \u0026 __GFP_WAIT); if (should_fail_alloc_page(gfp_mask, order)) return NULL; /* * Check the zones suitable for the gfp_mask contain at least one * valid zone. It's possible to have an empty zonelist as a result * of GFP_THISNODE and a memoryless node */ if (unlikely(!zonelist-\u003e_zonerefs-\u003ezone)) return NULL; if (IS_ENABLED(CONFIG_CMA) \u0026\u0026 ac.migratetype == MIGRATE_MOVABLE) alloc_flags |= ALLOC_CMA; retry_cpuset: cpuset_mems_cookie = read_mems_allowed_begin(); /* We set it here, as __alloc_pages_slowpath might have changed it */ ac.zonelist = zonelist; /* The preferred zone is used for statistics later */ preferred_zoneref = first_zones_zonelist(ac.zonelist, ac.high_zoneidx, ac.nodemask ? : \u0026cpuset_current_mems_allowed, \u0026ac.preferred_zone); if (!ac.preferred_zone) goto out; ac.classzone_idx = zonelist_zone_idx(preferred_zoneref); /* First allocation attempt */ alloc_mask = gfp_mask|__GFP_HARDWALL; page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026ac); if (unlikely(!page)) { /* * Runtime PM, block IO and its error handling path * can deadlock because I/O on the device might not * complete. */ alloc_mask = memalloc_noio_flags(gfp_mask); page = __alloc_pages_slowpath(alloc_mask, order, \u0026ac); } if (kmemcheck_enabled \u0026\u0026 page) kmemcheck_pagealloc_alloc(page, order, gfp_mask); trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); out: /* * When updating a task's mems_allowed, it is possible to race with * parallel threads in such a way that an allocation can fail while * the mask is being updated. If a page allocation is about to fail, * check if the cpuset changed during allocation and if so, retry. */ if (unlikely(!page \u0026\u0026 read_mems_allowed_retry(cpuset_mems_cookie))) goto retry_cpuset; return page; } struct alloc_context { struct zonelist *zonelist; nodemask_t *nodemask; struct zone *preferred_zone; int classzone_idx; int migratetype; enum zone_type high_zoneidx; }; struct alloc_context ac = { .high_zoneidx = gfp_zone(gfp_mask), .nodemask = nodemask, .migratetype = gfpflags_to_migratetype(gfp_mask), }; static inline enum zone_type gfp_zone(gfp_t flags) { enum zone_type z; int bit = (__force int) (flags \u0026 GFP_ZONEMASK); z = (GFP_ZONE_TABLE \u003e\u003e (bit * ZONES_SHIFT)) \u0026 ((1 \u003c\u003c ZONES_SHIFT) - 1); VM_BUG_ON((GFP_ZONE_BAD \u003e\u003e bit) \u0026 1); return z; } // GFP --\u003e migratetype static inline int gfpflags_to_migratetype(const gfp_t gfp_flags) { WARN_ON((gfp_flags \u0026 GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK); if (unlikely(page_group_by_mobility_disabled)) return MIGRATE_UNMOVABLE; /* Group based on mobility */ return (((gfp_flags \u0026 __GFP_MOVABLE) != 0) \u003c\u003c 1) | ((gfp_flags \u0026 __GFP_RECLAIMABLE) != 0); } ","date":"2021-10-28","objectID":"/page_allocator/:1:1","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__alloc_pages_nodemask"},{"categories":["linux"],"content":" 1.2 first_zones_zonelist static inline struct zoneref *first_zones_zonelist(struct zonelist *zonelist, enum zone_type highest_zoneidx, nodemask_t *nodes, struct zone **zone) { struct zoneref *z = next_zones_zonelist(zonelist-\u003e_zonerefs, highest_zoneidx, nodes); *zone = zonelist_zone(z); return z; } // 提取zone的指针 static inline struct zone *zonelist_zone(struct zoneref *zoneref) { return zoneref-\u003ezone; } struct zoneref *next_zones_zonelist(struct zoneref *z, enum zone_type highest_zoneidx, nodemask_t *nodes) { /* * Find the next suitable zone to use for the allocation. * Only filter based on nodemask if it's set */ if (likely(nodes == NULL)) while (zonelist_zone_idx(z) \u003e highest_zoneidx) z++; else while (zonelist_zone_idx(z) \u003e highest_zoneidx || (z-\u003ezone \u0026\u0026 !zref_in_nodemask(z, nodes))) z++; return z; } ","date":"2021-10-28","objectID":"/page_allocator/:1:2","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#first_zones_zonelist"},{"categories":["linux"],"content":" 2 free_pages void free_pages(unsigned long addr, unsigned int order) { if (addr != 0) { VM_BUG_ON(!virt_addr_valid((void *)addr)); __free_pages(virt_to_page((void *)addr), order); } } ","date":"2021-10-28","objectID":"/page_allocator/:2:0","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#free_pages"},{"categories":["linux"],"content":" 2.1 __free_pages void __free_pages(struct page *page, unsigned int order) { if (put_page_testzero(page)) { if (order == 0) free_hot_cold_page(page, false); else __free_pages_ok(page, order); } } ","date":"2021-10-28","objectID":"/page_allocator/:2:1","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_pages"},{"categories":["linux"],"content":" 2.2 __free_pages_ok static void __free_pages_ok(struct page *page, unsigned int order) { unsigned long flags; int migratetype; unsigned long pfn = page_to_pfn(page); if (!free_pages_prepare(page, order)) return; migratetype = get_pfnblock_migratetype(page, pfn); local_irq_save(flags); __count_vm_events(PGFREE, 1 \u003c\u003c order); set_freepage_migratetype(page, migratetype); free_one_page(page_zone(page), page, pfn, order, migratetype); local_irq_restore(flags); } ","date":"2021-10-28","objectID":"/page_allocator/:2:2","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_pages_ok"},{"categories":["linux"],"content":" 2.3 free_one_page static void free_one_page(struct zone *zone, struct page *page, unsigned long pfn, unsigned int order, int migratetype) { unsigned long nr_scanned; spin_lock(\u0026zone-\u003elock); nr_scanned = zone_page_state(zone, NR_PAGES_SCANNED); if (nr_scanned) __mod_zone_page_state(zone, NR_PAGES_SCANNED, -nr_scanned); if (unlikely(has_isolate_pageblock(zone) || is_migrate_isolate(migratetype))) { migratetype = get_pfnblock_migratetype(page, pfn); } __free_one_page(page, pfn, zone, order, migratetype); spin_unlock(\u0026zone-\u003elock); } ","date":"2021-10-28","objectID":"/page_allocator/:2:3","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#free_one_page"},{"categories":["linux"],"content":" 2.4 __free_one_page static inline void __free_one_page(struct page *page, unsigned long pfn, struct zone *zone, unsigned int order, int migratetype) { unsigned long page_idx; unsigned long combined_idx; unsigned long uninitialized_var(buddy_idx); struct page *buddy; int max_order = MAX_ORDER; VM_BUG_ON(!zone_is_initialized(zone)); VM_BUG_ON_PAGE(page-\u003eflags \u0026 PAGE_FLAGS_CHECK_AT_PREP, page); VM_BUG_ON(migratetype == -1); if (is_migrate_isolate(migratetype)) { /* * We restrict max order of merging to prevent merge * between freepages on isolate pageblock and normal * pageblock. Without this, pageblock isolation * could cause incorrect freepage accounting. */ max_order = min(MAX_ORDER, pageblock_order + 1); } else { __mod_zone_freepage_state(zone, 1 \u003c\u003c order, migratetype); } page_idx = pfn \u0026 ((1 \u003c\u003c max_order) - 1); VM_BUG_ON_PAGE(page_idx \u0026 ((1 \u003c\u003c order) - 1), page); VM_BUG_ON_PAGE(bad_range(zone, page), page); while (order \u003c max_order - 1) { buddy_idx = __find_buddy_index(page_idx, order); buddy = page + (buddy_idx - page_idx); if (!page_is_buddy(page, buddy, order)) break; /* * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page, * merge with it and move up one order. */ if (page_is_guard(buddy)) { clear_page_guard(zone, buddy, order, migratetype); } else { list_del(\u0026buddy-\u003elru); zone-\u003efree_area[order].nr_free--; rmv_page_order(buddy); } combined_idx = buddy_idx \u0026 page_idx; page = page + (combined_idx - page_idx); page_idx = combined_idx; order++; } set_page_order(page, order); /* * If this is not the largest possible page, check if the buddy * of the next-highest order is free. If it is, it's possible * that pages are being freed that will coalesce soon. In case, * that is happening, add the free page to the tail of the list * so it's less likely to be used soon and more likely to be merged * as a higher order page */ if ((order \u003c MAX_ORDER-2) \u0026\u0026 pfn_valid_within(page_to_pfn(buddy))) { struct page *higher_page, *higher_buddy; combined_idx = buddy_idx \u0026 page_idx; higher_page = page + (combined_idx - page_idx); buddy_idx = __find_buddy_index(combined_idx, order + 1); higher_buddy = higher_page + (buddy_idx - combined_idx); if (page_is_buddy(higher_page, higher_buddy, order + 1)) { list_add_tail(\u0026page-\u003elru, \u0026zone-\u003efree_area[order].free_list[migratetype]); goto out; } } list_add(\u0026page-\u003elru, \u0026zone-\u003efree_area[order].free_list[migratetype]); out: zone-\u003efree_area[order].nr_free++; } ","date":"2021-10-28","objectID":"/page_allocator/:2:4","series":null,"tags":["kernel"],"title":"物理页面分配器","uri":"/page_allocator/#__free_one_page"},{"categories":["前端知识"],"content":"javascript基础教程","date":"2021-10-07","objectID":"/javascript/","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/"},{"categories":["前端知识"],"content":" 1 基础知识 JavaScript是一种运行在浏览器中的解释型的编程语言 JavaScript（JS）是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。 虽然作为 Web 页面中的脚本语言被人所熟知，但是它也被用到了很多非浏览器环境中， 例如 Node.js、Apache CouchDB、Adobe Acrobat 等。 进一步说，JavaScript 是一种基于原型、多范式、单线程的动态 (en-US)语言， 并且支持面向对象、命令式和声明式（如函数式编程）风格。 在hugo中运行javacsript脚本,可以使用hugo的script shortcode在文章中插入Javascript脚本 {{\u003c script \u003e}} console.log('javascript基础教程!'); {{\u003c /script \u003e}} 可以在浏览器的后台中看到日志javascript基础教程! 同样的道理,也可以直接写在html中; \u003cbutton onclick='alert(Date())'\u003e现在的时间是? \u003c/button\u003e 点击下面的按钮，显示效果 现在的时间是? JavaScript严格区分大小写 作为一个新的语言,我们学的第一个程序 打印hello world /* 打印弹窗 */ alert(\"hello world\"); /* 打印在html */ document.write(\"hello world\"); /* 打印在调试窗口 */ console.log(\"Hello world\") 但是直接在浏览器中运行显得特别麻烦,此时我们可以使用NodeJS在命令行中运行程序 Nodejs中的内容 执行js脚本 ","date":"2021-10-07","objectID":"/javascript/:1:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基础知识"},{"categories":["前端知识"],"content":" 2 基本语句 赋值语句 var x = 1; // 定义全局变量 let y = 12; // 定义局部变量 注释语句 // 单行注释 /** * 多行注释 */ 变量 变量必须以字母开头 变量也能以$和_符号开头 变量名称对大小写敏感 ","date":"2021-10-07","objectID":"/javascript/:2:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#基本语句"},{"categories":["前端知识"],"content":" 3 数据类型 九种数据类型 值类型(基本类型) 字符串(String) 数字(Number) 布尔(Boolean) 空(Null) 未定义(Undefined) Symbol 引用数据类型(对象类型) 对象(Object) 数组(Array) 函数(Function) ","date":"2021-10-07","objectID":"/javascript/:3:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数据类型"},{"categories":["前端知识"],"content":" 3.1 定义数据 var a = 'Hello'; // 字符串(String) var b = 10; // 数字(Number) var c = true; // 布尔(Boolean) var d = function() { // 函数(Function) console.log(\"Hello\"); }; var e = [1, 2, 3]; // 数组(Array) var f = null; // 空(Null) var g = Symbol(); // Symbol var h; // 未定义(Undefined) var i = Object(); // 对象(Object) ","date":"2021-10-07","objectID":"/javascript/:3:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义数据"},{"categories":["前端知识"],"content":" 3.2 检测数据 typeof 只可以检测基本数据类型 constructor返回实例的构造函数 instanceof 原型查找 Object.prototype.toString // 1. typeof检测类型 console.log(\"\\r\\n1. typeof检测类型\") console.log('type of a is ' + typeof(a)); console.log('type of b is ' + typeof(b)); console.log('type of c is ' + typeof(c)); console.log('type of d is ' + typeof(d)); console.log('type of e is ' + typeof(e)); console.log('type of f is ' + typeof(f)); console.log('type of g is ' + typeof(g)); console.log('type of h is ' + typeof(h)); console.log('type of i is ' + typeof(i)); // 2. constructor返回实例的构造函数 console.log(\"\\r\\n2. constructor返回实例的构造函数\") console.log(a.constructor == String); console.log(a.constructor == Number); console.log(e.constructor == Object); console.log(e.constructor == Array); // 3. instanceof 原型查找 console.log(\"\\r\\n3. instanceof 原型查找\") console.log(a instanceof String); console.log(a instanceof Number); console.log(e instanceof Object); console.log(e instanceof Array); // 4. Object.prototype.toString console.log(\"\\r\\n4. Object.prototype.toString\") console.log('type of a is ' + toString.call(a)); console.log('type of b is ' + toString.call(b)); console.log('type of c is ' + toString.call(c)); console.log('type of d is ' + toString.call(d)); console.log('type of e is ' + toString.call(e)); console.log('type of f is ' + toString.call(f)); console.log('type of g is ' + toString.call(g)); console.log('type of h is ' + toString.call(h)); console.log('type of i is ' + toString.call(i)); ","date":"2021-10-07","objectID":"/javascript/:3:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#检测数据"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#定义字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#拼接字符串"},{"categories":["前端知识"],"content":" 3.3 字符串 3.3.1 定义字符串 var a = \"hello\"; var b = \"world\"; var c = a + ',' + b; var d = `${a}, ${b}`; console.log(c); console.log(d); 根据上面的例子可以看出, 字符串的的拼接可以分成两种情况: 使用+拼接字符串 使用``拼接(前面的符号是Esc按键下面的按键) 3.3.2 拼接字符串要获取字符串某个指定位置的字符,类似于C语言的字符数组, str[0],str[1],str[2]….分别可以得到字符; 3.3.3 字符串函数 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf() 会搜索指定字符串出现的位置 substring()返回指定索引区间的子串 var s = 'Hello'; console.log(s.toUpperCase()); // 'HELLO' console.log(s.toLowerCase()); // 'HELLO' console.log(s.indexOf('ll')); // 2 console.log(s.substring(1,3)); // el console.log(s.substring(1)); // ello 执行测试,可以在浏览器中看到日志 ","date":"2021-10-07","objectID":"/javascript/:3:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#字符串函数"},{"categories":["前端知识"],"content":" 3.4 数组JavaScript的数组可以包含任意数据类型;并通过索引来访问每个元素. var array = [1, 2, 'hello', \"world\", true]; // 定义一个数组 array.length; // 5 array[0]; // 打印 ","date":"2021-10-07","objectID":"/javascript/:3:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#数组"},{"categories":["前端知识"],"content":" 4 条件判断 与C相似,此处就不过多赘述 if else else if switch if (1 \u003c 3) { console.log(\"1 \u003c 3 \\r\\n\"); } if (false) { console.log(\"false \\r\\n\"); } else { console.log(\"true \\r\\n\"); } if (false) { console.log(\"false \\r\\n\"); } else if(false) { console.log(\"false \\r\\n\"); } else { console.log(\"true \\r\\n\"); } 同样的道理,js也存在这多路选择 switch (new Date().getDay()) { case 0: day = \"星期天\"; break; case 1: day = \"星期一\"; break; case 2: day = \"星期二\"; break; case 3: day = \"星期三\"; break; case 4: day = \"星期四\"; break; case 5: day = \"星期五\"; break; case 6: day = \"星期六\"; } console.log('今天是' + day); ","date":"2021-10-07","objectID":"/javascript/:4:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#条件判断"},{"categories":["前端知识"],"content":" 5 循环语句 for for (语句 1; 语句 2; 语句 3) { 要执行的代码块 } for-in for (key in object) { // code block to be executed } for-of while do-while ","date":"2021-10-07","objectID":"/javascript/:5:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#循环语句"},{"categories":["前端知识"],"content":" 6 遍历语句","date":"2021-10-07","objectID":"/javascript/:6:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#遍历语句"},{"categories":["前端知识"],"content":" 7 函数","date":"2021-10-07","objectID":"/javascript/:7:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数"},{"categories":["前端知识"],"content":" 7.1 函数模型 c语言类型 function functionName(args) { return retVal; } function:函数定义 functionName parameter retVal 一种完全等价的定义 var functionName = function(args) { return retVal; } ","date":"2021-10-07","objectID":"/javascript/:7:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数模型"},{"categories":["前端知识"],"content":" 7.2 函数调用","date":"2021-10-07","objectID":"/javascript/:7:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#函数调用"},{"categories":["前端知识"],"content":" 7.3 箭头函数","date":"2021-10-07","objectID":"/javascript/:7:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#箭头函数"},{"categories":["前端知识"],"content":" 8 面向对象","date":"2021-10-07","objectID":"/javascript/:8:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#面向对象"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建对象es5"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#object对象"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#对象初始化器"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#构造函数"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#继承语法"},{"categories":["前端知识"],"content":" 8.1 创建对象(ES5) ES5设计的面向对象真的麻烦 8.1.1 Object对象 创建对象 // 定义对象 var student = new object(); 添加成员 // 添加属性 student.age = 18; student.name = \"hello\"; // 添加方法 student3.printStudent = function() { console.log('name : ' + this.name); console.log('age : ' + this.age); } 修改成员 // 修改属性 student.age = 19; student.name = \"world\"; // 修改方法 student3.printStudent = function() { console.log('new name : ' + this.name); console.log('new age : ' + this.age); } 删除成员 delete(student3.name); student3.printStudent(); // 打印结果 // new name : undefined // new age : 19 8.1.2 对象初始化器JavaScript的对象类似于Json,但是表示方法不同; var student = { name: \"hello\", age: 18 }; JavaScript用一个{…}表示一个对象,键值对以成员名:属性值声明; 与Json相同的是,最后一个元素不可以添加,; 8.1.3 构造函数 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。 通过 new 创建对象实例。 function Student(name, age) { this.name = name; this.age = age; } var student = new student(\"world\", 19); 8.1.4 继承语法 8.1.5 封装语法","date":"2021-10-07","objectID":"/javascript/:8:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装语法"},{"categories":["前端知识"],"content":" 8.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 8.2.1 继承语法 8.2.2 封装语法","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#创建对象es6"},{"categories":["前端知识"],"content":" 8.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 8.2.1 继承语法 8.2.2 封装语法","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#继承语法-1"},{"categories":["前端知识"],"content":" 8.2 创建对象(ES6) class StudentClass { // constructor constructor(name, age) { this.name = name; this.age = age; } // Getter get info() { return this.name + this.age; } // Method printStudent() { console.log('name : ' + this.name); console.log('age : ' + this.age); } } var student3 = new StudentClass('test', 12); // 使用getter函数的方法 console.log(student3.info); 8.2.1 继承语法 8.2.2 封装语法","date":"2021-10-07","objectID":"/javascript/:8:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#封装语法-1"},{"categories":["前端知识"],"content":" 8.3 访问成员 访问成员的方式存在两种 C方式:对象名.成员名 反射式:对象名['成员名'] 'use strict'; var student = { name: \"hello\", age: 18 }; console.log(student.name); // hello console.log(student['age']); // 18 ","date":"2021-10-07","objectID":"/javascript/:8:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#访问成员"},{"categories":["前端知识"],"content":" 9 标准对象 JS为我们定义的标准对象 Map(映射) Set(集合) Date(日期) RegExp(正则表达式) JSON(JSON) Math(数学) ","date":"2021-10-07","objectID":"/javascript/:9:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#标准对象"},{"categories":["前端知识"],"content":" 9.1 Map(映射)","date":"2021-10-07","objectID":"/javascript/:9:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#map映射"},{"categories":["前端知识"],"content":" 9.2 Set(集合)","date":"2021-10-07","objectID":"/javascript/:9:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#set集合"},{"categories":["前端知识"],"content":" 9.3 Date(日期)","date":"2021-10-07","objectID":"/javascript/:9:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#date日期"},{"categories":["前端知识"],"content":" 9.4 RegExp(正则表达式)","date":"2021-10-07","objectID":"/javascript/:9:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#regexp正则表达式"},{"categories":["前端知识"],"content":" 9.5 JSON(JSON) 序列化: stringify() 反序列化: parse() var text = '{ \"student\" : [' + '{ \"name\":\"hello\" , \"age\": 18 },' + '{ \"name\":\"world\" , \"age\": 18 }]}'; var jsonObj = JSON.parse(text); var jsonTxt = JSON.stringify(jsonObj); console.log(jsonObj); console.log(jsonTxt); ","date":"2021-10-07","objectID":"/javascript/:9:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#jsonjson"},{"categories":["前端知识"],"content":" 9.6 Math(数学) 与其他全局对象不同的是，Math 不是一个构造器。 Math 的所有属性与方法都是静态的. 引用圆周率的写法是 Math.PI,调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参数。 Math 的常量是使用 JavaScript 中的全精度浮点数来定义的。 Math 用于 Number 类型。它不支持 BigInt // 常数 console.log(\"自然常数: \" + Math.E); console.log(\"2的自然对数: \" + Math.LN2); console.log(\"10的自然对数: \" + Math.LN10); // 函数 console.log(\"-10的绝对值: \" + Math.abs(-10)); console.log(\"10的正弦值: \" + Math.sin(10)); console.log(\"10的余弦值: \" + Math.cos(10)); 输出值 $ node Math.js 自然常数: 2.718281828459045 2的自然对数: 0.6931471805599453 10的自然对数: 2.302585092994046 -10的绝对值: 10 10的正弦值: -0.5440211108893698 10的余弦值: -0.8390715290764524 ","date":"2021-10-07","objectID":"/javascript/:9:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#math数学"},{"categories":["前端知识"],"content":" 10 宿主对象 由浏览器提供的对象 window navigator location document history Dom Bom 表单 文件 AJAX Promise Canvas ","date":"2021-10-07","objectID":"/javascript/:10:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#宿主对象"},{"categories":["前端知识"],"content":" 10.1 window window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档。 使用 document.defaultView 属性可以获取指定文档所在窗口。 window作为全局变量，代表了脚本正在运行的窗口，暴露给 Javascript 代码。 ","date":"2021-10-07","objectID":"/javascript/:10:1","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#window"},{"categories":["前端知识"],"content":" 10.2 navigator","date":"2021-10-07","objectID":"/javascript/:10:2","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#navigator"},{"categories":["前端知识"],"content":" 10.3 location","date":"2021-10-07","objectID":"/javascript/:10:3","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#location"},{"categories":["前端知识"],"content":" 10.4 document","date":"2021-10-07","objectID":"/javascript/:10:4","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#document"},{"categories":["前端知识"],"content":" 10.5 history","date":"2021-10-07","objectID":"/javascript/:10:5","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#history"},{"categories":["前端知识"],"content":" 10.6 DOM 文档对象模型(DOM)将web页面与到脚本或编程语言连接起来. JS通过DOM访问文档; ","date":"2021-10-07","objectID":"/javascript/:10:6","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#dom"},{"categories":["前端知识"],"content":" 10.7 BOM","date":"2021-10-07","objectID":"/javascript/:10:7","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#bom"},{"categories":["前端知识"],"content":" 10.8 表单","date":"2021-10-07","objectID":"/javascript/:10:8","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#表单"},{"categories":["前端知识"],"content":" 10.9 文件","date":"2021-10-07","objectID":"/javascript/:10:9","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#文件"},{"categories":["前端知识"],"content":" 10.10 AJAX","date":"2021-10-07","objectID":"/javascript/:10:10","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#ajax"},{"categories":["前端知识"],"content":" 10.11 Promise","date":"2021-10-07","objectID":"/javascript/:10:11","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#promise"},{"categories":["前端知识"],"content":" 10.12 Canvas","date":"2021-10-07","objectID":"/javascript/:10:12","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#canvas"},{"categories":["前端知识"],"content":" 11 错误处理 程序有可能会出错,因此需要进行错误处理;高级语言try ... catch ... finally, 'use strict'; var r1, r2, s = null; try { r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行 } catch (e) { console.log('error: ' + e); } finally { console.log('finally'); } console.log('r1 = ' + r1); // r1应为undefined console.log('r2 = ' + r2); // r2应为undefined // 下面的文件 // 出错了：TypeError: Cannot read properties of null (reading 'length') // finally // r1 = undefined // r2 = undefined 出错 先执行try { ... }的代码; 执行到出错的语句时,后续语句不再继续执行.转而执行catch (e) { ... }代码； 最后执行finally{ ... }代码。 无错 先执行try { … }的代码； 因为没有出错，catch (e) { … }代码不会被执行； 最后执行finally { … }代码。 ","date":"2021-10-07","objectID":"/javascript/:11:0","series":null,"tags":["前端知识"],"title":"javascript基础教程","uri":"/javascript/#错误处理"},{"categories":["前端知识"],"content":"CSS3基础教程","date":"2021-10-07","objectID":"/css3/","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/"},{"categories":["前端知识"],"content":" 1 基础知识 Cascading Style Sheets(层叠样式表) HTML + CSS + JavaScript =\u003e 名词 + 形容词 + 动词 CSS可以认为对原始的HTML进行美化 ","date":"2021-10-07","objectID":"/css3/:1:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基础知识"},{"categories":["前端知识"],"content":" 1.1 快速入门 CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画 ","date":"2021-10-07","objectID":"/css3/:1:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#快速入门"},{"categories":["前端知识"],"content":" 1.2 什么是CSS美化:字体, 颜色,高度,宽度, 背景图片 ","date":"2021-10-07","objectID":"/css3/:1:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#什么是css"},{"categories":["前端知识"],"content":" 1.3 CSS的优势 内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件 ","date":"2021-10-07","objectID":"/css3/:1:3","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css的优势"},{"categories":["前端知识"],"content":" 1.4 CSS导入的方法 行内样式 \u003ch1 style=\"color: red\"\u003e一级标题\u003c/h1\u003e style标签 \u003cstyle\u003e\u003c/style\u003e 外部样式 链接方式 \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e 导入式 \u003cstyle\u003e @import url(\"css/style.css\"); \u003c/style\u003e ","date":"2021-10-07","objectID":"/css3/:1:4","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css导入的方法"},{"categories":["前端知识"],"content":" 1.5 基本语法 /* 注释语法 */ selector { /* 声明 */ attr:value; } 下面的代码可以直接修改背景颜色 \u003cstyle\u003e body { background-color:gray; } \u003c/style\u003e CSS基本操作 选中元素(选择某一类或者某一个) 属性修改(修改一个或者多个) ","date":"2021-10-07","objectID":"/css3/:1:5","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基本语法"},{"categories":["前端知识"],"content":" 2 选择器 选择某一类或者某一个元素 ","date":"2021-10-07","objectID":"/css3/:2:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 \u003ch1 class=\"test\"\u003e测试\u003c/h1\u003e 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 \u003ch1 id=\"test\"\u003e测试\u003c/h1\u003e #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#基本选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#标签选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#类选择器"},{"categories":["前端知识"],"content":" 2.1 基本选择器 标签选择器 类选择器 ID选择器 2.1.1 标签选择器 选中html的标签 h1 { color: red; } h2 { color: black; } h3 { color: yellow; } h4 { color: red; } 2.1.2 类选择器 测试 此时,可以讲HTML选中 类选择器使用.+className .test { color: black; } 2.1.3 ID选择器 测试 #test { color: black; } ID唯一确定,不可以共享; 最为最精准的对位方式 ","date":"2021-10-07","objectID":"/css3/:2:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#id选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 \u003cp class=\"active\"\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp id=\"test\"\u003ep3\u003c/p\u003e \u003cp\u003ep4\u003c/p\u003e \u003cstyle\u003e .active+p { color: red; } #test+p { color: blue; } \u003c/style\u003e 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 \u003cp\u003ep1\u003c/p\u003e \u003cp class=\"hello\"\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cstyle\u003e .hello~{ color: red; } \u003c/style\u003e p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; \u003cbody\u003e \u003cp\u003ep1\u003c/p\u003e \u003cp\u003ep2\u003c/p\u003e \u003cp\u003ep3\u003c/p\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ep4\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep5\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ep6\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp id=\"test\"\u003ep7\u003c/p\u003e \u003cp\u003ep8\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#高级选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#层次选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#后代选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#子选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#相邻兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#通用兄弟选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#结构伪类选择器"},{"categories":["前端知识"],"content":" 2.2 高级选择器 层次选择器 结构伪类选择器 属性选择器 2.2.1 层次选择器 后代选择器 子选择器 相邻兄弟选择器 通用选择器 那么我们设想出一种结构,为其编写CSS 根据此图写出html p1 p2 p3 p4 p5 p6 2.2.1.1 后代选择器下面的代码可以使得body标签中的所有p标签为红色(没有实现,因为造成网页的颜色太恶心了) body p { color: red; } 2.2.1.2 子选择器下面的代码可以使得body标签中的第一级别p标签为红色(没有实现,因为造成网页的颜色太恶心了) body\u003ep { color: green; } 2.2.1.3 相邻兄弟选择器 后面的兄弟 只有一个 p1 p2 p3 p4 可以得知选中了p2,p4,二者变色 p1 p2 p3 p4 2.2.1.4 通用兄弟选择器 选中所有下的 相同标签 p1 p2 p3 p1 p2 p3 p4 p5 p6 2.2.2 结构伪类选择器 结构可以根据元素在文档中所处的位置,来动态选择元素,从而减少HTML文档对ID或类的依赖,有助于保持代码干净整洁; p1 p2 p3 p4 p5 p6 p7 p8 选中ul标签下面的li的第一个子成员 ul li:first-child { color: red; } 选中ul标签下面的li的最后一个子成员 ul li:last-child { color: red; } 选中父节点的第n个元素,并且是P标签 p:nth-child(1) { background: green; } 2.2.3 属性选择器 选择携带某个属性的元素 /* 选中所有带有id属性的元素 */ p[id] { color: pink; } /* 选中id为test的元素 */ p[id=\"test\"] { color: pink; } /* 选中id开头为test的元素 */ p[id^=\"test\"] { color: pink; } ","date":"2021-10-07","objectID":"/css3/:2:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性选择器"},{"categories":["前端知识"],"content":" 3 CSS属性 选中元素开始设置属性 ","date":"2021-10-07","objectID":"/css3/:3:0","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#css属性"},{"categories":["前端知识"],"content":" 3.1 属性基础 字体样式 文本样式 文本阴影 超链接 列表样式 背景 span标签强调,这是一个标签, div标签,分块 \u003c!-- 字体样式 --\u003e \u003cstyle\u003e body { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-style: oblique; } \u003c/style\u003e font-family; 字体设置 font-size 字体大小 font-style 字体风格 ","date":"2021-10-07","objectID":"/css3/:3:1","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性基础"},{"categories":["前端知识"],"content":" 3.2 属性提高 盒子模型与边框 ","date":"2021-10-07","objectID":"/css3/:3:2","series":null,"tags":["前端知识"],"title":"CSS3基础教程","uri":"/css3/#属性提高"},{"categories":["前端知识"],"content":"html5基础教程","date":"2021-10-07","objectID":"/html5/","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/"},{"categories":["前端知识"],"content":" hugo中markdown可以直接渲染html,可以直接得到效果 但是网页基础结构却不可以编写,这样会破坏渲染过程 因此点击例子,同时点击F12,确定效果. 页面显示空白 但是我们可以在源代码中看到 \u003c!-- 告诉浏览器,需要使用的规范 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 网页标题 --\u003e \u003chead\u003e \u003c!-- 描述标签 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页标题 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 网页主体 --\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 因此后面我们就使用独立的html文件进行学习 ","date":"2021-10-07","objectID":"/html5/:0:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#"},{"categories":["前端知识"],"content":" 1 网页结构 \u003c!DOCTYPE html\u003e www规范\r注释的写法 \u003c!-- 注释 --\u003e html: 网页 head: 标题标签 meta: 网站信息 body: 网页主题 meta标签处于head区,对用户不可见,用于对网页进行描述,一般SEO优化 \u003chead\u003e \u003cmeta name=\"description\" content=\"前端基础\"\u003e \u003cmeta name=\"keywords\" content=\"HTML,CSS,JavaScript\"\u003e \u003cmeta name=\"author\" content=\"孟德茂\"\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c/head\u003e 实现自动跳转 因此点击例子,网页显示空白,等待3S,网页自动回到本页面 实现原理 \u003cmeta http-equiv=\"refresh\" content=\"3; https://mengdemao.github.io/html5\"/\u003e 头文件区添加,可以看到虽然meta没有显示,但还是存在较大用处 ","date":"2021-10-07","objectID":"/html5/:1:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#网页结构"},{"categories":["前端知识"],"content":" 2 基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号标签 ","date":"2021-10-07","objectID":"/html5/:2:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#基本标签"},{"categories":["前端知识"],"content":" 2.1 标题标签 \u003ch1\u003e一级标签\u003c/h1\u003e \u003ch2\u003e二级标签\u003c/h2\u003e \u003ch3\u003e三级标签\u003c/h3\u003e \u003ch4\u003e四级标签\u003c/h4\u003e \u003ch5\u003e五级标签\u003c/h5\u003e \u003ch6\u003e六级标签\u003c/h6\u003e 在HUGO中实现,但是效果会显示的很诡异,因此独立文件实现; 点击例子,可以看到效果;同时F12，检查元素实现 ","date":"2021-10-07","objectID":"/html5/:2:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#标题标签"},{"categories":["前端知识"],"content":" 2.2 段落标签 \u003cp\u003e段落标签\u003c/p\u003e 显示如下: 我是一个段落 我又是一个段落 ","date":"2021-10-07","objectID":"/html5/:2:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#段落标签"},{"categories":["前端知识"],"content":" 2.3 换行标签 \u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:2:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#换行标签"},{"categories":["前端知识"],"content":" 2.4 抄录环境 pre code pre显示的是原始的结构文本,程序不修改其中的tab,回车空格等;pre演示 code标签显示的语义化文本,显示等宽字体,但是格式被打乱code演示 语义化演示 var 定义程序变量 kbd 定义用户输入 samp 定义程序输出 \u003cp\u003e定义变量\u003cvar\u003euser_input\u003c/var\u003e,用作用户的输入\u003c/p\u003e \u003cp\u003e接收用户的输入\u003ckbd\u003e用户输入\u003c/kbd\u003e\u003c/p\u003e \u003cp\u003e执行程序的输出\u003csamp\u003e程序输出\u003c/samp\u003e\u003c/p\u003e 但是程序好像并没有产生什么效果 演示 ","date":"2021-10-07","objectID":"/html5/:2:4","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#抄录环境"},{"categories":["前端知识"],"content":" 2.5 引用标签","date":"2021-10-07","objectID":"/html5/:2:5","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#引用标签"},{"categories":["前端知识"],"content":" 2.6 强调标签","date":"2021-10-07","objectID":"/html5/:2:6","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#强调标签"},{"categories":["前端知识"],"content":" 2.7 水平线标签 \u003chr/\u003e 我在水平线标签上方 我在水平线标签下方 ","date":"2021-10-07","objectID":"/html5/:2:7","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#水平线标签"},{"categories":["前端知识"],"content":" 2.8 字体样式标签 \u003c!-- 字体样式标签 --\u003e 普通文本\u003cspan\u003e无效果\u003c/span\u003e\u003c/br\u003e 普通文本\u003cb\u003e加粗\u003c/b\u003e\u003c/br\u003e 普通文本\u003cstrong\u003e粗体\u003c/strong\u003e\u003c/br\u003e 普通文本\u003ci\u003e斜体\u003c/i\u003e\u003c/br\u003e 普通文本\u003cem\u003e斜体\u003c/em\u003e\u003c/br\u003e 普通文本\u003cu\u003e下划线\u003c/u\u003e\u003c/br\u003e 普通文本\u003cins\u003e下划线\u003c/ins\u003e\u003c/br\u003e 普通文本\u003cs\u003e删除线\u003c/s\u003e\u003c/br\u003e 普通文本\u003cdel\u003e删除线\u003c/del\u003e\u003c/br\u003e 普通文本\u003csub\u003e下标文本\u003c/sub\u003e\u003c/br\u003e 普通文本\u003csup\u003e上标文本\u003c/sup\u003e\u003c/br\u003e 普通文本无效果 普通文本加粗 普通文本粗体 普通文本斜体 普通文本斜体 普通文本下划线 普通文本下划线 普通文本删除线 普通文本删除线 普通文本下标文本 普通文本上标文本 ","date":"2021-10-07","objectID":"/html5/:2:8","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#字体样式标签"},{"categories":["前端知识"],"content":" 3 图片标签 \u003cimg src=\"测试.png\" alt=\"测试\" title=\"测试\"/\u003e ","date":"2021-10-07","objectID":"/html5/:3:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#图片标签"},{"categories":["前端知识"],"content":" 4 链接 \u003c!-- 当前页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_self\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e \u003c!-- 新建页打开 --\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度一下\u003c/a\u003e\u003cbr/\u003e ","date":"2021-10-07","objectID":"/html5/:4:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#链接"},{"categories":["前端知识"],"content":" 5 列表标签","date":"2021-10-07","objectID":"/html5/:5:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#列表标签"},{"categories":["前端知识"],"content":" 5.1 有序列表 \u003col\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ol\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:1","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#有序列表"},{"categories":["前端知识"],"content":" 5.2 无序列表 \u003cul\u003e \u003cli\u003eHTML\u003c/li\u003e \u003cli\u003eCSS\u003c/li\u003e \u003cli\u003eJavaScript\u003c/li\u003e \u003c/ul\u003e HTML\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:2","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#无序列表"},{"categories":["前端知识"],"content":" 5.3 定义列表 \u003cdl\u003e \u003cdt\u003e前端\u003c/dt\u003e \u003cdd\u003ehtml\u003c/dd\u003e \u003cdd\u003eCSS\u003c/dd\u003e \u003cdd\u003eJavaScript\u003c/dd\u003e \u003c/dl\u003e 前端\rhtml\rCSS\rJavaScript\r","date":"2021-10-07","objectID":"/html5/:5:3","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#定义列表"},{"categories":["前端知识"],"content":" 6 表格 \u003ctable border=\"1px\"\u003e \u003ctr\u003e \u003ctd\u003e1-1\u003c/td\u003e \u003ctd\u003e1-2\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e2-1\u003c/td\u003e \u003ctd\u003e2-2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 1-1\r1-2\r2-1\r2-2\r","date":"2021-10-07","objectID":"/html5/:6:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表格"},{"categories":["前端知识"],"content":" 7 页面结构分析 元素名 描述 header 标题头部区域 footer 标记尾部内容 section web页面中一块独立的区域 article 独立文章内容 aside 相关页面或者内容 nav 导航类辅助内容 ","date":"2021-10-07","objectID":"/html5/:7:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#页面结构分析"},{"categories":["前端知识"],"content":" 8 iframe内联框架 \u003ciframe src=\"path\" name=\"mainFrame\"\u003e\u003c/frame\u003e bilibili的例子 \u003ciframe src=\"//player.bilibili.com/player.html?aid=55631961\u0026bvid=BV1x4411V75C\u0026cid=97257967\u0026page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"\u003e \u003c/iframe\u003e ","date":"2021-10-07","objectID":"/html5/:8:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#iframe内联框架"},{"categories":["前端知识"],"content":" 9 表单 \u003cform action=\"submit.html\" method=\"GET/POST\"\u003e \u003cp\u003e名字: \u003cinput type=\"text\" name=\"name\"\u003e\u003c/p\u003e \u003cp\u003e密码: \u003cinput type=\"password\" name=\"password\"\u003e\u003c/p\u003e \u003cp\u003e \u003cinput type=\"submit\"\u003e \u003cinput type=\"reset\"\u003e \u003c/p\u003e \u003c/form\u003e 出入账户和密码,点击按钮会触发相应的 动作http://url/html5/submit.html?name=mengdemao\u0026password=1234, 但是此时会显示失败,因为没有处理函数. 名字: 密码: ","date":"2021-10-07","objectID":"/html5/:9:0","series":null,"tags":["前端知识"],"title":"HTML5基础教程","uri":"/html5/#表单"},{"categories":["开源软件"],"content":"sds","date":"2021-10-06","objectID":"/sds/","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/"},{"categories":["开源软件"],"content":" A C dynamic strings library C语言版本动态字符串库 ","date":"2021-10-06","objectID":"/sds/:0:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#"},{"categories":["开源软件"],"content":" 1 SDSSDS的类型就是 typedef char *sds; 可以明显的看到,sds就是普通的char类型 ","date":"2021-10-06","objectID":"/sds/:1:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#sds"},{"categories":["开源软件"],"content":" 1.1 下面是sds的数据类型 +--------+-------------------------------+-----------+ | Header | Binary safe C alike string... | Null term | +--------+-------------------------------+-----------+ | -\u003e Pointer returned to the user. #define SDS_HDR_VAR(T,s) \\ struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); #define SDS_HDR(T,s) \\ ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) #define SDS_TYPE_5_LEN(f) ((f)\u003e\u003eSDS_TYPE_BITS) ","date":"2021-10-06","objectID":"/sds/:1:1","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#下面是sds的数据类型"},{"categories":["开源软件"],"content":" 1.2 SDS 头根据不同的标志计算不同的头部数据 宏定义 标志 SDS_TYPE_5 sdshdr5 SDS_TYPE_8 sdshdr8 SDS_TYPE_16 sdshdr16 SDS_TYPE_32 sdshdr32 SDS_TYPE_64 sdshdr64 flag标志: unsigned char flags = s[-1]; /* 最后一个头部数据 */ #define SDS_TYPE_5 0 #define SDS_TYPE_8 1 #define SDS_TYPE_16 2 #define SDS_TYPE_32 3 #define SDS_TYPE_64 4 /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; #define SDS_TYPE_MASK 7 #define SDS_TYPE_BITS 3 ","date":"2021-10-06","objectID":"/sds/:1:2","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#sds-头"},{"categories":["开源软件"],"content":" 2 创建SDS函数原型 sds sdsnewlen(const void *init, size_t initlen); ","date":"2021-10-06","objectID":"/sds/:2:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#创建sds"},{"categories":["开源软件"],"content":" 3 扩张字符串缓存区 sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh; void *newsh; size_t avail = sdsavail(s); /* 计算剩余的可以使用的大小 */ size_t len; size_t newlen; char type, oldtype = s[-1] \u0026 SDS_TYPE_MASK; int hdrlen; if (avail \u003e= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ return s; } len = sdslen(s); /* 计算字符串大小 */ sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ /* 计算得到新的长度 */ newlen = (len+addlen); if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; /* 重新生成类型 */ type = sdsReqType(newlen); /* Don't use type 5: the user is appending to the string and type 5 is * not able to remember empty space, so sdsMakeRoomFor() must be called * at every appending operation. */ if (type == SDS_TYPE_5) { type = SDS_TYPE_8; } /* 计算头部大小 */ hdrlen = sdsHdrSize(type); if (oldtype == type) { newsh = s_realloc(sh, hdrlen + newlen + 1); if (newsh == NULL) { return NULL; } s = (char*)newsh + hdrlen; } else { /* Since the header size changes, need to move the string forward, * and can't use realloc */ newsh = s_malloc(hdrlen+newlen+1); if (newsh == NULL) { return NULL; } memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh + hdrlen; s[-1] = type; sdssetlen(s, len); } sdssetalloc(s, newlen); return s; } ","date":"2021-10-06","objectID":"/sds/:3:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#扩张字符串缓存区"},{"categories":["开源软件"],"content":" 4 追加字符串 sds sdscatlen(sds s, const void *t, size_t len) { size_t curlen = sdslen(s); /* 计算字符串的长度 */ s = sdsMakeRoomFor(s,len); /* 扩展字符串缓冲区长度 */ if (s == NULL) { return NULL; } memcpy(s+curlen, t, len); /* 添加字符串 */ sdssetlen(s, curlen+len); /* 设置长度标志 */ s[curlen+len] = '\\0'; /* 补全结束符 */ return s; } ","date":"2021-10-06","objectID":"/sds/:4:0","series":null,"tags":["开源软件"],"title":"Sds","uri":"/sds/#追加字符串"},{"categories":["操作系统"],"content":"进程创建","date":"2021-10-04","objectID":"/fork/","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/"},{"categories":["操作系统"],"content":" fork linux创建线程的函数 fork –\u003e do_fork do_fork的执行线路 do_fork函数原型 long _do_fork(unsigned long clone_flags, unsigned long stack_start, unsigned long stack_size, int __user *parent_tidptr, int __user *child_tidptr, unsigned long tls); clone_flags stack_start stack_size parent_tidptr child_tidptr tls ","date":"2021-10-04","objectID":"/fork/:0:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#fork"},{"categories":["操作系统"],"content":" 1 copy_process","date":"2021-10-04","objectID":"/fork/:1:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#copy_process"},{"categories":["操作系统"],"content":" 2 get_task_pid","date":"2021-10-04","objectID":"/fork/:2:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#get_task_pid"},{"categories":["操作系统"],"content":" 3 wake_up_new_task","date":"2021-10-04","objectID":"/fork/:3:0","series":null,"tags":["进程管理"],"title":"进程创建","uri":"/fork/#wake_up_new_task"},{"categories":["linux"],"content":"系统调度","date":"2021-10-04","objectID":"/scheduler/","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/"},{"categories":["linux"],"content":" 调度器分为主调度器和周期调度器 但是本节不考虑调度器的具体实现 只进行大方向接口的分析 系统调度器基础 完全公平调度器 ","date":"2021-10-04","objectID":"/scheduler/:0:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#"},{"categories":["linux"],"content":" 1 权重计算","date":"2021-10-04","objectID":"/scheduler/:1:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#权重计算"},{"categories":["linux"],"content":" 1.1 优先级计算优先级 // 1. 当前优先级normal_prio p-\u003eprio = current-\u003enormal_prio; // 2. 静态优先级 p-\u003estatic_prio = NICE_TO_PRIO(0) // 3. 继续计算优先级 p-\u003eprio = p-\u003enormal_prio = __normal_prio(p); // 4. 这在计算什么? #define NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO) #define PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO) static inline int __normal_prio(struct task_struct *p) { return p-\u003estatic_prio; } ","date":"2021-10-04","objectID":"/scheduler/:1:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#优先级计算"},{"categories":["linux"],"content":" 1.2 权重计算 struct load_weight { unsigned long weight; u32 inv_weight; }; static void set_load_weight(struct task_struct *p) { int prio = p-\u003estatic_prio - MAX_RT_PRIO; struct load_weight *load = \u0026p-\u003ese.load; /* * SCHED_IDLE tasks get minimal weight: */ if (p-\u003epolicy == SCHED_IDLE) { load-\u003eweight = scale_load(WEIGHT_IDLEPRIO); load-\u003einv_weight = WMULT_IDLEPRIO; return; } load-\u003eweight = scale_load(prio_to_weight[prio]); load-\u003einv_weight = prio_to_wmult[prio]; } static const int prio_to_weight[40] = { /* -20 */ 88761, 71755, 56483, 46273, 36291, /* -15 */ 29154, 23254, 18705, 14949, 11916, /* -10 */ 9548, 7620, 6100, 4904, 3906, /* -5 */ 3121, 2501, 1991, 1586, 1277, /* 0 */ 1024, 820, 655, 526, 423, /* 5 */ 335, 272, 215, 172, 137, /* 10 */ 110, 87, 70, 56, 45, /* 15 */ 36, 29, 23, 18, 15, }; static const u32 prio_to_wmult[40] = { /* -20 */ 48388, 59856, 76040, 92818, 118348, /* -15 */ 147320, 184698, 229616, 287308, 360437, /* -10 */ 449829, 563644, 704093, 875809, 1099582, /* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, /* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, /* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, /* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, /* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, }; 优先级与负载计算关系 $weight = \\frac{1024}{1.25^{nice}}$ ${inv_weight} = \\frac{2^{32}}{weight}$ ","date":"2021-10-04","objectID":"/scheduler/:1:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#权重计算-1"},{"categories":["linux"],"content":" 2 调度器类linux内核充分使用了面向对象的思想, 依靠sched_class将所有的调度器整合 linux上的调度器 调度器类 描述信息 用户接口调度策略 dl_sched_class deadline调度器 SCHED_DEADLINE rt_sched_class 实时调度器 SCHED_FIFO、``SCHED_RR` fair_sched_class 完全公平调度器 SCHED_NORMAL、``SCHED_BATCH` idle_sched_class idle task SCHED_IDLE ","date":"2021-10-04","objectID":"/scheduler/:2:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器类"},{"categories":["linux"],"content":" 2.1 调度器类结构体 struct sched_class { const struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); void (*yield_task) (struct rq *rq); bool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt); void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags); /* * It is the responsibility of the pick_next_task() method that will * return the next task to call put_prev_task() on the @prev task or * something equivalent. * * May return RETRY_TASK when it finds a higher prio class has runnable * tasks. */ struct task_struct * (*pick_next_task) (struct rq *rq, struct task_struct *prev); void (*put_prev_task) (struct rq *rq, struct task_struct *p); #ifdef CONFIG_SMP int (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); void (*migrate_task_rq)(struct task_struct *p, int next_cpu); void (*post_schedule) (struct rq *this_rq); void (*task_waking) (struct task_struct *task); void (*task_woken) (struct rq *this_rq, struct task_struct *task); void (*set_cpus_allowed)(struct task_struct *p, const struct cpumask *newmask); void (*rq_online)(struct rq *rq); void (*rq_offline)(struct rq *rq); #endif void (*set_curr_task) (struct rq *rq); void (*task_tick) (struct rq *rq, struct task_struct *p, int queued); void (*task_fork) (struct task_struct *p); void (*task_dead) (struct task_struct *p); /* * The switched_from() call is allowed to drop rq-\u003elock, therefore we * cannot assume the switched_from/switched_to pair is serliazed by * rq-\u003elock. They are however serialized by p-\u003epi_lock. */ void (*switched_from) (struct rq *this_rq, struct task_struct *task); void (*switched_to) (struct rq *this_rq, struct task_struct *task); void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio); unsigned int (*get_rr_interval) (struct rq *rq, struct task_struct *task); void (*update_curr) (struct rq *rq); #ifdef CONFIG_FAIR_GROUP_SCHED void (*task_move_group) (struct task_struct *p, int on_rq); #endif }; ","date":"2021-10-04","objectID":"/scheduler/:2:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器类结构体"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度器封装"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#入队出队"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#激活销毁"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#主动放弃"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#唤醒抢占任务"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#获取释放任务"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#任务切换"},{"categories":["linux"],"content":" 2.2 调度器封装对调度器进行多态实现; 2.2.1 入队/出队 enqueue_task dequeue_task static void enqueue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_queued(rq, p); p-\u003esched_class-\u003eenqueue_task(rq, p, flags); } static void dequeue_task(struct rq *rq, struct task_struct *p, int flags) { update_rq_clock(rq); sched_info_dequeued(rq, p); p-\u003esched_class-\u003edequeue_task(rq, p, flags); } 2.2.2 激活/销毁 activate_task deactivate_task void activate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible--; enqueue_task(rq, p, flags); } void deactivate_task(struct rq *rq, struct task_struct *p, int flags) { if (task_contributes_to_load(p)) rq-\u003enr_uninterruptible++; dequeue_task(rq, p, flags); } 2.2.3 主动放弃 sched_yield yield_to SYSCALL_DEFINE0(sched_yield) { struct rq *rq = this_rq_lock(); schedstat_inc(rq, yld_count); current-\u003esched_class-\u003eyield_task(rq); /* * Since we are going to call schedule() anyway, there's * no need to preempt or enable interrupts: */ __release(rq-\u003elock); spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); do_raw_spin_unlock(\u0026rq-\u003elock); sched_preempt_enable_no_resched(); schedule(); return 0; } int __sched yield_to(struct task_struct *p, bool preempt) { struct task_struct *curr = current; struct rq *rq, *p_rq; unsigned long flags; int yielded = 0; local_irq_save(flags); rq = this_rq(); again: p_rq = task_rq(p); /* * If we're the only runnable task on the rq and target rq also * has only one task, there's absolutely no point in yielding. */ if (rq-\u003enr_running == 1 \u0026\u0026 p_rq-\u003enr_running == 1) { yielded = -ESRCH; goto out_irq; } double_rq_lock(rq, p_rq); if (task_rq(p) != p_rq) { double_rq_unlock(rq, p_rq); goto again; } if (!curr-\u003esched_class-\u003eyield_to_task) goto out_unlock; if (curr-\u003esched_class != p-\u003esched_class) goto out_unlock; if (task_running(p_rq, p) || p-\u003estate) goto out_unlock; yielded = curr-\u003esched_class-\u003eyield_to_task(rq, p, preempt); if (yielded) { schedstat_inc(rq, yld_count); /* * Make p's CPU reschedule; pick_next_entity takes care of * fairness. */ if (preempt \u0026\u0026 rq != p_rq) resched_curr(p_rq); } out_unlock: double_rq_unlock(rq, p_rq); out_irq: local_irq_restore(flags); if (yielded \u003e 0) schedule(); return yielded; } EXPORT_SYMBOL_GPL(yield_to); 2.2.4 唤醒抢占任务 void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags) { const struct sched_class *class; if (p-\u003esched_class == rq-\u003ecurr-\u003esched_class) { rq-\u003ecurr-\u003esched_class-\u003echeck_preempt_curr(rq, p, flags); } else { for_each_class(class) { if (class == rq-\u003ecurr-\u003esched_class) break; if (class == p-\u003esched_class) { resched_curr(rq); break; } } } /* * A queue event has occurred, and we're going to schedule. In * this case, we can save a useless back to back clock update. */ if (task_on_rq_queued(rq-\u003ecurr) \u0026\u0026 test_tsk_need_resched(rq-\u003ecurr)) rq_clock_skip_update(rq, true); } 2.2.5 获取/释放任务 static inline struct task_struct * pick_next_task(struct rq *rq, struct task_struct *prev) { const struct sched_class *class = \u0026fair_sched_class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(prev-\u003esched_class == class \u0026\u0026 rq-\u003enr_running == rq-\u003ecfs.h_nr_running)) { p = fair_sched_class.pick_next_task(rq, prev); if (unlikely(p == RETRY_TASK)) goto again; /* assumes fair_sched_class-\u003enext == idle_sched_class */ if (unlikely(!p)) p = idle_sched_class.pick_next_task(rq, prev); return p; } again: for_each_class(class) { p = class-\u003epick_next_task(rq, prev); if (p) { if (unlikely(p == RETRY_TASK)) goto again; return p; } } BUG(); /* the idle class will always have a runnable task */ } static inline void put_prev_task(struct rq *rq, struct task_struct *prev) { prev-\u003esched_class-\u003eput_prev_task(rq, prev); } 2.2.6 任务切换 static inline void check_class_changed(struct rq *rq, struct task_struct *p, const struct sched_class *prev_class, int oldprio) { if (prev_class != p-\u003esched_class) { if (prev_class-\u003eswitched_from) prev_cla","date":"2021-10-04","objectID":"/scheduler/:2:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#更新当前任务"},{"categories":["linux"],"content":" 3 任务创建任务创建是由do_fork进行,与调度器进行沟通的函数是sched_fork,沟通的数据结构是 int sched_fork(unsigned long clone_flags, struct task_struct *p) { unsigned long flags; // #define get_cpu() ({ preempt_disable(); smp_processor_id(); }) // #define put_cpu() preempt_enable() int cpu = get_cpu(); // 获取CPUID // 进入内部实现 __sched_fork(clone_flags, p); /* * We mark the process as running here. This guarantees that * nobody will actually run it, and a signal or other external * event cannot wake it up and insert it on the runqueue either. */ p-\u003estate = TASK_RUNNING; // 设置运行状态 /* * Make sure we do not leak PI boosting priority to the child. */ p-\u003eprio = current-\u003enormal_prio; // 复制父优先级到当前 /* * Revert to default priority/policy on fork if requested. */ if (unlikely(p-\u003esched_reset_on_fork)) { if (task_has_dl_policy(p) || task_has_rt_policy(p)) { p-\u003epolicy = SCHED_NORMAL; p-\u003estatic_prio = NICE_TO_PRIO(0); p-\u003ert_priority = 0; } else if (PRIO_TO_NICE(p-\u003estatic_prio) \u003c 0) p-\u003estatic_prio = NICE_TO_PRIO(0); p-\u003eprio = p-\u003enormal_prio = __normal_prio(p); set_load_weight(p); /* * We don't need the reset flag anymore after the fork. It has * fulfilled its duty: */ p-\u003esched_reset_on_fork = 0; } if (dl_prio(p-\u003eprio)) { put_cpu(); return -EAGAIN; } else if (rt_prio(p-\u003eprio)) { p-\u003esched_class = \u0026rt_sched_class; } else { p-\u003esched_class = \u0026fair_sched_class; } if (p-\u003esched_class-\u003etask_fork) p-\u003esched_class-\u003etask_fork(p); /* * The child is not yet in the pid-hash so no cgroup attach races, * and the cgroup is pinned to this child due to cgroup_fork() * is ran before sched_fork(). * * Silence PROVE_RCU. */ raw_spin_lock_irqsave(\u0026p-\u003epi_lock, flags); set_task_cpu(p, cpu); raw_spin_unlock_irqrestore(\u0026p-\u003epi_lock, flags); #if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT) if (likely(sched_info_on())) memset(\u0026p-\u003esched_info, 0, sizeof(p-\u003esched_info)); #endif #if defined(CONFIG_SMP) p-\u003eon_cpu = 0; #endif init_task_preempt_count(p); #ifdef CONFIG_SMP plist_node_init(\u0026p-\u003epushable_tasks, MAX_PRIO); RB_CLEAR_NODE(\u0026p-\u003epushable_dl_tasks); #endif put_cpu(); return 0; } static void __sched_fork(unsigned long clone_flags, struct task_struct *p) { p-\u003eon_rq = 0; // 当前不在队列中 // 设置sched_entity p-\u003ese.on_rq = 0; // 当前不在队列中 p-\u003ese.exec_start = 0; p-\u003ese.sum_exec_runtime = 0; p-\u003ese.prev_sum_exec_runtime = 0; p-\u003ese.nr_migrations = 0; p-\u003ese.vruntime = 0; #ifdef CONFIG_SMP p-\u003ese.avg.decay_count = 0; #endif INIT_LIST_HEAD(\u0026p-\u003ese.group_node); #ifdef CONFIG_SCHEDSTATS memset(\u0026p-\u003ese.statistics, 0, sizeof(p-\u003ese.statistics)); #endif RB_CLEAR_NODE(\u0026p-\u003edl.rb_node); init_dl_task_timer(\u0026p-\u003edl); __dl_clear_params(p); INIT_LIST_HEAD(\u0026p-\u003ert.run_list); #ifdef CONFIG_PREEMPT_NOTIFIERS INIT_HLIST_HEAD(\u0026p-\u003epreempt_notifiers); #endif #ifdef CONFIG_NUMA_BALANCING if (p-\u003emm \u0026\u0026 atomic_read(\u0026p-\u003emm-\u003emm_users) == 1) { p-\u003emm-\u003enuma_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay); p-\u003emm-\u003enuma_scan_seq = 0; } if (clone_flags \u0026 CLONE_VM) p-\u003enuma_preferred_nid = current-\u003enuma_preferred_nid; else p-\u003enuma_preferred_nid = -1; p-\u003enode_stamp = 0ULL; p-\u003enuma_scan_seq = p-\u003emm ? p-\u003emm-\u003enuma_scan_seq : 0; p-\u003enuma_scan_period = sysctl_numa_balancing_scan_delay; p-\u003enuma_work.next = \u0026p-\u003enuma_work; p-\u003enuma_faults = NULL; p-\u003elast_task_numa_placement = 0; p-\u003elast_sum_exec_runtime = 0; p-\u003enuma_group = NULL; #endif /* CONFIG_NUMA_BALANCING */ } 分析函数执行 根据上图，我们可以得知创建的是一个线程函数,但是这个不是我们要分析的,我们要分析``sched_fork`函数实现; 设置sched_entity成员 设置优先级 调用调度器类中的task_fork函数 执行结束之后 // 将任务添加到调度器 void wake_up_new_task(struct task_struct *p) { unsigned long flags; struct rq *rq; raw_spin_lock_irqsave(\u0026p-\u003epi_lock, flags); #ifdef CONFIG_SMP /* * Fork balancing, do it here and not earlier because: * - cpus_allowed can change in the fork path * - any previously selected cpu might disappear through hotplug */ set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)); #endif /* Initialize new task's runnable average */ init_task_runnable_average(p); rq = __task_rq_lock(p); activate_task(rq, p, 0); // 激活任务 p-\u003eon_rq = TASK_ON_RQ_QUEUED; // 进入队列 trac","date":"2021-10-04","objectID":"/scheduler/:3:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#任务创建"},{"categories":["linux"],"content":" 4 调度基础 主调度器 滴答调度器 ","date":"2021-10-04","objectID":"/scheduler/:4:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度基础"},{"categories":["linux"],"content":" 4.1 主调度器 static void __sched __schedule(void) { struct task_struct *prev, *next; unsigned long *switch_count; struct rq *rq; int cpu; preempt_disable(); cpu = smp_processor_id(); rq = cpu_rq(cpu); rcu_note_context_switch(); prev = rq-\u003ecurr; schedule_debug(prev); if (sched_feat(HRTICK)) hrtick_clear(rq); /* * Make sure that signal_pending_state()-\u003esignal_pending() below * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE) * done by the caller to avoid the race with signal_wake_up(). */ smp_mb__before_spinlock(); raw_spin_lock_irq(\u0026rq-\u003elock); rq-\u003eclock_skip_update \u003c\u003c= 1; /* promote REQ to ACT */ switch_count = \u0026prev-\u003enivcsw; if (prev-\u003estate \u0026\u0026 !(preempt_count() \u0026 PREEMPT_ACTIVE)) { if (unlikely(signal_pending_state(prev-\u003estate, prev))) { prev-\u003estate = TASK_RUNNING; } else { deactivate_task(rq, prev, DEQUEUE_SLEEP); prev-\u003eon_rq = 0; /* * If a worker went to sleep, notify and ask workqueue * whether it wants to wake up a task to maintain * concurrency. */ if (prev-\u003eflags \u0026 PF_WQ_WORKER) { struct task_struct *to_wakeup; to_wakeup = wq_worker_sleeping(prev, cpu); if (to_wakeup) try_to_wake_up_local(to_wakeup); } } switch_count = \u0026prev-\u003envcsw; } if (task_on_rq_queued(prev)) update_rq_clock(rq); next = pick_next_task(rq, prev); clear_tsk_need_resched(prev); clear_preempt_need_resched(); rq-\u003eclock_skip_update = 0; if (likely(prev != next)) { rq-\u003enr_switches++; rq-\u003ecurr = next; ++*switch_count; rq = context_switch(rq, prev, next); /* unlocks the rq */ cpu = cpu_of(rq); } else raw_spin_unlock_irq(\u0026rq-\u003elock); post_schedule(rq); sched_preempt_enable_no_resched(); } 进入任务切换的核心函数context_switch,这个函数真够复杂的; static inline struct rq *context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next) { struct mm_struct *mm, *oldmm; // 执行切换前准备 prepare_task_switch(rq, prev, next); // 普通进程mm和active_mm相等 // 但是内核线程没有mm,只有active_mm mm = next-\u003emm; oldmm = prev-\u003eactive_mm; arch_start_context_switch(prev); if (!mm) { // 这个是内核线程 next-\u003eactive_mm = oldmm; // next线程借用oldmem，什么原因 atomic_inc(\u0026oldmm-\u003emm_count); // 减少计数 enter_lazy_tlb(oldmm, next); // 进入lazytlb，arm上为空 } else // 这个是用户线程 switch_mm(oldmm, mm, next); if (!prev-\u003emm) { // 代表prev是一个内核线程 prev-\u003eactive_mm = NULL; rq-\u003eprev_mm = oldmm; // 内核线程共享内存 } /* * Since the runqueue lock will be released by the next * task (which is an invalid locking op but in the case * of the scheduler it's an obvious special-case), so we * do an early lockdep release here: */ spin_release(\u0026rq-\u003elock.dep_map, 1, _THIS_IP_); context_tracking_task_switch(prev, next); // 调试使用 /* Here we just switch the register state and the stack. */ switch_to(prev, next, prev); // 这个函数和体系相关 barrier(); return finish_task_switch(prev); } extern struct task_struct *__switch_to(struct task_struct *, struct thread_info *, struct thread_info *); #define switch_to(prev,next,last) \\ do { \\ last = __switch_to(prev,task_thread_info(prev), task_thread_info(next)); \\ } while (0) 在arm32的实现中,这个是汇编编写的；我并没有看明白 这个地方和硬件进行强相关； 最终需要考虑的是进程在队列中的实现; ","date":"2021-10-04","objectID":"/scheduler/:4:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#主调度器"},{"categories":["linux"],"content":" 4.2 内存空间切换switch_mm当然也是和硬件体系强相关 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { #ifdef CONFIG_MMU unsigned int cpu = smp_processor_id(); /* * __sync_icache_dcache doesn't broadcast the I-cache invalidation, * so check for possible thread migration and invalidate the I-cache * if we're new to this CPU. */ if (cache_ops_need_broadcast() \u0026\u0026 !cpumask_empty(mm_cpumask(next)) \u0026\u0026 !cpumask_test_cpu(cpu, mm_cpumask(next))) __flush_icache_all(); if (!cpumask_test_and_set_cpu(cpu, mm_cpumask(next)) || prev != next) { check_and_switch_context(next, tsk); if (cache_is_vivt()) cpumask_clear_cpu(cpu, mm_cpumask(prev)); } #endif } ","date":"2021-10-04","objectID":"/scheduler/:4:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#内存空间切换switch_mm"},{"categories":["linux"],"content":" 4.3 滴答调度器 void scheduler_tick(void) { int cpu = smp_processor_id(); struct rq *rq = cpu_rq(cpu); struct task_struct *curr = rq-\u003ecurr; sched_clock_tick(); raw_spin_lock(\u0026rq-\u003elock); update_rq_clock(rq); curr-\u003esched_class-\u003etask_tick(rq, curr, 0); update_cpu_load_active(rq); raw_spin_unlock(\u0026rq-\u003elock); perf_event_task_tick(); #ifdef CONFIG_SMP rq-\u003eidle_balance = idle_cpu(cpu); trigger_load_balance(rq); #endif rq_last_tick_reset(rq); } ","date":"2021-10-04","objectID":"/scheduler/:4:3","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#滴答调度器"},{"categories":["linux"],"content":" 5 调度增强","date":"2021-10-04","objectID":"/scheduler/:5:0","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#调度增强"},{"categories":["linux"],"content":" 5.1 组调度组调度:多个用户登录时平均分配计算机时间; /* task group related information */ struct task_group { struct cgroup_subsys_state css; #ifdef CONFIG_FAIR_GROUP_SCHED /* schedulable entities of this group on each cpu */ struct sched_entity **se; /* runqueue \"owned\" by this group on each cpu */ struct cfs_rq **cfs_rq; unsigned long shares; #ifdef CONFIG_SMP atomic_long_t load_avg; atomic_t runnable_avg; #endif #endif #ifdef CONFIG_RT_GROUP_SCHED struct sched_rt_entity **rt_se; struct rt_rq **rt_rq; struct rt_bandwidth rt_bandwidth; #endif struct rcu_head rcu; struct list_head list; struct task_group *parent; struct list_head siblings; struct list_head children; #ifdef CONFIG_SCHED_AUTOGROUP struct autogroup *autogroup; #endif struct cfs_bandwidth cfs_bandwidth; }; ","date":"2021-10-04","objectID":"/scheduler/:5:1","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#组调度"},{"categories":["linux"],"content":" 5.2 负载均衡","date":"2021-10-04","objectID":"/scheduler/:5:2","series":null,"tags":["kernel"],"title":"调度器基础","uri":"/scheduler/#负载均衡"},{"categories":["前端知识"],"content":"WebAssembly","date":"2021-10-03","objectID":"/webassembly/","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/"},{"categories":["前端知识"],"content":" 1 前言","date":"2021-10-03","objectID":"/webassembly/:1:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#前言"},{"categories":["前端知识"],"content":" 2 安装工具链 $ git clone https://github.com/juj/emsdk.git $ cd emsdk $ ./emsdk install sdk-incoming-64bit binaryen-master-64bit $ ./emsdk activate sdk-incoming-64bit binaryen-master-64bit # 使用最新的代码 $ ./emsdk install latest $ ./emsdk activate latest 但是因为llvm需要连接github进行下载,常常会失败,因此需要使用mirror, 修改emsdk_manifest.json,找到https://github.com/llvm/llvm-project.git,修改为 https://mirrors.tuna.tsinghua.edu.cn/git/llvm-project.git,然后在执行下编译. 工具链编译结束,导入环境变量 source ./emsdk_env.sh ","date":"2021-10-03","objectID":"/webassembly/:2:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#安装工具链"},{"categories":["前端知识"],"content":" 3 入门 #include \u003cstdio.h\u003e int main(int argc, char *argv[]) { printf(\"Hello world\\r\\n\"); return 0; } #include \u003ciostream\u003e int main(int argc, char *argv[]) { std::cout \u003c\u003c \"Hello world\\r\\n\" \u003c\u003c std::endl; return 0; } 执行编译 emcc hello.c -s WASM=1 -o hello.html # 执行编译 emrun --no_browser --port 8080 . # 运行 ","date":"2021-10-03","objectID":"/webassembly/:3:0","series":null,"tags":["前端知识"],"title":"WebAssembly","uri":"/webassembly/#入门"},{"categories":[],"content":" 1 简述 驱动模型 顶级kobject 解释 block 块设备链接–\u003e/sys/deives相关文件 bus 存放各种总线文件 class 各种设备类 dev 存放(字符/块)设备主副设备号链接文件–\u003e/sys/deives devices 设备的具体存放文件 firmware 固件存放 fs 文件类型 kernel kernel子系统 module 模块信息 power 能源管理 ","date":"2021-10-01","objectID":"/drivermodel/:1:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#简述"},{"categories":[],"content":" 2 底层机制","date":"2021-10-01","objectID":"/drivermodel/:2:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#底层机制"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\u003cNULL\u003e\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\u003cNULL\u003e\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kobject"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#初始化"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#添加"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#sysfs文件夹生成"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#删除"},{"categories":[],"content":" 2.1 kobject 内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面 2.1.1 数据结构 struct kobject { const char *name; /* 名字 */ struct list_head entry; /* 链表:链接进入kset */ struct kobject *parent; /* 指向父对象,建立层次结构 */ struct kset *kset; /* 对象集合 */ struct kobj_type *ktype; /* 对象类型 */ struct kernfs_node *sd; /* sysfs directory entry */ struct kref kref; /* 引用计数 */ #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; /* 标志位:初始化 */ unsigned int state_in_sysfs:1; /* 标志位:在sysfs中 */ unsigned int state_add_uevent_sent:1; /* 标志位:发出KOBJ_ADD uevent */ unsigned int state_remove_uevent_sent:1; /* 标志位:发出KOBJ_REMOVE uevent */ unsigned int uevent_suppress:1; /* 标志位:禁止发出uevent */ }; 2.1.2 初始化 /** * kobject_init - initialize a kobject structure * @kobj: pointer to the kobject to initialize * @ktype: pointer to the ktype for this kobject. * * This function will properly initialize a kobject such that it can then * be passed to the kobject_add() call. * * After this function is called, the kobject MUST be cleaned up by a call * to kobject_put(), not by a call to kfree directly to ensure that all of * the memory is cleaned up properly. */ void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { char *err_str; /** 错误信息 */ /** 校验参数NULL */ if (!kobj) { err_str = \"invalid kobject pointer!\"; goto error; } if (!ktype) { err_str = \"must have a ktype to be initialized properly!\\n\"; goto error; } /** kobject是否已经初始化 */ if (kobj-\u003estate_initialized) { /* do not error out as sometimes we can recover */ pr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\", kobj); dump_stack(); /** 回溯堆栈 */ } /** 调用具体初始化函数 */ kobject_init_internal(kobj); /* 设置类型 */ kobj-\u003ektype = ktype; return; error: pr_err(\"kobject (%p): %s\\n\", kobj, err_str); dump_stack(); } EXPORT_SYMBOL(kobject_init); 2.1.3 添加 int kobject_add(struct kobject *kobj, /* 需要添加kobject */ struct kobject *parent, /* 父指针 */ const char *fmt, ...) /* 命名 */ { va_list args; int retval; /* 校验kobject */ if (!kobj) return -EINVAL; /* 是否已经初始化 */ if (!kobj-\u003estate_initialized) { pr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\", kobject_name(kobj), kobj); dump_stack(); return -EINVAL; } va_start(args, fmt); /* 设置名字并且将父指针添加到parent */ retval = kobject_add_varg(kobj, parent, fmt, args); va_end(args); return retval; } 最终调用添加函数 static int kobject_add_internal(struct kobject *kobj) { int error = 0; struct kobject *parent; /* 判断参数NULL */ if (!kobj) return -ENOENT; /* 判断名字是否有效 */ if (!kobj-\u003ename || !kobj-\u003ename[0]) { WARN(1, \"kobject: (%p): attempted to be registered with empty name!\\n\", kobj); return -EINVAL; } /** 获取父指针 */ parent = kobject_get(kobj-\u003eparent); /* join kset if set, use it as parent if we do not already have one */ if (kobj-\u003ekset) { /* kset已经设置 */ if (!parent) /* 不存在父指针 */ /* kset的kobject作为父指针 */ parent = kobject_get(\u0026kobj-\u003ekset-\u003ekobj); /* 将kobject加入kset */ kobj_kset_join(kobj); /* 保存父指针 */ kobj-\u003eparent = parent; } pr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\", kobject_name(kobj), kobj, __func__, parent ? kobject_name(parent) : \"\", kobj-\u003ekset ? kobject_name(\u0026kobj-\u003ekset-\u003ekobj) : \"\"); /* 创建dir */ error = create_dir(kobj); if (error) { /* 出错,清理 */ kobj_kset_leave(kobj); kobject_put(parent); kobj-\u003eparent = NULL; /* be noisy on error issues */ if (error == -EEXIST) pr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\", __func__, kobject_name(kobj)); else pr_err(\"%s failed for %s (error: %d parent: %s)\\n\", __func__, kobject_name(kobj), error, parent ? kobject_name(parent) : \"'none'\"); } else kobj-\u003estate_in_sysfs = 1; /* 添加到sysfs中 */ return error; } 2.1.3.1 sysfs文件夹生成 static int create_dir(struct kobject *kobj) { const struct kobj_ns_type_operations *ops; int error; error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); if (error) return error; error = populate_dir(kobj); if (error) { sysfs_remove_","date":"2021-10-01","objectID":"/drivermodel/:2:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#引用计数"},{"categories":[],"content":" 2.2 kset 2.2.1 数据结构 struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; } __randomize_layout; ","date":"2021-10-01","objectID":"/drivermodel/:2:2","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kset"},{"categories":[],"content":" 2.2 kset 2.2.1 数据结构 struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; } __randomize_layout; ","date":"2021-10-01","objectID":"/drivermodel/:2:2","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构-1"},{"categories":[],"content":" 2.3 ktype 2.3.1 数据结构 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ","date":"2021-10-01","objectID":"/drivermodel/:2:3","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#ktype"},{"categories":[],"content":" 2.3 ktype 2.3.1 数据结构 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ","date":"2021-10-01","objectID":"/drivermodel/:2:3","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#数据结构-2"},{"categories":[],"content":" 3 class 设备类描述 struct class { const char *name; struct module *owner; const struct attribute_group **class_groups; const struct attribute_group **dev_groups; struct kobject *dev_kobj; int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); char *(*devnode)(struct device *dev, umode_t *mode); void (*class_release)(struct class *class); void (*dev_release)(struct device *dev); int (*shutdown_pre)(struct device *dev); const struct kobj_ns_type_operations *ns_type; const void *(*namespace)(struct device *dev); void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid); const struct dev_pm_ops *pm; struct subsys_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:3:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#class"},{"categories":[],"content":" 4 bus 设备总线描述 ","date":"2021-10-01","objectID":"/drivermodel/:4:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#bus"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#总线类型"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#设备总线注册"},{"categories":[],"content":" 4.1 总线类型 # ls amba cpu nvmem platform virtio clockevents event_source pci scsi workqueue clocksource gpio pci_express serio container hid pcmcia spi 其中每一个总线具有如下信息 # ls devices drivers_autoprobe uevent drivers drivers_probe struct bus_type { const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); int (*num_vf)(struct device *dev); int (*dma_configure)(struct device *dev); const struct dev_pm_ops *pm; const struct iommu_ops *iommu_ops; struct subsys_private *p; struct lock_class_key lock_key; bool need_parent_lock; }; 4.1.1 设备总线注册 int bus_register(struct bus_type *bus) { int retval; struct subsys_private *priv; struct lock_class_key *key = \u0026bus-\u003elock_key; priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv-\u003ebus = bus; bus-\u003ep = priv; BLOCKING_INIT_NOTIFIER_HEAD(\u0026priv-\u003ebus_notifier); retval = kobject_set_name(\u0026priv-\u003esubsys.kobj, \"%s\", bus-\u003ename); if (retval) goto out; priv-\u003esubsys.kobj.kset = bus_kset; priv-\u003esubsys.kobj.ktype = \u0026bus_ktype; priv-\u003edrivers_autoprobe = 1; retval = kset_register(\u0026priv-\u003esubsys); if (retval) goto out; retval = bus_create_file(bus, \u0026bus_attr_uevent); if (retval) goto bus_uevent_fail; priv-\u003edevices_kset = kset_create_and_add(\"devices\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edevices_kset) { retval = -ENOMEM; goto bus_devices_fail; } priv-\u003edrivers_kset = kset_create_and_add(\"drivers\", NULL, \u0026priv-\u003esubsys.kobj); if (!priv-\u003edrivers_kset) { retval = -ENOMEM; goto bus_drivers_fail; } INIT_LIST_HEAD(\u0026priv-\u003einterfaces); __mutex_init(\u0026priv-\u003emutex, \"subsys mutex\", key); klist_init(\u0026priv-\u003eklist_devices, klist_devices_get, klist_devices_put); klist_init(\u0026priv-\u003eklist_drivers, NULL, NULL); retval = add_probe_files(bus); if (retval) goto bus_probe_files_fail; retval = bus_add_groups(bus, bus-\u003ebus_groups); if (retval) goto bus_groups_fail; pr_debug(\"bus: '%s': registered\\n\", bus-\u003ename); return 0; bus_groups_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-\u003ep-\u003edrivers_kset); bus_drivers_fail: kset_unregister(bus-\u003ep-\u003edevices_kset); bus_devices_fail: bus_remove_file(bus, \u0026bus_attr_uevent); bus_uevent_fail: kset_unregister(\u0026bus-\u003ep-\u003esubsys); out: kfree(bus-\u003ep); bus-\u003ep = NULL; return retval; } 4.1.2 设备总线卸载 void bus_unregister(struct bus_type *bus) { pr_debug(\"bus: '%s': unregistering\\n\", bus-\u003ename); if (bus-\u003edev_root) device_unregister(bus-\u003edev_root); bus_remove_groups(bus, bus-\u003ebus_groups); remove_probe_files(bus); kset_unregister(bus-\u003ep-\u003edrivers_kset); kset_unregister(bus-\u003ep-\u003edevices_kset); bus_remove_file(bus, \u0026bus_attr_uevent); kset_unregister(\u0026bus-\u003ep-\u003esubsys); } ","date":"2021-10-01","objectID":"/drivermodel/:4:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#设备总线卸载"},{"categories":[],"content":" 5 devices 设备文件具体描述: device(设备描述) device_driver(驱动描述) bus_type(总线信息) |-- breakpoint |-- kprobe |-- platform |-- software |-- system |-- tracepoint |-- uprobe `-- virtual ","date":"2021-10-01","objectID":"/drivermodel/:5:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#devices"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#heading"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#device"},{"categories":[],"content":" 5.1 5.1.1 device 描述设备 struct device { struct device *parent; struct device_private *p; struct kobject kobj; const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_links_info links; struct dev_pm_info power; struct dev_pm_domain *pm_domain; #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN struct irq_domain *msi_domain; #endif #ifdef CONFIG_PINCTRL struct dev_pin_info *pins; #endif #ifdef CONFIG_GENERIC_MSI_IRQ struct list_head msi_list; #endif #ifdef CONFIG_NUMA int numa_node; /* NUMA node this device is close to */ #endif const struct dma_map_ops *dma_ops; u64 *dma_mask; /* dma mask (if dma'able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ u64 bus_dma_mask; /* upstream dma_mask constraint */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma'ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ #ifdef CONFIG_DMA_CMA struct cma *cma_area; /* contiguous memory area for dma allocations */ #endif /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct fwnode_handle *fwnode; /* firmware device node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; struct iommu_fwspec *iommu_fwspec; bool offline_disabled:1; bool offline:1; bool of_node_reused:1; }; 5.1.2 driver 描述驱动 struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ enum probe_type probe_type; const struct of_device_id *of_match_table; const struct acpi_device_id *acpi_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; void (*coredump) (struct device *dev); struct driver_private *p; }; ","date":"2021-10-01","objectID":"/drivermodel/:5:1","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#driver"},{"categories":[],"content":" 6 kernel kernel子系统 ","date":"2021-10-01","objectID":"/drivermodel/:6:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#kernel"},{"categories":[],"content":" 7 module 模块信息 ","date":"2021-10-01","objectID":"/drivermodel/:7:0","series":null,"tags":["kernel"],"title":"驱动模型","uri":"/drivermodel/#module"},{"categories":null,"content":" 博客内容 大部分都没有完成 C C++ C++教程 C++模板 stl分析 汇编语言 kernel 系统调度 组调度 PLET 负载均衡 完全公平调度算法 实时系统 FreeRTOS RT-Thread 编译原理 cmake 编程语言 python rust go lua 前端 html5 css3 javascript typescript wasm ","date":"2021-09-25","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/#博客内容"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制 ","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#"},{"categories":null,"content":" 使用","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#使用"},{"categories":null,"content":" 1 等待队列头 struct __wait_queue_head { wq_lock_t lock; struct list_head task_list; }; typedef struct __wait_queue_head wait_queue_head_t; ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列头"},{"categories":null,"content":" 2 等待队列实体 struct __wait_queue { unsigned int flags; struct task_struct * task; struct list_head task_list; }; typedef struct __wait_queue wait_queue_t; ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列实体"},{"categories":null,"content":" 3 初始化等待队列头 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *); void init_waitqueue_head(struct wait_queue_head *wq_head); ","date":"2021-05-04","objectID":"/wait_queue/:3:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列头"},{"categories":null,"content":" 4 初始化等待队列 #define __WAITQUEUE_INITIALIZER(name, tsk) \\ { \\ .private = tsk, \\ .func = default_wake_function, \\ .entry = { NULL, NULL } \\ } #define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) // 但是，一般直接 DECLARE_WAITQUEUE(wait, current); 等待队列入口 等待的任务 ","date":"2021-05-04","objectID":"/wait_queue/:4:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#初始化等待队列"},{"categories":null,"content":" 5 等待队列操作 void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); 等待队列头 等待队列实体 ","date":"2021-05-04","objectID":"/wait_queue/:5:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待队列操作"},{"categories":null,"content":" 6 等待事件 void wait_event(wq, condition); void wait_event_interruptible(wq, condition); ","date":"2021-05-04","objectID":"/wait_queue/:6:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#等待事件"},{"categories":null,"content":" 7 唤醒队列 wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync ","date":"2021-05-04","objectID":"/wait_queue/:7:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#唤醒队列"},{"categories":null,"content":" 例子","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#例子"},{"categories":null,"content":" 1 写端 ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = -1; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_write; } add_wait_queue(\u0026wait_device.wait_w, \u0026wait); while (wait_device.wait_flag == true) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_w, \u0026wait); pure_write: wait_device.wait_flag = true; pr_err(\"Write Successful\"); wake_up_interruptible(\u0026wait_device.wait_r); pr_err(\"Wakeup Read\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return ret; } ","date":"2021-05-04","objectID":"/wait_queue/:1:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#写端"},{"categories":null,"content":" 2 读端 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) { DECLARE_WAITQUEUE(wait, current); /* 声明等待队列 */ int ret = 0; PTRACE; mutex_lock(\u0026wait_device.mutex); /* 非阻塞模式直接写入 */ if (file-\u003ef_flags \u0026 O_NONBLOCK) { pr_err(\"write in O_NONBLOCK Mode\"); goto pure_read; } add_wait_queue(\u0026wait_device.wait_r, \u0026wait); while (wait_device.wait_flag == false) { pr_err(\"Write INTERRUPTIBLE\"); __set_current_state(TASK_INTERRUPTIBLE); mutex_unlock(\u0026wait_device.mutex); schedule(); if (signal_pending(current)) { ret = -ERESTARTSYS; remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); __set_current_state(TASK_RUNNING); goto out; } } remove_wait_queue(\u0026wait_device.wait_r, \u0026wait); pure_read: wait_device.wait_flag = false; pr_err(\"Read Successful\"); wake_up_interruptible(\u0026wait_device.wait_w); pr_err(\"Wakeup Write\"); goto out; out: mutex_unlock(\u0026wait_device.mutex); return 0; } ","date":"2021-05-04","objectID":"/wait_queue/:2:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#读端"},{"categories":null,"content":" 原理","date":"2021-05-04","objectID":"/wait_queue/:0:0","series":null,"tags":null,"title":"Linux等待队列实现","uri":"/wait_queue/#原理"},{"categories":["编译原理"],"content":"编译原理","date":"2021-05-04","objectID":"/antlr/","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/"},{"categories":["编译原理"],"content":" 1 简介 ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件. 类似于flex/bison,根据描述文件,自动生成词法语法分析器; 解析规则文件,生成解析源文件,与SDK组合编译生成可执行文件; 生成器可以支持的语言,但是下面我只会其中的几个语言: 因此暂时只进行下面几种语言的开发,下面描述开发的情况和进度 Python3 JavaScript Go C++ ","date":"2021-05-04","objectID":"/antlr/:1:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#简介"},{"categories":["编译原理"],"content":" 2 安装说明 下载antlr 设置path和classpath 编写相关脚本 ","date":"2021-05-04","objectID":"/antlr/:2:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#安装说明"},{"categories":["编译原理"],"content":" 3 语法设计","date":"2021-05-04","objectID":"/antlr/:3:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#语法设计"},{"categories":["编译原理"],"content":" 4 错误处理","date":"2021-05-04","objectID":"/antlr/:4:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#错误处理"},{"categories":["编译原理"],"content":" 5 解析器","date":"2021-05-04","objectID":"/antlr/:5:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#解析器"},{"categories":["编译原理"],"content":" 6 测试程序","date":"2021-05-04","objectID":"/antlr/:6:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#测试程序"},{"categories":["编译原理"],"content":" 6.1 antlr4编译器 #!/bin/sh antlr4 Expr.g4 ","date":"2021-05-04","objectID":"/antlr/:6:1","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#antlr4编译器"},{"categories":["编译原理"],"content":" 6.2 编译生成的java文件 $ javac *.java ","date":"2021-05-04","objectID":"/antlr/:6:2","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#编译生成的java文件"},{"categories":["编译原理"],"content":" 6.3 运行编译的结果 $ grun Expr prog -tree (prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) grun Expr prog -gui grun Expr prog -tokens [@0,0:0='1',\u003cINT\u003e,1:0] [@1,1:1='+',\u003c'+'\u003e,1:1] [@2,2:2='2',\u003cINT\u003e,1:2] [@3,3:3='+',\u003c'+'\u003e,1:3] [@4,4:4='3',\u003cINT\u003e,1:4] [@5,5:6='\\r\\n',\u003cNEWLINE\u003e,1:5] [@6,7:6='\u003cEOF\u003e',\u003cEOF\u003e,2:0] ","date":"2021-05-04","objectID":"/antlr/:6:3","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#运行编译的结果"},{"categories":["编译原理"],"content":" 7 antlr语法详解","date":"2021-05-04","objectID":"/antlr/:7:0","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#antlr语法详解"},{"categories":["编译原理"],"content":" 7.1 Hello // antlr4 Hello.g4 // javac *.java // grun Hello r -gui grammar Hello; // 定义一个Hello的grammer r : 'hello' ID ; // 开头是hello后面接着一个ID ID : [a-z]+ ; // ID由小写字母组成 WS : [ \\t\\r\\n]+ -\u003e skip ; // 控制符清除 ","date":"2021-05-04","objectID":"/antlr/:7:1","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#hello"},{"categories":["编译原理"],"content":" 7.2 ArrayInit // antlr4 ArrayInit.g4 // javac *.java // grun ArrayInit init -gui grammar ArrayInit; // 定义一个ArrayInit的grammer init : '{' value (',' value)* '}' ; // value : init // 嵌套定义 | INT // 定义整数 ; INT : [0-9]+ ; WS : [ \\t\\r\\n]+ -\u003e skip ; ()* –\u003e 相当于扩展 ","date":"2021-05-04","objectID":"/antlr/:7:2","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#arrayinit"},{"categories":["编译原理"],"content":" 7.3 Expr // antlr4 Expr.g4 // javac *.java // grun Expr prog -gui grammar Expr; prog : stat+; stat: expr NEWLINE # printExpr | ID '=' expr NEWLINE # assign | NEWLINE # blank ; expr: expr op=('*'|'/') expr # MulDiv | expr op=('+'|'-') expr # AddSub | INT # int | ID # id | '('expr')' # parens ; MUL : '*' ; // assigns token name to '*' used above in grammar DIV : '/' ; ADD : '+' ; SUB : '-' ; ID : [a-zA-Z]+ ; INT : [0-9]+ ; NEWLINE :'\\r'? '\\n' ; WS : [ \\t]+ -\u003e skip; ","date":"2021-05-04","objectID":"/antlr/:7:3","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#expr"},{"categories":["编译原理"],"content":" 7.4 json 在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础 grammar JSON; // 声明一个grammar json : value // 一个value候选 ; obj // 对象类型 : '{' pair (',' pair)* '}' | '{' '}' ; pair : STRING ':' value ; arr : '[' value (',' value)* ']' | '[' ']' ; value : STRING | NUMBER | obj | arr | 'true' | 'false' | 'null' ; STRING : '\"' (ESC | SAFECODEPOINT)* '\"' ; fragment ESC : '\\\\' ([\"\\\\/bfnrt] | UNICODE) ; fragment UNICODE : 'u' HEX HEX HEX HEX ; fragment HEX : [0-9a-fA-F] ; fragment SAFECODEPOINT : ~ [\"\\\\\\u0000-\\u001F] ; NUMBER : '-'? INT ('.' [0-9] +)? EXP? ; fragment INT : '0' | [1-9] [0-9]* ; // no leading zeros fragment EXP : [Ee] [+\\-]? INT ; // \\- since - means \"range\" inside [...] WS : [ \\t\\n\\r] + -\u003e skip ; 测试例子 { \"glossary\": { \"title\": \"example glossary\", \"GlossDiv\": { \"title\": \"S\", \"GlossList\": { \"GlossEntry\": { \"ID\": \"SGML\", \"SortAs\": \"SGML\", \"GlossTerm\": \"Standard Generalized Markup Language\", \"Acronym\": \"SGML\", \"Abbrev\": \"ISO 8879:1986\", \"GlossDef\": { \"para\": \"A meta-markup language\", \"GlossSeeAlso\": [\"GML\", \"XML\"] }, \"GlossSee\": \"markup\" } } } } } 显示结果： ","date":"2021-05-04","objectID":"/antlr/:7:4","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#json"},{"categories":["编译原理"],"content":" 7.5 XML 孤岛语法: ","date":"2021-05-04","objectID":"/antlr/:7:5","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#xml"},{"categories":["编译原理"],"content":" 7.6 dot grammar DOT; graph : STRICT? ( GRAPH | DIGRAPH ) id_? '{' stmt_list '}' ; stmt_list : ( stmt ';'? )* ; stmt : node_stmt | edge_stmt | attr_stmt | id_ '=' id_ | subgraph ; attr_stmt : ( GRAPH | NODE | EDGE ) attr_list ; attr_list : ( '[' a_list? ']' )+ ; a_list : ( id_ ( '=' id_ )? ','? )+ ; edge_stmt : ( node_id | subgraph ) edgeRHS attr_list? ; edgeRHS : ( edgeop ( node_id | subgraph ) )+ ; edgeop : '-\u003e' | '--' ; node_stmt : node_id attr_list? ; node_id : id_ port? ; port : ':' id_ ( ':' id_ )? ; subgraph : ( SUBGRAPH id_? )? '{' stmt_list '}' ; id_ : ID | STRING | HTML_STRING | NUMBER ; // \"The keywords node, edge, graph, digraph, subgraph, and strict are // case-independent\" STRICT : [Ss] [Tt] [Rr] [Ii] [Cc] [Tt] ; GRAPH : [Gg] [Rr] [Aa] [Pp] [Hh] ; DIGRAPH : [Dd] [Ii] [Gg] [Rr] [Aa] [Pp] [Hh] ; NODE : [Nn] [Oo] [Dd] [Ee] ; EDGE : [Ee] [Dd] [Gg] [Ee] ; SUBGRAPH : [Ss] [Uu] [Bb] [Gg] [Rr] [Aa] [Pp] [Hh] ; /** \"a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\" */ NUMBER : '-'? ( '.' DIGIT+ | DIGIT+ ( '.' DIGIT* )? ) ; fragment DIGIT : [0-9] ; /** \"any double-quoted string (\"...\") possibly containing escaped quotes\" */ STRING : '\"' ( '\\\\\"' | . )*? '\"' ; /** \"Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores * ('_') or digits ([0-9]), not beginning with a digit\" */ ID : LETTER ( LETTER | DIGIT )* ; fragment LETTER : [a-zA-Z\\u0080-\\u00FF_] ; /** \"HTML strings, angle brackets must occur in matched pairs, and * unescaped newlines are allowed.\" */ HTML_STRING : '\u003c' ( TAG | ~ [\u003c\u003e] )* '\u003e' ; fragment TAG : '\u003c' .*? '\u003e' ; COMMENT : '/*' .*? '*/' -\u003e skip ; LINE_COMMENT : '//' .*? '\\r'? '\\n' -\u003e skip ; /** \"a '#' character is considered a line output from a C preprocessor (e.g., * # 34 to indicate line 34 ) and discarded\" */ PREPROC : '#' ~[\\r\\n]* -\u003e skip ; WS : [ \\t\\n\\r]+ -\u003e skip ; ","date":"2021-05-04","objectID":"/antlr/:7:6","series":null,"tags":["编译原理"],"title":"antlr笔记","uri":"/antlr/#dot"},{"categories":null,"content":" 1 基本操作","date":"2021-05-04","objectID":"/hugo/:1:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#基本操作"},{"categories":null,"content":" 1.1 安装hugo在linux/windows上只能通过直接release下载, ","date":"2021-05-04","objectID":"/hugo/:1:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#安装hugo"},{"categories":null,"content":" 1.2 创建网站 hugo new site 路径 ","date":"2021-05-04","objectID":"/hugo/:1:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建网站"},{"categories":null,"content":" 1.3 添加主题 将主题直接添加到theme文件下面 将主题作为一个submodule ","date":"2021-05-04","objectID":"/hugo/:1:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#添加主题"},{"categories":null,"content":" 1.4 创建文档 hugo new posts/hugo.md ","date":"2021-05-04","objectID":"/hugo/:1:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#创建文档"},{"categories":null,"content":" 1.5 设置预览 hugo server -D --disableFastRender ","date":"2021-05-04","objectID":"/hugo/:1:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#设置预览"},{"categories":null,"content":" 2 文件结构 . ├── archetypes ├── config ├── content ├── data ├── layouts ├── static ├── themes ├── static └── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。 ","date":"2021-05-04","objectID":"/hugo/:2:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#文件结构"},{"categories":null,"content":" 2.1 archetypeshugo模板,在创建文件时作为模板自动生成 ","date":"2021-05-04","objectID":"/hugo/:2:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#archetypes"},{"categories":null,"content":" 2.2 assets存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录 ","date":"2021-05-04","objectID":"/hugo/:2:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#assets"},{"categories":null,"content":" 2.3 configHugo配置目录 ","date":"2021-05-04","objectID":"/hugo/:2:3","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#config"},{"categories":null,"content":" 2.4 content此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分. ","date":"2021-05-04","objectID":"/hugo/:2:4","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#content"},{"categories":null,"content":" 2.5 data该目录用于存储 Hugo 在生成网站时可以使用的配置文件 ","date":"2021-05-04","objectID":"/hugo/:2:5","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#data"},{"categories":null,"content":" 2.6 layouts以 .html文件的形式存储模板. ","date":"2021-05-04","objectID":"/hugo/:2:6","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#layouts"},{"categories":null,"content":" 2.7 static存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制 ","date":"2021-05-04","objectID":"/hugo/:2:7","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#static"},{"categories":null,"content":" 3 编写工具","date":"2021-05-04","objectID":"/hugo/:3:0","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#编写工具"},{"categories":null,"content":" 3.1 typora使用typora作为markdown编写工具 ","date":"2021-05-04","objectID":"/hugo/:3:1","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#typora"},{"categories":null,"content":" 3.2 picgo ","date":"2021-05-04","objectID":"/hugo/:3:2","series":null,"tags":["技巧"],"title":"Hugo教程","uri":"/hugo/#picgo"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"离线","uri":"/offline/#"}]
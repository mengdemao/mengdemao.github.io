[{"categories":[],"content":"pthread源码分析  基于musl源码库\n pthread句柄 1struct pthread { 23struct pthread *self; 45#ifndef TLS_ABOVE_TP 6\tuintptr_t *dtv; 7#endif 8\t9/* 线程链表项 */ 10struct pthread *prev, *next; /* non-ABI */ 1112/* 系统信息 */ 13uintptr_t sysinfo; 1415#ifndef TLS_ABOVE_TP 16\t#ifdef CANARY_PAD 17\tuintptr_t canary_pad; 18#endif 19\tuintptr_t canary; 20#endif /* TLS_ABOVE_TP */21 22int tid; // 线程ID 23\t24int errno_val; 2526volatile int detach_state; // 分离状态 27\t28volatile int cancel;\t// cancle启动标志 29 volatile unsigned char canceldisable; // cancle控制 30 volatile unsigned char cancelasync; // cancle同步标志 31\t32unsigned char tsd_used:1; 33unsigned char dlerror_flag:1; 3435unsigned char *map_base;\t// mmap 36\tsize_t map_size; 3738void *stack;\t// 堆栈 39\tsize_t stack_size; 4041size_t guard_size; 4243void *result; // 返回结果, 44 45/* 线程清理回调函数 pthread_cleanup_push、pthread_cleanup_pop */ 46struct __ptcb *cancelbuf; 4748void **tsd; 4950struct { 51volatile void *volatile head; 52long off; 53volatile void *volatile pending; 54} robust_list; 5556int h_errno_val; 5758volatile int timer_id; 5960locale_t locale; 6162volatile int killlock[1];\t// 退出锁 63\t64char *dlerror_buf; 6566void *stdio_locks; 6768#ifdef TLS_ABOVE_TP 69\tuintptr_t canary; 70uintptr_t *dtv; 71#endif 72 73}; 7475// 因此在此处使用了技巧,在内部和外部使用的定义形式不一致 76#ifdef __cplusplus 77typedef unsigned long pthread_t; 78#else 79typedef struct __pthread* pthread_t; 80#endif 所有的函数 线程基础 1// 线程创建 2int pthread_create(pthread_t *__restrict, 3const pthread_attr_t *__restrict, 4void *(*)(void *), void *__restrict); 56// 线程退出 7void pthread_exit(void *); 89// 线程属性 10int pthread_attr_init(pthread_attr_t *); 11int pthread_attr_destroy(pthread_attr_t *); 1213int pthread_attr_getguardsize(const pthread_attr_t *__restrict, size_t *__restrict); 14int pthread_attr_setguardsize(pthread_attr_t *, size_t); 15int pthread_attr_getstacksize(const pthread_attr_t *__restrict, size_t *__restrict); 16int pthread_attr_setstacksize(pthread_attr_t *, size_t); 17int pthread_attr_getdetachstate(const pthread_attr_t *, int *); 18int pthread_attr_setdetachstate(pthread_attr_t *, int); 19int pthread_attr_getstack(const pthread_attr_t *__restrict, void **__restrict, size_t *__restrict); 20int pthread_attr_setstack(pthread_attr_t *, void *, size_t); 21int pthread_attr_getscope(const pthread_attr_t *__restrict, int *__restrict); 22int pthread_attr_setscope(pthread_attr_t *, int); 23int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict, int *__restrict); 24int pthread_attr_setschedpolicy(pthread_attr_t *, int); 25int pthread_attr_getschedparam(const pthread_attr_t *__restrict, struct sched_param *__restrict); 26int pthread_attr_setschedparam(pthread_attr_t *__restrict, const struct sched_param *__restrict); 27int pthread_attr_getinheritsched(const pthread_attr_t *__restrict, int *__restrict); 28int pthread_attr_setinheritsched(pthread_attr_t *, int); 线程分离 1// 线程分离 2int pthread_detach(pthread_t); 34// 线程等待 5int pthread_join(pthread_t, void **); 1// 获取线程自己的ID 2pthread_t pthread_self(void); 34// 判断线程是否相等 5int pthread_equal(pthread_t, pthread_t); // 其实,之间简单的比较id就可以了 线程取消 1int pthread_setcancelstate(int, int *); 2int pthread_setcanceltype(int, int *); 3void pthread_testcancel(void); 4int pthread_cancel(pthread_t); 调度相关 1int pthread_getschedparam(pthread_t t, 2int *restrict policy, 3struct sched_param *restrict param); 4__syscall(SYS_sched_getparam, pthread_t-\u0026gt;tid, sched_param); 5__syscall(SYS_sched_getscheduler, pthread_t-\u0026gt;tid); 67int pthread_setschedparam(pthread_t t, 8int policy, 9const struct sched_param *param); 10__syscall(SYS_sched_setscheduler, pthread_t-\u0026gt;tid, policy, sched_param); 11// sched_param保存着优先级参数 12 13int pthread_setschedprio(pthread_t t, int prio); 14__syscall(SYS_sched_setparam, pthread_t-\u0026gt;tid, \u0026amp;prio); 线程同步 互斥锁 1int pthread_mutex_init(pthread_mutex_t *__restrict, const pthread_mutexattr_t *__restrict); 2int pthread_mutex_lock(pthread_mutex_t *); 3int pthread_mutex_unlock(pthread_mutex_t *); 4int pthread_mutex_trylock(pthread_mutex_t *); 5int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict); 6int pthread_mutex_destroy(pthread_mutex_t *); 7int pthread_mutex_consistent(pthread_mutex_t *); 89int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict); 10int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict); 1112int pthread_mutexattr_destroy(pthread_mutexattr_t *); 13int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict, int *__restrict); 14int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict, int *__restrict); 15int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict, int *__restrict); 16int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__restrict, int *__restrict); 17int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict, int *__restrict); 18int pthread_mutexattr_init(pthread_mutexattr_t *); 19int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int); 20int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int); 21int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int); 22int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int); 23int pthread_mutexattr_settype(pthread_mutexattr_t *, int); 条件变量 1int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict); 2int pthread_cond_destroy(pthread_cond_t *); 3int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict); 4int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict); 5int pthread_cond_broadcast(pthread_cond_t *); 6int pthread_cond_signal(pthread_cond_t *); 78int pthread_condattr_init(pthread_condattr_t *); 9int pthread_condattr_destroy(pthread_condattr_t *); 10int pthread_condattr_setclock(pthread_condattr_t *, clockid_t); 11int pthread_condattr_setpshared(pthread_condattr_t *, int); 12int pthread_condattr_getclock(const pthread_condattr_t *__restrict, clockid_t *__restrict); 13int pthread_condattr_getpshared(const pthread_condattr_t *__restrict, int *__restrict); 读写锁 1int pthread_rwlock_init(pthread_rwlock_t *__restrict, const pthread_rwlockattr_t *__restrict); 2int pthread_rwlock_destroy(pthread_rwlock_t *); 3int pthread_rwlock_rdlock(pthread_rwlock_t *); 4int pthread_rwlock_tryrdlock(pthread_rwlock_t *); 5int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); 6int pthread_rwlock_wrlock(pthread_rwlock_t *); 7int pthread_rwlock_trywrlock(pthread_rwlock_t *); 8int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict); 9int pthread_rwlock_unlock(pthread_rwlock_t *); 10int pthread_rwlockattr_init(pthread_rwlockattr_t *); 11int pthread_rwlockattr_destroy(pthread_rwlockattr_t *); 12int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int); 13int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict, int *__restrict); 自旋锁 1int pthread_spin_init(pthread_spinlock_t *, int); 2int pthread_spin_destroy(pthread_spinlock_t *); 3int pthread_spin_lock(pthread_spinlock_t *); 4int pthread_spin_trylock(pthread_spinlock_t *); 5int pthread_spin_unlock(pthread_spinlock_t *); 屏障 1int pthread_barrier_init(pthread_barrier_t *__restrict, const pthread_barrierattr_t *__restrict, unsigned); 2int pthread_barrier_destroy(pthread_barrier_t *); 3int pthread_barrier_wait(pthread_barrier_t *); 4int pthread_barrierattr_destroy(pthread_barrierattr_t *); 5int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict, int *__restrict); 6int pthread_barrierattr_init(pthread_barrierattr_t *); 7int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int); 线程资源 1int pthread_key_create(pthread_key_t *, void (*)(void *)); 2int pthread_key_delete(pthread_key_t); 3void *pthread_getspecific(pthread_key_t); 4int pthread_setspecific(pthread_key_t, const void *); 补充知识  Linux系统调用\n 用户层调用SVC指令实现\n1#define __asm_syscall(...) 2do { 3__asm__ __volatile__ ( \u0026#34;svc 0\u0026#34; : \u0026#34;=r\u0026#34;(r0) : __VA_ARGS__ : \u0026#34;memory\u0026#34;); 4return r0; 5} while (0); 67#define R7_OPERAND \u0026#34;r\u0026#34;(r7) 8static inline long __syscall0(long n) 9{ 10register long r7 __ASM____R7__ = n; //使用R7传递个数 11\tregister long r0 __asm__(\u0026#34;r0\u0026#34;); 12__asm_syscall(R7_OPERAND); 13} 1415static inline long __syscall1(long n, long a) 16{ 17register long r7 __ASM____R7__ = n; 18register long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 19__asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0)); 20} 2122static inline long __syscall6(long n, long a, long b, long c, long d, long e, long f) 23{ 24register long r7 __ASM____R7__ = n; 25register long r0 __asm__(\u0026#34;r0\u0026#34;) = a; 26register long r1 __asm__(\u0026#34;r1\u0026#34;) = b; 27register long r2 __asm__(\u0026#34;r2\u0026#34;) = c; 28register long r3 __asm__(\u0026#34;r3\u0026#34;) = d; 29register long r4 __asm__(\u0026#34;r4\u0026#34;) = e; 30register long r5 __asm__(\u0026#34;r5\u0026#34;) = f; 31__asm_syscall(R7_OPERAND, \u0026#34;0\u0026#34;(r0), \u0026#34;r\u0026#34;(r1), \u0026#34;r\u0026#34;(r2), \u0026#34;r\u0026#34;(r3), \u0026#34;r\u0026#34;(r4), \u0026#34;r\u0026#34;(r5)); 32} 3334// 一个相当巧妙的宏定义的实现 35#define __SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n 36#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_X(__VA_ARGS__,7,6,5,4,3,2,1,0,) 37// 每次添加一个参数,就会将数字向后面推一个位置,形成参数个数 38 39// 拼装函数调用 40#define __SYSCALL_CONCAT_X(a,b) a##b 41#define __SYSCALL_CONCAT(a,b) __SYSCALL_CONCAT_X(a,b) 42#define __SYSCALL_DISP(b,...) __SYSCALL_CONCAT(b,__SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__) 43 44// __syscall_ret仅仅检查了系统调用号 45#define __syscall(...) __SYSCALL_DISP(__syscall,__VA_ARGS__) 46#define syscall(...) __syscall_ret(__syscall(__VA_ARGS__))  syscall(SYS_close, fd) 原始函数 __syscall_ret(__syscall(SYS_close, fd)) syscall宏定义展开 __syscall(SYS_close, fd) 直接拿掉syscall_ret __SYSCALL_DISP(__syscall, SYS_close, fd) 展开__syscall __SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(SYS_close, fd))(SYS_close, fd) __SYSCALL_CONCAT(_syscall, 1, (SYS_close, fd)) __syscall1(SYS_close, fd) 生成结束  系统调用号实现\n1#ifndef _UAPI_ASM_ARM_UNISTD_COMMON_H 2#define _UAPI_ASM_ARM_UNISTD_COMMON_H 1 3#define __NR_restart_syscall (__NR_SYSCALL_BASE + 0) 4#define __NR_exit (__NR_SYSCALL_BASE + 1) 5#define __NR_fork (__NR_SYSCALL_BASE + 2) 6#define __NR_read (__NR_SYSCALL_BASE + 3) 7#define __NR_write (__NR_SYSCALL_BASE + 4) 8#define __NR_open (__NR_SYSCALL_BASE + 5) 9#define __NR_close (__NR_SYSCALL_BASE + 6) 10#define __NR_creat (__NR_SYSCALL_BASE + 8) 11... 12#define __NR_io_pgetevents (__NR_SYSCALL_BASE + 399) 13#endif /* _UAPI_ASM_ARM_UNISTD_COMMON_H */clone系统调用 1int __clone(int (*func)(void *), void *stack, int flags, void *arg, ...); 23// 但是实现的地方却存在着异常 4 5__clone: 6stmfd sp!,{r4,r5,r6,r7} 78mov r7,#120 910mov r6,r3 11mov r5,r0 12mov r0,r2 1314and r1,r1,#-16 15ldr r2,[sp,#16] 16ldr r3,[sp,#20] 17ldr r4,[sp,#24] 18svc 0 1920tst r0,r0 21beq 1f 2223ldmfd sp!,{r4,r5,r6,r7} 24bx lr futex Futex 是Fast Userspace muTexes的缩写\n调用实例\n1// 对内核的调用进行抽象 2static inline void __wake(volatile void *addr, int cnt, int priv) 3{ 4if (priv) priv = FUTEX_PRIVATE; 5if (cnt\u0026lt;0) cnt = INT_MAX; 6__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS || 7__syscall(SYS_futex, addr, FUTEX_WAKE, cnt); 8} 910static inline void __futexwait(volatile void *addr, int val, int priv) 11{ 12if (priv) { 13priv = FUTEX_PRIVATE; 14} 15__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS || 16__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0); 17} 内核调用基础\n1long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout, 2u32 __user *uaddr2, u32 val2, u32 val3) 3{ 4int cmd = op \u0026amp; FUTEX_CMD_MASK; 5unsigned int flags = 0; 67if (!(op \u0026amp; FUTEX_PRIVATE_FLAG)) 8flags |= FLAGS_SHARED; 910if (op \u0026amp; FUTEX_CLOCK_REALTIME) { 11flags |= FLAGS_CLOCKRT; 12if (cmd != FUTEX_WAIT \u0026amp;\u0026amp; cmd != FUTEX_WAIT_BITSET \u0026amp;\u0026amp; \\ 13cmd != FUTEX_WAIT_REQUEUE_PI) 14return -ENOSYS; 15} 1617switch (cmd) { 18case FUTEX_LOCK_PI: 19case FUTEX_UNLOCK_PI: 20case FUTEX_TRYLOCK_PI: 21case FUTEX_WAIT_REQUEUE_PI: 22case FUTEX_CMP_REQUEUE_PI: 23if (!futex_cmpxchg_enabled) 24return -ENOSYS; 25} 2627switch (cmd) { 28case FUTEX_WAIT: 29val3 = FUTEX_BITSET_MATCH_ANY; 30/* fall through */ 31case FUTEX_WAIT_BITSET: 32return futex_wait(uaddr, flags, val, timeout, val3); 33case FUTEX_WAKE: 34val3 = FUTEX_BITSET_MATCH_ANY; 35/* fall through */ 36case FUTEX_WAKE_BITSET: 37return futex_wake(uaddr, flags, val, val3); 38case FUTEX_REQUEUE: 39return futex_requeue(uaddr, flags, uaddr2, val, val2, NULL, 0); 40case FUTEX_CMP_REQUEUE: 41return futex_requeue(uaddr, flags, uaddr2, val, val2, \u0026amp;val3, 0); 42case FUTEX_WAKE_OP: 43return futex_wake_op(uaddr, flags, uaddr2, val, val2, val3); 44case FUTEX_LOCK_PI: 45return futex_lock_pi(uaddr, flags, timeout, 0); 46case FUTEX_UNLOCK_PI: 47return futex_unlock_pi(uaddr, flags); 48case FUTEX_TRYLOCK_PI: 49return futex_lock_pi(uaddr, flags, NULL, 1); 50case FUTEX_WAIT_REQUEUE_PI: 51val3 = FUTEX_BITSET_MATCH_ANY; 52return futex_wait_requeue_pi(uaddr, flags, val, timeout, val3, 53uaddr2); 54case FUTEX_CMP_REQUEUE_PI: 55return futex_requeue(uaddr, flags, uaddr2, val, val2, \u0026amp;val3, 1); 56} 57return -ENOSYS; 58} 5960SYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val, 61struct timespec __user *, utime, u32 __user *, uaddr2, 62u32, val3) 63{ 64struct timespec ts; 65ktime_t t, *tp = NULL; 66u32 val2 = 0; 67int cmd = op \u0026amp; FUTEX_CMD_MASK; 6869if (utime \u0026amp;\u0026amp; (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI || 70cmd == FUTEX_WAIT_BITSET || 71cmd == FUTEX_WAIT_REQUEUE_PI)) { 72if (unlikely(should_fail_futex(!(op \u0026amp; FUTEX_PRIVATE_FLAG)))) 73return -EFAULT; 74if (copy_from_user(\u0026amp;ts, utime, sizeof(ts)) != 0) 75return -EFAULT; 76if (!timespec_valid(\u0026amp;ts)) 77return -EINVAL; 7879t = timespec_to_ktime(ts); 80if (cmd == FUTEX_WAIT) 81t = ktime_add_safe(ktime_get(), t); 82tp = \u0026amp;t; 83} 84/* 85* requeue parameter in \u0026#39;utime\u0026#39; if cmd == FUTEX_*_REQUEUE_*. 86* number of waiters to wake in \u0026#39;utime\u0026#39; if cmd == FUTEX_WAKE_OP. 87*/ 88if (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE || 89cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP) 90val2 = (u32) (unsigned long) utime; 9192return do_futex(uaddr, op, val, tp, uaddr2, val2, val3); 93} 线程基础 线程创建 1typedef struct { 2union { 3int __i[sizeof(long)==8?14:9]; 4volatile int __vi[sizeof(long)==8?14:9]; 5unsigned long __s[sizeof(long)==8?7:9]; 6} __u; 7} pthread_attr_t; 89#define __SU (sizeof(size_t)/sizeof(int)) 10 11#define _a_stacksize __u.__s[0] 12#define _a_guardsize __u.__s[1] 13#define _a_stackaddr __u.__s[2] 14#define _a_detach __u.__i[3*__SU+0] 15#define _a_sched __u.__i[3*__SU+1] 16#define _a_policy __u.__i[3*__SU+2] 17#define _a_prio __u.__i[3*__SU+3] 18#define _m_type __u.__i[0] 19#define _m_lock __u.__vi[1] 20#define _m_waiters __u.__vi[2] 21#define _m_prev __u.__p[3] 22#define _m_next __u.__p[4] 23#define _m_count __u.__i[5] 24#define _c_shared __u.__p[0] 25#define _c_seq __u.__vi[2] 26#define _c_waiters __u.__vi[3] 27#define _c_clock __u.__i[4] 28#define _c_lock __u.__vi[8] 29#define _c_head __u.__p[1] 30#define _c_tail __u.__p[5] 31#define _rw_lock __u.__vi[0] 32#define _rw_waiters __u.__vi[1] 33#define _rw_shared __u.__i[2] 34#define _b_lock __u.__vi[0] 35#define _b_waiters __u.__vi[1] 36#define _b_limit __u.__i[2] 37#define _b_count __u.__vi[3] 38#define _b_waiters2 __u.__vi[4] 39#define _b_inst __u.__p[3] 40 4142/** 43* @fn int pthread_create(pthread_t* restrict, const pthread_attr_t* restrict, void*(*)(void*), void* restrict) 44* @brief 创建线程 45* 46* @param res pthread指针 47* @param attrp\tpthread属性 48* @param entry\t入口地址 49* @param arg\t入口属性 50* @return\t创建结果 51*/ 52int pthread_create(pthread_t *restrict res, 53const pthread_attr_t *restrict attrp, 54void *(*entry)(void *), 55void *restrict arg) 56{ 57int ret, c11 = (attrp == __ATTRP_C11_THREAD); 58size_t size; 59size_t guard; 60struct pthread *self; 61struct pthread *new; 62unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit; 63unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND 64| CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS 65| CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED; 6667// 通过一定的规则将attrp--\u0026gt;attr 68 pthread_attr_t attr = { 0 }; 69sigset_t set; 7071/* 如果没有设置堆栈大小,先设置默认的堆栈大小 */ 72attr._a_stacksize = __default_stacksize; 73attr._a_guardsize = __default_guardsize; 7475/* 填充pthread成员 */ 76new = __copy_tls(tsd - libc.tls_size); 77new-\u0026gt;map_base = map; 78new-\u0026gt;map_size = size; 79new-\u0026gt;stack = stack; 80new-\u0026gt;stack_size = stack - stack_limit; 81new-\u0026gt;guard_size = guard; 82new-\u0026gt;self = new; 83new-\u0026gt;tsd = (void *)tsd; 84new-\u0026gt;locale = \u0026amp;libc.global_locale; 85if (attr._a_detach) { 86new-\u0026gt;detach_state = DT_DETACHED; 87} else { 88new-\u0026gt;detach_state = DT_JOINABLE; 89} 90new-\u0026gt;robust_list.head = \u0026amp;new-\u0026gt;robust_list.head; 91new-\u0026gt;canary = self-\u0026gt;canary; 92new-\u0026gt;sysinfo = self-\u0026gt;sysinfo; 9394/* 移动stack指针,保存启动参数 */ 95stack -= (uintptr_t)stack % sizeof(uintptr_t); 96stack -= sizeof(struct start_args); 9798/* 设置启动参数 */ 99struct start_args *args = (void *)stack; 100args-\u0026gt;start_func = entry; 101args-\u0026gt;start_arg = arg; 102args-\u0026gt;control = attr._a_sched ? 1 : 0; 103104/* 调用clone创建线程 */ 105clone(start, stack, flags, args, \u0026amp;new-\u0026gt;tid, TP_ADJ(new), \u0026amp;__thread_list_lock); 106107/* 设置调度器 */ 108ret = __syscall(SYS_sched_setscheduler, new-\u0026gt;tid, attr._a_policy, \u0026amp;attr._a_prio); 109if (a_swap(\u0026amp;args-\u0026gt;control, ret ? 3 : 0)==2) 110__wake(\u0026amp;args-\u0026gt;control, 1, 1); 111if (ret) 112__wait(\u0026amp;args-\u0026gt;control, 0, 3, 0); 113114/* 初始化链表 */ 115new-\u0026gt;next = self-\u0026gt;next; 116new-\u0026gt;prev = self; 117new-\u0026gt;next-\u0026gt;prev = new; 118new-\u0026gt;prev-\u0026gt;next = new; 119120/* 返回new作为线程ID */ 121} 1221void __pthread_exit(void *result) 2{ 3pthread_t self = __pthread_self(); 4sigset_t set; 56/* 设置退出标志 */ 7self-\u0026gt;canceldisable = 1; 8self-\u0026gt;cancelasync = 0; 9self-\u0026gt;result = result; 1011/* 执行线程清理函数 */ 12while (self-\u0026gt;cancelbuf) { 13void (*f)(void *) = self-\u0026gt;cancelbuf-\u0026gt;__f; 14void *x = self-\u0026gt;cancelbuf-\u0026gt;__x; 15self-\u0026gt;cancelbuf = self-\u0026gt;cancelbuf-\u0026gt;__next; 16f(x); 17} 1819int state = a_cas(\u0026amp;self-\u0026gt;detach_state, DT_JOINABLE, DT_EXITING); 2021/* 如果线程分离状态,则代表需要自己手动释放内存 */ 22if (state==DT_DETACHED \u0026amp;\u0026amp; self-\u0026gt;map_base) { 23__vm_wait(); 24} 2526volatile void *volatile *rp; 27while ((rp=self-\u0026gt;robust_list.head) \u0026amp;\u0026amp; rp != \u0026amp;self-\u0026gt;robust_list.head) { 28pthread_mutex_t *m = (void *)((char *)rp 29- offsetof(pthread_mutex_t, _m_next)); 30int waiters = m-\u0026gt;_m_waiters; 31int priv = (m-\u0026gt;_m_type \u0026amp; 128) ^ 128; 32self-\u0026gt;robust_list.pending = rp; 33self-\u0026gt;robust_list.head = *rp; 34int cont = a_swap(\u0026amp;m-\u0026gt;_m_lock, 0x40000000); 35self-\u0026gt;robust_list.pending = 0; 36if (cont \u0026lt; 0 || waiters) 37__wake(\u0026amp;m-\u0026gt;_m_lock, 1, priv); 38} 3940self-\u0026gt;next-\u0026gt;prev = self-\u0026gt;prev; 41self-\u0026gt;prev-\u0026gt;next = self-\u0026gt;next; 42self-\u0026gt;prev = self-\u0026gt;next = self; 4344if (state==DT_DETACHED \u0026amp;\u0026amp; self-\u0026gt;map_base) { 45if (self-\u0026gt;robust_list.off) { 46__syscall(SYS_set_robust_list, 0, 3*sizeof(long)); 47} 4849__unmapself(self-\u0026gt;map_base, self-\u0026gt;map_size); 50} 5152/* 设置线程为退出 */ 53a_store(\u0026amp;self-\u0026gt;detach_state, DT_EXITED); 5455/* 唤醒 */ 56__wake(\u0026amp;self-\u0026gt;detach_state, 1, 1); 5758/* 清除线程ID */ 59self-\u0026gt;tid = 0; 6061/* 杀死线程 */ 62for (;;) __syscall(SYS_exit, 0); 63} ptrhead进程属性机制 12int pthread_attr_init(pthread_attr_t *a); 3pthread_attr_t-\u0026gt;_a_stacksize = __default_stacksize; 4pthread_attr_t-\u0026gt;_a_guardsize = __default_guardsize; 56int pthread_attr_setdetachstate(pthread_attr_t *a, int state); 7pthread_attr_t-\u0026gt;_a_detach = state; 89int pthread_attr_setguardsize(pthread_attr_t *a, size_t size); 10pthread_attr_t-\u0026gt;_a_guardsize = size; 1112int pthread_attr_setinheritsched(pthread_attr_t *a, int inherit); 13pthread_attr_t-\u0026gt;_a_sched = inherit; 1415int pthread_attr_setschedparam(pthread_attr_t *restrict a, 16const struct sched_param *restrict param); 17pthread_attr_t-\u0026gt;_a_prio = param-\u0026gt;sched_priority; 1819int pthread_attr_setschedpolicy(pthread_attr_t *a, int policy); 20pthread_attr_t-\u0026gt;_a_policy = policy; 2122int pthread_attr_setstack(pthread_attr_t *a, void *addr, size_t size); 23pthread_attr_t-\u0026gt;_a_stackaddr = (size_t)addr + size; 24pthread_attr_t-\u0026gt;_a_stacksize = size; 2526int pthread_attr_setstacksize(pthread_attr_t *a, size_t size); 27pthread_attr_t-\u0026gt;_a_stackaddr = 0; 28pthread_attr_t-\u0026gt;_a_stacksize = size; 自身线程ID 1static inline uintptr_t __get_tp() 2{ 3uintptr_t tp; 4__asm__ ( \u0026#34;mrc p15,0,%0,c13,c0,3\u0026#34; : \u0026#34;=r\u0026#34;(tp) ); 5return tp; 6} 78// 获取线程自身的方法 9#define __pthread_self() ((pthread_t)(__get_tp() - sizeof(struct __pthread) - TP_OFFSET)) 线程清理函数 一句话:就是设置pthread-\u0026gt;cancelbuf成员函数\n1#define pthread_cleanup_push(f, x) \\ 2do { \\ 3struct __ptcb __cb; \\ 4_pthread_cleanup_push(\u0026amp;__cb, f, x); \\ 56#define pthread_cleanup_pop(r) \\ 7_pthread_cleanup_pop(\u0026amp;__cb, (r)); \\ 8} while(0) 9 10void _pthread_cleanup_push(struct __ptcb *cb, void (*f)(void *), void *x) 11{ 12cb-\u0026gt;__f = f; 13cb-\u0026gt;__x = x; 14__do_cleanup_push(cb); 15} 1617void _pthread_cleanup_pop(struct __ptcb *cb, int run) 18{ 19__do_cleanup_pop(cb); 20if (run) cb-\u0026gt;__f(cb-\u0026gt;__x); 21} 2223void __do_cleanup_push(struct __ptcb *cb) 24{ 25struct pthread *self = __pthread_self(); 26cb-\u0026gt;__next = self-\u0026gt;cancelbuf; 27self-\u0026gt;cancelbuf = cb; 28} 2930void __do_cleanup_pop(struct __ptcb *cb) 31{ 32__pthread_self()-\u0026gt;cancelbuf = cb-\u0026gt;__next; 33} cancle设置 1int __pthread_setcancelstate(int new, int *old); 2self-\u0026gt;canceldisable --\u0026gt; old; 3self-\u0026gt;canceldisable \u0026lt;-- new; 45int pthread_setcanceltype(int new, int *old); 6self-\u0026gt;cancelasync --\u0026gt; old; 7self-\u0026gt;cancelasync \u0026lt;-- new; 8// 同时还会执行__pthread_testcancel 9\t10int pthread_cancel(pthread_t t) 11{ 12// 自己的线程,直接退出 13\tpthread_exit(PTHREAD_CANCELED); 1415// 不是自己,发送退出信息 16\tpthread_kill(t, SIGCANCEL) 17} 1819// 设置线程取消点 20__pthread_testcancel --\u0026gt; __testcancel --\u0026gt; __cancel() 21void __pthread_testcancel() 22{ 23__testcancel(); 24} 2526void __testcancel() 27{ 28pthread_t self = __pthread_self(); 29if (self-\u0026gt;cancel \u0026amp;\u0026amp; !self-\u0026gt;canceldisable) 30__cancel(); 31} 3233/* 允许进行cancle才可以 */ 34long __cancel() 35{ 36pthread_t self = __pthread_self(); 37if (self-\u0026gt;canceldisable == PTHREAD_CANCEL_ENABLE || 38self-\u0026gt;cancelasync) 39pthread_exit(PTHREAD_CANCELED); 40self-\u0026gt;canceldisable = PTHREAD_CANCEL_DISABLE; 41return -ECANCELED; 42} 43// 此处产生效果,强行将pthread_testcancel退出点设置到此处 但是此时还是一个问题,从信号到处理究竟发生了什么?\n因此需要分析一下pthread_kill发生了什么?\n1int pthread_kill(pthread_t t, int sig) 2{ 3__block_all_sigs(\u0026amp;set); 4LOCK(t-\u0026gt;killlock); 56// 仅仅对线程发送了一个信号 7\t__syscall(SYS_tkill, t-\u0026gt;tid, sig); 89UNLOCK(t-\u0026gt;killlock); 10__restore_sigs(\u0026amp;set); 11} 1213// 那么在此回到pthread_cancle函数 14static void init_cancellation() 15{ 16struct sigaction sa = { 17.sa_flags = SA_SIGINFO | SA_RESTART, 18.sa_sigaction = cancel_handler 19}; 20memset(\u0026amp;sa.sa_mask, -1, _NSIG/8); 21__libc_sigaction(SIGCANCEL, \u0026amp;sa, 0); 22} 2324int pthread_cancel(pthread_t t) 25{ 26/* 此处存在这一个初始化 */ 27static int init; 28if (!init) { 29init_cancellation(); 30init = 1; 31} 32} 3334static void cancel_handler(int sig, siginfo_t *si, void *ctx) 35{ 36pthread_t self = __pthread_self(); 37ucontext_t *uc = ctx; 38uintptr_t pc = uc-\u0026gt;uc_mcontext.MC_PC; 3940a_barrier(); 41if (!self-\u0026gt;cancel || self-\u0026gt;canceldisable == PTHREAD_CANCEL_DISABLE) return; 4243_sigaddset(\u0026amp;uc-\u0026gt;uc_sigmask, SIGCANCEL); 4445if (self-\u0026gt;cancelasync || pc \u0026gt;= (uintptr_t)__cp_begin \u0026amp;\u0026amp; pc \u0026lt; (uintptr_t)__cp_end) { 46uc-\u0026gt;uc_mcontext.MC_PC = (uintptr_t)__cp_cancel; 47#ifdef CANCEL_GOT 48\tuc-\u0026gt;uc_mcontext.MC_GOT = CANCEL_GOT; 49#endif 50\treturn; 51} 5253__syscall(SYS_tkill, self-\u0026gt;tid, SIGCANCEL); 54} 线程分离 1// 线程分离 2int pthread_detach(pthread_t) 3--\u0026gt; __pthread_join(pthread_t, 0) 4--\u0026gt; __pthread_timedjoin_np(pthread_t, 0, 0) 567// 设置线程等待 8int pthread_join(pthread_t, void **); 9--\u0026gt;__pthread_timedjoin_np(pthread_t, res, 0) 1011// 那么也就是说明都调用了相同的函数 12 13static int __pthread_timedjoin_np(pthread_t t, void **res, const struct timespec *at) 14{ 15/* 设置线程分离状态 */ 16} ","date":"May 1, 2022","img":"","permalink":"https://mengdemao.github.io/posts/pthread/","series":null,"tags":[],"title":"Pthread源码分析"},{"categories":[],"content":"ZONE ZONE类型  ZONE_DMA, ZONE_DMA32 ZONE_NORMAL ZONE_HIGHMEM ZONE_MOVABLE ZONE_DEVICE  ","date":"Mar 13, 2022","img":"","permalink":"https://mengdemao.github.io/posts/memory_management/","series":null,"tags":[],"title":"内存管理"},{"categories":["rootfs"],"content":"下载buildroot 1git clone --depth=1 https://git.busybox.net/buildroot 2git branch -a [new branch] 3git checkout [new branch] 快速开始  可以先找到一个类似的配置文件,配置文件在下载的根目录的configs文件夹,下面 复制成为自己的配置文件cp configs/qemu_arm_vexpress_defconfig configs/qemu_arm_mengdemao_defconfig 测试环境是否正常,执行make qemu_arm_mengdemao_defconfig \u0026amp;\u0026amp; make,此时就是漫长的等待时间 运行测试程序cd output/images,并且执行start-qemu.sh  基础配置 使用自定义的内核 在defconfig文件中添加下面的配置\n1BR2_LINUX_KERNEL=y # 是否编译内核 2BR2_LINUX_KERNEL_CUSTOM_GIT=y # 是否使用git版本管理 3BR2_LINUX_KERNEL_CUSTOM_REPO_URL=\u0026#34;git@github.com:mengdemao/kernel.git\u0026#34; # kernel的地址 4BR2_LINUX_KERNEL_CUSTOM_REPO_VERSION=\u0026#34;master\u0026#34; # 版本 5BR2_LINUX_KERNEL_VERSION=\u0026#34;master\u0026#34; 6BR2_LINUX_KERNEL_USE_DEFCONFIG=y 7BR2_LINUX_KERNEL_DEFCONFIG=\u0026#34;debian\u0026#34; 8BR2_LINUX_KERNEL_ZIMAGE=y 9BR2_LINUX_KERNEL_GZIP=y ","date":"Mar 13, 2022","img":"","permalink":"https://mengdemao.github.io/posts/buildroot/","series":null,"tags":["rootfs"],"title":"Buildroot"},{"categories":["compiler"],"content":"C4实现 C4共实现了4个函数\n1void stmt(); 2void next(); 3void expr(int lev); 4int main(int argc, char **argv); 全局数据 全局变量 1char *p, *lp, // current position in source code 2 *data; // data/bss pointer 3 4int *e, *le, // current position in emitted code 5 *id, // currently parsed identifier 6 *sym, // symbol table (simple list of identifiers) 7 tk, // current token 8 ival, // current token value 9 ty, // current expression type 10 loc, // local variable offset 11 line, // current line number 12 src, // print source and assembly flag 13 debug; // print executed instructions 表达式描述 1// 符号描述 2enum { 3Num = 128, Fun, Sys, Glo, Loc, Id, 4Char, Else, Enum, If, Int, Return, Sizeof, While, 5Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak 6}; 78// 操作符 9enum 10{ 11LEA , 12IMM , 13JMP , 14JSR , 15BZ , 16BNZ , 17ENT , 18ADJ , 19LEV , 20LI , 21LC , 22SI , 23SC , 24PSH , 25OR , 26XOR , 27AND , 28EQ , 29NE , 30LT , 31GT , 32LE , 33GE , 34SHL , 35SHR , 36ADD , 37SUB , 38MUL , 39DIV , 40MOD , 41OPEN, 42READ, 43CLOS, 44PRTF, 45MALC, 46FREE, 47MSET, 48MCMP, 49EXIT 50}; 5152// 类型描述 53enum 54{ 55CHAR, 56INT, 57PTR 58}; 5960// 表达式描述 61enum 62{ 63Tk, 64Hash, 65Name, 66Class, 67Type, 68Val, 69HClass, 70HType, 71HVal, 72Idsz 73}; 基本架构 1graph TD 2main--\u0026gt;stmt 3stmt--\u0026gt;stmt 4main--\u0026gt;next 5stmt--\u0026gt;next 6stmt--\u0026gt;expr 7expr--\u0026gt;expr 8expr--\u0026gt;next 词法分析(next)  提取下一个单词\n 12tk, // current token 3ival, // current token value parse code generator stack based virtual machine  pc sp bp  1while (1) { 2i = *pc++; ++cycle; 3if (i == LEA) a = (int)(bp + *pc++); // load local address 4 else if (i == IMM) a = *pc++; // load global address or immediate 5 else if (i == JMP) pc = (int *)*pc; // jump 6 else if (i == JSR) { *--sp = (int)(pc + 1); pc = (int *)*pc; } // jump to subroutine 7 else if (i == BZ) pc = a ? pc + 1 : (int *)*pc; // branch if zero 8 else if (i == BNZ) pc = a ? (int *)*pc : pc + 1; // branch if not zero 9 else if (i == ENT) { *--sp = (int)bp; bp = sp; sp = sp - *pc++; } // enter subroutine 10 else if (i == ADJ) sp = sp + *pc++; // stack adjust 11 else if (i == LEV) { sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; } // leave subroutine 12 else if (i == LI) a = *(int *)a; // load int 13 else if (i == LC) a = *(char *)a; // load char 14 else if (i == SI) *(int *)*sp++ = a; // store int 15 else if (i == SC) a = *(char *)*sp++ = a; // store char 16 else if (i == PSH) *--sp = a; // push 17 18else if (i == OR) a = *sp++ | a; 19else if (i == XOR) a = *sp++ ^ a; 20else if (i == AND) a = *sp++ \u0026amp; a; 21else if (i == EQ) a = *sp++ == a; 22else if (i == NE) a = *sp++ != a; 23else if (i == LT) a = *sp++ \u0026lt; a; 24else if (i == GT) a = *sp++ \u0026gt; a; 25else if (i == LE) a = *sp++ \u0026lt;= a; 26else if (i == GE) a = *sp++ \u0026gt;= a; 27else if (i == SHL) a = *sp++ \u0026lt;\u0026lt; a; 28else if (i == SHR) a = *sp++ \u0026gt;\u0026gt; a; 29else if (i == ADD) a = *sp++ + a; 30else if (i == SUB) a = *sp++ - a; 31else if (i == MUL) a = *sp++ * a; 32else if (i == DIV) a = *sp++ / a; 33else if (i == MOD) a = *sp++ % a; 3435else if (i == OPEN) a = open((char *)sp[1], *sp); 36else if (i == READ) a = read(sp[2], (char *)sp[1], *sp); 37else if (i == CLOS) a = close(*sp); 38else if (i == PRTF) { t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); } 39else if (i == MALC) a = (int)malloc(*sp); 40else if (i == FREE) free((void *)*sp); 41else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp); 42else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp); 43else if (i == EXIT) { printf(\u0026#34;exit(%d) cycle = %d\\n\u0026#34;, *sp, cycle); return *sp; } 44else { printf(\u0026#34;unknown instruction = %d! cycle = %d\\n\u0026#34;, i, cycle); return -1; } 45} ","date":"Jan 16, 2022","img":"","permalink":"https://mengdemao.github.io/posts/c4/","series":null,"tags":["compiler"],"title":"C4"},{"categories":[],"content":"Lua源码分析  Lua运行结构\n graph LR 编译器==PROTO==虚拟机  相关数据结构 全局状态机  描述Lua运行状态,同时可以产生一种面向对象的模拟\n 1struct lua_State { 2CommonHeader; 3lu_byte status; 4lu_byte allowhook; 5unsigned short nci; /* number of items in \u0026#39;ci\u0026#39; list */ 6StkId top; /* first free slot in the stack */ 7global_State *l_G; 8CallInfo *ci; /* call info for current function */ 9StkId stack_last; /* end of stack (last element + 1) */ 10StkId stack; /* stack base */ 11UpVal *openupval; /* list of open upvalues in this stack */ 12StkId tbclist; /* list of to-be-closed variables */ 13GCObject *gclist; 14struct lua_State *twups; /* list of threads with open upvalues */ 15struct lua_longjmp *errorJmp; /* current error recover point */ 16CallInfo base_ci; /* CallInfo for first level (C calling Lua) */ 17volatile lua_Hook hook; 18ptrdiff_t errfunc; /* current error handling function (stack index) */ 19l_uint32 nCcalls; /* number of nested (non-yieldable | C) calls */ 20int oldpc; /* last pc traced */ 21int basehookcount; 22int hookcount; 23volatile l_signalT hookmask; 24};  Lua编译器  lua并没有直接运行源文件,而是将源文件编译成字节码，然后运行字节码 其中运行编译驱动文件名luac.c\n    文件名 功能 入口函数     llex.c 词法分析 luaX_next   lparser.c 语法解析 luaY_parser   lcode.c 代码生成 luaK_finish   ldump.c/lundump.c 字节码 luaU_dump/luaU_undump    词法分析 外部接口 1// 读取下一个单词 2void luaX_next (LexState *ls); 34// 预读下一个单词 5int luaX_lookahead (LexState *ls); 核心函数 1// 词法分析状态机 2typedef struct LexState { 3int current; /* current character (charint) */ 4int linenumber; /* input line counter */ 5int lastline; /* line of last token \u0026#39;consumed\u0026#39; */ 6Token t; /* current token */ 7Token lookahead; /* look ahead token */ 8struct FuncState *fs; /* current function (parser) */ 9struct lua_State *L; 10ZIO *z; /* input stream */ 11Mbuffer *buff; /* buffer for tokens */ 12Table *h; /* to avoid collection/reuse strings */ 13struct Dyndata *dyd; /* dynamic structures used by the parser */ 14TString *source; /* current source name */ 15TString *envn; /* environment variable name */ 16} LexState; 1718// 语义信息 19typedef union { 20lua_Number r; 21lua_Integer i; 22TString *ts; 23} SemInfo; 2425int llex (LexState *ls, SemInfo *seminfo); 语法分析 1typedef struct Proto { 2CommonHeader; 3lu_byte numparams; /* number of fixed (named) parameters */ 4lu_byte is_vararg; 5lu_byte maxstacksize; /* number of registers needed by this function */ 6int sizeupvalues; /* size of \u0026#39;upvalues\u0026#39; */ 7int sizek; /* size of \u0026#39;k\u0026#39; */ 8int sizecode; 9int sizelineinfo; 10int sizep; /* size of \u0026#39;p\u0026#39; */ 11int sizelocvars; 12int sizeabslineinfo; /* size of \u0026#39;abslineinfo\u0026#39; */ 13int linedefined; /* debug information */ 14int lastlinedefined; /* debug information */ 15TValue *k; /* constants used by the function */ 16Instruction *code; /* opcodes */ 17struct Proto **p; /* functions defined inside the function */ 18Upvaldesc *upvalues; /* upvalue information */ 19ls_byte *lineinfo; /* information about source lines (debug information) */ 20AbsLineInfo *abslineinfo; /* idem */ 21LocVar *locvars; /* information about local variables (debug information) */ 22TString *source; /* used for debug information */ 23GCObject *gclist; 24} Proto; 25typedef struct LClosure { 26ClosureHeader; 27struct Proto *p; 28UpVal *upvals[1]; /* list of upvalues */ 29} LClosure; 3031LClosure *luaY_parser ( 32lua_State *L, 33ZIO *z, 34Mbuffer *buff, 35Dyndata *dyd, 36const char *name, 37int firstchar);  代码生成 1void luaK_finish (FuncState *fs) { 2int i; 3Proto *p = fs-\u0026gt;f; 4for (i = 0; i \u0026lt; fs-\u0026gt;pc; i++) { 5Instruction *pc = \u0026amp;p-\u0026gt;code[i]; 6lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc)); 7switch (GET_OPCODE(*pc)) { 8case OP_RETURN0: case OP_RETURN1: { 9if (!(fs-\u0026gt;needclose || p-\u0026gt;is_vararg)) 10break; /* no extra work */ 11/* else use OP_RETURN to do the extra work */ 12SET_OPCODE(*pc, OP_RETURN); 13} /* FALLTHROUGH */ 14case OP_RETURN: case OP_TAILCALL: { 15if (fs-\u0026gt;needclose) 16SETARG_k(*pc, 1); /* signal that it needs to close */ 17if (p-\u0026gt;is_vararg) 18SETARG_C(*pc, p-\u0026gt;numparams + 1); /* signal that it is vararg */ 19break; 20} 21case OP_JMP: { 22int target = finaltarget(p-\u0026gt;code, i); 23fixjump(fs, i, target); 24break; 25} 26default: break; 27} 28} 29} 字节码 1int luaU_dump(lua_State *L, const Proto *f, lua_Writer w, void *data, 2int strip) { 3DumpState D; 4D.L = L; 5D.writer = w; 6D.data = data; 7D.strip = strip; 8D.status = 0; 9dumpHeader(\u0026amp;D); 10dumpByte(\u0026amp;D, f-\u0026gt;sizeupvalues); 11dumpFunction(\u0026amp;D, f, NULL); 12return D.status; 13} 14LClosure *luaU_undump(lua_State *L, ZIO *Z, const char *name) { 15LoadState S; 16LClosure *cl; 17if (*name == \u0026#39;@\u0026#39; || *name == \u0026#39;=\u0026#39;) 18S.name = name + 1; 19else if (*name == LUA_SIGNATURE[0]) 20S.name = \u0026#34;binary string\u0026#34;; 21else 22S.name = name; 23S.L = L; 24S.Z = Z; 25checkHeader(\u0026amp;S); 26cl = luaF_newLclosure(L, loadByte(\u0026amp;S)); 27setclLvalue2s(L, L-\u0026gt;top, cl); 28luaD_inctop(L); 29cl-\u0026gt;p = luaF_newproto(L); 30luaC_objbarrier(L, cl, cl-\u0026gt;p); 31loadFunction(\u0026amp;S, cl-\u0026gt;p, NULL); 32lua_assert(cl-\u0026gt;nupvalues == cl-\u0026gt;p-\u0026gt;sizeupvalues); 33luai_verifycode(L, cl-\u0026gt;p); 34return cl; 35} Lua虚拟机  接受编译器产生的字节码并且运行,执行的入口函数是luaV_execute\n Lua指令分析    指令名 参数 描述     OP_MOVE A B R(A) := R(B)   OP_LOADK A Bx R(A) := Kst(Bx)   OP_LOADBOOL A B C R(A) := (Bool)B; if (C) pc++   OP_LOADNIL A B R(A) := ... := R(B) := nil   OP_GETUPVAL A B R(A) := UpValue[B]   OP_GETGLOBAL A Bx R(A) := Gbl[Kst(Bx)]   OP_GETTABLE A B C R(A) := R(B)[RK(C)]   OP_SETGLOBAL A Bx Gbl[Kst(Bx)] := R(A)   OP_SETUPVAL A B UpValue[B] := R(A)   OP_SETTABLE A B C `R(A)[RK(B)] := RK(C)   OP_NEWTABLE A B C R(A) := {} (size = B,C)   OP_SELF A B C R(A+1) := R(B); R(A) := R(B)[RK(C)]   OP_ADD A B C R(A) := RK(B) + RK(C)   OP_SUB A B C R(A) := RK(B) - RK(C)   OP_MUL A B C R(A) := RK(B) * RK(C)   OP_DIV A B C R(A) := RK(B) / RK(C)   OP_MOD A B C R(A) := RK(B) % RK(C)   OP_POW A B C R(A) := RK(B) ^ RK(C)   OP_UNM A B R(A) := -R(B)   OP_NOT A B R(A) := not R(B)   OP_LEN A B R(A) := length of R(B)   OP_CONCAT A B C R(A) := R(B).. ... ..R(C)   OP_JMP sBx pc+=sBx   OP_EQ A B C if ((RK(B) == RK(C)) ~= A) then pc++   OP_LT A B C if ((RK(B) \u0026lt; RK(C)) ~= A) then pc++   OP_LE A B C if ((RK(B) \u0026lt;= RK(C)) ~= A) then pc++   OP_TEST A C if not (R(A) \u0026lt;=\u0026gt; C) then pc++   OP_TESTSET A B C if (R(B) \u0026lt;=\u0026gt; C) then R(A) := R(B) else pc++   OP_CALL A B C R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1))    OP_TAILCALL A B C return R(A)(R(A+1), ... ,R(A+B-1))   OP_RETURN A B return R(A), ... ,R(A+B-2)\t(see note)   OP_FORLOOP A sBx R(A)+=R(A+2); if R(A) \u0026lt;?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }   OP_FORPREP A sBx R(A)-=R(A+2); pc+=sBx   OP_TFORLOOP A C R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++   OP_SETLIST A B C R(A)[(C-1)*FPF+i] := R(A+i), 1 \u0026lt;= i \u0026lt;= B   OP_CLOSE A close all variables in the stack up to (\u0026gt;=) R(A)   OP_CLOSURE A Bx R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))   OP_VARARG A B R(A), R(A+1), ..., R(A+B-1) = vararg    指令解析 1lua_State *L;\t/* Lua状态机 */ 2LClosure *cl = \u0026amp;clvalue(L-\u0026gt;ci-\u0026gt;func)-\u0026gt;l;\t/* 当前函数执行环境 */ 3TValue *k = cl-\u0026gt;p-\u0026gt;k;\t/* 函数环境常量数组 */ 4const Instruction *pc = L-\u0026gt;savedpc; /* 当前函数指针 */ 5StkId base = L-\u0026gt;base;;\t/* 函数环境栈基地址 */ 1// R(A|B|C) 寄存器索引 2#define RA(i)\t(base+GETARG_A(i)) 3#define RB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i)) 4#define RC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) 5 6// RKB() 寄存器索引或者常量索引 7#define RKB(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, \\ 8ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i)) 9#define RKC(i)\tcheck_exp(getCMode(GET_OPCODE(i)) == OpArgK, \\ 10ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i)) 11 12#define KBx(i)\tcheck_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i)) 指令分发 1const Instruction i = *pc++; 2StkId ra = RA(i); 钩子函数处理 1// 不明白在处理什么 2if ((L-\u0026gt;hookmask \u0026amp; (LUA_MASKLINE | LUA_MASKCOUNT)) \u0026amp;\u0026amp; 3(--L-\u0026gt;hookcount == 0 || L-\u0026gt;hookmask \u0026amp; LUA_MASKLINE)) { 4traceexec(L, pc); 5if (L-\u0026gt;status == LUA_YIELD) { /* did hook yield? */ 6L-\u0026gt;savedpc = pc - 1; 7return; 8} 9base = L-\u0026gt;base; 10} OP_MOVE 1#define setobjs2s\tsetobj 2case OP_MOVE: { 3setobjs2s(L, ra, RB(i)); 4continue; 5} OP_LOADK 1#define setobj2s\tsetobj 2case OP_LOADK: { 3setobj2s(L, ra, KBx(i)); 4continue; 5} 统一调用此函数\n1// 拷贝lua_TValue,也只有两个成员 2void setobj(lua_State *L, const TValue *obj1, TValue *obj2) 3{ 4const TValue *o2=(obj2); 5TValue *o1=(obj1); 67o1-\u0026gt;value = o2-\u0026gt;value; 8o1-\u0026gt;tt=o2-\u0026gt;tt; 910checkliveness(G(L),o1); 11} OP_LOADBOOL 1case OP_LOADBOOL: { 2setbvalue(ra, GETARG_B(i)); 3if (GETARG_C(i)) 4pc++; /* skip next instruction (if C) */ 5continue; 6} OP_LOADNIL 1case OP_LOADNIL: { 2TValue *rb = RB(i); 3do { 4setnilvalue(rb--); 5} while (rb \u0026gt;= ra); 6continue; 7} OP_GETUPVAL 1case OP_GETUPVAL: { 2int b = GETARG_B(i); 3setobj2s(L, ra, cl-\u0026gt;upvals[b]-\u0026gt;v); 4continue; 5} 1case OP_GETGLOBAL: { 2TValue g; 3TValue *rb = KBx(i); 4sethvalue(L, \u0026amp;g, cl-\u0026gt;env); 5lua_assert(ttisstring(rb)); 6Protect(luaV_gettable(L, \u0026amp;g, rb, ra)); 7continue; 8} 1case OP_GETTABLE: { 2Protect(luaV_gettable(L, RB(i), RKC(i), ra)); 3continue; 4} 1case OP_SETGLOBAL: { 2TValue g; 3sethvalue(L, \u0026amp;g, cl-\u0026gt;env); 4lua_assert(ttisstring(KBx(i))); 5Protect(luaV_settable(L, \u0026amp;g, KBx(i), ra)); 6continue; 7} 1case OP_SETUPVAL: { 2UpVal *uv = cl-\u0026gt;upvals[GETARG_B(i)]; 3setobj(L, uv-\u0026gt;v, ra); 4luaC_barrier(L, uv, ra); 5continue; 6} 1case OP_SETTABLE: { 2Protect(luaV_settable(L, ra, RKB(i), RKC(i))); 3continue; 4} 算术指令 1case OP_ADD: { 2arith_op(luai_numadd, TM_ADD); 3continue; 4} 5case OP_SUB: { 6arith_op(luai_numsub, TM_SUB); 7continue; 8} 9case OP_MUL: { 10arith_op(luai_nummul, TM_MUL); 11continue; 12} 13case OP_DIV: { 14arith_op(luai_numdiv, TM_DIV); 15continue; 16} 17case OP_MOD: { 18arith_op(luai_nummod, TM_MOD); 19continue; 20} 21case OP_POW: { 22arith_op(luai_numpow, TM_POW); 23continue; 24} 统一调用arith_op,计算数据效果\n   功能 第一参数 第二参数     加 #define luai_numadd(a,b)\t((a)+(b)) TM_ADD   减 #define luai_numsub(a,b)\t((a)-(b)) TM_SUB   乘 #define luai_nummul(a,b)\t((a)*(b)) TM_MUL   除 #define luai_numdiv(a,b)\t((a)/(b)) TM_DIV   模 #define luai_nummod(a,b) ((a) - floor((a)/(b))*(b)) TM_MOD   方 #define luai_numpow(a,b)\t(pow(a,b)) TM_POW    1void arith_op(op,tm) 2{ 3TValue *rb = RKB(i);\t// 第二操作数 4\tTValue *rc = RKC(i);\t// 第三操作数 5 6if (ttisnumber(rb) \u0026amp;\u0026amp; // 校验数据 7 ttisnumber(rc)) {\t// 校验数据 8 9lua_Number nb = nvalue(rb);\t// 提取数据 10 lua_Number nc = nvalue(rc); // 提取数据 11 12setnvalue(ra, op(nb, nc)); // 设置第一操作数 13\t} else { 14Protect(Arith(L, ra, rb, rc, tm)); // 如果操作数不是数据,那么强转 15 } 16} 1718#define Protect(x)\t{ L-\u0026gt;savedpc = pc; {x;}; base = L-\u0026gt;base; } 19static void Arith (lua_State *L, StkId ra, const TValue *rb, 20const TValue *rc, TMS op) { 21TValue tempb, tempc; 22const TValue *b, *c; 23if ((b = luaV_tonumber(rb, \u0026amp;tempb)) != NULL \u0026amp;\u0026amp; 24(c = luaV_tonumber(rc, \u0026amp;tempc)) != NULL) { 25lua_Number nb = nvalue(b), nc = nvalue(c); 26switch (op) { 27case TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); break; 28case TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); break; 29case TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); break; 30case TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); break; 31case TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); break; 32case TM_POW: setnvalue(ra, luai_numpow(nb, nc)); break; 33case TM_UNM: setnvalue(ra, luai_numunm(nb)); break; 34default: lua_assert(0); break; 35} 36} 37else if (!call_binTM(L, rb, rc, ra, op)) 38luaG_aritherror(L, rb, rc); 39} ","date":"Jan 2, 2022","img":"","permalink":"https://mengdemao.github.io/posts/lua/","series":null,"tags":[],"title":"Lua"},{"categories":[],"content":"","date":"Dec 11, 2021","img":"","permalink":"https://mengdemao.github.io/posts/complete/","series":null,"tags":["kernel"],"title":"Complete"},{"categories":[],"content":"优先级定义  内核优先级使用0-139确定内部优先级,0-99分配实时进程; [100, 139]分配非实时进程,nice的映射[-20, 19]与非实时优先级的相对应.\n 相关数据结构 任务相关数据\n1struct task_struct { 23int\tprio;\t// 动态优先级 4\tint\tstatic_prio;\t// 静态优先级 5\tint\tnormal_prio;\t// 普通优先级\t6\tunsigned int\trt_priority;\t// 实时优先级 7}; 计算静态优先级 1static int effective_prio(struct task_struct *p) 2{ 3/* 设置普通优先级 */ 4p-\u0026gt;normal_prio = normal_prio(p); 56/* 如果不是实时优先级,则返回普通优先级 */ 7if (!rt_prio(p-\u0026gt;prio)) 8return p-\u0026gt;normal_prio; 910/* 返回动态优先级 */ 11return p-\u0026gt;prio; 12} 获取普通优先级 1static inline int __normal_prio(struct task_struct *p) 2{ 3return p-\u0026gt;static_prio; 4} 56static inline int normal_prio(struct task_struct *p) 7{ 8int prio; 910if (task_has_dl_policy(p)) 11prio = MAX_DL_PRIO-1; 12else if (task_has_rt_policy(p)) 13prio = MAX_RT_PRIO-1 - p-\u0026gt;rt_priority; 14else 15prio = __normal_prio(p); 16return prio; 17} 负载计算 1// 负载权重 2struct load_weight { 3unsigned long\tweight; 4u32\tinv_weight; 5}; 67// 调度实体 8struct sched_entity { 9struct load_weight\tload; 10}; 1112struct sched_rt_entity { 13struct list_head\trun_list; 14unsigned long\ttimeout; 15unsigned long\twatchdog_stamp; 16unsigned int\ttime_slice; 17unsigned short\ton_rq; 18unsigned short\ton_list; 1920struct sched_rt_entity\t*back; 21#ifdef CONFIG_RT_GROUP_SCHED 22\tstruct sched_rt_entity\t*parent; 23/* rq on which this entity is (to be) queued: */ 24struct rt_rq\t*rt_rq; 25/* rq \u0026#34;owned\u0026#34; by this entity/group: */ 26struct rt_rq\t*my_q; 27#endif 28} __randomize_layout; 2930struct sched_dl_entity { 31struct rb_node\trb_node; 3233/* 34* Original scheduling parameters. Copied here from sched_attr 35* during sched_setattr(), they will remain the same until 36* the next sched_setattr(). 37*/ 38u64\tdl_runtime;\t/* Maximum runtime for each instance\t*/ 39u64\tdl_deadline;\t/* Relative deadline of each instance\t*/ 40u64\tdl_period;\t/* Separation of two instances (period) */ 41u64\tdl_bw;\t/* dl_runtime / dl_period\t*/ 42u64\tdl_density;\t/* dl_runtime / dl_deadline\t*/ 4344/* 45* Actual scheduling parameters. Initialized with the values above, 46* they are continously updated during task execution. Note that 47* the remaining runtime could be \u0026lt; 0 in case we are in overrun. 48*/ 49s64\truntime;\t/* Remaining runtime for this instance\t*/ 50u64\tdeadline;\t/* Absolute deadline for this instance\t*/ 51unsigned int\tflags;\t/* Specifying the scheduler behaviour\t*/ 5253/* 54* Some bool flags: 55* 56* @dl_throttled tells if we exhausted the runtime. If so, the 57* task has to wait for a replenishment to be performed at the 58* next firing of dl_timer. 59* 60* @dl_boosted tells if we are boosted due to DI. If so we are 61* outside bandwidth enforcement mechanism (but only until we 62* exit the critical section); 63* 64* @dl_yielded tells if task gave up the CPU before consuming 65* all its available runtime during the last job. 66* 67* @dl_non_contending tells if the task is inactive while still 68* contributing to the active utilization. In other words, it 69* indicates if the inactive timer has been armed and its handler 70* has not been executed yet. This flag is useful to avoid race 71* conditions between the inactive timer handler and the wakeup 72* code. 73* 74* @dl_overrun tells if the task asked to be informed about runtime 75* overruns. 76*/ 77unsigned int\tdl_throttled : 1; 78unsigned int\tdl_boosted : 1; 79unsigned int\tdl_yielded : 1; 80unsigned int\tdl_non_contending : 1; 81unsigned int\tdl_overrun\t: 1; 8283/* 84* Bandwidth enforcement timer. Each -deadline task has its 85* own bandwidth to be enforced, thus we need one timer per task. 86*/ 87struct hrtimer\tdl_timer; 8889/* 90* Inactive timer, responsible for decreasing the active utilization 91* at the \u0026#34;0-lag time\u0026#34;. When a -deadline task blocks, it contributes 92* to GRUB\u0026#39;s active utilization until the \u0026#34;0-lag time\u0026#34;, hence a 93* timer is needed to decrease the active utilization at the correct 94* time. 95*/ 96struct hrtimer inactive_timer; 97}; 9899// 调度结构体 100struct task_struct { 101struct sched_entity\tse; // 调度实体 102\tstruct sched_rt_entity\trt; // 实时调度实体 103\tstruct sched_dl_entity\tdl;\t// 限期调度实体 104}; 设置负载权重 1const int sched_prio_to_weight[40] = { 2/* -20 */ 88761, 71755, 56483, 46273, 36291, 3/* -15 */ 29154, 23254, 18705, 14949, 11916, 4/* -10 */ 9548, 7620, 6100, 4904, 3906, 5/* -5 */ 3121, 2501, 1991, 1586, 1277, 6/* 0 */ 1024, 820, 655, 526, 423, 7/* 5 */ 335, 272, 215, 172, 137, 8/* 10 */ 110, 87, 70, 56, 45, 9/* 15 */ 36, 29, 23, 18, 15, 10}; 1112const u32 sched_prio_to_wmult[40] = { 13/* -20 */ 48388, 59856, 76040, 92818, 118348, 14/* -15 */ 147320, 184698, 229616, 287308, 360437, 15/* -10 */ 449829, 563644, 704093, 875809, 1099582, 16/* -5 */ 1376151, 1717300, 2157191, 2708050, 3363326, 17/* 0 */ 4194304, 5237765, 6557202, 8165337, 10153587, 18/* 5 */ 12820798, 15790321, 19976592, 24970740, 31350126, 19/* 10 */ 39045157, 49367440, 61356676, 76695844, 95443717, 20/* 15 */ 119304647, 148102320, 186737708, 238609294, 286331153, 21}; 2223static void set_load_weight(struct task_struct *p, bool update_load) 24{ 25int prio = p-\u0026gt;static_prio - MAX_RT_PRIO; 26struct load_weight *load = \u0026amp;p-\u0026gt;se.load; 2728// SCHED_IDLE 拥有最低权重 29\tif (idle_policy(p-\u0026gt;policy)) { 30load-\u0026gt;weight = scale_load(WEIGHT_IDLEPRIO); 31load-\u0026gt;inv_weight = WMULT_IDLEPRIO; 32return; 33} 3435if (update_load \u0026amp;\u0026amp; p-\u0026gt;sched_class == \u0026amp;fair_sched_class) { 36reweight_task(p, prio); 37} else { 38load-\u0026gt;weight = scale_load(sched_prio_to_weight[prio]); 39load-\u0026gt;inv_weight = sched_prio_to_wmult[prio]; 40} 41} 不需更新权重 1load-\u0026gt;weight = scale_load(sched_prio_to_weight[prio]); 2load-\u0026gt;inv_weight = sched_prio_to_wmult[prio]; 需要更新权重 1void reweight_task(struct task_struct *p, int prio) 2{ 3struct sched_entity *se = \u0026amp;p-\u0026gt;se; 4struct cfs_rq *cfs_rq = cfs_rq_of(se); 5struct load_weight *load = \u0026amp;se-\u0026gt;load; 6unsigned long weight = scale_load(sched_prio_to_weight[prio]); 78reweight_entity(cfs_rq, se, weight, weight); 9load-\u0026gt;inv_weight = sched_prio_to_wmult[prio]; 10} 11static void reweight_entity(struct cfs_rq *cfs_rq, 12struct sched_entity *se, 13unsigned long weight, 14unsigned long runnable) 15{ 16if (se-\u0026gt;on_rq) { 17/* commit outstanding execution time */ 18if (cfs_rq-\u0026gt;curr == se) 19update_curr(cfs_rq); 20account_entity_dequeue(cfs_rq, se); 21dequeue_runnable_load_avg(cfs_rq, se); 22} 23dequeue_load_avg(cfs_rq, se); 2425se-\u0026gt;runnable_weight = runnable; 26update_load_set(\u0026amp;se-\u0026gt;load, weight); 27enqueue_load_avg(cfs_rq, se); 28if (se-\u0026gt;on_rq) { 29account_entity_enqueue(cfs_rq, se); 30enqueue_runnable_load_avg(cfs_rq, se); 31} 32} ","date":"Nov 14, 2021","img":"","permalink":"https://mengdemao.github.io/posts/schedulepriority/","series":null,"tags":[],"title":"调度优先级"},{"categories":[],"content":"dwl桌面环境 编译流程  setup 1void 2setup(void) 3{ 4/* The Wayland display is managed by libwayland. It handles accepting 5* clients from the Unix socket, manging Wayland globals, and so on. */ 6dpy = wl_display_create(); 78/* Set up signal handlers */ 9sigchld(0); 10signal(SIGINT, quitsignal); 11signal(SIGTERM, quitsignal); 1213/* The backend is a wlroots feature which abstracts the underlying input and 14* output hardware. The autocreate option will choose the most suitable 15* backend based on the current environment, such as opening an X11 window 16* if an X11 server is running. The NULL argument here optionally allows you 17* to pass in a custom renderer if wlr_renderer doesn\u0026#39;t meet your needs. The 18* backend uses the renderer, for example, to fall back to software cursors 19* if the backend does not support hardware cursors (some older GPUs 20* don\u0026#39;t). */ 21if (!(backend = wlr_backend_autocreate(dpy))) 22BARF(\u0026#34;couldn\u0026#39;t create backend\u0026#34;); 2324/* If we don\u0026#39;t provide a renderer, autocreate makes a GLES2 renderer for us. 25* The renderer is responsible for defining the various pixel formats it 26* supports for shared memory, this configures that for clients. */ 27drw = wlr_backend_get_renderer(backend); 28wlr_renderer_init_wl_display(drw, dpy); 2930/* This creates some hands-off wlroots interfaces. The compositor is 31* necessary for clients to allocate surfaces and the data device manager 32* handles the clipboard. Each of these wlroots interfaces has room for you 33* to dig your fingers in and play with their behavior if you want. Note that 34* the clients cannot set the selection directly without compositor approval, 35* see the setsel() function. */ 36compositor = wlr_compositor_create(dpy, drw); 37wlr_export_dmabuf_manager_v1_create(dpy); 38wlr_screencopy_manager_v1_create(dpy); 39wlr_data_control_manager_v1_create(dpy); 40wlr_data_device_manager_create(dpy); 41wlr_gamma_control_manager_v1_create(dpy); 42wlr_primary_selection_v1_device_manager_create(dpy); 43wlr_viewporter_create(dpy); 4445/* Initializes the interface used to implement urgency hints */ 46activation = wlr_xdg_activation_v1_create(dpy); 47wl_signal_add(\u0026amp;activation-\u0026gt;events.request_activate, \u0026amp;request_activate); 4849/* Creates an output layout, which a wlroots utility for working with an 50* arrangement of screens in a physical layout. */ 51output_layout = wlr_output_layout_create(); 52wl_signal_add(\u0026amp;output_layout-\u0026gt;events.change, \u0026amp;layout_change); 53wlr_xdg_output_manager_v1_create(dpy, output_layout); 5455/* Configure a listener to be notified when new outputs are available on the 56* backend. */ 57wl_list_init(\u0026amp;mons); 58wl_signal_add(\u0026amp;backend-\u0026gt;events.new_output, \u0026amp;new_output); 5960/* Set up our client lists and the xdg-shell. The xdg-shell is a 61* Wayland protocol which is used for application windows. For more 62* detail on shells, refer to the article: 63* 64* https://drewdevault.com/2018/07/29/Wayland-shells.html 65*/ 66wl_list_init(\u0026amp;clients); 67wl_list_init(\u0026amp;fstack); 68wl_list_init(\u0026amp;stack); 69wl_list_init(\u0026amp;independents); 7071idle = wlr_idle_create(dpy); 7273layer_shell = wlr_layer_shell_v1_create(dpy); 74wl_signal_add(\u0026amp;layer_shell-\u0026gt;events.new_surface, \u0026amp;new_layer_shell_surface); 7576xdg_shell = wlr_xdg_shell_create(dpy); 77wl_signal_add(\u0026amp;xdg_shell-\u0026gt;events.new_surface, \u0026amp;new_xdg_surface); 7879/* Use decoration protocols to negotiate server-side decorations */ 80wlr_server_decoration_manager_set_default_mode( 81wlr_server_decoration_manager_create(dpy), 82WLR_SERVER_DECORATION_MANAGER_MODE_SERVER); 83wlr_xdg_decoration_manager_v1_create(dpy); 8485/* 86* Creates a cursor, which is a wlroots utility for tracking the cursor 87* image shown on screen. 88*/ 89cursor = wlr_cursor_create(); 90wlr_cursor_attach_output_layout(cursor, output_layout); 9192/* Creates an xcursor manager, another wlroots utility which loads up 93* Xcursor themes to source cursor images from and makes sure that cursor 94* images are available at all scale factors on the screen (necessary for 95* HiDPI support). Scaled cursors will be loaded with each output. */ 96cursor_mgr = wlr_xcursor_manager_create(NULL, 24); 9798/* 99* wlr_cursor *only* displays an image on screen. It does not move around 100* when the pointer moves. However, we can attach input devices to it, and 101* it will generate aggregate events for all of them. In these events, we 102* can choose how we want to process them, forwarding them to clients and 103* moving the cursor around. More detail on this process is described in my 104* input handling blog post: 105* 106* https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html 107* 108* And more comments are sprinkled throughout the notify functions above. 109*/ 110wl_signal_add(\u0026amp;cursor-\u0026gt;events.motion, \u0026amp;cursor_motion); 111wl_signal_add(\u0026amp;cursor-\u0026gt;events.motion_absolute, \u0026amp;cursor_motion_absolute); 112wl_signal_add(\u0026amp;cursor-\u0026gt;events.button, \u0026amp;cursor_button); 113wl_signal_add(\u0026amp;cursor-\u0026gt;events.axis, \u0026amp;cursor_axis); 114wl_signal_add(\u0026amp;cursor-\u0026gt;events.frame, \u0026amp;cursor_frame); 115116/* 117* Configures a seat, which is a single \u0026#34;seat\u0026#34; at which a user sits and 118* operates the computer. This conceptually includes up to one keyboard, 119* pointer, touch, and drawing tablet device. We also rig up a listener to 120* let us know when new input devices are available on the backend. 121*/ 122wl_list_init(\u0026amp;keyboards); 123wl_signal_add(\u0026amp;backend-\u0026gt;events.new_input, \u0026amp;new_input); 124virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy); 125wl_signal_add(\u0026amp;virtual_keyboard_mgr-\u0026gt;events.new_virtual_keyboard, 126\u0026amp;new_virtual_keyboard); 127seat = wlr_seat_create(dpy, \u0026#34;seat0\u0026#34;); 128wl_signal_add(\u0026amp;seat-\u0026gt;events.request_set_cursor, 129\u0026amp;request_cursor); 130wl_signal_add(\u0026amp;seat-\u0026gt;events.request_set_selection, 131\u0026amp;request_set_sel); 132wl_signal_add(\u0026amp;seat-\u0026gt;events.request_set_primary_selection, 133\u0026amp;request_set_psel); 134135output_mgr = wlr_output_manager_v1_create(dpy); 136wl_signal_add(\u0026amp;output_mgr-\u0026gt;events.apply, \u0026amp;output_mgr_apply); 137wl_signal_add(\u0026amp;output_mgr-\u0026gt;events.test, \u0026amp;output_mgr_test); 138139presentation = wlr_presentation_create(dpy, backend); 140141#ifdef XWAYLAND 142\t/* 143* Initialise the XWayland X server. 144* It will be started when the first X client is started. 145*/ 146xwayland = wlr_xwayland_create(dpy, compositor, 1); 147if (xwayland) { 148wl_signal_add(\u0026amp;xwayland-\u0026gt;events.ready, \u0026amp;xwayland_ready); 149wl_signal_add(\u0026amp;xwayland-\u0026gt;events.new_surface, \u0026amp;new_xwayland_surface); 150151setenv(\u0026#34;DISPLAY\u0026#34;, xwayland-\u0026gt;display_name, 1); 152} else { 153fprintf(stderr, \u0026#34;failed to setup XWayland X server, continuing without it\\n\u0026#34;); 154} 155#endif 156} run 1void 2run(char *startup_cmd) 3{ 4pid_t startup_pid = -1; 56/* Add a Unix socket to the Wayland display. */ 7const char *socket = wl_display_add_socket_auto(dpy); 8if (!socket) 9BARF(\u0026#34;startup: display_add_socket_auto\u0026#34;); 10setenv(\u0026#34;WAYLAND_DISPLAY\u0026#34;, socket, 1); 1112/* Now that the socket exists, run the startup command */ 13if (startup_cmd) { 14int piperw[2]; 15pipe(piperw); 16startup_pid = fork(); 17if (startup_pid \u0026lt; 0) 18EBARF(\u0026#34;startup: fork\u0026#34;); 19if (startup_pid == 0) { 20dup2(piperw[0], STDIN_FILENO); 21close(piperw[1]); 22execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, startup_cmd, NULL); 23EBARF(\u0026#34;startup: execl\u0026#34;); 24} 25dup2(piperw[1], STDOUT_FILENO); 26close(piperw[0]); 27} 28/* If nobody is reading the status output, don\u0026#39;t terminate */ 29signal(SIGPIPE, SIG_IGN); 30printstatus(); 3132/* Start the backend. This will enumerate outputs and inputs, become the DRM 33* master, etc */ 34if (!wlr_backend_start(backend)) 35BARF(\u0026#34;startup: backend_start\u0026#34;); 3637/* Now that outputs are initialized, choose initial selmon based on 38* cursor position, and set default cursor image */ 39selmon = xytomon(cursor-\u0026gt;x, cursor-\u0026gt;y); 4041/* TODO hack to get cursor to display in its initial location (100, 100) 42* instead of (0, 0) and then jumping. still may not be fully 43* initialized, as the image/coordinates are not transformed for the 44* monitor when displayed here */ 45wlr_cursor_warp_closest(cursor, NULL, cursor-\u0026gt;x, cursor-\u0026gt;y); 46wlr_xcursor_manager_set_cursor_image(cursor_mgr, \u0026#34;left_ptr\u0026#34;, cursor); 4748/* Run the Wayland event loop. This does not return until you exit the 49* compositor. Starting the backend rigged up all of the necessary event 50* loop configuration to listen to libinput events, DRM events, generate 51* frame events at the refresh rate, and so on. */ 52wl_display_run(dpy); 5354if (startup_cmd) { 55kill(startup_pid, SIGTERM); 56waitpid(startup_pid, NULL, 0); 57} 58} cleanup 1void cleanup(void) 2{ 3#ifdef XWAYLAND 4\twlr_xwayland_destroy(xwayland); 5#endif 6\twl_display_destroy_clients(dpy); 78wlr_backend_destroy(backend); 9wlr_xcursor_manager_destroy(cursor_mgr); 10wlr_cursor_destroy(cursor); 11wlr_output_layout_destroy(output_layout); 12wlr_seat_destroy(seat); 13wl_display_destroy(dpy); 14} ","date":"Nov 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/dwl/","series":null,"tags":[],"title":"Dwl"},{"categories":[],"content":"TinyCC  TinyCC (aka TCC) is a small but hyper fast C compiler. Unlike other C compilers, it is meant to be self-relying: you do not need an external assembler or linker because TCC does that for you.\n TCC 执行概览 TCC组成代码\n   文件名 解释     tcc.c/libtcc.c tcc运行代码   tccpp.c    tccelf.c tcccoff.c    tccasm.c    tccrun.c    tccgen.c    x86_64-gen.c x86_64-link.c i386-asm.c 不同架构的生成器     TCC状态信息 1struct TCCState { 2unsigned char verbose; /* if true, display some information during compilation */ 3unsigned char nostdinc; /* if true, no standard headers are added */ 4unsigned char nostdlib; /* if true, no standard libraries are added */ 5unsigned char nocommon; /* if true, do not use common symbols for .bss data */ 6unsigned char static_link; /* if true, static linking is performed */ 7unsigned char rdynamic; /* if true, all symbols are exported */ 8unsigned char symbolic; /* if true, resolve symbols in the current module first */ 9unsigned char filetype; /* file type for compilation (NONE,C,ASM) */ 10unsigned char optimize; /* only to #define __OPTIMIZE__ */ 11unsigned char option_pthread; /* -pthread option */ 12unsigned char enable_new_dtags; /* -Wl,--enable-new-dtags */ 13unsigned int cversion; /* supported C ISO version, 199901 (the default), 201112, ... */ 1415/* C language options */ 16unsigned char char_is_unsigned; 17unsigned char leading_underscore; 18unsigned char ms_extensions; /* allow nested named struct w/o identifier behave like unnamed */ 19unsigned char dollars_in_identifiers; /* allows \u0026#39;$\u0026#39; char in identifiers */ 20unsigned char ms_bitfields; /* if true, emulate MS algorithm for aligning bitfields */ 2122/* warning switches */ 23unsigned char warn_none; 24unsigned char warn_all; 25unsigned char warn_error; 26unsigned char warn_write_strings; 27unsigned char warn_unsupported; 28unsigned char warn_implicit_function_declaration; 29unsigned char warn_discarded_qualifiers; 30#define WARN_ON 1 /* warning is on (-Woption) */31 unsigned char warn_num; /* temp var for tcc_warning_c() */ 3233unsigned char option_r; /* option -r */ 34unsigned char do_bench; /* option -bench */ 35unsigned char just_deps; /* option -M */ 36unsigned char gen_deps; /* option -MD */ 37unsigned char include_sys_deps; /* option -MD */ 3839/* compile with debug symbol (and use them if error during execution) */ 40unsigned char do_debug; 41unsigned char do_backtrace; 42#ifdef CONFIG_TCC_BCHECK 43 /* compile with built-in memory and bounds checker */ 44unsigned char do_bounds_check; 45#endif 46 unsigned char test_coverage; /* generate test coverage code */ 4748/* use GNU C extensions */ 49unsigned char gnu_ext; 50/* use TinyCC extensions */ 51unsigned char tcc_ext; 5253unsigned char dflag; /* -dX value */ 54unsigned char Pflag; /* -P switch (LINE_MACRO_OUTPUT_FORMAT) */ 5556#ifdef TCC_TARGET_X86_64 57 unsigned char nosse; /* For -mno-sse support. */ 58#endif 59#ifdef TCC_TARGET_ARM 60 unsigned char float_abi; /* float ABI of the generated code*/ 61#endif 62 63unsigned char has_text_addr; 64addr_t text_addr; /* address of text section */ 65unsigned section_align; /* section alignment */ 66#ifdef TCC_TARGET_I386 67 int seg_size; /* 32. Can be 16 with i386 assembler (.code16) */ 68#endif 69 70char *tcc_lib_path; /* CONFIG_TCCDIR or -B option */ 71char *soname; /* as specified on the command line (-soname) */ 72char *rpath; /* as specified on the command line (-Wl,-rpath=) */ 7374char *init_symbol; /* symbols to call at load-time (not used currently) */ 75char *fini_symbol; /* symbols to call at unload-time (not used currently) */ 7677/* output type, see TCC_OUTPUT_XXX */ 78int output_type; 79/* output format, see TCC_OUTPUT_FORMAT_xxx */ 80int output_format; 81/* nth test to run with -dt -run */ 82int run_test; 8384/* array of all loaded dlls (including those referenced by loaded dlls) */ 85DLLReference **loaded_dlls; 86int nb_loaded_dlls; 8788/* include paths */ 89char **include_paths; 90int nb_include_paths; 9192char **sysinclude_paths; 93int nb_sysinclude_paths; 9495/* library paths */ 96char **library_paths; 97int nb_library_paths; 9899/* crt?.o object path */ 100char **crt_paths; 101int nb_crt_paths; 102103/* -D / -U options */ 104CString cmdline_defs; 105/* -include options */ 106CString cmdline_incl; 107108/* error handling */ 109void *error_opaque; 110void (*error_func)(void *opaque, const char *msg); 111int error_set_jmp_enabled; 112jmp_buf error_jmp_buf; 113int nb_errors; 114115/* output file for preprocessing (-E) */ 116FILE *ppfp; 117118/* for -MD/-MF: collected dependencies for this compilation */ 119char **target_deps; 120int nb_target_deps; 121122/* compilation */ 123BufferedFile *include_stack[INCLUDE_STACK_SIZE]; 124BufferedFile **include_stack_ptr; 125126int ifdef_stack[IFDEF_STACK_SIZE]; 127int *ifdef_stack_ptr; 128129/* included files enclosed with #ifndef MACRO */ 130int cached_includes_hash[CACHED_INCLUDES_HASH_SIZE]; 131CachedInclude **cached_includes; 132int nb_cached_includes; 133134/* #pragma pack stack */ 135int pack_stack[PACK_STACK_SIZE]; 136int *pack_stack_ptr; 137char **pragma_libs; 138int nb_pragma_libs; 139140/* inline functions are stored as token lists and compiled last 141only if referenced */ 142struct InlineFunc **inline_fns; 143int nb_inline_fns; 144145/* sections */ 146Section **sections; 147int nb_sections; /* number of sections, including first dummy section */ 148149Section **priv_sections; 150int nb_priv_sections; /* number of private sections */ 151152/* got \u0026amp; plt handling */ 153Section *got; 154Section *plt; 155156/* predefined sections */ 157Section *text_section, *data_section, *rodata_section, *bss_section; 158Section *common_section; 159Section *cur_text_section; /* current section where function code is generated */ 160#ifdef CONFIG_TCC_BCHECK 161 /* bound check related sections */ 162Section *bounds_section; /* contains global data bound description */ 163Section *lbounds_section; /* contains local data bound description */ 164#endif 165 /* test coverage */ 166Section *tcov_section; 167/* symbol sections */ 168Section *symtab_section; 169/* debug sections */ 170Section *stab_section; 171/* Is there a new undefined sym since last new_undef_sym() */ 172int new_undef_sym; 173174/* temporary dynamic symbol sections (for dll loading) */ 175Section *dynsymtab_section; 176/* exported dynamic symbol section */ 177Section *dynsym; 178/* copy of the global symtab_section variable */ 179Section *symtab; 180/* extra attributes (eg. GOT/PLT value) for symtab symbols */ 181struct sym_attr *sym_attrs; 182int nb_sym_attrs; 183/* ptr to next reloc entry reused */ 184ElfW_Rel *qrel; 185#define qrel s1-\u0026gt;qrel 186 187#ifdef TCC_TARGET_RISCV64 188 struct pcrel_hi { addr_t addr, val; } last_hi; 189#define last_hi s1-\u0026gt;last_hi 190#endif 191 192#ifdef TCC_TARGET_PE 193 /* PE info */ 194int pe_subsystem; 195unsigned pe_characteristics; 196unsigned pe_file_align; 197unsigned pe_stack_size; 198addr_t pe_imagebase; 199# ifdef TCC_TARGET_X86_64 200 Section *uw_pdata; 201int uw_sym; 202unsigned uw_offs; 203# endif 204#endif 205 206#ifndef ELF_OBJ_ONLY 207 int nb_sym_versions; 208struct sym_version *sym_versions; 209int nb_sym_to_version; 210int *sym_to_version; 211int dt_verneednum; 212Section *versym_section; 213Section *verneed_section; 214#endif 215 216#ifdef TCC_IS_NATIVE 217 const char *runtime_main; 218void **runtime_mem; 219int nb_runtime_mem; 220#endif 221 222#ifdef CONFIG_TCC_BACKTRACE 223 int rt_num_callers; 224#endif 225 226/* benchmark info */ 227int total_idents; 228int total_lines; 229int total_bytes; 230int total_output[4]; 231232/* option -dnum (for general development purposes) */ 233int g_debug; 234235/* used by tcc_load_ldscript */ 236int fd, cc; 237238/* for warnings/errors for object files */ 239const char *current_filename; 240241/* used by main and tcc_parse_args only */ 242struct filespec **files; /* files seen on command line */ 243int nb_files; /* number thereof */ 244int nb_libraries; /* number of libs thereof */ 245char *outfile; /* output filename */ 246char *deps_outfile; /* option -MF */ 247int argc; 248char **argv; 249}; 1LIBTCCAPI TCCState *tcc_new(void) 2{ 3TCCState *s; 45s = tcc_mallocz(sizeof(TCCState)); 6if (!s) 7return NULL; 8#ifdef MEM_DEBUG 9 ++nb_states; 10#endif 11 12#undef gnu_ext 13 14s-\u0026gt;gnu_ext = 1; 15s-\u0026gt;tcc_ext = 1; 16s-\u0026gt;nocommon = 1; 17s-\u0026gt;dollars_in_identifiers = 1; /*on by default like in gcc/clang*/ 18s-\u0026gt;cversion = 199901; /* default unless -std=c11 is supplied */ 19s-\u0026gt;warn_implicit_function_declaration = 1; 20s-\u0026gt;warn_discarded_qualifiers = 1; 21s-\u0026gt;ms_extensions = 1; 2223#ifdef CHAR_IS_UNSIGNED 24 s-\u0026gt;char_is_unsigned = 1; 25#endif 26#ifdef TCC_TARGET_I386 27 s-\u0026gt;seg_size = 32; 28#endif 29 /* enable this if you want symbols with leading underscore on windows: */ 30#if defined TCC_TARGET_MACHO /* || defined TCC_TARGET_PE */31 s-\u0026gt;leading_underscore = 1; 32#endif 33#ifdef TCC_TARGET_ARM 34 s-\u0026gt;float_abi = ARM_FLOAT_ABI; 35#endif 36 37s-\u0026gt;ppfp = stdout; 38/* might be used in error() before preprocess_start() */ 39s-\u0026gt;include_stack_ptr = s-\u0026gt;include_stack; 4041tccelf_new(s); 4243tcc_set_lib_path(s, CONFIG_TCCDIR); 44return s; 45} 4647LIBTCCAPI void tcc_delete(TCCState *s1) 48{ 49/* free sections */ 50tccelf_delete(s1); 5152/* free library paths */ 53dynarray_reset(\u0026amp;s1-\u0026gt;library_paths, \u0026amp;s1-\u0026gt;nb_library_paths); 54dynarray_reset(\u0026amp;s1-\u0026gt;crt_paths, \u0026amp;s1-\u0026gt;nb_crt_paths); 5556/* free include paths */ 57dynarray_reset(\u0026amp;s1-\u0026gt;include_paths, \u0026amp;s1-\u0026gt;nb_include_paths); 58dynarray_reset(\u0026amp;s1-\u0026gt;sysinclude_paths, \u0026amp;s1-\u0026gt;nb_sysinclude_paths); 5960tcc_free(s1-\u0026gt;tcc_lib_path); 61tcc_free(s1-\u0026gt;soname); 62tcc_free(s1-\u0026gt;rpath); 63tcc_free(s1-\u0026gt;init_symbol); 64tcc_free(s1-\u0026gt;fini_symbol); 65tcc_free(s1-\u0026gt;outfile); 66tcc_free(s1-\u0026gt;deps_outfile); 67dynarray_reset(\u0026amp;s1-\u0026gt;files, \u0026amp;s1-\u0026gt;nb_files); 68dynarray_reset(\u0026amp;s1-\u0026gt;target_deps, \u0026amp;s1-\u0026gt;nb_target_deps); 69dynarray_reset(\u0026amp;s1-\u0026gt;pragma_libs, \u0026amp;s1-\u0026gt;nb_pragma_libs); 70dynarray_reset(\u0026amp;s1-\u0026gt;argv, \u0026amp;s1-\u0026gt;argc); 71cstr_free(\u0026amp;s1-\u0026gt;cmdline_defs); 72cstr_free(\u0026amp;s1-\u0026gt;cmdline_incl); 73#ifdef TCC_IS_NATIVE 74 /* free runtime memory */ 75tcc_run_free(s1); 76#endif 77 78tcc_free(s1); 79#ifdef MEM_DEBUG 80 if (0 == --nb_states) 81tcc_memcheck(); 82#endif 83} 文件读取 文件描述信息 1typedef struct BufferedFile { 2uint8_t *buf_ptr; 3uint8_t *buf_end; 4int fd; 5struct BufferedFile *prev; 6int line_num; /* current line number - here to simplify code */ 7int line_ref; /* tcc -E: last printed line */ 8int ifndef_macro; /* #ifndef macro / #endif search */ 9int ifndef_macro_saved; /* saved ifndef_macro */ 10int *ifdef_stack_ptr; /* ifdef_stack value at the start of the file */ 11int include_next_index; /* next search path */ 12char filename[1024]; /* filename */ 13char *true_filename; /* filename not modified by # line directive */ 14unsigned char unget[4]; 15unsigned char buffer[1]; /* extra size for CH_EOB char */ 16} BufferedFile; 文件相关操作 1static int _tcc_open(TCCState *s1, const char *filename) 2{ 3int fd; 4if (strcmp(filename, \u0026#34;-\u0026#34;) == 0) 5fd = 0, filename = \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;; 6else 7fd = open(filename, O_RDONLY | O_BINARY); 8if ((s1-\u0026gt;verbose == 2 \u0026amp;\u0026amp; fd \u0026gt;= 0) || s1-\u0026gt;verbose == 3) 9printf(\u0026#34;%s %*s%s\\n\u0026#34;, fd \u0026lt; 0 ? \u0026#34;nf\u0026#34;:\u0026#34;-\u0026gt;\u0026#34;, 10(int)(s1-\u0026gt;include_stack_ptr - s1-\u0026gt;include_stack), \u0026#34;\u0026#34;, filename); 11return fd; 12} 1314ST_FUNC int tcc_open(TCCState *s1, const char *filename) 15{ 16int fd = _tcc_open(s1, filename); 17if (fd \u0026lt; 0) 18return -1; 19tcc_open_bf(s1, filename, 0); 20file-\u0026gt;fd = fd; 21return 0; 22} 2324ST_FUNC void tcc_close(void) 25{ 26TCCState *s1 = tcc_state; 27BufferedFile *bf = file; 28if (bf-\u0026gt;fd \u0026gt; 0) { 29close(bf-\u0026gt;fd); 30total_lines += bf-\u0026gt;line_num; 31} 32if (bf-\u0026gt;true_filename != bf-\u0026gt;filename) 33tcc_free(bf-\u0026gt;true_filename); 34file = bf-\u0026gt;prev; 35tcc_free(bf); 36} 词法分析 语法分析 类型检查 符号表 段机制 代码生成 ","date":"Nov 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/tinycc/","series":null,"tags":[],"title":"Tinycc"},{"categories":[],"content":"个人服务器安装记录 配置交换文件 1# 创建交换文件 2sudo fallocate -l 2G /swapfile 34# 修改权限只允许ROOT使用 5sudo chmod 600 /swapfile 67# 创建swapfile 8sudo mkswap /swapfile 910# 开启swapfile 11sudo swapon /swapfile 1213# 写入fstab 14echo \u0026#39;/swapfile none swap sw 0 0\u0026#39; | sudo tee -a /etc/fstab jenkins安装 安装jdk 1sudo apt install default-jdk 安装jenkins 1wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add - 2sudo sh -c \u0026#39;echo deb https://pkg.jenkins.io/debian-stable binary/ \u0026gt; /etc/apt/sources.list.d/jenkins.list\u0026#39; 3sudo apt-get update 4sudo apt-get install jenkins docker安装 安装依赖 1sudo apt install \\ 2 apt-transport-https \\ 3 ca-certificates \\ 4 curl \\ 5 gnupg-agent \\ 6 software-properties-common 安装公钥 1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 设置仓库 1sudo add-apt-repository \\ 2 \u0026#34;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \\ 3$(lsb_release -cs)\\ 4stable\u0026#34; 安装Docker 1sudo apt update 2sudo apt install docker-ce docker-ce-cli containerd.io 添加root组 1sudo usermod -aG docker `whoami` docker辅助工具  docker-compose lazydocker  嵌入式开发工具链 arm编译工具链 1sudo apt install gcc-arm-linux-gnueabihf 2sudo apt install gcc-arm-linux-gnueabi 3sudo apt install gcc-arm-none-eabi 测试工具 1sudo apt install qemu 2sudo apt install qemu-system-arm 3sudo apt install qemu-user-static 4sudo apt install qemu-user 5sudo apt install qemu-user-binfmt 打包工具 1sudo apt install u-boot-tools ","date":"Nov 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/server/","series":null,"tags":[],"title":"Server"},{"categories":[],"content":"bsdiff  bsdiff and bspatch are tools for building and applying patches to binary files. By using suffix \u0026gt; sorting (specifically, Larsson and Sadakane\u0026rsquo;s qsufsort) and taking advantage of how executable files change, bsdiff routinely produces binary patches 50-80% smaller than those produced by Xdelta, and 15% smaller than those produced by .RTPatch (a $2750/seat commercial patch tool) \u0026ndash; 直接摘抄自官网\n 详情可以查看bsdiff官网,存在这个详细描述.\n测试 新建立两个文件old.c与new.c,二者的差别是\n1// new.c 2#include \u0026lt;stdio.h\u0026gt;3int main(void) 4{ 5printf(\u0026#34;Hello World\\r\\n\u0026#34;); 6return 0; 7} 1#include \u0026lt;stdio.h\u0026gt;2int main(void) 3{ 4return 0; 5} 测试的情况\n1# 执行编译 2gcc old.c -o old \u0026amp;\u0026amp; ./old 3gcc new.c -o new \u0026amp;\u0026amp; ./new 计算md5\n1md5sum old 2# d08fd167e74f279522fe8aa64d8e27dd old 34md5sum new 5# b0b4be993de61064a118d32a692bf795 new 67md5sum mid 8# b0b4be993de61064a118d32a692bf795 mid 生成补丁并且测试\n1# 生成diff 2bsdiff old new test.diff 34# 打入补丁--\u0026gt;mid 5bspatch old mid test.diff 分析 接口分析 1struct bsdiff_stream 2{ 3void* opaque;\t/* bzip文件 */ 45void* (*malloc)(size_t size);\t/* 内存申请接口 */ 6void (*free)(void* ptr);\t/* 内存释放接口 */ 7int (*write)(struct bsdiff_stream* stream, /* 写文件接口 */ 8const void* buffer, int size); 9}; 1011struct bspatch_stream 12{ 13void* opaque;\t/* bzip文件 */ 14int (*read)(const struct bspatch_stream* stream, /* 读取文件接口 */ 15void* buffer, int length); 16}; 1718int bsdiff(const uint8_t* old, int64_t oldsize, 19const uint8_t* new, int64_t newsize, 20struct bsdiff_stream* stream); 2122int bspatch(const uint8_t* old, int64_t oldsize, 23uint8_t* new, int64_t newsize, 24struct bspatch_stream* stream); diff算法核心 bsdiff更新数据由四部分组成:Header,ctrl block,diff block,extra block\n Header描述了文件基本信息 ctrl 包含了ADD和INSERT指令的控制文件  每一个ADD指令指定了旧文件中的偏移位置和长度，从旧文件中读取相应数量的字节内容并且从差异文件中读取相同字节的内容添加进去。 INSERT指令仅仅制定一个长度，用于从额外文件中读取指定数量的字节内容   diff 含了概率匹配中不同字节内容的差异文件 extra 包含了不属于概略匹配中内容的额外的文件  Header的结构:    start/bytes length/bytes content     0 8 \u0026ldquo;BSDIFF40\u0026rdquo;   8 8 the length of ctrl block   16 8 the length of diff block   24 8 新文件的大小      BSDIFF40 0x93 \u0026ndash;\u0026gt; 147 0x313 \u0026ndash;\u0026gt; 787 0x3ED0 \u0026ndash;\u0026gt; 16080 可以匹配新生成的文件  代码分析 偏移信息与字符串信息相互转化 1/* 一般情况下,buf的长度为8个字节 */ 2static int64_t offtin(uint8_t *buf) 3{ 4int64_t y; 56y=buf[7]\u0026amp;0x7F; /* 提取绝对值 */ 78y=y*256;y+=buf[6]; 9y=y*256;y+=buf[5]; 10y=y*256;y+=buf[4]; 11y=y*256;y+=buf[3]; 12y=y*256;y+=buf[2]; 13y=y*256;y+=buf[1]; 14y=y*256;y+=buf[0]; 1516/* 根据最高位置确定正负 */ 17if (buf[7] \u0026amp; 0x80) { 18y=-y; 19} 2021return y; 22} 23static void offtout(int64_t x,uint8_t *buf) 24{ 25int64_t y; 2627/* 保证 y = |x| */ 28if (x \u0026lt; 0) { 29y = -x; 30} 31else { 32y = x; 33} 3435buf[0]=y%256;y-=buf[0]; 36y=y/256;buf[1]=y%256;y-=buf[1]; 37y=y/256;buf[2]=y%256;y-=buf[2]; 38y=y/256;buf[3]=y%256;y-=buf[3]; 39y=y/256;buf[4]=y%256;y-=buf[4]; 40y=y/256;buf[5]=y%256;y-=buf[5]; 41y=y/256;buf[6]=y%256;y-=buf[6]; 42y=y/256;buf[7]=y%256; 4344if(x\u0026lt;0) buf[7]|=0x80; 45} patch代码分析 总体的执行路径  1int bspatch(const uint8_t* old, int64_t oldsize, 2uint8_t* new, int64_t newsize, 3struct bspatch_stream* stream) 4{ 5uint8_t buf[8]; 6int64_t oldpos; 7int64_t newpos; 8int64_t ctrl[3]; 9int64_t i; 1011oldpos=0; 12newpos=0; 13while (newpos \u0026lt; newsize) { 14/* Read control data 3*8个为一组,每次生成3个控制数据 */ 15for(i=0;i\u0026lt;=2;i++) { 16if (stream-\u0026gt;read(stream, buf, 8)) 17return -1; 18ctrl[i]=offtin(buf); 19}; 2021/* 健壮性检查 */ 22if (ctrl[0]\u0026lt;0 || ctrl[0]\u0026gt;INT_MAX || 23ctrl[1]\u0026lt;0 || ctrl[1]\u0026gt;INT_MAX || 24newpos+ctrl[0]\u0026gt;newsize) 25return -1; 2627/* Read diff string */ 28if (stream-\u0026gt;read(stream, new + newpos, ctrl[0])) 29return -1; 3031/* Add old data to diff string */ 32for(i=0;i\u0026lt;ctrl[0];i++) 33if((oldpos+i\u0026gt;=0) \u0026amp;\u0026amp; (oldpos+i\u0026lt;oldsize)) 34new[newpos+i]+=old[oldpos+i]; 3536/* Adjust pointers */ 37newpos+=ctrl[0]; 38oldpos+=ctrl[0]; 3940/* Sanity-check */ 41if(newpos+ctrl[1]\u0026gt;newsize) 42return -1; 4344/* Read extra string */ 45if (stream-\u0026gt;read(stream, new + newpos, ctrl[1])) 46return -1; 4748/* Adjust pointers */ 49newpos+=ctrl[1]; 50oldpos+=ctrl[2]; 51}; 5253return 0; 54} 主要函数的调用路线\n qsufsort  调用qsufsort该函数生成后缀数组,但是后缀数组是什么? 我现在还没有理解\n 参数分析:\n I 后缀数组 V 辅助信息 old 原始文件 oldsiz原始文件大小  1static void qsufsort(int64_t *I,int64_t *V,const uint8_t *old,int64_t oldsize) 2{ 3int64_t buckets[256]; 4int64_t i,h,len; 56for(i=0;i\u0026lt;256;i++) buckets[i]=0; 7for(i=0;i\u0026lt;oldsize;i++) buckets[old[i]]++; 8for(i=1;i\u0026lt;256;i++) buckets[i]+=buckets[i-1]; 9for(i=255;i\u0026gt;0;i--) buckets[i]=buckets[i-1]; 10buckets[0]=0; 1112for(i=0;i\u0026lt;oldsize;i++) I[++buckets[old[i]]]=i; 13I[0]=oldsize; 14for(i=0;i\u0026lt;oldsize;i++) V[i]=buckets[old[i]]; 15V[oldsize]=0; 16for(i=1;i\u0026lt;256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1; 17I[0]=-1; 1819for(h=1;I[0]!=-(oldsize+1);h+=h) { 20len=0; 21for(i=0;i\u0026lt;oldsize+1;) { 22if(I[i]\u0026lt;0) { 23len-=I[i]; 24i-=I[i]; 25} else { 26if(len) I[i-len]=-len; 27len=V[I[i]]+1-i; 28split(I,V,i,len,h); 29i+=len; 30len=0; 31}; 32}; 33if(len) I[i-len]=-len; 34}; 3536for(i=0;i\u0026lt;oldsize+1;i++) I[V[i]]=i; 37} 3839static void split(int64_t *I,int64_t *V,int64_t start,int64_t len,int64_t h) 40{ 41int64_t i,j,k,x,tmp,jj,kk; 4243if(len\u0026lt;16) { 44for(k=start;k\u0026lt;start+len;k+=j) { 45j=1;x=V[I[k]+h]; 46for(i=1;k+i\u0026lt;start+len;i++) { 47if(V[I[k+i]+h]\u0026lt;x) { 48x=V[I[k+i]+h]; 49j=0; 50}; 51if(V[I[k+i]+h]==x) { 52tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp; 53j++; 54}; 55}; 56for(i=0;i\u0026lt;j;i++) V[I[k+i]]=k+j-1; 57if(j==1) I[k]=-1; 58}; 59return; 60}; 6162x=V[I[start+len/2]+h]; 63jj=0;kk=0; 64for(i=start;i\u0026lt;start+len;i++) { 65if(V[I[i]+h]\u0026lt;x) jj++; 66if(V[I[i]+h]==x) kk++; 67}; 68jj+=start;kk+=jj; 6970i=start;j=0;k=0; 71while(i\u0026lt;jj) { 72if(V[I[i]+h]\u0026lt;x) { 73i++; 74} else if(V[I[i]+h]==x) { 75tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp; 76j++; 77} else { 78tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp; 79k++; 80}; 81}; 8283while(jj+j\u0026lt;kk) { 84if(V[I[jj+j]+h]==x) { 85j++; 86} else { 87tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp; 88k++; 89}; 90}; 9192if(jj\u0026gt;start) split(I,V,start,jj-start,h); 9394for(i=0;i\u0026lt;kk-jj;i++) V[I[jj+i]]=kk-1; 95if(jj==kk-1) I[jj]=-1; 9697if(start+len\u0026gt;kk) split(I,V,kk,start+len-kk,h); 98} search 1static int64_t matchlen(const uint8_t *old,int64_t oldsize,const uint8_t *new,int64_t newsize) 2{ 3int64_t i; 45for(i=0;(i\u0026lt;oldsize)\u0026amp;\u0026amp;(i\u0026lt;newsize);i++) 6if(old[i]!=new[i]) break; 78return i; 9} 10static int64_t search(const int64_t *I,const uint8_t *old,int64_t oldsize, 11const uint8_t *new,int64_t newsize,int64_t st,int64_t en,int64_t *pos) 12{ 13int64_t x,y; 1415if(en-st\u0026lt;2) { 16x=matchlen(old+I[st],oldsize-I[st],new,newsize); 17y=matchlen(old+I[en],oldsize-I[en],new,newsize); 1819if(x\u0026gt;y) { 20*pos=I[st]; 21return x; 22} else { 23*pos=I[en]; 24return y; 25} 26}; 2728x=st+(en-st)/2; 29if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))\u0026lt;0) { 30return search(I,old,oldsize,new,newsize,x,en,pos); 31} else { 32return search(I,old,oldsize,new,newsize,st,x,pos); 33}; 34} writedata 1static int64_t writedata(struct bsdiff_stream* stream, 2const void* buffer, int64_t length) 3{ 4int64_t result = 0; 56while (length \u0026gt; 0) 7{ 8const int smallsize = (int)MIN(length, INT_MAX); 9const int writeresult = stream-\u0026gt;write(stream, buffer, smallsize); 10if (writeresult == -1) 11{ 12return -1; 13} 1415result += writeresult; 16length -= smallsize; 17buffer = (uint8_t*)buffer + smallsize; 18} 1920return result; 21} diff文件生成核心代码 1struct bsdiff_request 2{ 3const uint8_t* old; 4int64_t oldsize; 5const uint8_t* new; 6int64_t newsize; 7struct bsdiff_stream* stream; 8int64_t *I; 9uint8_t *buffer; 10}; 1112static int bsdiff_internal(const struct bsdiff_request req) 13{ 14int64_t *I,*V; 15int64_t scan,pos,len; 16int64_t lastscan,lastpos,lastoffset; 17int64_t oldscore,scsc; 18int64_t s,Sf,lenf,Sb,lenb; 19int64_t overlap,Ss,lens; 20int64_t i; 21uint8_t *buffer; 22uint8_t buf[8 * 3]; 2324if((V=req.stream-\u0026gt;malloc((req.oldsize+1)*sizeof(int64_t)))==NULL) return -1; 25I = req.I; 2627qsufsort(I,V,req.old,req.oldsize); 2829req.stream-\u0026gt;free(V); 3031buffer = req.buffer; 3233/* Compute the differences, writing ctrl as we go */ 34scan=0;len=0;pos=0; 35lastscan=0;lastpos=0;lastoffset=0; 36while(scan\u0026lt;req.newsize) { 37oldscore=0; 3839for(scsc=scan+=len;scan\u0026lt;req.newsize;scan++) { 40len=search(I,req.old,req.oldsize,req.new+scan,req.newsize-scan, 410,req.oldsize,\u0026amp;pos); 4243for(;scsc\u0026lt;scan+len;scsc++) 44if((scsc+lastoffset\u0026lt;req.oldsize) \u0026amp;\u0026amp; 45(req.old[scsc+lastoffset] == req.new[scsc])) 46oldscore++; 4748if(((len==oldscore) \u0026amp;\u0026amp; (len!=0)) || 49(len\u0026gt;oldscore+8)) break; 5051if((scan+lastoffset\u0026lt;req.oldsize) \u0026amp;\u0026amp; 52(req.old[scan+lastoffset] == req.new[scan])) 53oldscore--; 54}; 5556if((len!=oldscore) || (scan==req.newsize)) { 57s=0;Sf=0;lenf=0; 58for(i=0;(lastscan+i\u0026lt;scan)\u0026amp;\u0026amp;(lastpos+i\u0026lt;req.oldsize);) { 59if(req.old[lastpos+i]==req.new[lastscan+i]) s++; 60i++; 61if(s*2-i\u0026gt;Sf*2-lenf) { Sf=s; lenf=i; }; 62}; 6364lenb=0; 65if(scan\u0026lt;req.newsize) { 66s=0;Sb=0; 67for(i=1;(scan\u0026gt;=lastscan+i)\u0026amp;\u0026amp;(pos\u0026gt;=i);i++) { 68if(req.old[pos-i]==req.new[scan-i]) s++; 69if(s*2-i\u0026gt;Sb*2-lenb) { Sb=s; lenb=i; }; 70}; 71}; 7273if(lastscan+lenf\u0026gt;scan-lenb) { 74overlap=(lastscan+lenf)-(scan-lenb); 75s=0;Ss=0;lens=0; 76for(i=0;i\u0026lt;overlap;i++) { 77if(req.new[lastscan+lenf-overlap+i]== 78req.old[lastpos+lenf-overlap+i]) s++; 79if(req.new[scan-lenb+i]== 80req.old[pos-lenb+i]) s--; 81if(s\u0026gt;Ss) { Ss=s; lens=i+1; }; 82}; 8384lenf+=lens-overlap; 85lenb-=lens; 86}; 8788offtout(lenf,buf); 89offtout((scan-lenb)-(lastscan+lenf),buf+8); 90offtout((pos-lenb)-(lastpos+lenf),buf+16); 9192/* Write control data */ 93if (writedata(req.stream, buf, sizeof(buf))) 94return -1; 9596/* Write diff data */ 97for(i=0;i\u0026lt;lenf;i++) 98buffer[i]=req.new[lastscan+i]-req.old[lastpos+i]; 99if (writedata(req.stream, buffer, lenf)) 100return -1; 101102/* Write extra data */ 103for(i=0;i\u0026lt;(scan-lenb)-(lastscan+lenf);i++) 104buffer[i]=req.new[lastscan+lenf+i]; 105if (writedata(req.stream, buffer, (scan-lenb)-(lastscan+lenf))) 106return -1; 107108lastscan=scan-lenb; 109lastpos=pos-lenb; 110lastoffset=pos-scan; 111}; 112}; 113114return 0; 115} ","date":"Oct 30, 2021","img":"","permalink":"https://mengdemao.github.io/posts/bsdiff/","series":null,"tags":[],"title":"Bsdiff"},{"categories":[],"content":"ARM笔记 ARM体系结构 相关术语  流水线 DSP Jazelle ThumbEE Thumb-2 TrustZone VFP NEON LAPE big.LITTLE  工具链    文件名 详解     addr2line 把程序地址转化为文件名和行号   ar 建立、修改和提取归档文件   as 汇编编译器   ld 链接器   nm 列出文件的符号   objcopy 文件个数格式转换   objdump 反汇编   ranlib 产生索引,并且保存进入文件中   readelf 显示elf文件信息   size 列出文件大小   string 打印文件可打印字符串   strip 丢弃文件符号    交叉工具链测试\n1arm-none-linux-gnueabihf-addr2line arm-none-linux-gnueabihf-gdb 2arm-none-linux-gnueabihf-ar arm-none-linux-gnueabihf-gdb-add-index 3arm-none-linux-gnueabihf-as arm-none-linux-gnueabihf-gfortran 4arm-none-linux-gnueabihf-c++ arm-none-linux-gnueabihf-gprof 5arm-none-linux-gnueabihf-c++filt arm-none-linux-gnueabihf-ld 6arm-none-linux-gnueabihf-cpp arm-none-linux-gnueabihf-ld.bfd 7arm-none-linux-gnueabihf-dwp arm-none-linux-gnueabihf-ld.gold 8arm-none-linux-gnueabihf-elfedit arm-none-linux-gnueabihf-lto-dump 9arm-none-linux-gnueabihf-g++ arm-none-linux-gnueabihf-nm 10arm-none-linux-gnueabihf-gcc arm-none-linux-gnueabihf-objcopy 11arm-none-linux-gnueabihf-gcc-10.2.1 arm-none-linux-gnueabihf-objdump 12arm-none-linux-gnueabihf-gcc-ar arm-none-linux-gnueabihf-ranlib 13arm-none-linux-gnueabihf-gcc-nm arm-none-linux-gnueabihf-readelf 14arm-none-linux-gnueabihf-gcc-ranlib arm-none-linux-gnueabihf-size 15arm-none-linux-gnueabihf-gcov arm-none-linux-gnueabihf-strings 16arm-none-linux-gnueabihf-gcov-dump arm-none-linux-gnueabihf-strip 17arm-none-linux-gnueabihf-gcov-tool ARMv7处理器模式    模式 编码 功能 安全 优先级     User (USR) 10000 大多数运行的非特权模式 Both PL0   FIQ 10001 FIQ中断 Both PL1   IRQ 10010 IRQ中断 Both PL1   Supervisor (SVC) 10011 设备重启或者SVC指令 Both PL1   Monitor (MON) 10110 安全扩展实现 only PL1   Abort (ABT) 10111 内存权限异常 Both PL1   Hyp (HYP) 11010 虚拟化扩展实现. Non-secure PL2   Undef (UND) 11011 未定义指令调用 Both PL1   System (SYS) 11111 特权模式,与用户模式共享寄存器 Both PL1    不同的处理器模式上寄存器共享的情况\n ARM指令集 翻译结果 统一汇编语言 分支指令 数据处理指令    指令 作用     LSL Logical Shift Left by 1-31 bits.   LSR Logical Shift Right by 1-32 bits.   ASR Arithmetic Shift Right by 1-32 bits.   ROR Rotate Right by 1-31 bits.   RRX Rotate Right with Extend.    状态寄存器访问指令 加载存储指令 加载存储多条指令 杂项指令 异常生成与处理指令 协处理器指令 SIMD指令 ","date":"Oct 30, 2021","img":"","permalink":"https://mengdemao.github.io/posts/arm/","series":null,"tags":[],"title":"Arm"},{"categories":["linux"],"content":"IDLE调度器类 1/* 2* Generic entry points for the idle threads and 3* implementation of the idle task scheduling class. 4* 5* (NOTE: these are not related to SCHED_IDLE batch scheduled 6* tasks which are handled in sched/fair.c ) 7*/ 8#include \u0026#34;sched.h\u0026#34;9 10#include \u0026lt;trace/events/power.h\u0026gt;11 12/* Linker adds these: start and end of __cpuidle functions */ 13extern char __cpuidle_text_start[], __cpuidle_text_end[]; 1415/** 16* sched_idle_set_state - Record idle state for the current CPU. 17* @idle_state: State to record. 18*/ 19void sched_idle_set_state(struct cpuidle_state *idle_state) 20{ 21idle_set_state(this_rq(), idle_state); 22} 2324static int __read_mostly cpu_idle_force_poll; 2526void cpu_idle_poll_ctrl(bool enable) 27{ 28if (enable) { 29cpu_idle_force_poll++; 30} else { 31cpu_idle_force_poll--; 32WARN_ON_ONCE(cpu_idle_force_poll \u0026lt; 0); 33} 34} 3536#ifdef CONFIG_GENERIC_IDLE_POLL_SETUP 37static int __init cpu_idle_poll_setup(char *__unused) 38{ 39cpu_idle_force_poll = 1; 4041return 1; 42} 43__setup(\u0026#34;nohlt\u0026#34;, cpu_idle_poll_setup); 4445static int __init cpu_idle_nopoll_setup(char *__unused) 46{ 47cpu_idle_force_poll = 0; 4849return 1; 50} 51__setup(\u0026#34;hlt\u0026#34;, cpu_idle_nopoll_setup); 52#endif 53 54static noinline int __cpuidle cpu_idle_poll(void) 55{ 56rcu_idle_enter(); 57trace_cpu_idle_rcuidle(0, smp_processor_id()); 58local_irq_enable(); 59stop_critical_timings(); 6061while (!tif_need_resched() \u0026amp;\u0026amp; 62(cpu_idle_force_poll || tick_check_broadcast_expired())) 63cpu_relax(); 64start_critical_timings(); 65trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id()); 66rcu_idle_exit(); 6768return 1; 69} 7071/* Weak implementations for optional arch specific functions */ 72void __weak arch_cpu_idle_prepare(void) { } 73void __weak arch_cpu_idle_enter(void) { } 74void __weak arch_cpu_idle_exit(void) { } 75void __weak arch_cpu_idle_dead(void) { } 76void __weak arch_cpu_idle(void) 77{ 78cpu_idle_force_poll = 1; 79local_irq_enable(); 80} 8182/** 83* default_idle_call - Default CPU idle routine. 84* 85* To use when the cpuidle framework cannot be used. 86*/ 87void __cpuidle default_idle_call(void) 88{ 89if (current_clr_polling_and_test()) { 90local_irq_enable(); 91} else { 92stop_critical_timings(); 93arch_cpu_idle(); 94start_critical_timings(); 95} 96} 9798static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev, 99int next_state) 100{ 101/* 102* The idle task must be scheduled, it is pointless to go to idle, just 103* update no idle residency and return. 104*/ 105if (current_clr_polling_and_test()) { 106dev-\u0026gt;last_residency = 0; 107local_irq_enable(); 108return -EBUSY; 109} 110111/* 112* Enter the idle state previously returned by the governor decision. 113* This function will block until an interrupt occurs and will take 114* care of re-enabling the local interrupts 115*/ 116return cpuidle_enter(drv, dev, next_state); 117} 118119/** 120* cpuidle_idle_call - the main idle function 121* 122* NOTE: no locks or semaphores should be used here 123* 124* On archs that support TIF_POLLING_NRFLAG, is called with polling 125* set, and it returns with polling set. If it ever stops polling, it 126* must clear the polling bit. 127*/ 128static void cpuidle_idle_call(void) 129{ 130struct cpuidle_device *dev = cpuidle_get_device(); 131struct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev); 132int next_state, entered_state; 133134/* 135* Check if the idle task must be rescheduled. If it is the 136* case, exit the function after re-enabling the local irq. 137*/ 138if (need_resched()) { 139local_irq_enable(); 140return; 141} 142143/* 144* The RCU framework needs to be told that we are entering an idle 145* section, so no more rcu read side critical sections and one more 146* step to the grace period 147*/ 148149if (cpuidle_not_available(drv, dev)) { 150tick_nohz_idle_stop_tick(); 151rcu_idle_enter(); 152153default_idle_call(); 154goto exit_idle; 155} 156157/* 158* Suspend-to-idle (\u0026#34;s2idle\u0026#34;) is a system state in which all user space 159* has been frozen, all I/O devices have been suspended and the only 160* activity happens here and in iterrupts (if any). In that case bypass 161* the cpuidle governor and go stratight for the deepest idle state 162* available. Possibly also suspend the local tick and the entire 163* timekeeping to prevent timer interrupts from kicking us out of idle 164* until a proper wakeup interrupt happens. 165*/ 166167if (idle_should_enter_s2idle() || dev-\u0026gt;use_deepest_state) { 168if (idle_should_enter_s2idle()) { 169rcu_idle_enter(); 170171entered_state = cpuidle_enter_s2idle(drv, dev); 172if (entered_state \u0026gt; 0) { 173local_irq_enable(); 174goto exit_idle; 175} 176177rcu_idle_exit(); 178} 179180tick_nohz_idle_stop_tick(); 181rcu_idle_enter(); 182183next_state = cpuidle_find_deepest_state(drv, dev); 184call_cpuidle(drv, dev, next_state); 185} else { 186bool stop_tick = true; 187188/* 189* Ask the cpuidle framework to choose a convenient idle state. 190*/ 191next_state = cpuidle_select(drv, dev, \u0026amp;stop_tick); 192193if (stop_tick || tick_nohz_tick_stopped()) 194tick_nohz_idle_stop_tick(); 195else 196tick_nohz_idle_retain_tick(); 197198rcu_idle_enter(); 199200entered_state = call_cpuidle(drv, dev, next_state); 201/* 202* Give the governor an opportunity to reflect on the outcome 203*/ 204cpuidle_reflect(dev, entered_state); 205} 206207exit_idle: 208__current_set_polling(); 209210/* 211* It is up to the idle functions to reenable local interrupts 212*/ 213if (WARN_ON_ONCE(irqs_disabled())) 214local_irq_enable(); 215216rcu_idle_exit(); 217} 218219/* 220* Generic idle loop implementation 221* 222* Called with polling cleared. 223*/ 224static void do_idle(void) 225{ 226int cpu = smp_processor_id(); 227/* 228* If the arch has a polling bit, we maintain an invariant: 229* 230* Our polling bit is clear if we\u0026#39;re not scheduled (i.e. if rq-\u0026gt;curr != 231* rq-\u0026gt;idle). This means that, if rq-\u0026gt;idle has the polling bit set, 232* then setting need_resched is guaranteed to cause the CPU to 233* reschedule. 234*/ 235236__current_set_polling(); 237tick_nohz_idle_enter(); 238239while (!need_resched()) { 240check_pgt_cache(); 241rmb(); 242243local_irq_disable(); 244245if (cpu_is_offline(cpu)) { 246tick_nohz_idle_stop_tick(); 247cpuhp_report_idle_dead(); 248arch_cpu_idle_dead(); 249} 250251arch_cpu_idle_enter(); 252253/* 254* In poll mode we reenable interrupts and spin. Also if we 255* detected in the wakeup from idle path that the tick 256* broadcast device expired for us, we don\u0026#39;t want to go deep 257* idle as we know that the IPI is going to arrive right away. 258*/ 259if (cpu_idle_force_poll || tick_check_broadcast_expired()) { 260tick_nohz_idle_restart_tick(); 261cpu_idle_poll(); 262} else { 263cpuidle_idle_call(); 264} 265arch_cpu_idle_exit(); 266} 267268/* 269* Since we fell out of the loop above, we know TIF_NEED_RESCHED must 270* be set, propagate it into PREEMPT_NEED_RESCHED. 271* 272* This is required because for polling idle loops we will not have had 273* an IPI to fold the state for us. 274*/ 275preempt_set_need_resched(); 276tick_nohz_idle_exit(); 277__current_clr_polling(); 278279/* 280* We promise to call sched_ttwu_pending() and reschedule if 281* need_resched() is set while polling is set. That means that clearing 282* polling needs to be visible before doing these things. 283*/ 284smp_mb__after_atomic(); 285286sched_ttwu_pending(); 287schedule_idle(); 288289if (unlikely(klp_patch_pending(current))) 290klp_update_patch_state(current); 291} 292293bool cpu_in_idle(unsigned long pc) 294{ 295return pc \u0026gt;= (unsigned long)__cpuidle_text_start \u0026amp;\u0026amp; 296pc \u0026lt; (unsigned long)__cpuidle_text_end; 297} 298299struct idle_timer { 300struct hrtimer timer; 301int done; 302}; 303304static enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer) 305{ 306struct idle_timer *it = container_of(timer, struct idle_timer, timer); 307308WRITE_ONCE(it-\u0026gt;done, 1); 309set_tsk_need_resched(current); 310311return HRTIMER_NORESTART; 312} 313314void play_idle(unsigned long duration_ms) 315{ 316struct idle_timer it; 317318/* 319* Only FIFO tasks can disable the tick since they don\u0026#39;t need the forced 320* preemption. 321*/ 322WARN_ON_ONCE(current-\u0026gt;policy != SCHED_FIFO); 323WARN_ON_ONCE(current-\u0026gt;nr_cpus_allowed != 1); 324WARN_ON_ONCE(!(current-\u0026gt;flags \u0026amp; PF_KTHREAD)); 325WARN_ON_ONCE(!(current-\u0026gt;flags \u0026amp; PF_NO_SETAFFINITY)); 326WARN_ON_ONCE(!duration_ms); 327328rcu_sleep_check(); 329preempt_disable(); 330current-\u0026gt;flags |= PF_IDLE; 331cpuidle_use_deepest_state(true); 332333it.done = 0; 334hrtimer_init_on_stack(\u0026amp;it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); 335it.timer.function = idle_inject_timer_fn; 336hrtimer_start(\u0026amp;it.timer, ms_to_ktime(duration_ms), HRTIMER_MODE_REL_PINNED); 337338while (!READ_ONCE(it.done)) 339do_idle(); 340341cpuidle_use_deepest_state(false); 342current-\u0026gt;flags \u0026amp;= ~PF_IDLE; 343344preempt_fold_need_resched(); 345preempt_enable(); 346} 347EXPORT_SYMBOL_GPL(play_idle); 348349void cpu_startup_entry(enum cpuhp_state state) 350{ 351/* 352* This #ifdef needs to die, but it\u0026#39;s too late in the cycle to 353* make this generic (ARM and SH have never invoked the canary 354* init for the non boot CPUs!). Will be fixed in 3.11 355*/ 356#ifdef CONFIG_X86 357\t/* 358* If we\u0026#39;re the non-boot CPU, nothing set the stack canary up 359* for us. The boot CPU already has it initialized but no harm 360* in doing it again. This is a good place for updating it, as 361* we wont ever return from this function (so the invalid 362* canaries already on the stack wont ever trigger). 363*/ 364boot_init_stack_canary(); 365#endif 366\tarch_cpu_idle_prepare(); 367cpuhp_online_idle(state); 368while (1) 369do_idle(); 370} 371372/* 373* idle-task scheduling class. 374*/ 375376#ifdef CONFIG_SMP 377static int 378select_task_rq_idle(struct task_struct *p, int cpu, int sd_flag, int flags) 379{ 380return task_cpu(p); /* IDLE tasks as never migrated */ 381} 382#endif 383 384/* 385* Idle tasks are unconditionally rescheduled: 386*/ 387static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags) 388{ 389resched_curr(rq); 390} 391392static struct task_struct * 393pick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf) 394{ 395put_prev_task(rq, prev); 396update_idle_core(rq); 397schedstat_inc(rq-\u0026gt;sched_goidle); 398399return rq-\u0026gt;idle; 400} 401402/* 403* It is not legal to sleep in the idle task - print a warning 404* message if some code attempts to do it: 405*/ 406static void 407dequeue_task_idle(struct rq *rq, struct task_struct *p, int flags) 408{ 409raw_spin_unlock_irq(\u0026amp;rq-\u0026gt;lock); 410printk(KERN_ERR \u0026#34;bad: scheduling from the idle thread!\\n\u0026#34;); 411dump_stack(); 412raw_spin_lock_irq(\u0026amp;rq-\u0026gt;lock); 413} 414415static void put_prev_task_idle(struct rq *rq, struct task_struct *prev) 416{ 417} 418419/* 420* scheduler tick hitting a task of our scheduling class. 421* 422* NOTE: This function can be called remotely by the tick offload that 423* goes along full dynticks. Therefore no local assumption can be made 424* and everything must be accessed through the @rq and @curr passed in 425* parameters. 426*/ 427static void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued) 428{ 429} 430431static void set_curr_task_idle(struct rq *rq) 432{ 433} 434435static void switched_to_idle(struct rq *rq, struct task_struct *p) 436{ 437BUG(); 438} 439440static void 441prio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio) 442{ 443BUG(); 444} 445446static unsigned int get_rr_interval_idle(struct rq *rq, struct task_struct *task) 447{ 448return 0; 449} 450451static void update_curr_idle(struct rq *rq) 452{ 453} 454455/* 456* Simple, special scheduling class for the per-CPU idle tasks: 457*/ 458const struct sched_class idle_sched_class = { 459/* .next is NULL */ 460/* no enqueue/yield_task for idle tasks */ 461462/* dequeue is not valid, we print a debug message there: */ 463.dequeue_task\t= dequeue_task_idle, 464465.check_preempt_curr\t= check_preempt_curr_idle, 466467.pick_next_task\t= pick_next_task_idle, 468.put_prev_task\t= put_prev_task_idle, 469470#ifdef CONFIG_SMP 471\t.select_task_rq\t= select_task_rq_idle, 472.set_cpus_allowed\t= set_cpus_allowed_common, 473#endif 474 475.set_curr_task = set_curr_task_idle, 476.task_tick\t= task_tick_idle, 477478.get_rr_interval\t= get_rr_interval_idle, 479480.prio_changed\t= prio_changed_idle, 481.switched_to\t= switched_to_idle, 482.update_curr\t= update_curr_idle, 483}; ","date":"Oct 28, 2021","img":"","permalink":"https://mengdemao.github.io/posts/idle/","series":null,"tags":["kernel"],"title":"Idle"},{"categories":["linux"],"content":"完全公平调度器 1const struct sched_class fair_sched_class = { 2.next\t= \u0026amp;idle_sched_class, 3.enqueue_task\t= enqueue_task_fair, 4.dequeue_task\t= dequeue_task_fair, 5.yield_task\t= yield_task_fair, 6.yield_to_task\t= yield_to_task_fair, 78.check_preempt_curr\t= check_preempt_wakeup, 910.pick_next_task\t= pick_next_task_fair, 11.put_prev_task\t= put_prev_task_fair, 1213#ifdef CONFIG_SMP 14\t.select_task_rq\t= select_task_rq_fair, 15.migrate_task_rq\t= migrate_task_rq_fair, 1617.rq_online\t= rq_online_fair, 18.rq_offline\t= rq_offline_fair, 1920.task_dead\t= task_dead_fair, 21.set_cpus_allowed\t= set_cpus_allowed_common, 22#endif 23 24.set_curr_task = set_curr_task_fair, 25.task_tick\t= task_tick_fair, 26.task_fork\t= task_fork_fair, 2728.prio_changed\t= prio_changed_fair, 29.switched_from\t= switched_from_fair, 30.switched_to\t= switched_to_fair, 3132.get_rr_interval\t= get_rr_interval_fair, 3334.update_curr\t= update_curr_fair, 3536#ifdef CONFIG_FAIR_GROUP_SCHED 37\t.task_change_group\t= task_change_group_fair, 38#endif 39}; 调度器类分析\n1struct sched_class { 2const struct sched_class *next; 34void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags); 5void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags); 6void (*yield_task) (struct rq *rq); 7bool (*yield_to_task)(struct rq *rq, struct task_struct *p, bool preempt); 89void (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags); 1011/* 12* It is the responsibility of the pick_next_task() method that will 13* return the next task to call put_prev_task() on the @prev task or 14* something equivalent. 15* 16* May return RETRY_TASK when it finds a higher prio class has runnable 17* tasks. 18*/ 19struct task_struct * (*pick_next_task)(struct rq *rq, 20struct task_struct *prev, 21struct rq_flags *rf); 22void (*put_prev_task)(struct rq *rq, struct task_struct *p); 2324#ifdef CONFIG_SMP 25\tint (*select_task_rq)(struct task_struct *p, int task_cpu, int sd_flag, int flags); 26void (*migrate_task_rq)(struct task_struct *p, int new_cpu); 2728void (*task_woken)(struct rq *this_rq, struct task_struct *task); 2930void (*set_cpus_allowed)(struct task_struct *p, 31const struct cpumask *newmask); 3233void (*rq_online)(struct rq *rq); 34void (*rq_offline)(struct rq *rq); 35#endif 36 37void (*set_curr_task)(struct rq *rq); 38void (*task_tick)(struct rq *rq, struct task_struct *p, int queued); 39void (*task_fork)(struct task_struct *p); 40void (*task_dead)(struct task_struct *p); 4142/* 43* The switched_from() call is allowed to drop rq-\u0026gt;lock, therefore we 44* cannot assume the switched_from/switched_to pair is serliazed by 45* rq-\u0026gt;lock. They are however serialized by p-\u0026gt;pi_lock. 46*/ 47void (*switched_from)(struct rq *this_rq, struct task_struct *task); 48void (*switched_to) (struct rq *this_rq, struct task_struct *task); 49void (*prio_changed) (struct rq *this_rq, struct task_struct *task, 50int oldprio); 5152unsigned int (*get_rr_interval)(struct rq *rq, 53struct task_struct *task); 5455void (*update_curr)(struct rq *rq); 5657#define TASK_SET_GROUP\t0 58#define TASK_MOVE_GROUP\t1 59 60#ifdef CONFIG_FAIR_GROUP_SCHED 61\tvoid (*task_change_group)(struct task_struct *p, int type); 62#endif 63}; enqueue_task_fair 1static void 2enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags) 3{ 4struct cfs_rq *cfs_rq; 5struct sched_entity *se = \u0026amp;p-\u0026gt;se; 67/* 8* The code below (indirectly) updates schedutil which looks at 9* the cfs_rq utilization to select a frequency. 10* Let\u0026#39;s add the task\u0026#39;s estimated utilization to the cfs_rq\u0026#39;s 11* estimated utilization, before we update schedutil. 12*/ 13util_est_enqueue(\u0026amp;rq-\u0026gt;cfs, p); 1415/* 16* If in_iowait is set, the code below may not trigger any cpufreq 17* utilization updates, so do it here explicitly with the IOWAIT flag 18* passed. 19*/ 20if (p-\u0026gt;in_iowait) 21cpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT); 2223for_each_sched_entity(se) { 24if (se-\u0026gt;on_rq) 25break; 26cfs_rq = cfs_rq_of(se); 27enqueue_entity(cfs_rq, se, flags); 2829/* 30* end evaluation on encountering a throttled cfs_rq 31* 32* note: in the case of encountering a throttled cfs_rq we will 33* post the final h_nr_running increment below. 34*/ 35if (cfs_rq_throttled(cfs_rq)) 36break; 37cfs_rq-\u0026gt;h_nr_running++; 3839flags = ENQUEUE_WAKEUP; 40} 4142for_each_sched_entity(se) { 43cfs_rq = cfs_rq_of(se); 44cfs_rq-\u0026gt;h_nr_running++; 4546if (cfs_rq_throttled(cfs_rq)) 47break; 4849update_load_avg(cfs_rq, se, UPDATE_TG); 50update_cfs_group(se); 51} 5253if (!se) 54add_nr_running(rq, 1); 5556if (cfs_bandwidth_used()) { 57/* 58* When bandwidth control is enabled; the cfs_rq_throttled() 59* breaks in the above iteration can result in incomplete 60* leaf list maintenance, resulting in triggering the assertion 61* below. 62*/ 63for_each_sched_entity(se) { 64cfs_rq = cfs_rq_of(se); 6566if (list_add_leaf_cfs_rq(cfs_rq)) 67break; 68} 69} 7071assert_list_leaf_cfs_rq(rq); 7273hrtick_update(rq); 74} dequeue_task_fair 1static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags) 2{ 3struct cfs_rq *cfs_rq; 4struct sched_entity *se = \u0026amp;p-\u0026gt;se; 5int task_sleep = flags \u0026amp; DEQUEUE_SLEEP; 67for_each_sched_entity(se) { 8cfs_rq = cfs_rq_of(se); 9dequeue_entity(cfs_rq, se, flags); 1011/* 12* end evaluation on encountering a throttled cfs_rq 13* 14* note: in the case of encountering a throttled cfs_rq we will 15* post the final h_nr_running decrement below. 16*/ 17if (cfs_rq_throttled(cfs_rq)) 18break; 19cfs_rq-\u0026gt;h_nr_running--; 2021/* Don\u0026#39;t dequeue parent if it has other entities besides us */ 22if (cfs_rq-\u0026gt;load.weight) { 23/* Avoid re-evaluating load for this entity: */ 24se = parent_entity(se); 25/* 26* Bias pick_next to pick a task from this cfs_rq, as 27* p is sleeping when it is within its sched_slice. 28*/ 29if (task_sleep \u0026amp;\u0026amp; se \u0026amp;\u0026amp; !throttled_hierarchy(cfs_rq)) 30set_next_buddy(se); 31break; 32} 33flags |= DEQUEUE_SLEEP; 34} 3536for_each_sched_entity(se) { 37cfs_rq = cfs_rq_of(se); 38cfs_rq-\u0026gt;h_nr_running--; 3940if (cfs_rq_throttled(cfs_rq)) 41break; 4243update_load_avg(cfs_rq, se, UPDATE_TG); 44update_cfs_group(se); 45} 4647if (!se) 48sub_nr_running(rq, 1); 4950util_est_dequeue(\u0026amp;rq-\u0026gt;cfs, p, task_sleep); 51hrtick_update(rq); 52} yield_task_fair yield_to_task_fair ","date":"Oct 28, 2021","img":"","permalink":"https://mengdemao.github.io/posts/fair/","series":null,"tags":["kernel"],"title":"Fair"},{"categories":[],"content":"简述  驱动模型\n    顶级kobject 解释     block 块设备链接\u0026ndash;\u0026gt;/sys/deives相关文件   bus 存放各种总线文件   class 各种设备类   dev 存放(字符/块)设备主副设备号链接文件\u0026ndash;\u0026gt;/sys/deives   devices 设备的具体存放文件   firmware 固件存放   fs 文件类型   kernel kernel子系统   module 模块信息   power 能源管理    底层机制 kobject  内核对象:kobject/kobject_type/kset 为模块提供一个底层抽象,其中文件存放于/sys文件下面\n 数据结构 1struct kobject { 2const char\t*name;\t/* 名字 */ 3struct list_head\tentry;\t/* 链表:链接进入kset */ 4struct kobject\t*parent;\t/* 指向父对象,建立层次结构 */ 5struct kset\t*kset;\t/* 对象集合 */ 6struct kobj_type\t*ktype;\t/* 对象类型 */ 7struct kernfs_node\t*sd; /* sysfs directory entry */ 8struct kref\tkref;\t/* 引用计数 */ 910#ifdef CONFIG_DEBUG_KOBJECT_RELEASE 11\tstruct delayed_work\trelease; 12#endif 13\t14unsigned int state_initialized:1;\t/* 标志位:初始化 */ 15unsigned int state_in_sysfs:1;\t/* 标志位:在sysfs中 */ 16unsigned int state_add_uevent_sent:1;\t/* 标志位:发出KOBJ_ADD uevent */ 17unsigned int state_remove_uevent_sent:1;\t/* 标志位:发出KOBJ_REMOVE uevent */ 18unsigned int uevent_suppress:1;\t/* 标志位:禁止发出uevent */ 19}; 初始化 1/** 2* kobject_init - initialize a kobject structure 3* @kobj: pointer to the kobject to initialize 4* @ktype: pointer to the ktype for this kobject. 5* 6* This function will properly initialize a kobject such that it can then 7* be passed to the kobject_add() call. 8* 9* After this function is called, the kobject MUST be cleaned up by a call 10* to kobject_put(), not by a call to kfree directly to ensure that all of 11* the memory is cleaned up properly. 12*/ 13void kobject_init(struct kobject *kobj, struct kobj_type *ktype) 14{ 15char *err_str;\t/** 错误信息 */ 1617/** 校验参数NULL */ 18if (!kobj) { 19err_str = \u0026#34;invalid kobject pointer!\u0026#34;; 20goto error; 21} 22if (!ktype) { 23err_str = \u0026#34;must have a ktype to be initialized properly!\\n\u0026#34;; 24goto error; 25} 2627/** kobject是否已经初始化 */ 28if (kobj-\u0026gt;state_initialized) { 29/* do not error out as sometimes we can recover */ 30pr_err(\u0026#34;kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\u0026#34;, 31kobj); 32dump_stack(); /** 回溯堆栈 */ 33} 3435/** 调用具体初始化函数 */ 36kobject_init_internal(kobj); 3738/* 设置类型 */ 39kobj-\u0026gt;ktype = ktype; 40return; 4142error: 43pr_err(\u0026#34;kobject (%p): %s\\n\u0026#34;, kobj, err_str); 44dump_stack(); 45} 46EXPORT_SYMBOL(kobject_init); 添加 1int kobject_add(struct kobject *kobj, /* 需要添加kobject */ 2struct kobject *parent, /* 父指针 */ 3const char *fmt, ...) /* 命名 */ 4{ 5va_list args; 6int retval; 78/* 校验kobject */ 9if (!kobj) 10return -EINVAL; 1112/* 是否已经初始化 */ 13if (!kobj-\u0026gt;state_initialized) { 14pr_err(\u0026#34;kobject \u0026#39;%s\u0026#39; (%p): tried to add an uninitialized object, something is seriously wrong.\\n\u0026#34;, 15kobject_name(kobj), kobj); 16dump_stack(); 17return -EINVAL; 18} 19va_start(args, fmt); 20/* 设置名字并且将父指针添加到parent */ 21retval = kobject_add_varg(kobj, parent, fmt, args); 22va_end(args); 2324return retval; 25} 最终调用添加函数\n1static int kobject_add_internal(struct kobject *kobj) 2{ 3int error = 0; 4struct kobject *parent; 56/* 判断参数NULL */ 7if (!kobj) 8return -ENOENT; 910/* 判断名字是否有效 */ 11if (!kobj-\u0026gt;name || !kobj-\u0026gt;name[0]) { 12WARN(1, 13\u0026#34;kobject: (%p): attempted to be registered with empty name!\\n\u0026#34;, 14kobj); 15return -EINVAL; 16} 1718/** 获取父指针 */ 19parent = kobject_get(kobj-\u0026gt;parent); 2021/* join kset if set, use it as parent if we do not already have one */ 22if (kobj-\u0026gt;kset) {\t/* kset已经设置 */ 23if (!parent)\t/* 不存在父指针 */ 24/* kset的kobject作为父指针 */ 25parent = kobject_get(\u0026amp;kobj-\u0026gt;kset-\u0026gt;kobj); 26/* 将kobject加入kset */ 27kobj_kset_join(kobj); 2829/* 保存父指针 */ 30kobj-\u0026gt;parent = parent; 31} 3233pr_debug(\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): %s: parent: \u0026#39;%s\u0026#39;, set: \u0026#39;%s\u0026#39;\\n\u0026#34;, 34kobject_name(kobj), kobj, __func__, 35parent ? kobject_name(parent) : \u0026#34;\u0026lt;NULL\u0026gt;\u0026#34;, 36kobj-\u0026gt;kset ? kobject_name(\u0026amp;kobj-\u0026gt;kset-\u0026gt;kobj) : \u0026#34;\u0026lt;NULL\u0026gt;\u0026#34;); 3738/* 创建dir */ 39error = create_dir(kobj); 40if (error) { /* 出错,清理 */ 41kobj_kset_leave(kobj); 42kobject_put(parent); 43kobj-\u0026gt;parent = NULL; 4445/* be noisy on error issues */ 46if (error == -EEXIST) 47pr_err(\u0026#34;%s failed for %s with -EEXIST, don\u0026#39;t try to register things with the same name in the same directory.\\n\u0026#34;, 48__func__, kobject_name(kobj)); 49else 50pr_err(\u0026#34;%s failed for %s (error: %d parent: %s)\\n\u0026#34;, 51__func__, kobject_name(kobj), error, 52parent ? kobject_name(parent) : \u0026#34;\u0026#39;none\u0026#39;\u0026#34;); 53} else 54kobj-\u0026gt;state_in_sysfs = 1; /* 添加到sysfs中 */ 5556return error; 57} sysfs文件夹生成 1static int create_dir(struct kobject *kobj) 2{ 3const struct kobj_ns_type_operations *ops; 4int error; 56error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); 7if (error) 8return error; 910error = populate_dir(kobj); 11if (error) { 12sysfs_remove_dir(kobj); 13return error; 14} 1516/* 17* @kobj-\u0026gt;sd may be deleted by an ancestor going away. Hold an 18* extra reference so that it stays until @kobj is gone. 19*/ 20sysfs_get(kobj-\u0026gt;sd); 2122/* 23* If @kobj has ns_ops, its children need to be filtered based on 24* their namespace tags. Enable namespace support on @kobj-\u0026gt;sd. 25*/ 26ops = kobj_child_ns_ops(kobj); 27if (ops) { 28BUG_ON(ops-\u0026gt;type \u0026lt;= KOBJ_NS_TYPE_NONE); 29BUG_ON(ops-\u0026gt;type \u0026gt;= KOBJ_NS_TYPES); 30BUG_ON(!kobj_ns_type_registered(ops-\u0026gt;type)); 3132sysfs_enable_ns(kobj-\u0026gt;sd); 33} 3435return 0; 36} 删除 1void kobject_del(struct kobject *kobj) 2{ 3struct kernfs_node *sd; 45if (!kobj) 6return; 78sd = kobj-\u0026gt;sd; 9sysfs_remove_dir(kobj); 10sysfs_put(sd); 1112kobj-\u0026gt;state_in_sysfs = 0; 13kobj_kset_leave(kobj); 14kobject_put(kobj-\u0026gt;parent); 15kobj-\u0026gt;parent = NULL; 16} 引用计数 1struct kobject *kobject_get(struct kobject *kobj) 2{ 3if (kobj) { 4if (!kobj-\u0026gt;state_initialized) 5WARN(1, KERN_WARNING 6\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): is not initialized, yet kobject_get() is being called.\\n\u0026#34;, 7kobject_name(kobj), kobj); 8kref_get(\u0026amp;kobj-\u0026gt;kref); 9} 10return kobj; 11} 1213void kobject_put(struct kobject *kobj) 14{ 15if (kobj) { 16if (!kobj-\u0026gt;state_initialized) 17WARN(1, KERN_WARNING 18\u0026#34;kobject: \u0026#39;%s\u0026#39; (%p): is not initialized, yet kobject_put() is being called.\\n\u0026#34;, 19kobject_name(kobj), kobj); 20kref_put(\u0026amp;kobj-\u0026gt;kref, kobject_release); 21} 22} kset 数据结构 1struct kset { 2struct list_head list; 3spinlock_t list_lock; 4struct kobject kobj; 5const struct kset_uevent_ops *uevent_ops; 6} __randomize_layout; ktype 数据结构 1struct kobj_type { 2void (*release)(struct kobject *kobj); 3const struct sysfs_ops *sysfs_ops; 4struct attribute **default_attrs; 5const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); 6const void *(*namespace)(struct kobject *kobj); 7void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); 8}; class  设备类描述\n 1struct class { 2const char\t*name; 3struct module\t*owner; 45const struct attribute_group\t**class_groups; 6const struct attribute_group\t**dev_groups; 7struct kobject\t*dev_kobj; 89int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); 10char *(*devnode)(struct device *dev, umode_t *mode); 1112void (*class_release)(struct class *class); 13void (*dev_release)(struct device *dev); 1415int (*shutdown_pre)(struct device *dev); 1617const struct kobj_ns_type_operations *ns_type; 18const void *(*namespace)(struct device *dev); 1920void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid); 2122const struct dev_pm_ops *pm; 2324struct subsys_private *p; 25}; bus  设备总线描述\n 总线类型 1# ls 2amba cpu nvmem platform virtio 3clockevents event_source pci scsi workqueue 4clocksource gpio pci_express serio 5container hid pcmcia spi 其中每一个总线具有如下信息\n1# ls 2devices drivers_autoprobe uevent 3drivers drivers_probe 1struct bus_type { 2const char\t*name; 3const char\t*dev_name; 4struct device\t*dev_root; 5const struct attribute_group **bus_groups; 6const struct attribute_group **dev_groups; 7const struct attribute_group **drv_groups; 89int (*match)(struct device *dev, struct device_driver *drv); 10int (*uevent)(struct device *dev, struct kobj_uevent_env *env); 11int (*probe)(struct device *dev); 12int (*remove)(struct device *dev); 13void (*shutdown)(struct device *dev); 1415int (*online)(struct device *dev); 16int (*offline)(struct device *dev); 1718int (*suspend)(struct device *dev, pm_message_t state); 19int (*resume)(struct device *dev); 2021int (*num_vf)(struct device *dev); 2223int (*dma_configure)(struct device *dev); 2425const struct dev_pm_ops *pm; 2627const struct iommu_ops *iommu_ops; 2829struct subsys_private *p; 30struct lock_class_key lock_key; 3132bool need_parent_lock; 33}; 设备总线注册 1int bus_register(struct bus_type *bus) 2{ 3int retval; 4struct subsys_private *priv; 5struct lock_class_key *key = \u0026amp;bus-\u0026gt;lock_key; 67priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL); 8if (!priv) 9return -ENOMEM; 1011priv-\u0026gt;bus = bus; 12bus-\u0026gt;p = priv; 1314BLOCKING_INIT_NOTIFIER_HEAD(\u0026amp;priv-\u0026gt;bus_notifier); 1516retval = kobject_set_name(\u0026amp;priv-\u0026gt;subsys.kobj, \u0026#34;%s\u0026#34;, bus-\u0026gt;name); 17if (retval) 18goto out; 1920priv-\u0026gt;subsys.kobj.kset = bus_kset; 21priv-\u0026gt;subsys.kobj.ktype = \u0026amp;bus_ktype; 22priv-\u0026gt;drivers_autoprobe = 1; 2324retval = kset_register(\u0026amp;priv-\u0026gt;subsys); 25if (retval) 26goto out; 2728retval = bus_create_file(bus, \u0026amp;bus_attr_uevent); 29if (retval) 30goto bus_uevent_fail; 3132priv-\u0026gt;devices_kset = kset_create_and_add(\u0026#34;devices\u0026#34;, NULL, 33\u0026amp;priv-\u0026gt;subsys.kobj); 34if (!priv-\u0026gt;devices_kset) { 35retval = -ENOMEM; 36goto bus_devices_fail; 37} 3839priv-\u0026gt;drivers_kset = kset_create_and_add(\u0026#34;drivers\u0026#34;, NULL, 40\u0026amp;priv-\u0026gt;subsys.kobj); 41if (!priv-\u0026gt;drivers_kset) { 42retval = -ENOMEM; 43goto bus_drivers_fail; 44} 4546INIT_LIST_HEAD(\u0026amp;priv-\u0026gt;interfaces); 47__mutex_init(\u0026amp;priv-\u0026gt;mutex, \u0026#34;subsys mutex\u0026#34;, key); 48klist_init(\u0026amp;priv-\u0026gt;klist_devices, klist_devices_get, klist_devices_put); 49klist_init(\u0026amp;priv-\u0026gt;klist_drivers, NULL, NULL); 5051retval = add_probe_files(bus); 52if (retval) 53goto bus_probe_files_fail; 5455retval = bus_add_groups(bus, bus-\u0026gt;bus_groups); 56if (retval) 57goto bus_groups_fail; 5859pr_debug(\u0026#34;bus: \u0026#39;%s\u0026#39;: registered\\n\u0026#34;, bus-\u0026gt;name); 60return 0; 6162bus_groups_fail: 63remove_probe_files(bus); 64bus_probe_files_fail: 65kset_unregister(bus-\u0026gt;p-\u0026gt;drivers_kset); 66bus_drivers_fail: 67kset_unregister(bus-\u0026gt;p-\u0026gt;devices_kset); 68bus_devices_fail: 69bus_remove_file(bus, \u0026amp;bus_attr_uevent); 70bus_uevent_fail: 71kset_unregister(\u0026amp;bus-\u0026gt;p-\u0026gt;subsys); 72out: 73kfree(bus-\u0026gt;p); 74bus-\u0026gt;p = NULL; 75return retval; 76} 设备总线卸载 1void bus_unregister(struct bus_type *bus) 2{ 3pr_debug(\u0026#34;bus: \u0026#39;%s\u0026#39;: unregistering\\n\u0026#34;, bus-\u0026gt;name); 4if (bus-\u0026gt;dev_root) 5device_unregister(bus-\u0026gt;dev_root); 6bus_remove_groups(bus, bus-\u0026gt;bus_groups); 7remove_probe_files(bus); 8kset_unregister(bus-\u0026gt;p-\u0026gt;drivers_kset); 9kset_unregister(bus-\u0026gt;p-\u0026gt;devices_kset); 10bus_remove_file(bus, \u0026amp;bus_attr_uevent); 11kset_unregister(\u0026amp;bus-\u0026gt;p-\u0026gt;subsys); 12} devices  设备文件具体描述: device(设备描述) device_driver(驱动描述) bus_type(总线信息)\n 1|-- breakpoint 2|-- kprobe 3|-- platform 4|-- software 5|-- system 6|-- tracepoint 7|-- uprobe 8`-- virtual  device  描述设备\n 1struct device { 2struct device\t*parent; 34struct device_private\t*p; 56struct kobject kobj; 7const char\t*init_name; /* initial name of the device */ 8const struct device_type *type; 910struct mutex\tmutex;\t/* mutex to synchronize calls to 11* its driver. 12*/ 1314struct bus_type\t*bus;\t/* type of bus device is on */ 15struct device_driver *driver;\t/* which driver has allocated this 16device */ 17void\t*platform_data;\t/* Platform specific data, device 18core doesn\u0026#39;t touch it */ 19void\t*driver_data;\t/* Driver data, set and get with 20dev_set/get_drvdata */ 21struct dev_links_info\tlinks; 22struct dev_pm_info\tpower; 23struct dev_pm_domain\t*pm_domain; 2425#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN 26\tstruct irq_domain\t*msi_domain; 27#endif 28#ifdef CONFIG_PINCTRL 29\tstruct dev_pin_info\t*pins; 30#endif 31#ifdef CONFIG_GENERIC_MSI_IRQ 32\tstruct list_head\tmsi_list; 33#endif 34 35#ifdef CONFIG_NUMA 36\tint\tnuma_node;\t/* NUMA node this device is close to */ 37#endif 38\tconst struct dma_map_ops *dma_ops; 39u64\t*dma_mask;\t/* dma mask (if dma\u0026#39;able device) */ 40u64\tcoherent_dma_mask;/* Like dma_mask, but for 41alloc_coherent mappings as 42not all hardware supports 4364 bit addresses for consistent 44allocations such descriptors. */ 45u64\tbus_dma_mask;\t/* upstream dma_mask constraint */ 46unsigned long\tdma_pfn_offset; 4748struct device_dma_parameters *dma_parms; 4950struct list_head\tdma_pools;\t/* dma pools (if dma\u0026#39;ble) */ 5152struct dma_coherent_mem\t*dma_mem; /* internal for coherent mem 53override */ 54#ifdef CONFIG_DMA_CMA 55\tstruct cma *cma_area;\t/* contiguous memory area for dma 56allocations */ 57#endif 58\t/* arch specific additions */ 59struct dev_archdata\tarchdata; 6061struct device_node\t*of_node; /* associated device tree node */ 62struct fwnode_handle\t*fwnode; /* firmware device node */ 6364dev_t\tdevt;\t/* dev_t, creates the sysfs \u0026#34;dev\u0026#34; */ 65u32\tid;\t/* device instance */ 6667spinlock_t\tdevres_lock; 68struct list_head\tdevres_head; 6970struct klist_node\tknode_class; 71struct class\t*class; 72const struct attribute_group **groups;\t/* optional groups */ 7374void\t(*release)(struct device *dev); 75struct iommu_group\t*iommu_group; 76struct iommu_fwspec\t*iommu_fwspec; 7778bool\toffline_disabled:1; 79bool\toffline:1; 80bool\tof_node_reused:1; 81}; driver  描述驱动\n 1struct device_driver { 2const char\t*name; 3struct bus_type\t*bus; 45struct module\t*owner; 6const char\t*mod_name;\t/* used for built-in modules */ 78bool suppress_bind_attrs;\t/* disables bind/unbind via sysfs */ 9enum probe_type probe_type; 1011const struct of_device_id\t*of_match_table; 12const struct acpi_device_id\t*acpi_match_table; 1314int (*probe) (struct device *dev); 15int (*remove) (struct device *dev); 16void (*shutdown) (struct device *dev); 17int (*suspend) (struct device *dev, pm_message_t state); 18int (*resume) (struct device *dev); 19const struct attribute_group **groups; 2021const struct dev_pm_ops *pm; 22void (*coredump) (struct device *dev); 2324struct driver_private *p; 25}; kernel  kernel子系统\n module  模块信息\n ","date":"Oct 24, 2021","img":"","permalink":"https://mengdemao.github.io/posts/drivermodel/","series":null,"tags":["kernel"],"title":"驱动模型"},{"categories":["python"],"content":"python基础绘图\n","date":"Oct 16, 2021","img":"","permalink":"https://mengdemao.github.io/posts/tkinter/","series":null,"tags":[],"title":"Tkinter"},{"categories":[],"content":"","date":"Oct 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/javascript/","series":null,"tags":[],"title":"Javascript"},{"categories":[],"content":"CSS开始(层叠样式表) HTML + CSS + JavaScript 名词 + 形容词 + 动词 相当于对原始的HTML进行美化\n快速入门  CSS是什么 CSS怎么用 CSS选择器 美化网页 盒子模型 浮动 定位 网页动画  什么是CSS 美化:字体, 颜色,高度,宽度, 背景图片\nCSS的优势:  内容和表现分离 CSS文件可以复用 样式十分丰富 建议使用独立的CSS文件  CSS导入的方法  行内样式  1\u0026lt;h1 style=\u0026#34;color: red\u0026#34;\u0026gt;一级标题\u0026lt;/h1\u0026gt; style标签  1\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; 外部样式   链接方式  1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt;  导入式  1\u0026lt;style\u0026gt; 2@import url(\u0026#34;css/style.css\u0026#34;); 3\u0026lt;/style\u0026gt; 基本语法 1/* 注释语法 */ 2selector { 3/* 声明 */ 4attr:value; 5} 选择器 基本选择器   标签选择器\n  类选择器\n  ID选择器\n  标签选择器 1h1 { 2color: red; 3} 4h2 { 5color: black; 6} 7h3 { 8color: yellow; 9} 10h4 { 11color: red; 12} 类选择器 1\u0026lt;h1 class=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/h1\u0026gt; 此时,可以讲HTML选中\n1.test { 2color: black; 3} ID选择器 1\u0026lt;h1 id=\u0026#34;test\u0026#34;\u0026gt;测试\u0026lt;/h1\u0026gt; 1#test { 2color: black; 3} ID唯一确定,不可以共享;\n层次选择器 ","date":"Oct 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/css/","series":null,"tags":[],"title":"Css"},{"categories":[],"content":"开始 网页基础结构\n1\u0026lt;!-- 告诉浏览器,需要使用的规范 --\u0026gt; 2\u0026lt;!DOCTYPE html\u0026gt; 3\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 45\u0026lt;!-- 网页标题 --\u0026gt; 6\u0026lt;head\u0026gt; 7\u0026lt;!-- 描述标签 --\u0026gt; 8\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 910\u0026lt;!-- 网页标题 --\u0026gt; 11\u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 12\u0026lt;/head\u0026gt; 1314\u0026lt;!-- 网页主体 --\u0026gt; 15\u0026lt;body\u0026gt; 16\u0026lt;/body\u0026gt; 17\u0026lt;/html\u0026gt; 网页基本标签 标题标签 1\u0026lt;h1\u0026gt;一级标签\u0026lt;/h1\u0026gt; 2\u0026lt;h2\u0026gt;二级标签\u0026lt;/h2\u0026gt; 3\u0026lt;h3\u0026gt;三级标签\u0026lt;/h3\u0026gt; 4\u0026lt;h4\u0026gt;四级标签\u0026lt;/h4\u0026gt; 5\u0026lt;h5\u0026gt;五级标签\u0026lt;/h5\u0026gt; 6\u0026lt;h6\u0026gt;六级标签\u0026lt;/h6\u0026gt; 段落标签 1\u0026lt;p\u0026gt;段落标签\u0026lt;/p\u0026gt; 换行标签 1\u0026lt;br/\u0026gt; 水平线标签 1\u0026lt;hr/\u0026gt; 字体样式标签 1\u0026lt;!-- 字体样式标签 --\u0026gt; 2\u0026lt;strong\u0026gt;粗体\u0026lt;/strong\u0026gt;\u0026lt;br/\u0026gt; 3\u0026lt;em\u0026gt;斜体\u0026lt;/em\u0026gt;\u0026lt;br/\u0026gt; 图片标签 1\u0026lt;img src=\u0026#34;测试.png\u0026#34; alt=\u0026#34;测试\u0026#34; title=\u0026#34;测试\u0026#34;/\u0026gt; 链接 1\u0026lt;!-- 当前页打开 --\u0026gt; 2\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 3\u0026lt;!-- 新建页打开 --\u0026gt; 4\u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 行内元素和块元素 列表标签 有序列表 1\u0026lt;ol\u0026gt; 2\u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; 3\u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; 4\u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; 5\u0026lt;/ol\u0026gt; 无序列表 1\u0026lt;ul\u0026gt; 2\u0026lt;li\u0026gt;HTML\u0026lt;/li\u0026gt; 3\u0026lt;li\u0026gt;CSS\u0026lt;/li\u0026gt; 4\u0026lt;li\u0026gt;JavaScript\u0026lt;/li\u0026gt; 5\u0026lt;/ul\u0026gt; 定义列表 1\u0026lt;dl\u0026gt; 2\u0026lt;dt\u0026gt;前端\u0026lt;/dt\u0026gt; 3\u0026lt;dd\u0026gt;html\u0026lt;/dd\u0026gt; 4\u0026lt;dd\u0026gt;CSS\u0026lt;/dd\u0026gt; 5\u0026lt;dd\u0026gt;JavaScript\u0026lt;/dd\u0026gt; 6\u0026lt;/dl\u0026gt; 表格 1\u0026lt;table border=\u0026#34;1px\u0026#34;\u0026gt; 2\u0026lt;tr\u0026gt; 3\u0026lt;td\u0026gt;1-1\u0026lt;/td\u0026gt; 4\u0026lt;td\u0026gt;1-2\u0026lt;/td\u0026gt; 5\u0026lt;/tr\u0026gt; 6\u0026lt;tr\u0026gt; 7\u0026lt;td\u0026gt;2-1\u0026lt;/td\u0026gt; 8\u0026lt;td\u0026gt;2-2\u0026lt;/td\u0026gt; 9\u0026lt;/tr\u0026gt; 10\u0026lt;/table\u0026gt; 页面结构分析    元素名 描述     header 标题头部区域   footer 标记尾部内容   section web页面中一块独立的区域   article 独立文章内容   aside 相关页面或者内容   nav 导航类辅助内容    iframe内联框架 1\u0026lt;iframe src=\u0026#34;path\u0026#34; name=\u0026#34;mainFrame\u0026#34;\u0026gt;\u0026lt;/frame\u0026gt; bilibili的例子\n 1\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=55631961\u0026amp;bvid=BV1x4411V75C\u0026amp;cid=97257967\u0026amp;page=11\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 表单 表单form\n1\u0026lt;form action=\u0026#34;开始.html\u0026#34; method=\u0026#34;GET/POST\u0026#34;\u0026gt; 2\u0026lt;p\u0026gt;名字: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 3\u0026lt;p\u0026gt;密码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 4\u0026lt;p\u0026gt; 5\u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; 6\u0026lt;input type=\u0026#34;reset\u0026#34;\u0026gt; 7\u0026lt;/p\u0026gt; 8\u0026lt;/form\u0026gt; 产生的效果\n1?name=111\u0026amp;password= ","date":"Oct 7, 2021","img":"","permalink":"https://mengdemao.github.io/posts/html5/","series":null,"tags":[],"title":"Html5"},{"categories":[],"content":" A C dynamic strings library C语言版本动态字符串库\n SDS SDS的类型就是\n1typedef char *sds; 可以明显的看到,sds就是普通的char类型\n下面是sds的数据类型 1+--------+-------------------------------+-----------+ 2| Header | Binary safe C alike string... | Null term | 3+--------+-------------------------------+-----------+ 4| 5-\u0026gt; Pointer returned to the user. 1#define SDS_HDR_VAR(T,s) \\ 2struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); 3#define SDS_HDR(T,s) \\ 4((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 5#define SDS_TYPE_5_LEN(f) ((f)\u0026gt;\u0026gt;SDS_TYPE_BITS) SDS 头 根据不同的标志计算不同的头部数据\n   宏定义 标志     SDS_TYPE_5 sdshdr5   SDS_TYPE_8 sdshdr8   SDS_TYPE_16 sdshdr16   SDS_TYPE_32 sdshdr32   SDS_TYPE_64 sdshdr64    flag标志:\n1unsigned char flags = s[-1]; /* 最后一个头部数据 */ 1#define SDS_TYPE_5 0 2#define SDS_TYPE_8 1 3#define SDS_TYPE_16 2 4#define SDS_TYPE_32 3 5#define SDS_TYPE_64 4 1/* Note: sdshdr5 is never used, we just access the flags byte directly. 2* However is here to document the layout of type 5 SDS strings. */ 3struct __attribute__ ((__packed__)) sdshdr5 { 4unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ 5char buf[]; 6}; 7struct __attribute__ ((__packed__)) sdshdr8 { 8uint8_t len; /* used */ 9uint8_t alloc; /* excluding the header and null terminator */ 10unsigned char flags; /* 3 lsb of type, 5 unused bits */ 11char buf[]; 12}; 13struct __attribute__ ((__packed__)) sdshdr16 { 14uint16_t len; /* used */ 15uint16_t alloc; /* excluding the header and null terminator */ 16unsigned char flags; /* 3 lsb of type, 5 unused bits */ 17char buf[]; 18}; 19struct __attribute__ ((__packed__)) sdshdr32 { 20uint32_t len; /* used */ 21uint32_t alloc; /* excluding the header and null terminator */ 22unsigned char flags; /* 3 lsb of type, 5 unused bits */ 23char buf[]; 24}; 25struct __attribute__ ((__packed__)) sdshdr64 { 26uint64_t len; /* used */ 27uint64_t alloc; /* excluding the header and null terminator */ 28unsigned char flags; /* 3 lsb of type, 5 unused bits */ 29char buf[]; 30}; 1#define SDS_TYPE_MASK 7 2#define SDS_TYPE_BITS 3 创建SDS 函数原型\n1sds sdsnewlen(const void *init, size_t initlen); 扩张字符串缓存区 1sds sdsMakeRoomFor(sds s, size_t addlen) 2{ 3void *sh; 4void *newsh; 5size_t avail = sdsavail(s);\t/* 计算剩余的可以使用的大小 */ 6size_t len; 7size_t newlen; 8char type, oldtype = s[-1] \u0026amp; SDS_TYPE_MASK; 9int hdrlen; 1011if (avail \u0026gt;= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ 12return s; 13} 14len = sdslen(s);\t/* 计算字符串大小 */ 15sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ 1617/* 计算得到新的长度 */ 18newlen = (len+addlen); 19if (newlen \u0026lt; SDS_MAX_PREALLOC) 20newlen *= 2; 21else 22newlen += SDS_MAX_PREALLOC; 23/* 重新生成类型 */ 24type = sdsReqType(newlen); 2526/* Don\u0026#39;t use type 5: the user is appending to the string and type 5 is 27* not able to remember empty space, so sdsMakeRoomFor() must be called 28* at every appending operation. */ 29if (type == SDS_TYPE_5) { 30type = SDS_TYPE_8; 31} 3233/* 计算头部大小 */ 34hdrlen = sdsHdrSize(type); 3536if (oldtype == type) { 37newsh = s_realloc(sh, hdrlen + newlen + 1); 38if (newsh == NULL) { 39return NULL; 40} 41s = (char*)newsh + hdrlen; 42} else { 43/* Since the header size changes, need to move the string forward, 44* and can\u0026#39;t use realloc */ 45newsh = s_malloc(hdrlen+newlen+1); 46if (newsh == NULL) { 47return NULL; 48} 49memcpy((char*)newsh+hdrlen, s, len+1); 50s_free(sh); 5152s = (char*)newsh + hdrlen; 53s[-1] = type; 5455sdssetlen(s, len); 56} 5758sdssetalloc(s, newlen); 59return s; 60} 追加字符串 1sds sdscatlen(sds s, const void *t, size_t len) 2{ 3size_t curlen = sdslen(s);\t/* 计算字符串的长度 */ 45s = sdsMakeRoomFor(s,len);\t/* 扩展字符串缓冲区长度 */ 6if (s == NULL) { 7return NULL; 8} 9memcpy(s+curlen, t, len);\t/* 添加字符串 */ 10sdssetlen(s, curlen+len);\t/* 设置长度标志 */ 11s[curlen+len] = \u0026#39;\\0\u0026#39;;\t/* 补全结束符 */ 12return s; 13} ","date":"Oct 6, 2021","img":"","permalink":"https://mengdemao.github.io/posts/sds/","series":null,"tags":[],"title":"Sds"},{"categories":[],"content":" STL称为标准模板库(Standard Template Library) 广义上可以分为容器,算法,迭代器 容器和算法通过迭代器进行无缝连接 STL几乎所有的代码都采用了函数模版或者类模板\n STL组件    序号 名称 解释     1 容器 各种数据结构   2 算法 各种常用的算法   3 迭代器 容器域算法的胶合   4 仿函数 行为类似函数   5 适配器 修饰容器或者仿函数迭代器   6 空间配置器 负责空间的配置和管理    容器算法和迭代器 vector vector使用 1/* 创建vector容器 */ 2vector\u0026lt;int\u0026gt; v; 3/* 插入数据 */ 4v.push_back(10); 5v.push_back(20); 6v.push_back(30); 7v.push_back(40); 迭代器使用 迭代器方案1 1vector\u0026lt;int\u0026gt;::iterator itBegin = v.begin(); 2vector\u0026lt;int\u0026gt;::iterator itEnd = v.end(); 3while (itBegin != itEnd) { 4cout \u0026lt;\u0026lt; *itBegin \u0026lt;\u0026lt; endl; 5itBegin += 1; 6} 迭代器2 1for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 2{ 3cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; 4} 遍历算法 1template \u0026lt;class T\u0026gt; 2void myPrint(T val) 3{ 4cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 5} 67/* 可惜回调函数不支持自动推导 */ 8for_each(v.begin(), v.end(), myPrint\u0026lt;int\u0026gt;); 容器自定义数据 容器嵌套容器 1vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;v; // 外部大容器 2vector\u0026lt;int\u0026gt; vx[10]; // 内部小容器 3 4/* 插入容器 */ 5for (int i = 0; i \u0026lt; 10; i++) 6{ 7for (int j = 0; j \u0026lt; 30; j++) 8{ 9vx[i].push_back(i + j + 10); 10} 11v.push_back(vx[i]); 12} 1314/* 遍历容器 */ 15for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 16{ 17for (vector\u0026lt;int\u0026gt;::iterator vit = it-\u0026gt;begin(); vit != it-\u0026gt;end(); vit++) 18{ 19cout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 20} 21cout \u0026lt;\u0026lt; endl; 22} string string本质上是一个类,封装了char*,提供了许多的成员方法;\n构造函数 1string s1(str); 2string s2 = \u0026#34;Hello World\u0026#34;; 3string s3(s2); 赋值操作  重载操作符**=**  1string s1; 2s1 = \u0026#34;Hello World\u0026#34;; 成员函数assign  1string str; 2str.assign(\u0026#34;Hello World\u0026#34;); 追加操作  重载操作符**+=** 成员函数append  查找和替换 find replace 比较 compare 字符存取  [] at  插入和删除 insert earse 子串 substr array deque hashtable map list queue stack set rbtree ","date":"Oct 6, 2021","img":"","permalink":"https://mengdemao.github.io/posts/stl/","series":null,"tags":[],"title":"STL学习笔记"},{"categories":[],"content":"HelloWorld 1#!/bin/python3 23if __name__ == \u0026#39;__main__\u0026#39;: 4print(\u0026#39;Hello World\u0026#39;) 数据类型 Numbers(数字) 1intA = 10 2print(intA) 布尔类型 1true 2false String(字符串) 1strB = \u0026#34;Hello\u0026#34; 2print(strB) List(列表) 1listC = [\u0026#34;12\u0026#34;, 3, 4] 2print(listC) Tuple(元组) 1tupleD = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) 2print(tupleD) Dictionary(字典) 1DictE = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;b\u0026#39;: \u0026#39;3\u0026#39;} 2print(DictE) 运算符 控制结构 条件语句 单执行语句 1if 判断条件： 2执行语句 3else： 4执行语句 多条件语句 1if 判断条件1: 2执行语句1…… 3elif 判断条件2: 4执行语句2…… 5elif 判断条件3: 6执行语句3…… 7else: 8执行语句4…… while循环 1c = 0 2while (c \u0026lt; 10): 3print(c) 4c += 1 5print(\u0026#34;while Loop finish\u0026#34;) ###　for循环\n函数 面向对象 ","date":"Oct 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/python/","series":null,"tags":[],"title":"Python学习笔记"},{"categories":[],"content":"输入子设备分为三层\n handle core device  input的相关结构体 1struct input_dev {\t/* 输入设备的描述 */ 2const char *name;\t/* 设备名称 */ 3const char *phys; 4const char *uniq; 5struct input_id id; 67unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; 89unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; 10unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; 11unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; 12unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; 13unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; 14unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; 15unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; 16unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; 17unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; 1819unsigned int hint_events_per_packet; 2021unsigned int keycodemax; 22unsigned int keycodesize; 23void *keycode; 2425int (*setkeycode)(struct input_dev *dev, 26const struct input_keymap_entry *ke, 27unsigned int *old_keycode); 28int (*getkeycode)(struct input_dev *dev, 29struct input_keymap_entry *ke); 3031struct ff_device *ff; 3233unsigned int repeat_key; 34struct timer_list timer; 3536int rep[REP_CNT]; 3738struct input_mt *mt; 3940struct input_absinfo *absinfo; 4142unsigned long key[BITS_TO_LONGS(KEY_CNT)]; 43unsigned long led[BITS_TO_LONGS(LED_CNT)]; 44unsigned long snd[BITS_TO_LONGS(SND_CNT)]; 45unsigned long sw[BITS_TO_LONGS(SW_CNT)]; 4647int (*open)(struct input_dev *dev); 48void (*close)(struct input_dev *dev); 49int (*flush)(struct input_dev *dev, struct file *file); 50int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); 5152struct input_handle __rcu *grab; 5354spinlock_t event_lock; 55struct mutex mutex; 5657unsigned int users; 58bool going_away; 5960struct device dev; 6162struct list_head\th_list; 63struct list_head\tnode; 6465unsigned int num_vals; 66unsigned int max_vals; 67struct input_value *vals; 6869bool devres_managed; 70}; 71#define to_input_dev(d) container_of(d, struct input_dev, dev) input子系统使用 input子系统分析  Makefile编写  1obj-$(CONFIG_INPUT)\t+= input-core.o 2input-core-y := input.o input-compat.o input-mt.o ff-core.o 开始判断下面的第一个文件 input.c  1subsys_initcall(input_init); 2module_exit(input_exit); 输入子系统的设备号\n1#define INPUT_MAJOR 13 安装驱动\n1static int __init input_init(void) 2{ 3int err; 4/* 注册设备类 */ 5err = class_register(\u0026amp;input_class); 6if (err) { 7pr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 8return err; 9} 1011/* 注册proc文件系统 */ 12err = input_proc_init(); 13if (err) 14goto fail1; 15/* 注册设备 */ 16err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), 17INPUT_MAX_CHAR_DEVICES, \u0026#34;input\u0026#34;); 18if (err) { 19pr_err(\u0026#34;unable to register char major %d\u0026#34;, INPUT_MAJOR); 20goto fail2; 21} 2223return 0; 2425fail2:\tinput_proc_exit(); 26fail1:\tclass_unregister(\u0026amp;input_class); 27return err; 28} 卸载驱动\n1static void __exit input_exit(void) 2{ 3/* 卸载proc文件系统 */ 4input_proc_exit(); 56/* 注销设备号 */ 7unregister_chrdev_region(MKDEV(INPUT_MAJOR, 0), 8INPUT_MAX_CHAR_DEVICES); 910/* 注销CLass */ 11class_unregister(\u0026amp;input_class); 12} 设备类操作\n1/* 设备类型 */ 2struct class input_class = { 3.name\t= \u0026#34;input\u0026#34;, 4.devnode\t= input_devnode, 5}; 6EXPORT_SYMBOL_GPL(input_class); 78/* 注册设备 */ 9err = class_register(\u0026amp;input_class); 10if (err) { 11pr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 12return err; 13} 1415/* 卸载设备 */ 16class_unregister(\u0026amp;input_class); Proc文件系统操作\nProc文件系统添加\n1static int __init input_proc_init(void) 2{ 3struct proc_dir_entry *entry; 45proc_bus_input_dir = proc_mkdir(\u0026#34;bus/input\u0026#34;, NULL); 6if (!proc_bus_input_dir) 7return -ENOMEM; 89entry = proc_create(\u0026#34;devices\u0026#34;, 0, proc_bus_input_dir, 10\u0026amp;input_devices_fileops); 11if (!entry) 12goto fail1; 1314entry = proc_create(\u0026#34;handlers\u0026#34;, 0, proc_bus_input_dir, 15\u0026amp;input_handlers_fileops); 16if (!entry) 17goto fail2; 1819return 0; 2021fail2:\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 22fail1: remove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 23return -ENOMEM; 24} Proc文件系统卸载\n1static void input_proc_exit(void) 2{ 3remove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 4remove_proc_entry(\u0026#34;handlers\u0026#34;, proc_bus_input_dir); 5remove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 6} 接口部分 Handler操作 1/** 2* 注册 input handler 3* input_register_handler - register a new input handler 4* @handler: handler to be registered 5* 6* This function registers a new input handler (interface) for input 7* devices in the system and attaches it to all input devices that 8* are compatible with the handler. 9*/ 10int input_register_handler(struct input_handler *handler) 11{ 12struct input_dev *dev; 13int error; 1415error = mutex_lock_interruptible(\u0026amp;input_mutex); 16if (error) 17return error; 1819INIT_LIST_HEAD(\u0026amp;handler-\u0026gt;h_list); 2021list_add_tail(\u0026amp;handler-\u0026gt;node, \u0026amp;input_handler_list); 2223list_for_each_entry(dev, \u0026amp;input_dev_list, node) 24input_attach_handler(dev, handler); 2526input_wakeup_procfs_readers(); 2728mutex_unlock(\u0026amp;input_mutex); 29return 0; 30} 31EXPORT_SYMBOL(input_register_handler); 3233/** 34* 解除注册 input handler 35* input_unregister_handler - unregisters an input handler 36* @handler: handler to be unregistered 37* 38* This function disconnects a handler from its input devices and 39* removes it from lists of known handlers. 40*/ 41void input_unregister_handler(struct input_handler *handler) 42{ 43struct input_handle *handle, *next; 4445mutex_lock(\u0026amp;input_mutex); 4647list_for_each_entry_safe(handle, next, \u0026amp;handler-\u0026gt;h_list, h_node) 48handler-\u0026gt;disconnect(handle); 49WARN_ON(!list_empty(\u0026amp;handler-\u0026gt;h_list)); 5051list_del_init(\u0026amp;handler-\u0026gt;node); 5253input_wakeup_procfs_readers(); 5455mutex_unlock(\u0026amp;input_mutex); 56} 57EXPORT_SYMBOL(input_unregister_handler); 注册设备 1/** 2* 注册一个设备 3* input_register_device - register device with input core 4* @dev: device to be registered 5* 6* This function registers device with input core. The device must be 7* allocated with input_allocate_device() and all it\u0026#39;s capabilities 8* set up before registering. 9* If function fails the device must be freed with input_free_device(). 10* Once device has been successfully registered it can be unregistered 11* with input_unregister_device(); input_free_device() should not be 12* called in this case. 13* 14* Note that this function is also used to register managed input devices 15* (ones allocated with devm_input_allocate_device()). Such managed input 16* devices need not be explicitly unregistered or freed, their tear down 17* is controlled by the devres infrastructure. It is also worth noting 18* that tear down of managed input devices is internally a 2-step process: 19* registered managed input device is first unregistered, but stays in 20* memory and can still handle input_event() calls (although events will 21* not be delivered anywhere). The freeing of managed input device will 22* happen later, when devres stack is unwound to the point where device 23* allocation was made. 24*/ 25int input_register_device(struct input_dev *dev) 26{ 27struct input_devres *devres = NULL; 28struct input_handler *handler; 29unsigned int packet_size; 30const char *path; 31int error; 3233if (dev-\u0026gt;devres_managed) { 34devres = devres_alloc(devm_input_device_unregister, 35sizeof(struct input_devres), GFP_KERNEL); 36if (!devres) 37return -ENOMEM; 3839devres-\u0026gt;input = dev; 40} 4142/* Every input device generates EV_SYN/SYN_REPORT events. */ 43__set_bit(EV_SYN, dev-\u0026gt;evbit); 4445/* KEY_RESERVED is not supposed to be transmitted to userspace. */ 46__clear_bit(KEY_RESERVED, dev-\u0026gt;keybit); 4748/* Make sure that bitmasks not mentioned in dev-\u0026gt;evbit are clean. */ 49input_cleanse_bitmasks(dev); 5051packet_size = input_estimate_events_per_packet(dev); 52if (dev-\u0026gt;hint_events_per_packet \u0026lt; packet_size) 53dev-\u0026gt;hint_events_per_packet = packet_size; 5455dev-\u0026gt;max_vals = dev-\u0026gt;hint_events_per_packet + 2; 56dev-\u0026gt;vals = kcalloc(dev-\u0026gt;max_vals, sizeof(*dev-\u0026gt;vals), GFP_KERNEL); 57if (!dev-\u0026gt;vals) { 58error = -ENOMEM; 59goto err_devres_free; 60} 6162/* 63* If delay and period are pre-set by the driver, then autorepeating 64* is handled by the driver itself and we don\u0026#39;t do it in input.c. 65*/ 66if (!dev-\u0026gt;rep[REP_DELAY] \u0026amp;\u0026amp; !dev-\u0026gt;rep[REP_PERIOD]) { 67dev-\u0026gt;timer.data = (long) dev; 68dev-\u0026gt;timer.function = input_repeat_key; 69dev-\u0026gt;rep[REP_DELAY] = 250; 70dev-\u0026gt;rep[REP_PERIOD] = 33; 71} 7273if (!dev-\u0026gt;getkeycode) 74dev-\u0026gt;getkeycode = input_default_getkeycode; 7576if (!dev-\u0026gt;setkeycode) 77dev-\u0026gt;setkeycode = input_default_setkeycode; 7879error = device_add(\u0026amp;dev-\u0026gt;dev); 80if (error) 81goto err_free_vals; 8283path = kobject_get_path(\u0026amp;dev-\u0026gt;dev.kobj, GFP_KERNEL); 84pr_info(\u0026#34;%s as %s\\n\u0026#34;, 85dev-\u0026gt;name ? dev-\u0026gt;name : \u0026#34;Unspecified device\u0026#34;, 86path ? path : \u0026#34;N/A\u0026#34;); 87kfree(path); 8889error = mutex_lock_interruptible(\u0026amp;input_mutex); 90if (error) 91goto err_device_del; 9293list_add_tail(\u0026amp;dev-\u0026gt;node, \u0026amp;input_dev_list); 9495list_for_each_entry(handler, \u0026amp;input_handler_list, node) 96input_attach_handler(dev, handler); 9798input_wakeup_procfs_readers(); 99100mutex_unlock(\u0026amp;input_mutex); 101102if (dev-\u0026gt;devres_managed) { 103dev_dbg(dev-\u0026gt;dev.parent, \u0026#34;%s: registering %s with devres.\\n\u0026#34;, 104__func__, dev_name(\u0026amp;dev-\u0026gt;dev)); 105devres_add(dev-\u0026gt;dev.parent, devres); 106} 107return 0; 108109err_device_del: 110device_del(\u0026amp;dev-\u0026gt;dev); 111err_free_vals: 112kfree(dev-\u0026gt;vals); 113dev-\u0026gt;vals = NULL; 114err_devres_free: 115devres_free(devres); 116return error; 117} 118EXPORT_SYMBOL(input_register_device); 119120/** 121* 解除注册设备 122* input_unregister_device - unregister previously registered device 123* @dev: device to be unregistered 124* 125* This function unregisters an input device. Once device is unregistered 126* the caller should not try to access it as it may get freed at any moment. 127*/ 128void input_unregister_device(struct input_dev *dev) 129{ 130if (dev-\u0026gt;devres_managed) { 131WARN_ON(devres_destroy(dev-\u0026gt;dev.parent, 132devm_input_device_unregister, 133devm_input_device_match, 134dev)); 135__input_unregister_device(dev); 136/* 137* We do not do input_put_device() here because it will be done 138* when 2nd devres fires up. 139*/ 140} else { 141__input_unregister_device(dev); 142input_put_device(dev); 143} 144} 145EXPORT_SYMBOL(input_unregister_device); ","date":"Oct 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/input_drive/","series":null,"tags":[],"title":"输入子系统"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/slab/","series":null,"tags":[],"title":"Slab"},{"categories":[],"content":"MMU内存管理单元  ARM内存管理单元分析\n ","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/mmu/","series":null,"tags":[],"title":"Mmu"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/page/","series":null,"tags":[],"title":"Page"},{"categories":[],"content":"fork  linux创建线程的函数 fork \u0026ndash;\u0026gt; do_fork\n do_fork的执行线路 do_fork \u0026ndash;\u0026gt; copy_process \u0026ndash;\u0026gt; get_task_pid \u0026ndash;\u0026gt; wake_up_new_task \u0026ndash;\u0026gt; put_pid\ndo_fork函数原型\n1long _do_fork(unsigned long clone_flags, 2unsigned long stack_start, 3unsigned long stack_size, 4int __user *parent_tidptr, 5int __user *child_tidptr, 6unsigned long tls);  clone_flags stack_start stack_size parent_tidptr child_tidptr tls  copy_process get_task_pid wake_up_new_task ","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/fork/","series":null,"tags":[],"title":"Fork"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/task/","series":null,"tags":[],"title":"任务管理"},{"categories":["linux"],"content":"系统调度  主调度器schedule 周期调度器scheduler_tick  周期调度器函数实现 1void scheduler_tick(void) 2{ 3int cpu = smp_processor_id();\t// CPUID 4\tstruct rq *rq = cpu_rq(cpu);\t// 提取消息队列 5\tstruct task_struct *curr = rq-\u0026gt;curr;\t// 提取正在运行的进程 6\tstruct rq_flags rf;\t// 7\tsched_clock_tick();\t// 8\trq_lock(rq, \u0026amp;rf);\t// 9\tupdate_rq_clock(rq);\t// 更新运行时钟 10\tcurr-\u0026gt;sched_class-\u0026gt;task_tick(rq, curr, 0);\t// 调用调度器类 11\tcpu_load_update_active(rq); 12calc_global_load_tick(rq); 13rq_unlock(rq, \u0026amp;rf); 14perf_event_task_tick(); 15} 主调度器函数实现 1static void __sched notrace __schedule(bool preempt) 2{ 3struct task_struct *prev, *next; 4unsigned long *switch_count; 5struct rq_flags rf; 6struct rq *rq; 7int cpu; 89cpu = smp_processor_id(); 10rq = cpu_rq(cpu); 11prev = rq-\u0026gt;curr; 1213schedule_debug(prev); 1415if (sched_feat(HRTICK)) 16hrtick_clear(rq); 1718local_irq_disable(); 19rcu_note_context_switch(preempt); 2021rq_lock(rq, \u0026amp;rf); 22smp_mb__after_spinlock(); 2324rq-\u0026gt;clock_update_flags \u0026lt;\u0026lt;= 1; 25update_rq_clock(rq); 2627switch_count = \u0026amp;prev-\u0026gt;nivcsw; 28if (!preempt \u0026amp;\u0026amp; prev-\u0026gt;state) { 29if (unlikely(signal_pending_state(prev-\u0026gt;state, prev))) { 30prev-\u0026gt;state = TASK_RUNNING; 31} else { 32deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK); 33prev-\u0026gt;on_rq = 0; 3435if (prev-\u0026gt;in_iowait) { 36atomic_inc(\u0026amp;rq-\u0026gt;nr_iowait); 37delayacct_blkio_start(); 38} 39if (prev-\u0026gt;flags \u0026amp; PF_WQ_WORKER) { 40struct task_struct *to_wakeup; 4142to_wakeup = wq_worker_sleeping(prev); 43if (to_wakeup) 44try_to_wake_up_local(to_wakeup, \u0026amp;rf); 45} 46} 47switch_count = \u0026amp;prev-\u0026gt;nvcsw; 48} 4950next = pick_next_task(rq, prev, \u0026amp;rf); 51clear_tsk_need_resched(prev); 52clear_preempt_need_resched(); 5354if (likely(prev != next)) { 55rq-\u0026gt;nr_switches++; 56rq-\u0026gt;curr = next; 57++*switch_count; 5859trace_sched_switch(preempt, prev, next); 60rq = context_switch(rq, prev, next, \u0026amp;rf); 61} else { 62rq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); 63rq_unlock_irq(rq, \u0026amp;rf); 64} 6566balance_callback(rq); 67} 寻找最高优先级任务 1/* 2* 获取最高优先级的任务: 3*/ 4static inline struct task_struct 5*pick_next_task(struct rq *rq, 6struct task_struct *prev, 7struct rq_flags *rf) 8{ 9const struct sched_class *class;\t// 调度器类 10\tstruct task_struct *p;\t// 任务实体 11 12if (likely((prev-\u0026gt;sched_class == \u0026amp;idle_sched_class || 13prev-\u0026gt;sched_class == \u0026amp;fair_sched_class) \u0026amp;\u0026amp; 14rq-\u0026gt;nr_running == rq-\u0026gt;cfs.h_nr_running)) { 1516p = fair_sched_class.pick_next_task(rq, prev, rf); 17if (unlikely(p == RETRY_TASK)) 18goto again; 1920/* Assumes fair_sched_class-\u0026gt;next == idle_sched_class */ 21if (unlikely(!p)) 22p = idle_sched_class.pick_next_task(rq, prev, rf); 2324return p; 25} 2627again: 28for_each_class(class) { 29p = class-\u0026gt;pick_next_task(rq, prev, rf); 30if (p) { 31if (unlikely(p == RETRY_TASK)) 32goto again; 33return p; 34} 35} 3637/* IDLE线程不会退出 */ 38BUG(); 39} 任务切换 1static __always_inline struct rq * 2context_switch(struct rq *rq, struct task_struct *prev, 3struct task_struct *next, struct rq_flags *rf) 4{ 5struct mm_struct *mm, *oldmm; 67prepare_task_switch(rq, prev, next); 89mm = next-\u0026gt;mm; 10oldmm = prev-\u0026gt;active_mm; 11/* 12* For paravirt, this is coupled with an exit in switch_to to 13* combine the page table reload and the switch backend into 14* one hypercall. 15*/ 16arch_start_context_switch(prev); 1718/* 19* If mm is non-NULL, we pass through switch_mm(). If mm is 20* NULL, we will pass through mmdrop() in finish_task_switch(). 21* Both of these contain the full memory barrier required by 22* membarrier after storing to rq-\u0026gt;curr, before returning to 23* user-space. 24*/ 25if (!mm) { 26next-\u0026gt;active_mm = oldmm; 27mmgrab(oldmm); 28enter_lazy_tlb(oldmm, next); 29} else 30switch_mm_irqs_off(oldmm, mm, next); 3132if (!prev-\u0026gt;mm) { 33prev-\u0026gt;active_mm = NULL; 34rq-\u0026gt;prev_mm = oldmm; 35} 3637rq-\u0026gt;clock_update_flags \u0026amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP); 3839prepare_lock_switch(rq, next, rf); 4041/* Here we just switch the register state and the stack. */ 42switch_to(prev, next, prev); 43barrier(); 4445return finish_task_switch(prev); 46} ","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/sched/","series":null,"tags":["kernel"],"title":"系统调度"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/rime/","series":null,"tags":[],"title":"Rime"},{"categories":[],"content":"WASM笔记 ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/wasm/","series":null,"tags":[],"title":"Wasm"},{"categories":[],"content":"jupyter 安装 1conda install jupyter 基本配置 生成配置 1jupyter notebook --generate-config 自动生成配置文件 ~/.jupyter/jupyter_notebook_config.py\n设置密码 1jupyter notebook password  ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/jupyter/","series":null,"tags":[],"title":"Jupyter"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/conda/","series":null,"tags":[],"title":"Conda"},{"categories":[],"content":"RUST学习笔记\n====\n安装  添加环境变量.bashrc/profile  1set RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 2set RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 安装工具链  1curl https://mirrors.ustc.edu.cn/rust-static/rustup/rustup-init.sh | sh 设置rust的环境变量.bashrc/profile  1source ~/.cargo/env 2set PATH=~/.cargo/bin;$PATH 入门基础 HelloWorld  创建工程  1cargo new hello_world 编译  1cargo build 运行  1cargo run 数据类型    长度 有符号 无符号     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128   arch isize usize    1// 创建变量 2let_xi32: i32 =5;3let_xu32: u32 =5;4let_xi64: i64 =10;5let_xu64: u64 =10;6let_xi128: i128 =5;7let_xu128: u128 =5;8let_xisize: isize =10;9let_xusize: usize =10;函数 1// 有返回值 2fn function_return()-\u0026gt; i32 {3println!(\u0026#34;Hello, World!\u0026#34;);4return0;5}67// 无返回值 8fn function_noreturn(){9println!(\u0026#34;Hello, World!\u0026#34;);10} 必须明确表示是否存在返回值 语法校验比较严格,  条件语句 1if\u0026lt;cond\u0026gt;{2do;3}1if\u0026lt;cond\u0026gt;{2Do1;3}else{4Do2;5}1if\u0026lt;cond1\u0026gt;{2Do1;3}elseif\u0026lt;cond2\u0026gt;{4Do2;5}else{6Do3;7}","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/rust/","series":null,"tags":[],"title":"Rust"},{"categories":[],"content":"C++基础语法 第一个程序 1#include \u0026lt;iostream\u0026gt;2 3using namespace std; 45int main(int argc, char *argv[]) 6{ 7cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; 8return 0; 9} 注释类型  单行注释  1// 这个是一个单行注释  多行注释  1/* 2这个里面是一个注释 3*/ 变量 变量的存在意义:方便我们管理内存\n变量创建的语法\n1数据类型 变量名 = 变量初始化; 常量 作用: 记录程序中不可以改变的数据\n define 宏常量(预编译期) const 修饰变量(编译期)  关键字    关键字        asm else new this   auto enum operator throw   bool explicit private true   break export protected try   case extern public typedef   catch false register typeid   char float reinterpret_cast typename   class for return union   const friend short unsigned   const_cast goto signed using   continue if sizeof virtual   default inline static void   delete int static_cast volatile   do long struct wchar_t   double mutable switch while   dynamic_cast namespace template     标识符命名规则  标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写  数据类型 指定类型,分配内存\n整形 浮点型  单精度float 双精度double  字符型 转义字符 字符串  C风格  1char 变量名[] = \u0026#34;字符串值\u0026#34;; C++风格  1string 变量名 = \u0026#34;字符串值\u0026#34;; 布尔类型 1bool A = true; 2bool B = false; 运算符 基本运算符 取模运算 就是取余数\n自增自减运算 1a1++; 2a2--; 赋值运算    运算符 术语 示例 结果     =      +=      -=      *=      /=      %=       比较运算符 逻辑运算符 程序流程结构 顺序结构 if语句 三目运算符 1表达式1? 表达式2:表达式3 选择结构 1switch(condition) 2{ 3case 条件1: 4break; 5case 条件2: 6break; 7default: 8break; 9} 循环结构 while循环 1while(条件) 2{ 3循环体; 4} dowhile循环 1do { 23} while(条件) for循环 1for (起始表达式; 条件表达式; 末尾循环体) 2{ 3循环体; 4} 跳转语句 break continue goto 数组 函数定义  返回值类型 函数名 参数列表 函数体语句 return表达式  1返回值类型 函数名字(参数列表) 2{ 3函数体语句; 4return 表达式; 5} 值传递 类似数值拷贝\n函数的常见样式  无参无返 有参无返 无参有反 有参有返  函数的声明 作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现;\n函数的分文件编写 指针 指针的定义和使用 指针所占用空间 空指针 含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的\n野指针 指针指向非法的内存空间\nconst与指针  const修饰指针 const修饰常量 const既修饰指针又修饰常量  1const int *p = \u0026amp;a; 23int const *p = \u0026amp;a; 45const int *const p = \u0026amp;a; 指针与数组 指针与函数 结构体 结构体数组 结构体指针 结构体嵌套 C++核心编程 本阶段主要对面向对象进行详细讲解\nC++内存分区 c++程序在运行时,将内存分为4个区域\n 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放  new/delete操作符 C++利用new操作符在堆区开辟内存\n引用 作用: 给变量起别名 语法: 数据类型 \u0026amp;别名 = 原名;\n引用做参数 1#include \u0026lt;iostream\u0026gt;2void swap(int \u0026amp;a, int \u0026amp;b) 3{ 4int t; t = a;a = b;b = t; 5} 6int main(int argc, char *argv[]) 7{ 8int a = 10;int b = 12; 9std::cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 10swap(a, b); 11std::cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 12return 0; 13} 执行结果\n 引用做返回值 引用的本质 引用的本质是C++内部实现的一个指针常量\n常量引用 1const int \u0026amp;ref = 10; 函数提高 函数默认值  某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突)  1void test_default_param(int a = 0, int b = 0, int c = 0) 2{ 3std::cout \u0026lt;\u0026lt; a + b + c \u0026lt;\u0026lt; std::endl; 4} 函数的占位参数 占位参数还可以有默认值\n1void test(int a, int = 10) { 2std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; 3} 函数重载 作用:函数名相同,提高复用性\n重载的条件:\n  相同作用域\n  函数名相同\n  参数不同(类型, 个数,顺序)\n  注意事项:\n 引用作为重载条件 函数重载碰到默认参数  类和对象 类的访问属性\n public: protected: private:  class与struct的区别 class默认权限是private struct默认权限是public\n构造函数和析构函数 对象的初始化和清理\n 构造函数有参数 析构函数没有参数 二者都没有返回值  拷贝构造函数 1class Person { 2public: 3/* 构造函数 */ 4Person(std::string name, int age) { 5std::cout \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 6} 7/* 析构函数 */ 8~Person() { 9std::cout \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; std::endl; 10} 11/* 拷贝构造函数 */ 12Person(const Person \u0026amp;p) { 13std::cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 14} 15};  调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果  1Person testPerson();\t// 表面上是执行构造函数 2int func();\t// 类似函数声明 拷贝构造函数的调用时机  使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象  构造函数的调用规则 默认情况下:C++编译器至少给一个类添加3个函数\n 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝  构造函数构造规则如下:\n 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数  深拷贝和浅拷贝  浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作  初始化列表 作用:C++提供了初始化列表语法,用来初始化属性;\n语法:\n1构造函数(): 属性1(值1),属性2(值2),属性3(值3) 2{ 3/* 函数体 */ 4} 类对象作为类成员 静态成员 静态成员就是在静态成员变量和成员函数前加上static,称为静态成员;\n 静态成员变量  所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化   静态成员函数  所有对象共享同一个函数 静态成员函数只能访问静态成员变量    1class Person { 2public: 3static int age; 4static void func() 5{ 6std::cout \u0026lt;\u0026lt; \u0026#34;静态成员函数\u0026#34; \u0026lt;\u0026lt; std::endl; 7} 8}; 9/* 通过对象访问 */ 10Person p; 11p.func(); 12/* 通过类访问 */ 13Person::func(); 成员变量和成员函数分开存储  非静态成员,\t属于类的对象 静态成员,\t不属于类的对象 非静态成员函数,\t不属于类的对象 静态成员函数, 不属于类的对象  空对象大小为1\nC++对象模型 this指针 this指针指向被调用成员函数所属的对象 this指针本质：指针常量\n空指针访问成员函数 C++空指针也是可以访问成员函数的,但是要注意的this指针;\nconst修饰成员函数 常函数:\n 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数  执行原理\n1this ==\u0026gt; Person * const this; 2后面新追加的const则会造成 3const Person * const this; 1class Person { 2public: 3int m_A; 4mutable int m_B; 5void showPerson() const 6{ 7m_A = 10; /* 错误,不可修改 */ 8m_B = 10; /* 正确,可以修改 */ 9} 10}; 友元  全局函数 全局类 成员函数  运算符重载 重载的原理:对已有的运算符进行重新定义,赋予新的功能含义;\n通过成员函数重载运算符 1class Person { 2public: 3int m_A; 4int m_B; 56/* 使用成员函数实现 */ 7Person PersonAddPerson(Person \u0026amp;p) 8{ 9Person t; 10t.m_A = this-\u0026gt;m_A + p.m_A; 11t.m_B = this-\u0026gt;m_B + p.m_B; 12return t; 13} 1415/* 重载+ */ 16Person operator+(Person \u0026amp;p) 17{ 18Person t; 19t.m_A = this-\u0026gt;m_A + p.m_A; 20t.m_B = this-\u0026gt;m_B + p.m_B; 21return t; 22} 23}; 2425int main(int argc, char *argv[]) 26{ 27Person p1; 28Person p2; 2930Person p3 = p1.PersonAddPerson(p2); 3132Person p4 = p1.operator+(p2); 3334Person p5 = p1 + p2; 3536return 0; 37}  通过全局函数重载 1Person operator+(Person \u0026amp;p1, Person \u0026amp;p2) 2{ 3Person t; 4t.m_A = p1.m_A + p2.m_A; 5t.m_B = p2.m_B + p2.m_B; 6return t; 7} 重载左移运算符 1std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Person \u0026amp;p) 2{ 3cout \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; p.m_B; 4return cout; 5} 递增重载++ 注意:\n 前置递增 p++ 后置递增 ++p  重载例子(复数) 1#include \u0026lt;iostream\u0026gt;2 3class Complex { 4friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p); 56public: 7Complex(int i, int j); 89Complex(); 1011/* 重载+ */ 12Complex operator+(Complex \u0026amp;p) 13{ 14Complex t; 15t.i = this-\u0026gt;i + p.i; 16t.j = this-\u0026gt;j + p.j; 17return t; 18} 19/* 重载前置++ */ 20Complex\u0026amp; operator++() 21{ 22this-\u0026gt;i++; 23this-\u0026gt;j++; 24return *this; 25} 2627/* 重载后置++ */ 28Complex operator++(int) 29{ 30Complex t; 3132/* 记录 */ 33t.i = this-\u0026gt;i; 34t.j = this-\u0026gt;j; 3536/* 递增 */ 37this-\u0026gt;i++; 38this-\u0026gt;j++; 3940return t; 41} 4243/* 重载= */ 44Complex\u0026amp; operator=(Complex \u0026amp;p) 45{ 46this-\u0026gt;i = p.i; 47this-\u0026gt;j = p.j; 4849return *this; 50} 51private: 52int i; /* 实部 */ 53int j; /* 虚部 */ 54}; 5556/* 构造函数 */ 57Complex::Complex(int i, int j) 58{ 59this-\u0026gt;i = i; 60this-\u0026gt;j = j; 61} 6263Complex::Complex() 64{ 65this-\u0026gt;i = 0; 66this-\u0026gt;j = 0; 67} 6869std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p) 70{ 71cout \u0026lt;\u0026lt; p.i \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; p.j \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; 72return cout; 73} 7475int main(int argc, char *argv[]) 76{ 77Complex p1(1, 2); 78Complex p2(3, 4); 7980std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; std::endl; 81std::cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl; 82std::cout \u0026lt;\u0026lt; p1 + p2 \u0026lt;\u0026lt; std::endl; 8384std::cout \u0026lt;\u0026lt; ++p1 \u0026lt;\u0026lt; std::endl; 85std::cout \u0026lt;\u0026lt; p2++ \u0026lt;\u0026lt; std::endl; 8687Complex p3 = p2 = p1; 88std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p3 \u0026lt;\u0026lt; std::endl; 8990return 0; 91} 继承 减少重复代码\n1class 子类 : 继承方式 父类 父类:基类 子类:派生类\n继承方式  公共继承 保护继承 私有继承  继承中的对象模型 构造和析构的顺序  先构造父类再构造子类 先析构子类再析构父类\n 继承中同名成员处理  访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A  多重继承 C++允许一个类继承多个基类\n1class 子类 : 继承方式 父类1, 继承方式 父类2...  冲突解决：加上类名\n 菱形继承  孙子类继承了子类1和子类2,但是继承了两次父类。\n 多重继承数据会产生二义性 数据只需要一份即可  1/* 动物类 */ 2class Animal { 3public: 4int m_age; 5}; 6class Sheep : public Animal {}; /* 羊类 */ 7class Camel : public Animal {}; /* 驼类 */ 8class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ 9int main(int argc, char *argv[]) 10{ 11Alpaca a; 12a.Sheep::m_age = 18; 13a.Camel::m_age = 18; 14return 0; 15}  虚继承\n 1class Sheep : virtual public Animal {}; /* 羊类 */ 2class Camel : virtual public Animal {}; /* 驼类 */ 虚基类指针(vbptr) vbptr \u0026ndash;\u0026gt; vbtable\n多态  分类  静态多态: 重载 动态多态:虚函数   区别  静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址    父类接收子类的对象,在程序运行期间确定具体改调用那个函数;\n  有继承关系\n  子类重写父类的虚函数 重写：函数完全一致\n  纯虚函数  只要有一个纯虚函数，就称为抽象类\n  抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类  原理 虚析构和纯虚析构 C++提高编程  泛型编程/STL\n 模版 建立通用的模板,提高复用；\nC++提供两种模版机制:函数模版和类模板\n函数模版 1template \u0026lt;typename T\u0026gt; 2函数声明和定义  template \u0026ndash; 声明创建模版 typename \u0026ndash; 表明后面的符号是数据类型可以用class代替 T \u0026ndash; 通用的数据类型  实例 1/* 两个数据交换 */ 2template \u0026lt;typename T\u0026gt; 3void swap(T \u0026amp;a, T \u0026amp;b) 4{ 5T t= a; a = b; b = t; 6} 注意事项  自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用  普通函数和函数模版的区别  普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换  模版函数\n1template \u0026lt;typename T\u0026gt; 2T add(T a, T b) 3{ 4return a + b; 5} 调用方法\n1/* 自动推导 */ 2std::cout \u0026lt;\u0026lt; add(10, 20) \u0026lt;\u0026lt; std::endl; 3/* 显示指定 */ 4std::cout \u0026lt;\u0026lt; add\u0026lt;int\u0026gt;(10, 3.14) \u0026lt;\u0026lt; std::endl; 普通函数和模版函数调用规则  普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u0026lt;\u0026gt;(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版  类模板 1template \u0026lt;class T\u0026gt; 2类 例子\n1template \u0026lt;class NameType, class AgeType\u0026gt; 2class Person { 3public: 4Person(NameType Name, AgeType Age) 5{ 6m_Name = Name; 7m_Age = Age; 8} 9NameType m_Name; 10AgeType m_Age; 11}; 调用\n1Person\u0026lt;std::string, int\u0026gt; p(\u0026#34;Hello\u0026#34;, 99); ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/c++/","series":null,"tags":[],"title":"C++笔记"},{"categories":[],"content":"doxygen教程 开始doxygen ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/doxygen/","series":null,"tags":[],"title":"Doxygen"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/engineering_compiler/","series":null,"tags":["compiler"],"title":"Engineering_compiler"},{"categories":null,"content":"LuaJIT Lua语法 基本语法 1print(\u0026#34;Hello World\u0026#34;) 表(table) LuaJIT分析 LuaJIT主函数 1int main(int argc, char **argv) 2{ 3int status; /* 返回值 */ 4lua_State *L = lua_open(); /* 创建LUA状态机 */ 5if (L == NULL) { 6l_message(argv[0], \u0026#34;cannot create state: not enough memory\u0026#34;); 7return EXIT_FAILURE; 8} 910/* smain只存在三个参数,主要作用是向pmain传递数据 */ 11smain.argc = argc; 12smain.argv = argv; 1314status = lua_cpcall(L, pmain, NULL);\t/* 启动函数调用 */ 1516report(L, status); /* 提取报错参数 */ 1718lua_close(L);\t/* 销毁状态机 */ 1920return (status || smain.status \u0026gt; 0) ? EXIT_FAILURE : EXIT_SUCCESS; 21} Lua状态机 1struct lua_State { 2GCObject*next; 34lu_byte tt; 5lu_byte marked; 6lu_byte status; 78StkId top; 9StkId base; 1011global_State *l_G;\t/* 全局状态信息 */ 1213CallInfo*ci; 1415const Instruction*savedpc; 16StkId stack_last; 17StkId stack; 1819CallInfo*end_ci; 20CallInfo*base_ci; 2122int stacksize; 23int size_ci; 24unsigned short nCcalls; 25unsigned short baseCcalls; 2627lu_byte hookmask; 28lu_byte allowhook; 2930int basehookcount; 31int hookcount; 3233lua_Hook hook; 3435TValue l_gt; 36TValue env; 3738GCObject*openupval; 39GCObject*gclist; 4041struct lua_longjmp*errorJmp; 4243ptrdiff_t errfunc; 44}; 创建状态 1/* 此函数实际不存在,程序内部使用的是宏定义 */ 2void lua_open(void); 34/* 实际调用位置 */ 5LUALIB_API lua_State *luaL_newstate(void); 67/* 根据编译期64位信息选择调用 */ 8#if LJ_64 \u0026amp;\u0026amp; !LJ_GC64 \u0026amp;\u0026amp; !(defined(LUAJIT_USE_VALGRIND) \u0026amp;\u0026amp; defined(LUAJIT_USE_SYSMALLOC)) 9lua_State *lj_state_newstate(lua_Alloc allocf, void *allocd); 10#else 11LUA_API lua_State *lua_newstate(lua_Alloc allocf, void *allocd); 12#endif 函数调用 1LUA_API int lua_cpcall(lua_State *L, lua_CFunction func, void *ud); 2LUA_API int lua_pcall(lua_State *L, int nargs, int nresults, int errfunc); 3LUA_API void lua_call(lua_State *L, int nargs, int nresults); lua_cpcall函数调用\n执行原理 FFI分析 ","date":"Sep 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/luajit/","series":null,"tags":null,"title":"LuaJIT"},{"categories":null,"content":"页面分配器 核心函数: __alloc_pages_nodemask\n gfp_mask : 分配掩码 order : 分配阶数 preferred_nid nodemask  核心函数 1struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) 2{ 3struct page *page;\t// 分配变量 4\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\t// 分配标志 5\tgfp_t alloc_mask; // 真实分配掩码 6\tstruct alloc_context ac = { };\t// 保存相关参数 7 8/* 9* There are several places where we assume that the order value is sane 10* so bail out early if the request is out of bound. 11* 限制分配的大小 12*/ 13if (unlikely(order \u0026gt;= MAX_ORDER)) { 14WARN_ON_ONCE(!(gfp_mask \u0026amp; __GFP_NOWARN)); 15return NULL; 16} 1718gfp_mask \u0026amp;= gfp_allowed_mask; 19alloc_mask = gfp_mask; 20if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026amp;ac, \u0026amp;alloc_mask, \u0026amp;alloc_flags)) 21return NULL; 2223finalise_ac(gfp_mask, \u0026amp;ac); 2425/* First allocation attempt */ 26page = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026amp;ac); 27if (likely(page)) 28goto out; 2930/* 31* Apply scoped allocation constraints. This is mainly about GFP_NOFS 32* resp. GFP_NOIO which has to be inherited for all allocation requests 33* from a particular context which has been marked by 34* memalloc_no{fs,io}_{save,restore}. 35*/ 36alloc_mask = current_gfp_context(gfp_mask); 37ac.spread_dirty_pages = false; 3839/* 40* Restore the original nodemask if it was potentially replaced with 41* \u0026amp;cpuset_current_mems_allowed to optimize the fast-path attempt. 42*/ 43if (unlikely(ac.nodemask != nodemask)) 44ac.nodemask = nodemask; 4546page = __alloc_pages_slowpath(alloc_mask, order, \u0026amp;ac); 4748out: 49if (memcg_kmem_enabled() \u0026amp;\u0026amp; (gfp_mask \u0026amp; __GFP_ACCOUNT) \u0026amp;\u0026amp; page \u0026amp;\u0026amp; 50unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) { 51__free_pages(page, order); 52page = NULL; 53} 5455trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); 5657return page; 58} prepare_alloc_pages 1static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, 2int preferred_nid, nodemask_t *nodemask, 3struct alloc_context *ac, gfp_t *alloc_mask, 4unsigned int *alloc_flags) 5{ 6ac-\u0026gt;high_zoneidx = gfp_zone(gfp_mask); 7ac-\u0026gt;zonelist = node_zonelist(preferred_nid, gfp_mask); 8ac-\u0026gt;nodemask = nodemask; 9ac-\u0026gt;migratetype = gfpflags_to_migratetype(gfp_mask); 1011if (cpusets_enabled()) { 12*alloc_mask |= __GFP_HARDWALL; 13if (!ac-\u0026gt;nodemask) 14ac-\u0026gt;nodemask = \u0026amp;cpuset_current_mems_allowed; 15else 16*alloc_flags |= ALLOC_CPUSET; 17} 1819fs_reclaim_acquire(gfp_mask); 20fs_reclaim_release(gfp_mask); 2122might_sleep_if(gfp_mask \u0026amp; __GFP_DIRECT_RECLAIM); 2324if (should_fail_alloc_page(gfp_mask, order)) 25return false; 2627if (IS_ENABLED(CONFIG_CMA) \u0026amp;\u0026amp; ac-\u0026gt;migratetype == MIGRATE_MOVABLE) 28*alloc_flags |= ALLOC_CMA; 2930return true; 31} get_page_from_freelist 1static struct page * 2get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, 3const struct alloc_context *ac) 4{ 5struct zoneref *z = ac-\u0026gt;preferred_zoneref; 6struct zone *zone; 7struct pglist_data *last_pgdat_dirty_limit = NULL; 89/* 10* Scan zonelist, looking for a zone with enough free. 11* See also __cpuset_node_allowed() comment in kernel/cpuset.c. 12*/ 13for_next_zone_zonelist_nodemask(zone, z, ac-\u0026gt;zonelist, ac-\u0026gt;high_zoneidx, 14ac-\u0026gt;nodemask) { 15struct page *page; 16unsigned long mark; 1718if (cpusets_enabled() \u0026amp;\u0026amp; 19(alloc_flags \u0026amp; ALLOC_CPUSET) \u0026amp;\u0026amp; 20!__cpuset_zone_allowed(zone, gfp_mask)) 21continue; 22/* 23* When allocating a page cache page for writing, we 24* want to get it from a node that is within its dirty 25* limit, such that no single node holds more than its 26* proportional share of globally allowed dirty pages. 27* The dirty limits take into account the node\u0026#39;s 28* lowmem reserves and high watermark so that kswapd 29* should be able to balance it without having to 30* write pages from its LRU list. 31* 32* XXX: For now, allow allocations to potentially 33* exceed the per-node dirty limit in the slowpath 34* (spread_dirty_pages unset) before going into reclaim, 35* which is important when on a NUMA setup the allowed 36* nodes are together not big enough to reach the 37* global limit. The proper fix for these situations 38* will require awareness of nodes in the 39* dirty-throttling and the flusher threads. 40*/ 41if (ac-\u0026gt;spread_dirty_pages) { 42if (last_pgdat_dirty_limit == zone-\u0026gt;zone_pgdat) 43continue; 4445if (!node_dirty_ok(zone-\u0026gt;zone_pgdat)) { 46last_pgdat_dirty_limit = zone-\u0026gt;zone_pgdat; 47continue; 48} 49} 5051mark = zone-\u0026gt;watermark[alloc_flags \u0026amp; ALLOC_WMARK_MASK]; 52if (!zone_watermark_fast(zone, order, mark, 53ac_classzone_idx(ac), alloc_flags)) { 54int ret; 5556#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 57\t/* 58* Watermark failed for this zone, but see if we can 59* grow this zone if it contains deferred pages. 60*/ 61if (static_branch_unlikely(\u0026amp;deferred_pages)) { 62if (_deferred_grow_zone(zone, order)) 63goto try_this_zone; 64} 65#endif 66\t/* Checked here to keep the fast path fast */ 67BUILD_BUG_ON(ALLOC_NO_WATERMARKS \u0026lt; NR_WMARK); 68if (alloc_flags \u0026amp; ALLOC_NO_WATERMARKS) 69goto try_this_zone; 7071if (node_reclaim_mode == 0 || 72!zone_allows_reclaim(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone)) 73continue; 7475ret = node_reclaim(zone-\u0026gt;zone_pgdat, gfp_mask, order); 76switch (ret) { 77case NODE_RECLAIM_NOSCAN: 78/* did not scan */ 79continue; 80case NODE_RECLAIM_FULL: 81/* scanned but unreclaimable */ 82continue; 83default: 84/* did we reclaim enough */ 85if (zone_watermark_ok(zone, order, mark, 86ac_classzone_idx(ac), alloc_flags)) 87goto try_this_zone; 8889continue; 90} 91} 9293try_this_zone: 94page = rmqueue(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone, order, 95gfp_mask, alloc_flags, ac-\u0026gt;migratetype); 96if (page) { 97prep_new_page(page, order, gfp_mask, alloc_flags); 9899/* 100* If this is a high-order atomic allocation then check 101* if the pageblock should be reserved for the future 102*/ 103if (unlikely(order \u0026amp;\u0026amp; (alloc_flags \u0026amp; ALLOC_HARDER))) 104reserve_highatomic_pageblock(page, zone, order); 105106return page; 107} else { 108#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 109\t/* Try again if zone has deferred pages */ 110if (static_branch_unlikely(\u0026amp;deferred_pages)) { 111if (_deferred_grow_zone(zone, order)) 112goto try_this_zone; 113} 114#endif 115\t} 116} 117118return NULL; 119} ","date":"May 9, 2021","img":"","permalink":"https://mengdemao.github.io/posts/page_allocator/","series":null,"tags":null,"title":"Page_allocator"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制\n使用 等待队列头 1struct __wait_queue_head { 2wq_lock_t lock; 3struct list_head task_list; 4}; 5typedef struct __wait_queue_head wait_queue_head_t; 等待队列实体 1struct __wait_queue { 2unsigned int flags; 3struct task_struct * task; 4struct list_head task_list; 5}; 6typedef struct __wait_queue wait_queue_t; 初始化等待队列头 1void __init_waitqueue_head(struct wait_queue_head *wq_head, 2const char *name, struct lock_class_key *); 3void init_waitqueue_head(struct wait_queue_head *wq_head); 初始化等待队列 1#define __WAITQUEUE_INITIALIZER(name, tsk) \\ 2{\t\\ 3.private\t= tsk,\t\\ 4.func\t= default_wake_function,\t\\ 5.entry\t= { NULL, NULL }\t\\ 6} 78#define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) 9 10// 但是，一般直接 11DECLARE_WAITQUEUE(wait, current);  等待队列入口 等待的任务  等待队列操作 1void add_wait_queue(struct wait_queue_head *wq_head, 2struct wait_queue_entry *wq_entry); 3void remove_wait_queue(struct wait_queue_head *wq_head, 4struct wait_queue_entry *wq_entry);  等待队列头 等待队列实体  等待事件 1void wait_event(wq, condition); 2void wait_event_interruptible(wq, condition); 唤醒队列  wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync  例子 写端 1ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) 2{ 3DECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4int ret = -1; 5PTRACE; 67mutex_lock(\u0026amp;wait_device.mutex); 8/* 非阻塞模式直接写入 */ 9if (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10pr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11goto pure_write; 12} 1314add_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 15while (wait_device.wait_flag == true) { 16pr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17__set_current_state(TASK_INTERRUPTIBLE); 18mutex_unlock(\u0026amp;wait_device.mutex); 19schedule(); 20if (signal_pending(current)) { 21ret = -ERESTARTSYS; 22remove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 23__set_current_state(TASK_RUNNING); 24goto out; 25} 26} 27remove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 2829pure_write: 30wait_device.wait_flag = true; 31pr_err(\u0026#34;Write Successful\u0026#34;); 3233wake_up_interruptible(\u0026amp;wait_device.wait_r); 34pr_err(\u0026#34;Wakeup Read\u0026#34;); 35goto out; 3637out: 38mutex_unlock(\u0026amp;wait_device.mutex); 39return ret; 40} 读端 1ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) 2{ 3DECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4int ret = 0; 5PTRACE; 67mutex_lock(\u0026amp;wait_device.mutex); 8/* 非阻塞模式直接写入 */ 9if (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10pr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11goto pure_read; 12} 1314add_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 15while (wait_device.wait_flag == false) { 16pr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17__set_current_state(TASK_INTERRUPTIBLE); 18mutex_unlock(\u0026amp;wait_device.mutex); 19schedule(); 20if (signal_pending(current)) { 21ret = -ERESTARTSYS; 22remove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 23__set_current_state(TASK_RUNNING); 24goto out; 25} 26} 27remove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 2829pure_read: 30wait_device.wait_flag = false; 31pr_err(\u0026#34;Read Successful\u0026#34;); 3233wake_up_interruptible(\u0026amp;wait_device.wait_w); 34pr_err(\u0026#34;Wakeup Write\u0026#34;); 3536goto out; 3738out: 39mutex_unlock(\u0026amp;wait_device.mutex); 40return 0; 41} 原理 ","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/wait_queue/","series":null,"tags":null,"title":"Linux等待队列实现"},{"categories":null,"content":"简介  ANTLR是一款强大的语法分析器生成工具,用于读取、处理、执行和翻译结构化的文本或二进制文件.\n 类似于flex/bison,根据描述文件，自动生成词法语法分析器\n安装说明  下载antlr 设置path和classpath 编写相关脚本  语法设计 错误处理 解析器 测试程序 antlr4编译器 1#!/bin/sh 2antlr4 Expr.g4 编译生成的java文件 1javac *.java 运行编译的结果 1grun Expr prog -tree 1(prog (stat (expr (expr (expr 1) + (expr 2)) + (expr 3)) \\r\\n)) 1grun Expr prog -gui\t1grun Expr prog -tokens 1[@0,0:0=\u0026#39;1\u0026#39;,\u0026lt;INT\u0026gt;,1:0] 2[@1,1:1=\u0026#39;+\u0026#39;,\u0026lt;\u0026#39;+\u0026#39;\u0026gt;,1:1] 3[@2,2:2=\u0026#39;2\u0026#39;,\u0026lt;INT\u0026gt;,1:2] 4[@3,3:3=\u0026#39;+\u0026#39;,\u0026lt;\u0026#39;+\u0026#39;\u0026gt;,1:3] 5[@4,4:4=\u0026#39;3\u0026#39;,\u0026lt;INT\u0026gt;,1:4] 6[@5,5:6=\u0026#39;\\r\\n\u0026#39;,\u0026lt;NEWLINE\u0026gt;,1:5] 7[@6,7:6=\u0026#39;\u0026lt;EOF\u0026gt;\u0026#39;,\u0026lt;EOF\u0026gt;,2:0] antlr语法详解 Hello 1// antlr4 Hello.g42// javac *.java3// grun Hello r -gui4grammarHello;// 定义一个Hello的grammer5r:\u0026#39;hello\u0026#39;ID;// 开头是hello后面接着一个ID6ID:[a-z]+;// ID由小写字母组成7WS:[\\t\\r\\n]+-\u0026gt;skip;// 控制符清除ArrayInit 1// antlr4 ArrayInit.g42// javac *.java3// grun ArrayInit init -gui4grammarArrayInit;// 定义一个ArrayInit的grammer5init:\u0026#39;{\u0026#39;value(\u0026#39;,\u0026#39;value)*\u0026#39;}\u0026#39;;// 6value:init// 嵌套定义7|INT// 定义整数8;9INT:[0-9]+;10WS:[\\t\\r\\n]+-\u0026gt;skip;()* \u0026ndash;\u0026gt; 相当于扩展\nExpr 1// antlr4 Expr.g42// javac *.java3// grun Expr prog -gui4grammarExpr;56prog:stat+;78stat:exprNEWLINE#printExpr9|ID\u0026#39;=\u0026#39;exprNEWLINE#assign10|NEWLINE#blank11;1213expr:exprop=(\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39;)expr#MulDiv14|exprop=(\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;)expr#AddSub15|INT#int16|ID#id17|\u0026#39;(\u0026#39;expr\u0026#39;)\u0026#39;#parens18;1920MUL:\u0026#39;*\u0026#39;;// assigns token name to \u0026#39;*\u0026#39; used above in grammar21DIV:\u0026#39;/\u0026#39;;22ADD:\u0026#39;+\u0026#39;;23SUB:\u0026#39;-\u0026#39;;24ID:[a-zA-Z]+;25INT:[0-9]+;26NEWLINE:\u0026#39;\\r\u0026#39;?\u0026#39;\\n\u0026#39;;27WS:[\\t]+-\u0026gt;skip;json  在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识， fragment标识的规则只能为其它词法规则提供基础\n 1grammar JSON;\t// 声明一个grammar 23json 4: value\t// 一个value候选 5; 67obj\t// 对象类型 8: \u0026#39;{\u0026#39; pair (\u0026#39;,\u0026#39; pair)* \u0026#39;}\u0026#39; 9| \u0026#39;{\u0026#39; \u0026#39;}\u0026#39; 10; 1112pair 13: STRING \u0026#39;:\u0026#39; value 14; 1516arr 17: \u0026#39;[\u0026#39; value (\u0026#39;,\u0026#39; value)* \u0026#39;]\u0026#39; 18| \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; 19; 2021value 22: STRING 23| NUMBER 24| obj 25| arr 26| \u0026#39;true\u0026#39; 27| \u0026#39;false\u0026#39; 28| \u0026#39;null\u0026#39; 29; 303132STRING 33: \u0026#39;\u0026#34;\u0026#39; (ESC | SAFECODEPOINT)* \u0026#39;\u0026#34;\u0026#39; 34; 353637fragment ESC 38: \u0026#39;\\\\\u0026#39; ([\u0026#34;\\\\/bfnrt] | UNICODE) 39; 404142fragment UNICODE 43: \u0026#39;u\u0026#39; HEX HEX HEX HEX 44; 454647fragment HEX 48: [0-9a-fA-F] 49; 505152fragment SAFECODEPOINT 53: ~ [\u0026#34;\\\\\\u0000-\\u001F] 54; 555657NUMBER 58: \u0026#39;-\u0026#39;? INT (\u0026#39;.\u0026#39; [0-9] +)? EXP? 59; 606162fragment INT 63: \u0026#39;0\u0026#39; | [1-9] [0-9]* 64; 6566// no leading zeros 6768fragment EXP 69: [Ee] [+\\-]? INT 70; 7172// \\- since - means \u0026#34;range\u0026#34; inside [...] 7374WS 75: [ \\t\\n\\r] + -\u0026gt; skip 76; 测试例子\n1{ 2\u0026#34;glossary\u0026#34;: { 3\u0026#34;title\u0026#34;: \u0026#34;example glossary\u0026#34;, 4\u0026#34;GlossDiv\u0026#34;: { 5\u0026#34;title\u0026#34;: \u0026#34;S\u0026#34;, 6\u0026#34;GlossList\u0026#34;: { 7\u0026#34;GlossEntry\u0026#34;: { 8\u0026#34;ID\u0026#34;: \u0026#34;SGML\u0026#34;, 9\u0026#34;SortAs\u0026#34;: \u0026#34;SGML\u0026#34;, 10\u0026#34;GlossTerm\u0026#34;: \u0026#34;Standard Generalized Markup Language\u0026#34;, 11\u0026#34;Acronym\u0026#34;: \u0026#34;SGML\u0026#34;, 12\u0026#34;Abbrev\u0026#34;: \u0026#34;ISO 8879:1986\u0026#34;, 13\u0026#34;GlossDef\u0026#34;: { 14\u0026#34;para\u0026#34;: \u0026#34;A meta-markup language\u0026#34;, 15\u0026#34;GlossSeeAlso\u0026#34;: [\u0026#34;GML\u0026#34;, \u0026#34;XML\u0026#34;] 16}, 17\u0026#34;GlossSee\u0026#34;: \u0026#34;markup\u0026#34; 18} 19} 20} 21} 22} 显示结果：\nXML  孤岛语法:\n dot 1grammarDOT;23graph4:STRICT?(GRAPH|DIGRAPH)id_?\u0026#39;{\u0026#39;stmt_list\u0026#39;}\u0026#39;5;67stmt_list8:(stmt\u0026#39;;\u0026#39;?)*9;1011stmt12:node_stmt|edge_stmt|attr_stmt|id_\u0026#39;=\u0026#39;id_|subgraph13;1415attr_stmt16:(GRAPH|NODE|EDGE)attr_list17;1819attr_list20:(\u0026#39;[\u0026#39;a_list?\u0026#39;]\u0026#39;)+21;2223a_list24:(id_(\u0026#39;=\u0026#39;id_)?\u0026#39;,\u0026#39;?)+25;2627edge_stmt28:(node_id|subgraph)edgeRHSattr_list?29;3031edgeRHS32:(edgeop(node_id|subgraph))+33;3435edgeop36:\u0026#39;-\u0026gt;\u0026#39;|\u0026#39;--\u0026#39;37;3839node_stmt40:node_idattr_list?41;4243node_id44:id_port?45;4647port48:\u0026#39;:\u0026#39;id_(\u0026#39;:\u0026#39;id_)?49;5051subgraph52:(SUBGRAPHid_?)?\u0026#39;{\u0026#39;stmt_list\u0026#39;}\u0026#39;53;5455id_56:ID|STRING|HTML_STRING|NUMBER57;5859// \u0026#34;The keywords node, edge, graph, digraph, subgraph, and strict are60// case-independent\u0026#34;6162STRICT63:[Ss][Tt][Rr][Ii][Cc][Tt]64;656667GRAPH68:[Gg][Rr][Aa][Pp][Hh]69;707172DIGRAPH73:[Dd][Ii][Gg][Rr][Aa][Pp][Hh]74;757677NODE78:[Nn][Oo][Dd][Ee]79;808182EDGE83:[Ee][Dd][Gg][Ee]84;858687SUBGRAPH88:[Ss][Uu][Bb][Gg][Rr][Aa][Pp][Hh]89;909192/** \u0026#34;a numeral [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? )\u0026#34; */NUMBER93:\u0026#39;-\u0026#39;?(\u0026#39;.\u0026#39;DIGIT+|DIGIT+(\u0026#39;.\u0026#39;DIGIT*)?)94;959697fragmentDIGIT98:[0-9]99;100101102/** \u0026#34;any double-quoted string (\u0026#34;...\u0026#34;) possibly containing escaped quotes\u0026#34; */STRING103:\u0026#39;\u0026#34;\u0026#39;(\u0026#39;\\\\\u0026#34;\u0026#39;|.)*?\u0026#39;\u0026#34;\u0026#39;104;105106107/** \u0026#34;Any string of alphabetic ([a-zA-Z\\200-\\377]) characters, underscores 108* (\u0026#39;_\u0026#39;) or digits ([0-9]), not beginning with a digit\u0026#34; 109*/ID110:LETTER(LETTER|DIGIT)*111;112113114fragmentLETTER115:[a-zA-Z\\u0080-\\u00FF_]116;117118119/** \u0026#34;HTML strings, angle brackets must occur in matched pairs, and 120* unescaped newlines are allowed.\u0026#34; 121*/HTML_STRING122:\u0026#39;\u0026lt;\u0026#39;(TAG|~[\u0026lt;\u0026gt;])*\u0026#39;\u0026gt;\u0026#39;123;124125126fragmentTAG127:\u0026#39;\u0026lt;\u0026#39;.*?\u0026#39;\u0026gt;\u0026#39;128;129130131COMMENT132:\u0026#39;/*\u0026#39;.*?\u0026#39;*/\u0026#39;-\u0026gt;skip133;134135136LINE_COMMENT137:\u0026#39;//\u0026#39;.*?\u0026#39;\\r\u0026#39;?\u0026#39;\\n\u0026#39;-\u0026gt;skip138;139140141/** \u0026#34;a \u0026#39;#\u0026#39; character is considered a line output from a C preprocessor (e.g., 142* # 34 to indicate line 34 ) and discarded\u0026#34; 143*/PREPROC144:\u0026#39;#\u0026#39;~[\\r\\n]*-\u0026gt;skip145;146147148WS149:[\\t\\n\\r]+-\u0026gt;skip150;","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/antlr/","series":null,"tags":["编译原理"],"title":"Antlr教程"},{"categories":null,"content":"基本操作 安装hugo 在linux/windows上只能通过直接release下载,\n创建网站 1hugo new site 路径 添加主题  将主题直接添加到theme文件下面 将主题作为一个submodule  创建文档 1hugo new posts/hugo.md 设置预览 1hugo server -D --disableFastRender 文件结构 1. 2├── archetypes 3├── config 4├── content 5├── data 6├── layouts 7├── static 8├── themes 9├── static 10└── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。\narchetypes hugo模板,在创建文件时作为模板自动生成\nassets 存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录\nconfig Hugo配置目录\ncontent 此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分.\ndata 该目录用于存储 Hugo 在生成网站时可以使用的配置文件\nlayouts 以 .html文件的形式存储模板.\nstatic 存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制\n编写工具 typora 使用typora作为markdown编写工具\npicgo  ","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/hugo/","series":null,"tags":["技巧"],"title":"Hugo教程"},{"categories":null,"content":"nfs服务 安装 1sudo apt-get install nfs-kernel-server 设置导出 1/home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 开启服务 1sudo /etc/init.d/nfs-kernel-server restart 测试 1sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt 2ls /mnt ","date":"May 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/nfs/","series":null,"tags":["nfs"],"title":"Nfs"}]
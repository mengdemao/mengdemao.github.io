[{"categories":[],"content":" A C dynamic strings library C语言版本动态字符串库\n SDS SDS的类型就是\n1typedef char *sds; 可以明显的看到,sds就是普通的char类型\n下面是sds的数据类型 1+--------+-------------------------------+-----------+ 2| Header | Binary safe C alike string... | Null term | 3+--------+-------------------------------+-----------+ 4 | 5 -\u0026gt; Pointer returned to the user. 1#define SDS_HDR_VAR(T,s) \\ 2struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T))); 3#define SDS_HDR(T,s) \\ 4((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 5#define SDS_TYPE_5_LEN(f) ((f)\u0026gt;\u0026gt;SDS_TYPE_BITS) SDS 头 根据不同的标志计算不同的头部数据 SDS_TYPE_5 sdshdr5 SDS_TYPE_8 sdshdr8 SDS_TYPE_16 sdshdr16 SDS_TYPE_32 sdshdr32 SDS_TYPE_64 sdshdr64\nflag标志:\n1unsigned char flags = s[-1]; /* 最后一个头部数据 */ 1#define SDS_TYPE_5 0 2#define SDS_TYPE_8 1 3#define SDS_TYPE_16 2 4#define SDS_TYPE_32 3 5#define SDS_TYPE_64 4 1/* Note: sdshdr5 is never used, we just access the flags byte directly. 2* However is here to document the layout of type 5 SDS strings. */ 3struct __attribute__ ((__packed__)) sdshdr5 { 4 unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ 5 char buf[]; 6}; 7struct __attribute__ ((__packed__)) sdshdr8 { 8 uint8_t len; /* used */ 9 uint8_t alloc; /* excluding the header and null terminator */ 10 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 11 char buf[]; 12}; 13struct __attribute__ ((__packed__)) sdshdr16 { 14 uint16_t len; /* used */ 15 uint16_t alloc; /* excluding the header and null terminator */ 16 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 17 char buf[]; 18}; 19struct __attribute__ ((__packed__)) sdshdr32 { 20 uint32_t len; /* used */ 21 uint32_t alloc; /* excluding the header and null terminator */ 22 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 23 char buf[]; 24}; 25struct __attribute__ ((__packed__)) sdshdr64 { 26 uint64_t len; /* used */ 27 uint64_t alloc; /* excluding the header and null terminator */ 28 unsigned char flags; /* 3 lsb of type, 5 unused bits */ 29 char buf[]; 30}; 1#define SDS_TYPE_MASK 7 2#define SDS_TYPE_BITS 3 创建SDS 函数原型\n1sds sdsnewlen(const void *init, size_t initlen); 扩张字符串缓存区 1sds sdsMakeRoomFor(sds s, size_t addlen) 2{ 3 void *sh; 4 void *newsh; 5 size_t avail = sdsavail(s);\t/* 计算剩余的可以使用的大小 */ 6 size_t len; 7 size_t newlen; 8 char type, oldtype = s[-1] \u0026amp; SDS_TYPE_MASK; 9 int hdrlen; 10 11 if (avail \u0026gt;= addlen) { /* 如果剩余的存储空间超过添加大小,那么就可以直接返回 */ 12 return s; 13 } 14 len = sdslen(s);\t/* 计算字符串大小 */ 15 sh = (char*)s - sdsHdrSize(oldtype); /* 缓冲区地址 */ 16 17 /* 计算得到新的长度 */ 18 newlen = (len+addlen); 19 if (newlen \u0026lt; SDS_MAX_PREALLOC) 20 newlen *= 2; 21 else 22 newlen += SDS_MAX_PREALLOC; 23\t/* 重新生成类型 */ 24 type = sdsReqType(newlen); 25 26 /* Don\u0026#39;t use type 5: the user is appending to the string and type 5 is 27* not able to remember empty space, so sdsMakeRoomFor() must be called 28* at every appending operation. */ 29 if (type == SDS_TYPE_5) { 30 type = SDS_TYPE_8; 31\t} 32\t33 /* 计算头部大小 */ 34 hdrlen = sdsHdrSize(type); 35 36 if (oldtype == type) { 37 newsh = s_realloc(sh, hdrlen + newlen + 1); 38 if (newsh == NULL) { 39 return NULL; 40 } 41 s = (char*)newsh + hdrlen; 42 } else { 43 /* Since the header size changes, need to move the string forward, 44* and can\u0026#39;t use realloc */ 45 newsh = s_malloc(hdrlen+newlen+1); 46 if (newsh == NULL) { 47 return NULL; 48 } 49 memcpy((char*)newsh+hdrlen, s, len+1); 50 s_free(sh); 51 52 s = (char*)newsh + hdrlen; 53 s[-1] = type; 54 55 sdssetlen(s, len); 56 } 57 58 sdssetalloc(s, newlen); 59 return s; 60} 追加字符串 1sds sdscatlen(sds s, const void *t, size_t len) 2{ 3 size_t curlen = sdslen(s);\t/* 计算字符串的长度 */ 4 5 s = sdsMakeRoomFor(s,len);\t/* 扩展字符串缓冲区长度 */ 6 if (s == NULL) { 7 return NULL; 8 } 9 memcpy(s+curlen, t, len);\t/* 添加字符串 */ 10 sdssetlen(s, curlen+len);\t/* 设置长度标志 */ 11 s[curlen+len] = \u0026#39;\\0\u0026#39;;\t/* 补全结束符 */ 12 return s; 13} ","date":"Oct 6, 2021","img":"","permalink":"https://mengdemao.github.io/posts/sds/","series":null,"tags":[],"title":"Sds"},{"categories":[],"content":" STL称为标准模板库(Standard Template Library) 广义上可以分为容器,算法,迭代器 容器和算法通过迭代器进行无缝连接 STL几乎所有的代码都采用了函数模版或者类模板\n STL组件    序号 名称 解释     1 容器 各种数据结构   2 算法 各种常用的算法   3 迭代器 容器域算法的胶合   4 仿函数 行为类似函数   5 适配器 修饰容器或者仿函数迭代器   6 空间配置器 负责空间的配置和管理    容器算法和迭代器 vector vector使用 1/* 创建vector容器 */ 2vector\u0026lt;int\u0026gt; v; 3/* 插入数据 */ 4v.push_back(10); 5v.push_back(20); 6v.push_back(30); 7v.push_back(40); 迭代器使用 迭代器方案1 1 2vector\u0026lt;int\u0026gt;::iterator itBegin = v.begin(); 3vector\u0026lt;int\u0026gt;::iterator itEnd = v.end(); 4while (itBegin != itEnd) 5{ 6\tcout \u0026lt;\u0026lt; *itBegin \u0026lt;\u0026lt; endl; 7\titBegin += 1; 8} 迭代器2 1for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 2{ 3\tcout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; 4} 遍历算法 1template \u0026lt;class T\u0026gt; 2void myPrint(T val) 3{ 4\tcout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 5} 6 7/* 可惜回调函数不支持自动推导 */ 8for_each(v.begin(), v.end(), myPrint\u0026lt;int\u0026gt;); 容器自定义数据 容器嵌套容器 1vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;v; // 外部大容器 2vector\u0026lt;int\u0026gt; vx[10]; // 内部小容器 3 4/* 插入容器 */ 5for (int i = 0; i \u0026lt; 10; i++) 6{ 7\tfor (int j = 0; j \u0026lt; 30; j++) 8\t{ 9\tvx[i].push_back(i + j + 10); 10\t} 11\tv.push_back(vx[i]); 12} 13 14/* 遍历容器 */ 15for (vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;::iterator it = v.begin(); it != v.end(); it++) 16{ 17\tfor (vector\u0026lt;int\u0026gt;::iterator vit = it-\u0026gt;begin(); vit != it-\u0026gt;end(); vit++) 18\t{ 19\tcout \u0026lt;\u0026lt; *vit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 20\t} 21\tcout \u0026lt;\u0026lt; endl; 22} string ","date":"Oct 6, 2021","img":"","permalink":"https://mengdemao.github.io/posts/stl/","series":null,"tags":[],"title":"STL学习笔记"},{"categories":[],"content":"","date":"Oct 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/python/","series":null,"tags":[],"title":"Python学习笔记"},{"categories":[],"content":"输入子设备分为三层\n handle core device  input的相关结构体 1 struct input_dev {\t/* 输入设备的描述 */ 2 const char *name;\t/* 设备名称 */ 3\tconst char *phys; 4\tconst char *uniq; 5\tstruct input_id id; 6 7\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; 8 9\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)]; 10\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; 11\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)]; 12\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; 13\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; 14\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; 15\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; 16\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; 17\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)]; 18 19\tunsigned int hint_events_per_packet; 20 21\tunsigned int keycodemax; 22\tunsigned int keycodesize; 23\tvoid *keycode; 24 25\tint (*setkeycode)(struct input_dev *dev, 26\tconst struct input_keymap_entry *ke, 27\tunsigned int *old_keycode); 28\tint (*getkeycode)(struct input_dev *dev, 29\tstruct input_keymap_entry *ke); 30 31\tstruct ff_device *ff; 32 33\tunsigned int repeat_key; 34\tstruct timer_list timer; 35 36\tint rep[REP_CNT]; 37 38\tstruct input_mt *mt; 39 40\tstruct input_absinfo *absinfo; 41 42\tunsigned long key[BITS_TO_LONGS(KEY_CNT)]; 43\tunsigned long led[BITS_TO_LONGS(LED_CNT)]; 44\tunsigned long snd[BITS_TO_LONGS(SND_CNT)]; 45\tunsigned long sw[BITS_TO_LONGS(SW_CNT)]; 46 47\tint (*open)(struct input_dev *dev); 48\tvoid (*close)(struct input_dev *dev); 49\tint (*flush)(struct input_dev *dev, struct file *file); 50\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); 51 52\tstruct input_handle __rcu *grab; 53 54\tspinlock_t event_lock; 55\tstruct mutex mutex; 56 57\tunsigned int users; 58\tbool going_away; 59 60\tstruct device dev; 61 62\tstruct list_head\th_list; 63\tstruct list_head\tnode; 64 65\tunsigned int num_vals; 66\tunsigned int max_vals; 67\tstruct input_value *vals; 68 69\tbool devres_managed; 70 }; 71#define to_input_dev(d) container_of(d, struct input_dev, dev) input子系统使用 input子系统分析  Makefile编写  1obj-$(CONFIG_INPUT)\t+= input-core.o 2input-core-y := input.o input-compat.o input-mt.o ff-core.o 开始判断下面的第一个文件 input.c  1subsys_initcall(input_init); 2module_exit(input_exit); 输入子系统的设备号\n1#define INPUT_MAJOR 13 安装驱动\n1 static int __init input_init(void) 2 { 3\tint err; 4\t/* 注册设备类 */ 5\terr = class_register(\u0026amp;input_class); 6\tif (err) { 7\tpr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 8\treturn err; 9\t} 10 11\t/* 注册proc文件系统 */ 12\terr = input_proc_init(); 13\tif (err) 14\tgoto fail1; 15\t/* 注册设备 */ 16\terr = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), 17\tINPUT_MAX_CHAR_DEVICES, \u0026#34;input\u0026#34;); 18\tif (err) { 19\tpr_err(\u0026#34;unable to register char major %d\u0026#34;, INPUT_MAJOR); 20\tgoto fail2; 21\t} 22 23\treturn 0; 24 25 fail2:\tinput_proc_exit(); 26 fail1:\tclass_unregister(\u0026amp;input_class); 27\treturn err; 28 } 卸载驱动\n1 static void __exit input_exit(void) 2 { 3\t/* 卸载proc文件系统 */ 4\tinput_proc_exit(); 5 6\t/* 注销设备号 */ 7\tunregister_chrdev_region(MKDEV(INPUT_MAJOR, 0), 8\tINPUT_MAX_CHAR_DEVICES); 9 10\t/* 注销CLass */ 11\tclass_unregister(\u0026amp;input_class); 12 } 设备类操作\n1\t/* 设备类型 */ 2\tstruct class input_class = { 3\t.name\t= \u0026#34;input\u0026#34;, 4\t.devnode\t= input_devnode, 5\t}; 6\tEXPORT_SYMBOL_GPL(input_class); 7 8\t/* 注册设备 */ 9\terr = class_register(\u0026amp;input_class); 10\tif (err) { 11\tpr_err(\u0026#34;unable to register input_dev class\\n\u0026#34;); 12\treturn err; 13\t} 14 15\t/* 卸载设备 */ 16 class_unregister(\u0026amp;input_class); Proc文件系统操作\nProc文件系统添加\n1static int __init input_proc_init(void) 2{ 3\tstruct proc_dir_entry *entry; 4 5\tproc_bus_input_dir = proc_mkdir(\u0026#34;bus/input\u0026#34;, NULL); 6\tif (!proc_bus_input_dir) 7\treturn -ENOMEM; 8 9\tentry = proc_create(\u0026#34;devices\u0026#34;, 0, proc_bus_input_dir, 10\t\u0026amp;input_devices_fileops); 11\tif (!entry) 12\tgoto fail1; 13 14\tentry = proc_create(\u0026#34;handlers\u0026#34;, 0, proc_bus_input_dir, 15\t\u0026amp;input_handlers_fileops); 16\tif (!entry) 17\tgoto fail2; 18 19\treturn 0; 20 21 fail2:\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 22 fail1: remove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 23\treturn -ENOMEM; 24} Proc文件系统卸载\n1static void input_proc_exit(void) 2{ 3\tremove_proc_entry(\u0026#34;devices\u0026#34;, proc_bus_input_dir); 4\tremove_proc_entry(\u0026#34;handlers\u0026#34;, proc_bus_input_dir); 5\tremove_proc_entry(\u0026#34;bus/input\u0026#34;, NULL); 6} 接口部分 Handler操作 1/** 2* 注册 input handler 3* input_register_handler - register a new input handler 4* @handler: handler to be registered 5* 6* This function registers a new input handler (interface) for input 7* devices in the system and attaches it to all input devices that 8* are compatible with the handler. 9*/ 10int input_register_handler(struct input_handler *handler) 11{ 12\tstruct input_dev *dev; 13\tint error; 14 15\terror = mutex_lock_interruptible(\u0026amp;input_mutex); 16\tif (error) 17\treturn error; 18 19\tINIT_LIST_HEAD(\u0026amp;handler-\u0026gt;h_list); 20 21\tlist_add_tail(\u0026amp;handler-\u0026gt;node, \u0026amp;input_handler_list); 22 23\tlist_for_each_entry(dev, \u0026amp;input_dev_list, node) 24\tinput_attach_handler(dev, handler); 25 26\tinput_wakeup_procfs_readers(); 27 28\tmutex_unlock(\u0026amp;input_mutex); 29\treturn 0; 30} 31EXPORT_SYMBOL(input_register_handler); 32 33/** 34* 解除注册 input handler 35* input_unregister_handler - unregisters an input handler 36* @handler: handler to be unregistered 37* 38* This function disconnects a handler from its input devices and 39* removes it from lists of known handlers. 40*/ 41void input_unregister_handler(struct input_handler *handler) 42{ 43\tstruct input_handle *handle, *next; 44 45\tmutex_lock(\u0026amp;input_mutex); 46 47\tlist_for_each_entry_safe(handle, next, \u0026amp;handler-\u0026gt;h_list, h_node) 48\thandler-\u0026gt;disconnect(handle); 49\tWARN_ON(!list_empty(\u0026amp;handler-\u0026gt;h_list)); 50 51\tlist_del_init(\u0026amp;handler-\u0026gt;node); 52 53\tinput_wakeup_procfs_readers(); 54 55\tmutex_unlock(\u0026amp;input_mutex); 56} 57EXPORT_SYMBOL(input_unregister_handler); 注册设备 1/** 2* 注册一个设备 3* input_register_device - register device with input core 4* @dev: device to be registered 5* 6* This function registers device with input core. The device must be 7* allocated with input_allocate_device() and all it\u0026#39;s capabilities 8* set up before registering. 9* If function fails the device must be freed with input_free_device(). 10* Once device has been successfully registered it can be unregistered 11* with input_unregister_device(); input_free_device() should not be 12* called in this case. 13* 14* Note that this function is also used to register managed input devices 15* (ones allocated with devm_input_allocate_device()). Such managed input 16* devices need not be explicitly unregistered or freed, their tear down 17* is controlled by the devres infrastructure. It is also worth noting 18* that tear down of managed input devices is internally a 2-step process: 19* registered managed input device is first unregistered, but stays in 20* memory and can still handle input_event() calls (although events will 21* not be delivered anywhere). The freeing of managed input device will 22* happen later, when devres stack is unwound to the point where device 23* allocation was made. 24*/ 25int input_register_device(struct input_dev *dev) 26{ 27\tstruct input_devres *devres = NULL; 28\tstruct input_handler *handler; 29\tunsigned int packet_size; 30\tconst char *path; 31\tint error; 32 33\tif (dev-\u0026gt;devres_managed) { 34\tdevres = devres_alloc(devm_input_device_unregister, 35\tsizeof(struct input_devres), GFP_KERNEL); 36\tif (!devres) 37\treturn -ENOMEM; 38 39\tdevres-\u0026gt;input = dev; 40\t} 41 42\t/* Every input device generates EV_SYN/SYN_REPORT events. */ 43\t__set_bit(EV_SYN, dev-\u0026gt;evbit); 44 45\t/* KEY_RESERVED is not supposed to be transmitted to userspace. */ 46\t__clear_bit(KEY_RESERVED, dev-\u0026gt;keybit); 47 48\t/* Make sure that bitmasks not mentioned in dev-\u0026gt;evbit are clean. */ 49\tinput_cleanse_bitmasks(dev); 50 51\tpacket_size = input_estimate_events_per_packet(dev); 52\tif (dev-\u0026gt;hint_events_per_packet \u0026lt; packet_size) 53\tdev-\u0026gt;hint_events_per_packet = packet_size; 54 55\tdev-\u0026gt;max_vals = dev-\u0026gt;hint_events_per_packet + 2; 56\tdev-\u0026gt;vals = kcalloc(dev-\u0026gt;max_vals, sizeof(*dev-\u0026gt;vals), GFP_KERNEL); 57\tif (!dev-\u0026gt;vals) { 58\terror = -ENOMEM; 59\tgoto err_devres_free; 60\t} 61 62\t/* 63* If delay and period are pre-set by the driver, then autorepeating 64* is handled by the driver itself and we don\u0026#39;t do it in input.c. 65*/ 66\tif (!dev-\u0026gt;rep[REP_DELAY] \u0026amp;\u0026amp; !dev-\u0026gt;rep[REP_PERIOD]) { 67\tdev-\u0026gt;timer.data = (long) dev; 68\tdev-\u0026gt;timer.function = input_repeat_key; 69\tdev-\u0026gt;rep[REP_DELAY] = 250; 70\tdev-\u0026gt;rep[REP_PERIOD] = 33; 71\t} 72 73\tif (!dev-\u0026gt;getkeycode) 74\tdev-\u0026gt;getkeycode = input_default_getkeycode; 75 76\tif (!dev-\u0026gt;setkeycode) 77\tdev-\u0026gt;setkeycode = input_default_setkeycode; 78 79\terror = device_add(\u0026amp;dev-\u0026gt;dev); 80\tif (error) 81\tgoto err_free_vals; 82 83\tpath = kobject_get_path(\u0026amp;dev-\u0026gt;dev.kobj, GFP_KERNEL); 84\tpr_info(\u0026#34;%s as %s\\n\u0026#34;, 85\tdev-\u0026gt;name ? dev-\u0026gt;name : \u0026#34;Unspecified device\u0026#34;, 86\tpath ? path : \u0026#34;N/A\u0026#34;); 87\tkfree(path); 88 89\terror = mutex_lock_interruptible(\u0026amp;input_mutex); 90\tif (error) 91\tgoto err_device_del; 92 93\tlist_add_tail(\u0026amp;dev-\u0026gt;node, \u0026amp;input_dev_list); 94 95\tlist_for_each_entry(handler, \u0026amp;input_handler_list, node) 96\tinput_attach_handler(dev, handler); 97 98\tinput_wakeup_procfs_readers(); 99 100\tmutex_unlock(\u0026amp;input_mutex); 101 102\tif (dev-\u0026gt;devres_managed) { 103\tdev_dbg(dev-\u0026gt;dev.parent, \u0026#34;%s: registering %s with devres.\\n\u0026#34;, 104\t__func__, dev_name(\u0026amp;dev-\u0026gt;dev)); 105\tdevres_add(dev-\u0026gt;dev.parent, devres); 106\t} 107\treturn 0; 108 109err_device_del: 110\tdevice_del(\u0026amp;dev-\u0026gt;dev); 111err_free_vals: 112\tkfree(dev-\u0026gt;vals); 113\tdev-\u0026gt;vals = NULL; 114err_devres_free: 115\tdevres_free(devres); 116\treturn error; 117} 118EXPORT_SYMBOL(input_register_device); 119 120/** 121* 解除注册设备 122* input_unregister_device - unregister previously registered device 123* @dev: device to be unregistered 124* 125* This function unregisters an input device. Once device is unregistered 126* the caller should not try to access it as it may get freed at any moment. 127*/ 128void input_unregister_device(struct input_dev *dev) 129{ 130\tif (dev-\u0026gt;devres_managed) { 131\tWARN_ON(devres_destroy(dev-\u0026gt;dev.parent, 132\tdevm_input_device_unregister, 133\tdevm_input_device_match, 134\tdev)); 135\t__input_unregister_device(dev); 136\t/* 137* We do not do input_put_device() here because it will be done 138* when 2nd devres fires up. 139*/ 140\t} else { 141\t__input_unregister_device(dev); 142\tinput_put_device(dev); 143\t} 144} 145EXPORT_SYMBOL(input_unregister_device); ","date":"Oct 5, 2021","img":"","permalink":"https://mengdemao.github.io/posts/input_drive/","series":null,"tags":[],"title":"输入子系统"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/slab/","series":null,"tags":[],"title":"Slab"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/mmu/","series":null,"tags":[],"title":"Mmu"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/page/","series":null,"tags":[],"title":"Page"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/fork/","series":null,"tags":[],"title":"Fork"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/task/","series":null,"tags":[],"title":"任务管理"},{"categories":[],"content":"","date":"Oct 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/sched/","series":null,"tags":[],"title":"Sched"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/rime/","series":null,"tags":[],"title":"Rime"},{"categories":[],"content":"WASM笔记 ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/wasm/","series":null,"tags":[],"title":"Wasm"},{"categories":[],"content":"jupyter 安装 1conda install jupyter 基本配置 生成配置 1jupyter notebook --generate-config 自动生成配置文件 ~/.jupyter/jupyter_notebook_config.py\n设置密码 1jupyter notebook password  ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/jupyter/","series":null,"tags":[],"title":"Jupyter"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/conda/","series":null,"tags":[],"title":"Conda"},{"categories":[],"content":"RUST学习笔记 安装  添加环境变量.bashrc/profile  1set RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 2set RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup 安装工具链  1curl https://mirrors.ustc.edu.cn/rust-static/rustup/rustup-init.sh | sh 设置rust的环境变量.bashrc/profile  1source ~/.cargo/env 2set PATH=~/.cargo/bin;$PATH ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/rust/","series":null,"tags":[],"title":"Rust"},{"categories":[],"content":"C++基础语法 第一个程序 1#include \u0026lt;iostream\u0026gt;2 3using namespace std; 4 5int main(int argc, char *argv[]) 6{ 7\tcout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; 8\treturn 0; 9} 注释类型  单行注释  1// 这个是一个单行注释  多行注释  1/* 2这个里面是一个注释 3*/ 变量 变量的存在意义:方便我们管理内存\n变量创建的语法\n1数据类型 变量名 = 变量初始化; 常量 作用: 记录程序中不可以改变的数据\n define 宏常量(预编译期) const 修饰变量(编译期)  关键字    关键字        asm else new this   auto enum operator throw   bool explicit private true   break export protected try   case extern public typedef   catch false register typeid   char float reinterpret_cast typename   class for return union   const friend short unsigned   const_cast goto signed using   continue if sizeof virtual   default inline static void   delete int static_cast volatile   do long struct wchar_t   double mutable switch while   dynamic_cast namespace template     标识符命名规则  标识符不可以是关键字 只能由字母、数字、下划线构成 第一个字母只能是字母或者是下划线 区分大小写  数据类型 指定类型,分配内存\n整形 浮点型  单精度float 双精度double  字符型 转义字符 字符串  C风格  1char 变量名[] = \u0026#34;字符串值\u0026#34;; C++风格  1string 变量名 = \u0026#34;字符串值\u0026#34;; 布尔类型 1bool A = true; 2bool B = false; 运算符 基本运算符 取模运算 就是取余数\n自增自减运算 1a1++; 2a2--; 赋值运算    运算符 术语 示例 结果     =      +=      -=      *=      /=      %=       比较运算符 逻辑运算符 程序流程结构 顺序结构 if语句 三目运算符 1表达式1? 表达式2:表达式3 选择结构 1switch(condition) 2{ 3case 条件1: 4\tbreak; 5case 条件2: 6\tbreak; 7default: 8\tbreak; 9} 循环结构 while循环 1while(条件) 2{ 3\t循环体; 4} dowhile循环 1do { 2 3} while(条件) for循环 1for (起始表达式; 条件表达式; 末尾循环体) 2{ 3\t循环体; 4} 跳转语句 break continue goto 数组 函数定义  返回值类型 函数名 参数列表 函数体语句 return表达式  1返回值类型 函数名字(参数列表) 2{ 3\t函数体语句; 4\treturn 表达式; 5} 值传递 类似数值拷贝\n函数的常见样式  无参无返 有参无返 无参有反 有参有返  函数的声明 作用: 告诉编译器函数名以及调用方式,函数实体可以单独实现;\n函数的分文件编写 指针 指针的定义和使用 指针所占用空间 空指针 含义: 指针指向内存空间为0的指针; 用途: 初始化指针变量 注意: 空指针的地址是不可以访问的\n野指针 指针指向非法的内存空间\nconst与指针  const修饰指针 const修饰常量 const既修饰指针又修饰常量  1const int *p = \u0026amp;a; 2 3int const *p = \u0026amp;a; 4 5const int *const p = \u0026amp;a; 指针与数组 指针与函数 结构体 结构体数组 结构体指针 结构体嵌套 C++核心编程 本阶段主要对面向对象进行详细讲解\nC++内存分区 c++程序在运行时,将内存分为4个区域\n 代码区: 存放程序的二进制代码,由操作系统管理 全局区: 存放全局变量、静态变量和常量 栈区: 编译器自动分配 堆区: 程序负责分配和释放  new/delete操作符 C++利用new操作符在堆区开辟内存\n引用 作用: 给变量起别名 语法: 数据类型 \u0026amp;别名 = 原名;\n引用做参数 1#include \u0026lt;iostream\u0026gt;2void swap(int \u0026amp;a, int \u0026amp;b) 3{ 4 int t; t = a;a = b;b = t; 5} 6int main(int argc, char *argv[]) 7{ 8 int a = 10;int b = 12; 9 std::cout \u0026lt;\u0026lt; \u0026#34;交换前\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 10 swap(a, b); 11 std::cout \u0026lt;\u0026lt; \u0026#34;交换后\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 12 return 0; 13} 执行结果\n引用做返回值 引用的本质 引用的本质是C++内部实现的一个指针常量\n常量引用 1const int \u0026amp;ref = 10; 函数提高 函数默认值  某个位置有默认值，那么后面的参数也必须由默认值 如果声明了默认值，那么实现不可以有默认值(默认参数会产生冲突)  1void test_default_param(int a = 0, int b = 0, int c = 0) 2{ 3 std::cout \u0026lt;\u0026lt; a + b + c \u0026lt;\u0026lt; std::endl; 4} 函数的占位参数 占位参数还可以有默认值\n1void test(int a, int = 10) { 2 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; 3} 函数重载 作用:函数名相同,提高复用性\n重载的条件:\n  相同作用域\n  函数名相同\n  参数不同(类型, 个数,顺序)\n  注意事项:\n 引用作为重载条件 函数重载碰到默认参数  类和对象 类的访问属性\n public: protected: private:  class与struct的区别 class默认权限是private struct默认权限是public\n构造函数和析构函数 对象的初始化和清理\n 构造函数有参数 析构函数没有参数 二者都没有返回值  拷贝构造函数 1class Person { 2public: 3 /* 构造函数 */ 4 Person(std::string name, int age) { 5 std::cout \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 6 } 7 /* 析构函数 */ 8 ~Person() { 9 std::cout \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; std::endl; 10 } 11 /* 拷贝构造函数 */ 12 Person(const Person \u0026amp;p) { 13 std::cout \u0026lt;\u0026lt; \u0026#34;拷贝构造函数\u0026#34; \u0026lt;\u0026lt; std::endl; 14 } 15};  调用无参构造函数的时候不可以添加();否则就会产生函数声明的效果  1Person testPerson();\t// 表面上是执行构造函数 2int func();\t// 类似函数声明 拷贝构造函数的调用时机  使用一个已经创建完毕的对象初始化一个新对象 值传递的方式给函数进行参数传递 以值的方式返回局部对象  构造函数的调用规则 默认情况下:C++编译器至少给一个类添加3个函数\n 默认构造函数(无参) 默认析构函数(无参) 默认拷贝函数,对属性值进行拷贝  构造函数构造规则如下:\n 用户定义有参构造,C++默认不提供无参构造，但是提供默认拷贝构造 用户定义拷贝构造,C++不提供其他构造函数  深拷贝和浅拷贝  浅拷贝: 简单的复制操作 深拷贝: 在堆区重新申请空间，进行复制操作  初始化列表 作用:C++提供了初始化列表语法,用来初始化属性;\n语法:\n1构造函数(): 属性1(值1),属性2(值2),属性3(值3) 2{ 3\t/* 函数体 */ 4} 类对象作为类成员 静态成员 静态成员就是在静态成员变量和成员函数前加上static,称为静态成员;\n 静态成员变量  所有对象共享一份数据 编译阶段分配内存 类内声明,类外初始化   静态成员函数  所有对象共享同一个函数 静态成员函数只能访问静态成员变量    1class Person { 2public: 3 static int age; 4 static void func() 5 { 6 std::cout \u0026lt;\u0026lt; \u0026#34;静态成员函数\u0026#34; \u0026lt;\u0026lt; std::endl; 7 } 8}; 9/* 通过对象访问 */ 10Person p; 11p.func(); 12/* 通过类访问 */ 13Person::func(); 成员变量和成员函数分开存储  非静态成员,\t属于类的对象 静态成员,\t不属于类的对象 非静态成员函数,\t不属于类的对象 静态成员函数, 不属于类的对象  空对象大小为1\nC++对象模型 this指针 this指针指向被调用成员函数所属的对象 this指针本质：指针常量\n空指针访问成员函数 C++空指针也是可以访问成员函数的,但是要注意的this指针;\nconst修饰成员函数 常函数:\n 常函数不可以修改成员属性 成员属性加上mutable,常函数也可以修改 ** 常对象** 对象之前加const表示常对象 常对象只能调用函数  执行原理\n1this ==\u0026gt; Person * const this; 2后面新追加的const则会造成 3const Person * const this; 1class Person { 2public: 3 int m_A; 4 mutable int m_B; 5 void showPerson() const 6 { 7 m_A = 10; /* 错误,不可修改 */ 8 m_B = 10; /* 正确,可以修改 */ 9 } 10}; 友元  全局函数 全局类 成员函数  运算符重载 重载的原理:对已有的运算符进行重新定义,赋予新的功能含义;\n通过成员函数重载运算符 1class Person { 2public: 3 int m_A; 4 int m_B; 5 6 /* 使用成员函数实现 */ 7 Person PersonAddPerson(Person \u0026amp;p) 8 { 9 Person t; 10 t.m_A = this-\u0026gt;m_A + p.m_A; 11 t.m_B = this-\u0026gt;m_B + p.m_B; 12 return t; 13 } 14 15 /* 重载+ */ 16 Person operator+(Person \u0026amp;p) 17 { 18 Person t; 19 t.m_A = this-\u0026gt;m_A + p.m_A; 20 t.m_B = this-\u0026gt;m_B + p.m_B; 21 return t; 22 } 23}; 24 25int main(int argc, char *argv[]) 26{ 27 Person p1; 28 Person p2; 29 30 Person p3 = p1.PersonAddPerson(p2); 31 32 Person p4 = p1.operator+(p2); 33 34 Person p5 = p1 + p2; 35 36 return 0; 37} 通过全局函数重载 1Person operator+(Person \u0026amp;p1, Person \u0026amp;p2) 2{ 3 Person t; 4 t.m_A = p1.m_A + p2.m_A; 5 t.m_B = p2.m_B + p2.m_B; 6 return t; 7} 重载左移运算符 1std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Person \u0026amp;p) 2{ 3 cout \u0026lt;\u0026lt; p.m_A \u0026lt;\u0026lt; p.m_B; 4 return cout; 5} 递增重载++ 注意:\n 前置递增 p++ 后置递增 ++p  重载例子(复数) 1#include \u0026lt;iostream\u0026gt;2 3class Complex { 4 friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p); 5 6public: 7 Complex(int i, int j); 8 9 Complex(); 10 11 /* 重载+ */ 12 Complex operator+(Complex \u0026amp;p) 13 { 14 Complex t; 15 t.i = this-\u0026gt;i + p.i; 16 t.j = this-\u0026gt;j + p.j; 17 return t; 18 } 19 /* 重载前置++ */ 20 Complex\u0026amp; operator++() 21 { 22 this-\u0026gt;i++; 23 this-\u0026gt;j++; 24 return *this; 25 } 26 27 /* 重载后置++ */ 28 Complex operator++(int) 29 { 30 Complex t; 31 32 /* 记录 */ 33 t.i = this-\u0026gt;i; 34 t.j = this-\u0026gt;j; 35 36 /* 递增 */ 37 this-\u0026gt;i++; 38 this-\u0026gt;j++; 39 40 return t; 41 } 42 43 /* 重载= */ 44 Complex\u0026amp; operator=(Complex \u0026amp;p) 45 { 46 this-\u0026gt;i = p.i; 47 this-\u0026gt;j = p.j; 48 49 return *this; 50 } 51private: 52 int i; /* 实部 */ 53 int j; /* 虚部 */ 54}; 55 56/* 构造函数 */ 57Complex::Complex(int i, int j) 58{ 59 this-\u0026gt;i = i; 60 this-\u0026gt;j = j; 61} 62 63Complex::Complex() 64{ 65 this-\u0026gt;i = 0; 66 this-\u0026gt;j = 0; 67} 68 69std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;cout, Complex p) 70{ 71 cout \u0026lt;\u0026lt; p.i \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; p.j \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; 72 return cout; 73} 74 75int main(int argc, char *argv[]) 76{ 77 Complex p1(1, 2); 78 Complex p2(3, 4); 79 80 std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; std::endl; 81 std::cout \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl; 82 std::cout \u0026lt;\u0026lt; p1 + p2 \u0026lt;\u0026lt; std::endl; 83 84 std::cout \u0026lt;\u0026lt; ++p1 \u0026lt;\u0026lt; std::endl; 85 std::cout \u0026lt;\u0026lt; p2++ \u0026lt;\u0026lt; std::endl; 86 87 Complex p3 = p2 = p1; 88 std::cout \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p3 \u0026lt;\u0026lt; std::endl; 89 90 return 0; 91} 继承 减少重复代码\n1class 子类 : 继承方式 父类 父类:基类 子类:派生类\n继承方式  公共继承 保护继承 私有继承  继承中的对象模型 构造和析构的顺序  先构造父类再构造子类 先析构子类再析构父类\n 继承中同名成员处理  访问子类中同名成员,直接访问即可 s.m_A 访问父类中同名成员,需要加上作用域 s.Base:m_A  多重继承 C++允许一个类继承多个基类\n1class 子类 : 继承方式 父类1, 继承方式 父类2...  冲突解决：加上类名\n 菱形继承 孙子类继承了子类1和子类2,但是继承了两次父类。\n 多重继承数据会产生二义性 数据只需要一份即可  1/* 动物类 */ 2class Animal { 3public: 4 int m_age; 5}; 6class Sheep : public Animal {}; /* 羊类 */ 7class Camel : public Animal {}; /* 驼类 */ 8class Alpaca : public Sheep, public Camel {}; /* 羊驼 */ 9int main(int argc, char *argv[]) 10{ 11 Alpaca a; 12 a.Sheep::m_age = 18; 13 a.Camel::m_age = 18; 14 return 0; 15}  虚继承\n 1class Sheep : virtual public Animal {}; /* 羊类 */ 2class Camel : virtual public Animal {}; /* 驼类 */ 虚基类指针(vbptr) vbptr \u0026ndash;\u0026gt; vbtable\n多态  分类  静态多态: 重载 动态多态:虚函数   区别  静态多态函数地址早绑定:编译期确定函数地址 动态多态函数地址晚绑定:运行期确定函数地址    父类接收子类的对象,在程序运行期间确定具体改调用那个函数;\n  有继承关系\n  子类重写父类的虚函数 重写：函数完全一致\n  纯虚函数  只要有一个纯虚函数，就称为抽象类\n  抽象类无法直接实例化对象 抽象子类必须重写父类的纯虚函数,否则也是抽象类  原理 虚析构和纯虚析构 C++提高编程  泛型编程/STL\n 模版 建立通用的模板,提高复用；\nC++提供两种模版机制:函数模版和类模板\n函数模版 1template \u0026lt;typename T\u0026gt; 2函数声明和定义  template \u0026ndash; 声明创建模版 typename \u0026ndash; 表明后面的符号是数据类型可以用class代替 T \u0026ndash; 通用的数据类型  实例 1/* 两个数据交换 */ 2template \u0026lt;typename T\u0026gt; 3void swap(T \u0026amp;a, T \u0026amp;b) 4{ 5 T t= a; a = b; b = t; 6} 注意事项  自动类型推导,必须导出类型一致的T才可以使用 模版必须要确定T的数据类型,才可以使用  普通函数和函数模版的区别  普通函数可以发生隐式类型转换 函数模板: 用自动类型推导，不可以发生隐式转换 函数模板: 用显示类型推导，可以发生隐式转换  模版函数\n1template \u0026lt;typename T\u0026gt; 2T add(T a, T b) 3{ 4 return a + b; 5} 调用方法\n1/* 自动推导 */ 2std::cout \u0026lt;\u0026lt; add(10, 20) \u0026lt;\u0026lt; std::endl; 3/* 显示指定 */ 4std::cout \u0026lt;\u0026lt; add\u0026lt;int\u0026gt;(10, 3.14) \u0026lt;\u0026lt; std::endl; 普通函数和模版函数调用规则  普通函数和模版函数都可以调用,有限调用普通函数 强制通过空模版参数强制调用函数模版:函数名\u0026lt;\u0026gt;(参数列表) 函数模版也可以重载 函数模版更好的匹配,选择函数模版  类模板 1template \u0026lt;class T\u0026gt; 2类 例子\n1template \u0026lt;class NameType, class AgeType\u0026gt; 2class Person { 3public: 4 Person(NameType Name, AgeType Age) 5 { 6 m_Name = Name; 7 m_Age = Age; 8 } 9 NameType m_Name; 10 AgeType m_Age; 11}; 调用\n1Person\u0026lt;std::string, int\u0026gt; p(\u0026#34;Hello\u0026#34;, 99); ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/c++/","series":null,"tags":[],"title":"C++笔记"},{"categories":[],"content":"doxygen教程 开始 ","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/doxygen/","series":null,"tags":[],"title":"Doxygen"},{"categories":[],"content":"","date":"Oct 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/engineering_compiler/","series":null,"tags":["compiler"],"title":"Engineering_compiler"},{"categories":[],"content":"kobject 内核对象\n为模块提供一个底层抽象\n相关数据 kobject 1struct kobject { 2\tconst char\t*name;\t/* 名字 */ 3\tstruct list_head\tentry;\t/* 链表 */ 4\tstruct kobject\t*parent;\t/* 指向父对象,建立层次结构 */ 5\tstruct kset\t*kset;\t/* 对象集合 */ 6\tstruct kobj_type\t*ktype;\t/* 对象类型 */ 7\tstruct kernfs_node\t*sd; /* sysfs directory entry */ 8\tstruct kref\tkref;\t/* 引用计数 */ 9#ifdef CONFIG_DEBUG_KOBJECT_RELEASE 10\tstruct delayed_work\trelease; 11#endif 12\tunsigned int state_initialized:1; 13\tunsigned int state_in_sysfs:1; 14\tunsigned int state_add_uevent_sent:1; 15\tunsigned int state_remove_uevent_sent:1; 16\tunsigned int uevent_suppress:1; 17}; kset 1struct kset { 2\tstruct list_head list; 3\tspinlock_t list_lock; 4\tstruct kobject kobj; 5\tconst struct kset_uevent_ops *uevent_ops; 6} __randomize_layout; kobj_type 1struct kobj_type { 2\tvoid (*release)(struct kobject *kobj); 3\tconst struct sysfs_ops *sysfs_ops; 4\tstruct attribute **default_attrs; 5\tconst struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); 6\tconst void *(*namespace)(struct kobject *kobj); 7\tvoid (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); 8}; kref 1struct kref { 2\trefcount_t refcount; 3}; 相关操作 初始化 1void kobject_init(struct kobject *kobj, struct kobj_type *ktype) 2{ 3 4} 添加 删除 ","date":"Oct 1, 2021","img":"","permalink":"https://mengdemao.github.io/posts/kobject/","series":null,"tags":["kernel"],"title":"Kobject"},{"categories":null,"content":"LuaJIT Lua语法 基本语法 1\tprint(\u0026#34;Hello World\u0026#34;) 表(table) LuaJIT分析 LuaJIT主函数 1int main(int argc, char **argv) 2{ 3\tint status; /* 返回值 */ 4\tlua_State *L = lua_open(); /* 创建LUA状态机 */ 5\tif (L == NULL) { 6\tl_message(argv[0], \u0026#34;cannot create state: not enough memory\u0026#34;); 7\treturn EXIT_FAILURE; 8\t} 9\t10\t/* smain只存在三个参数,主要作用是向pmain传递数据 */ 11\tsmain.argc = argc; 12\tsmain.argv = argv; 13\t14\tstatus = lua_cpcall(L, pmain, NULL);\t/* 启动函数调用 */ 15\t16\treport(L, status); /* 提取报错参数 */ 17\t18\tlua_close(L);\t/* 销毁状态机 */ 19\t20\treturn (status || smain.status \u0026gt; 0) ? EXIT_FAILURE : EXIT_SUCCESS; 21} Lua状态机 1struct lua_State { 2\tGCObject*next; 3 4 lu_byte tt; 5 lu_byte marked; 6\tlu_byte status; 7\t8 StkId top; 9\tStkId base; 10\t11 global_State *l_G;\t/* 全局状态信息 */ 12\t13 CallInfo*ci; 14\t15 const Instruction*savedpc; 16\tStkId stack_last; 17\tStkId stack; 18\t19 CallInfo*end_ci; 20\tCallInfo*base_ci; 21\t22 int stacksize; 23\tint size_ci; 24\tunsigned short nCcalls; 25\tunsigned short baseCcalls; 26\t27 lu_byte hookmask; 28\tlu_byte allowhook; 29\t30 int basehookcount; 31\tint hookcount; 32\t33 lua_Hook hook; 34\t35 TValue l_gt; 36\tTValue env; 37\t38 GCObject*openupval; 39\tGCObject*gclist; 40\t41 struct lua_longjmp*errorJmp; 42\t43 ptrdiff_t errfunc; 44}; 创建状态 1/* 此函数实际不存在,程序内部使用的是宏定义 */ 2void lua_open(void); 3 4/* 实际调用位置 */ 5LUALIB_API lua_State *luaL_newstate(void); 6 7/* 根据编译期64位信息选择调用 */ 8#if LJ_64 \u0026amp;\u0026amp; !LJ_GC64 \u0026amp;\u0026amp; !(defined(LUAJIT_USE_VALGRIND) \u0026amp;\u0026amp; defined(LUAJIT_USE_SYSMALLOC)) 9lua_State *lj_state_newstate(lua_Alloc allocf, void *allocd); 10#else 11LUA_API lua_State *lua_newstate(lua_Alloc allocf, void *allocd); 12#endif 函数调用 1LUA_API int lua_cpcall(lua_State *L, lua_CFunction func, void *ud); 2LUA_API int lua_pcall(lua_State *L, int nargs, int nresults, int errfunc); 3LUA_API void lua_call(lua_State *L, int nargs, int nresults); lua_cpcall函数调用\n执行原理 FFI分析 ","date":"Sep 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/luajit/","series":null,"tags":null,"title":"LuaJIT"},{"categories":null,"content":"编译原理 基础概念 词法分析 RE NFA DFA 语法分析 上下文无关文法(CFG) 自上而下(Top Down) 自下而上(Bottom Up) 语义分析 中间代码 目标代码 ","date":"Sep 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/compiler_principles/","series":null,"tags":null,"title":"编译原理"},{"categories":null,"content":"页面分配器 核心函数: __alloc_pages_nodemask\n gfp_mask : 分配掩码 order : 分配阶数 preferred_nid nodemask  核心函数 1struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask) 2{ 3\tstruct page *page;\t// 分配变量 4\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\t// 分配标志 5\tgfp_t alloc_mask; // 真实分配掩码 6\tstruct alloc_context ac = { };\t// 保存相关参数 7 8\t/* 9* There are several places where we assume that the order value is sane 10* so bail out early if the request is out of bound. 11* 限制分配的大小 12*/ 13\tif (unlikely(order \u0026gt;= MAX_ORDER)) { 14\tWARN_ON_ONCE(!(gfp_mask \u0026amp; __GFP_NOWARN)); 15\treturn NULL; 16\t} 17 18\tgfp_mask \u0026amp;= gfp_allowed_mask; 19\talloc_mask = gfp_mask; 20\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, \u0026amp;ac, \u0026amp;alloc_mask, \u0026amp;alloc_flags)) 21\treturn NULL; 22 23\tfinalise_ac(gfp_mask, \u0026amp;ac); 24 25\t/* First allocation attempt */ 26\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, \u0026amp;ac); 27\tif (likely(page)) 28\tgoto out; 29 30\t/* 31* Apply scoped allocation constraints. This is mainly about GFP_NOFS 32* resp. GFP_NOIO which has to be inherited for all allocation requests 33* from a particular context which has been marked by 34* memalloc_no{fs,io}_{save,restore}. 35*/ 36\talloc_mask = current_gfp_context(gfp_mask); 37\tac.spread_dirty_pages = false; 38 39\t/* 40* Restore the original nodemask if it was potentially replaced with 41* \u0026amp;cpuset_current_mems_allowed to optimize the fast-path attempt. 42*/ 43\tif (unlikely(ac.nodemask != nodemask)) 44\tac.nodemask = nodemask; 45 46\tpage = __alloc_pages_slowpath(alloc_mask, order, \u0026amp;ac); 47 48out: 49\tif (memcg_kmem_enabled() \u0026amp;\u0026amp; (gfp_mask \u0026amp; __GFP_ACCOUNT) \u0026amp;\u0026amp; page \u0026amp;\u0026amp; 50\tunlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) { 51\t__free_pages(page, order); 52\tpage = NULL; 53\t} 54 55\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype); 56 57\treturn page; 58} prepare_alloc_pages 1static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order, 2\tint preferred_nid, nodemask_t *nodemask, 3\tstruct alloc_context *ac, gfp_t *alloc_mask, 4\tunsigned int *alloc_flags) 5{ 6\tac-\u0026gt;high_zoneidx = gfp_zone(gfp_mask); 7\tac-\u0026gt;zonelist = node_zonelist(preferred_nid, gfp_mask); 8\tac-\u0026gt;nodemask = nodemask; 9\tac-\u0026gt;migratetype = gfpflags_to_migratetype(gfp_mask); 10 11\tif (cpusets_enabled()) { 12\t*alloc_mask |= __GFP_HARDWALL; 13\tif (!ac-\u0026gt;nodemask) 14\tac-\u0026gt;nodemask = \u0026amp;cpuset_current_mems_allowed; 15\telse 16\t*alloc_flags |= ALLOC_CPUSET; 17\t} 18 19\tfs_reclaim_acquire(gfp_mask); 20\tfs_reclaim_release(gfp_mask); 21 22\tmight_sleep_if(gfp_mask \u0026amp; __GFP_DIRECT_RECLAIM); 23 24\tif (should_fail_alloc_page(gfp_mask, order)) 25\treturn false; 26 27\tif (IS_ENABLED(CONFIG_CMA) \u0026amp;\u0026amp; ac-\u0026gt;migratetype == MIGRATE_MOVABLE) 28\t*alloc_flags |= ALLOC_CMA; 29 30\treturn true; 31} get_page_from_freelist 1static struct page * 2get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags, 3\tconst struct alloc_context *ac) 4{ 5\tstruct zoneref *z = ac-\u0026gt;preferred_zoneref; 6\tstruct zone *zone; 7\tstruct pglist_data *last_pgdat_dirty_limit = NULL; 8 9\t/* 10* Scan zonelist, looking for a zone with enough free. 11* See also __cpuset_node_allowed() comment in kernel/cpuset.c. 12*/ 13\tfor_next_zone_zonelist_nodemask(zone, z, ac-\u0026gt;zonelist, ac-\u0026gt;high_zoneidx, 14\tac-\u0026gt;nodemask) { 15\tstruct page *page; 16\tunsigned long mark; 17 18\tif (cpusets_enabled() \u0026amp;\u0026amp; 19\t(alloc_flags \u0026amp; ALLOC_CPUSET) \u0026amp;\u0026amp; 20\t!__cpuset_zone_allowed(zone, gfp_mask)) 21\tcontinue; 22\t/* 23* When allocating a page cache page for writing, we 24* want to get it from a node that is within its dirty 25* limit, such that no single node holds more than its 26* proportional share of globally allowed dirty pages. 27* The dirty limits take into account the node\u0026#39;s 28* lowmem reserves and high watermark so that kswapd 29* should be able to balance it without having to 30* write pages from its LRU list. 31* 32* XXX: For now, allow allocations to potentially 33* exceed the per-node dirty limit in the slowpath 34* (spread_dirty_pages unset) before going into reclaim, 35* which is important when on a NUMA setup the allowed 36* nodes are together not big enough to reach the 37* global limit. The proper fix for these situations 38* will require awareness of nodes in the 39* dirty-throttling and the flusher threads. 40*/ 41\tif (ac-\u0026gt;spread_dirty_pages) { 42\tif (last_pgdat_dirty_limit == zone-\u0026gt;zone_pgdat) 43\tcontinue; 44 45\tif (!node_dirty_ok(zone-\u0026gt;zone_pgdat)) { 46\tlast_pgdat_dirty_limit = zone-\u0026gt;zone_pgdat; 47\tcontinue; 48\t} 49\t} 50 51\tmark = zone-\u0026gt;watermark[alloc_flags \u0026amp; ALLOC_WMARK_MASK]; 52\tif (!zone_watermark_fast(zone, order, mark, 53\tac_classzone_idx(ac), alloc_flags)) { 54\tint ret; 55 56#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 57\t/* 58* Watermark failed for this zone, but see if we can 59* grow this zone if it contains deferred pages. 60*/ 61\tif (static_branch_unlikely(\u0026amp;deferred_pages)) { 62\tif (_deferred_grow_zone(zone, order)) 63\tgoto try_this_zone; 64\t} 65#endif 66\t/* Checked here to keep the fast path fast */ 67\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS \u0026lt; NR_WMARK); 68\tif (alloc_flags \u0026amp; ALLOC_NO_WATERMARKS) 69\tgoto try_this_zone; 70 71\tif (node_reclaim_mode == 0 || 72\t!zone_allows_reclaim(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone)) 73\tcontinue; 74 75\tret = node_reclaim(zone-\u0026gt;zone_pgdat, gfp_mask, order); 76\tswitch (ret) { 77\tcase NODE_RECLAIM_NOSCAN: 78\t/* did not scan */ 79\tcontinue; 80\tcase NODE_RECLAIM_FULL: 81\t/* scanned but unreclaimable */ 82\tcontinue; 83\tdefault: 84\t/* did we reclaim enough */ 85\tif (zone_watermark_ok(zone, order, mark, 86\tac_classzone_idx(ac), alloc_flags)) 87\tgoto try_this_zone; 88 89\tcontinue; 90\t} 91\t} 92 93try_this_zone: 94\tpage = rmqueue(ac-\u0026gt;preferred_zoneref-\u0026gt;zone, zone, order, 95\tgfp_mask, alloc_flags, ac-\u0026gt;migratetype); 96\tif (page) { 97\tprep_new_page(page, order, gfp_mask, alloc_flags); 98 99\t/* 100* If this is a high-order atomic allocation then check 101* if the pageblock should be reserved for the future 102*/ 103\tif (unlikely(order \u0026amp;\u0026amp; (alloc_flags \u0026amp; ALLOC_HARDER))) 104\treserve_highatomic_pageblock(page, zone, order); 105 106\treturn page; 107\t} else { 108#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT 109\t/* Try again if zone has deferred pages */ 110\tif (static_branch_unlikely(\u0026amp;deferred_pages)) { 111\tif (_deferred_grow_zone(zone, order)) 112\tgoto try_this_zone; 113\t} 114#endif 115\t} 116\t} 117 118\treturn NULL; 119} ","date":"May 9, 2021","img":"","permalink":"https://mengdemao.github.io/posts/page_allocator/","series":null,"tags":null,"title":"Page_allocator"},{"categories":null,"content":"等待事件是建立在调度的基础之上的一种同步机制\n使用 等待队列头 1struct __wait_queue_head { 2\twq_lock_t lock; 3\tstruct list_head task_list; 4}; 5typedef struct __wait_queue_head wait_queue_head_t; 等待队列实体 1struct __wait_queue { 2\tunsigned int flags; 3\tstruct task_struct * task; 4\tstruct list_head task_list; 5}; 6typedef struct __wait_queue wait_queue_t; 初始化等待队列头 1void __init_waitqueue_head(struct wait_queue_head *wq_head, 2\tconst char *name, struct lock_class_key *); 3void init_waitqueue_head(struct wait_queue_head *wq_head); 初始化等待队列 1#define __WAITQUEUE_INITIALIZER(name, tsk) \\ 2{\t\\ 3.private\t= tsk,\t\\ 4.func\t= default_wake_function,\t\\ 5.entry\t= { NULL, NULL }\t\\ 6} 7 8#define DECLARE_WAITQUEUE(name, tsk) struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk) 9 10// 但是，一般直接 11DECLARE_WAITQUEUE(wait, current);  等待队列入口 等待的任务  等待队列操作 1void add_wait_queue(struct wait_queue_head *wq_head, 2\tstruct wait_queue_entry *wq_entry); 3void remove_wait_queue(struct wait_queue_head *wq_head, 4\tstruct wait_queue_entry *wq_entry);  等待队列头 等待队列实体  等待事件 1void wait_event(wq, condition); 2void wait_event_interruptible(wq, condition); 唤醒队列  wake_up wake_up_all wake_up_interruptible wake_up_interruptible_all wake_up_sync wake_up_interruptible_sync  例子 写端 1ssize_t wait_write(struct file *file, const char __user *data, size_t len, loff_t *ppos) 2{ 3\tDECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4\tint ret = -1; 5\tPTRACE; 6 7\tmutex_lock(\u0026amp;wait_device.mutex); 8\t/* 非阻塞模式直接写入 */ 9\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10\tpr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11\tgoto pure_write; 12\t} 13 14\tadd_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 15\twhile (wait_device.wait_flag == true) { 16\tpr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17\t__set_current_state(TASK_INTERRUPTIBLE); 18\tmutex_unlock(\u0026amp;wait_device.mutex); 19\tschedule(); 20\tif (signal_pending(current)) { 21\tret = -ERESTARTSYS; 22\tremove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 23\t__set_current_state(TASK_RUNNING); 24\tgoto out; 25\t} 26\t} 27\tremove_wait_queue(\u0026amp;wait_device.wait_w, \u0026amp;wait); 28 29pure_write: 30\twait_device.wait_flag = true; 31\tpr_err(\u0026#34;Write Successful\u0026#34;); 32 33\twake_up_interruptible(\u0026amp;wait_device.wait_r); 34\tpr_err(\u0026#34;Wakeup Read\u0026#34;); 35\tgoto out; 36 37out: 38\tmutex_unlock(\u0026amp;wait_device.mutex); 39\treturn ret; 40} 读端 1 ssize_t wait_read(struct file *file, char __user *buf, size_t len, loff_t * ppos) 2{ 3\tDECLARE_WAITQUEUE(wait, current);\t/* 声明等待队列 */ 4\tint ret = 0; 5\tPTRACE; 6 7\tmutex_lock(\u0026amp;wait_device.mutex); 8\t/* 非阻塞模式直接写入 */ 9\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) { 10\tpr_err(\u0026#34;write in O_NONBLOCK Mode\u0026#34;); 11\tgoto pure_read; 12\t} 13 14\tadd_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 15\twhile (wait_device.wait_flag == false) { 16\tpr_err(\u0026#34;Write INTERRUPTIBLE\u0026#34;); 17\t__set_current_state(TASK_INTERRUPTIBLE); 18\tmutex_unlock(\u0026amp;wait_device.mutex); 19\tschedule(); 20\tif (signal_pending(current)) { 21\tret = -ERESTARTSYS; 22\tremove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 23\t__set_current_state(TASK_RUNNING); 24\tgoto out; 25\t} 26\t} 27\tremove_wait_queue(\u0026amp;wait_device.wait_r, \u0026amp;wait); 28 29pure_read: 30\twait_device.wait_flag = false; 31\tpr_err(\u0026#34;Read Successful\u0026#34;); 32 33\twake_up_interruptible(\u0026amp;wait_device.wait_w); 34\tpr_err(\u0026#34;Wakeup Write\u0026#34;); 35 36\tgoto out; 37 38out: 39\tmutex_unlock(\u0026amp;wait_device.mutex); 40\treturn 0; 41} 原理 ","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/wait_queue/","series":null,"tags":null,"title":"Linux等待队列实现"},{"categories":null,"content":"","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/antlr/","series":null,"tags":["编译原理"],"title":"Antlr教程"},{"categories":null,"content":"基本操作 安装hugo 在linux/windows上只能通过直接release 下载,\n创建网站 1hugo new site 路径 添加主题  将主题直接添加到theme文件下面 将主题作为一个submodule  创建文档 1hugo new posts/hugo.md 设置预览 1 hugo server -D --disableFastRender 文件结构 1. 2├── archetypes 3├── config 4├── content 5├── data 6├── layouts 7├── static 8├── themes 9├── static 10└── resources 目录结构说明 以下是每个目录的高级概述，其中包含指向 Hugo 文档中每个相应部分的链接。\narchetypes hugo模板,在创建文件时作为模板自动生成\nassets 存储所有需要HugoPipes处理的文件;只有使用了.Permalink 或 .RelPermalink的文件才会发布到公共目录. 注意：默认情况下不创建该目录\nconfig Hugo配置目录\ncontent 此目录存在所有的网站内容,Hugo中的每个顶级文件夹都被视为一个内容部分.\ndata 该目录用于存储 Hugo 在生成网站时可以使用的配置文件\nlayouts 以 .html文件的形式存储模板.\nstatic 存储所有静态内容:图像、CSS、JavaScript等。当Hugo构建您的站点时,静态目录中的所有资产都按原样复制\n编写工具 typora 使用typora作为markdown编写工具\npicgo ","date":"May 4, 2021","img":"","permalink":"https://mengdemao.github.io/posts/hugo/","series":null,"tags":["技巧"],"title":"Hugo教程"},{"categories":null,"content":"nfs服务 安装 1sudo apt-get install nfs-kernel-server 设置导出 1/home/exports *(rw,nohide,insecure,no_subtree_check,async,no_root_squash) 开启服务 1sudo /etc/init.d/nfs-kernel-server restart 测试 1sudo mount -t nfs -o nolock,vers=3 127.0.0.1:/home/exports /mnt 2ls /mnt ","date":"May 3, 2021","img":"","permalink":"https://mengdemao.github.io/posts/nfs/","series":null,"tags":["nfs"],"title":"Nfs"}]